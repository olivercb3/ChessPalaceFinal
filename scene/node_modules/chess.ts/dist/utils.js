"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.strippedSan = exports.validateFen = exports.isFlagKey = exports.isSquare = exports.isPieceSymbol = exports.isColor = exports.symbol = exports.isDigit = exports.swapColor = exports.algebraic = exports.file = exports.rank = void 0;
var constants_1 = require("./constants");
/**
 * Extracts the zero-based rank of an 0x88 square.
 * @public
 */
function rank(i) {
    return i >> 4;
}
exports.rank = rank;
/**
 * Extracts the zero-based file of an 0x88 square.
 * @public
 */
function file(i) {
    return i & 15;
}
exports.file = file;
/**
 * Converts a 0x88 square to algebraic notation.
 * @public
 */
function algebraic(i) {
    var f = file(i);
    var r = rank(i);
    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);
}
exports.algebraic = algebraic;
/**
 * Returns the opposite color.
 */
function swapColor(c) {
    return c === constants_1.WHITE ? constants_1.BLACK : constants_1.WHITE;
}
exports.swapColor = swapColor;
/**
 * Checks if a character is a numeric digit.
 */
function isDigit(c) {
    return /^[0-9]$/.test(c);
}
exports.isDigit = isDigit;
/**
 * Returns the ASCII symbol for each piece.  White pieces are in uppercase,
 * black in lowercase.
 */
function symbol(_a) {
    var type = _a.type, color = _a.color;
    return color === constants_1.WHITE ? type.toUpperCase() : type.toLowerCase();
}
exports.symbol = symbol;
function isColor(color) {
    return color === 'w' || color === 'b';
}
exports.isColor = isColor;
function isPieceSymbol(symbol) {
    return /^[pnbrqk]$/.test(symbol);
}
exports.isPieceSymbol = isPieceSymbol;
function isSquare(sq) {
    return /^[a-h][1-8]$/.test(sq);
}
exports.isSquare = isSquare;
function isFlagKey(key) {
    var keys = ['NORMAL', 'CAPTURE', 'BIG_PAWN', 'EP_CAPTURE', 'PROMOTION', 'KSIDE_CASTLE', 'QSIDE_CASTLE'];
    return keys.indexOf(key) !== -1;
}
exports.isFlagKey = isFlagKey;
/* TODO: this function is pretty much crap - it validates structure but
 * completely ignores content (e.g. doesn't verify that each side has a king)
 * ... we should rewrite this, and ditch the silly error_number field while
 * we're at it
 */
function validateFen(fen) {
    var errors = {
        0: 'No errors.',
        1: 'FEN string must contain six space-delimited fields.',
        2: '6th field (move number) must be a positive integer.',
        3: '5th field (half move counter) must be a non-negative integer.',
        4: '4th field (en-passant square) is invalid.',
        5: '3rd field (castling availability) is invalid.',
        6: '2nd field (side to move) is invalid.',
        7: "1st field (piece positions) does not contain 8 '/'-delimited rows.",
        8: '1st field (piece positions) is invalid [consecutive numbers].',
        9: '1st field (piece positions) is invalid [invalid piece].',
        10: '1st field (piece positions) is invalid [row too large].',
        11: 'Illegal en-passant square'
    };
    /* 1st criterion: 6 space-seperated fields? */
    var tokens = fen.split(/\s+/);
    if (tokens.length !== 6) {
        return { valid: false, error_number: 1, error: errors[1] };
    }
    /* 2nd criterion: move number field is a integer value > 0? */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {
        return { valid: false, error_number: 2, error: errors[2] };
    }
    /* 3rd criterion: half move counter is an integer >= 0? */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {
        return { valid: false, error_number: 3, error: errors[3] };
    }
    /* 4th criterion: 4th field is a valid e.p.-string? */
    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {
        return { valid: false, error_number: 4, error: errors[4] };
    }
    /* 5th criterion: 3th field is a valid castle-string? */
    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {
        return { valid: false, error_number: 5, error: errors[5] };
    }
    /* 6th criterion: 2nd field is "w" (white) or "b" (black)? */
    if (!/^(w|b)$/.test(tokens[1])) {
        return { valid: false, error_number: 6, error: errors[6] };
    }
    /* 7th criterion: 1st field contains 8 rows? */
    var rows = tokens[0].split('/');
    if (rows.length !== 8) {
        return { valid: false, error_number: 7, error: errors[7] };
    }
    /* 8th criterion: every row is valid? */
    for (var i = 0; i < rows.length; i++) {
        /* check for right sum of fields AND not two numbers in succession */
        var sum_fields = 0;
        var previous_was_number = false;
        for (var k = 0; k < rows[i].length; k++) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (!isNaN(rows[i][k])) {
                if (previous_was_number) {
                    return { valid: false, error_number: 8, error: errors[8] };
                }
                sum_fields += parseInt(rows[i][k], 10);
                previous_was_number = true;
            }
            else {
                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {
                    return { valid: false, error_number: 9, error: errors[9] };
                }
                sum_fields += 1;
                previous_was_number = false;
            }
        }
        if (sum_fields !== 8) {
            return { valid: false, error_number: 10, error: errors[10] };
        }
    }
    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||
        (tokens[3][1] == '6' && tokens[1] == 'b')) {
        return { valid: false, error_number: 11, error: errors[11] };
    }
    /* everything's okay! */
    return { valid: true, error_number: 0, error: errors[0] };
}
exports.validateFen = validateFen;
// parses all of the decorators out of a SAN string
function strippedSan(move) {
    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');
}
exports.strippedSan = strippedSan;
