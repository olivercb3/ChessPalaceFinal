
/**
 * Converts a 0x88 square to algebraic notation.
 * @public
 */
export declare function algebraic(i: number): string;

/** @public */
export declare const BISHOP: PieceSymbol;

/** @public */
export declare const BITS: Record<FlagKey, number>;

/** @public */
export declare const BLACK: Color;

/** Private types */
declare type Board = Array<Piece | undefined>;

/** @public */
export declare class Chess {
    /** @internal */
    protected _state: State;
    /** @internal */
    protected _history: GameHistory[];
    /** @internal */
    protected _header: Record<string, string>;
    /** @internal */
    protected _comments: Comments;
    /**
     * The Chess() constructor takes an optional parameter which specifies the board configuration
     * in [Forsyth-Edwards Notation](http://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation).
     *
     * @example
     * ```js
     * // board defaults to the starting position when called with no parameters
     * const chess = new Chess()
     *
     * // pass in a FEN string to load a particular position
     * const chess = new Chess(
     *     'r1k4r/p2nb1p1/2b4p/1p1n1p2/2PP4/3Q1NB1/1P3PPP/R5K1 b - c3 0 19'
     * )
     * ```
     */
    constructor(fen?: string);
    /** @internal */
    get state(): State;
    /** @internal **/
    get states(): State[];
    /**
     * Clears the board and loads the Forsythâ€“Edwards Notation (FEN) string.
     *
     * @param fen - FEN string
     * @param keepHeaders - Flag to keep headers
     * @returns True if the position was successfully loaded, otherwise false.
     */
    load(fen: string, keepHeaders?: boolean): boolean;
    /**
     * Clears the board.
     *
     * @example
     * ```js
     * chess.clear()
     * chess.fen()
     * // -> '8/8/8/8/8/8/8/8 w - - 0 1' <- empty board
     * ```
     *
     * @param keepHeaders - Flag to keep headers
     */
    clear(keepHeaders?: boolean): void;
    /**
     * Reset the board to the initial starting position.
     */
    reset(): void;
    /**
     * Returns the piece on the square.
     *
     * @example
     * ```js
     * chess.clear()
     * chess.put({ type: chess.PAWN, color: chess.BLACK }, 'a5') // put a black pawn on a5
     *
     * chess.get('a5')
     * // -> { type: 'p', color: 'b' },
     * chess.get('a6')
     * // -> null
     * ```
     *
     * @param square - e.g. 'e4'
     * @returns Copy of the piece or null
     */
    get(square?: string): Piece | null;
    /**
     * Place a piece on the square where piece is an object with the form
     * `{ type: ..., color: ... }`. Returns true if the piece was successfully
     * placed, otherwise, the board remains unchanged and false is returned.
     * `put()` will fail when passed an invalid piece or square, or when two or
     * more kings of the same color are placed.
     *
     * @example
     * ```js
     * chess.clear()
     *
     * chess.put({ type: chess.PAWN, color: chess.BLACK }, 'a5') // put a black pawn on a5
     * // -> true
     * chess.put({ type: 'k', color: 'w' }, 'h1') // shorthand
     * // -> true
     *
     * chess.fen()
     * // -> '8/8/8/p7/8/8/8/7K w - - 0 0'
     *
     * chess.put({ type: 'z', color: 'w' }, 'a1') // invalid piece
     * // -> false
     *
     * chess.clear()
     *
     * chess.put({ type: 'k', color: 'w' }, 'a1')
     * // -> true
     *
     * chess.put({ type: 'k', color: 'w' }, 'h1') // fail - two kings
     * // -> false
     * ```
     *
     * @param piece - Object of the form `{ type: 'p', color: 'w' }`
     * @param square - e.g. `'e4'`
     * @returns True if placed successfully, otherwise false
     */
    put(piece: {
        type?: string;
        color?: string;
    }, square?: string): boolean;
    /**
     * Remove and return the piece on `square`.
     *
     * @example
     * ```js
     * chess.clear()
     * chess.put({ type: chess.PAWN, color: chess.BLACK }, 'a5') // put a black pawn on a5
     * chess.put({ type: chess.KING, color: chess.WHITE }, 'h1') // put a white king on h1
     *
     * chess.remove('a5')
     * // -> { type: 'p', color: 'b' },
     * chess.remove('h1')
     * // -> { type: 'k', color: 'w' },
     * chess.remove('e1')
     * // -> null
     * ```
     *
     * @param square - e.g. 'e4'
     * @returns Piece or null
     */
    remove(square?: string): Piece | null;
    /**
     * Returns a list of legal moves from the current position. The function
     * takes an optional parameter which controls the single-square move
     * generation and verbosity.
     *
     * @example
     * ```js
     * const chess = new Chess()
     * chess.moves()
     * // -> ['a3', 'a4', 'b3', 'b4', 'c3', 'c4', 'd3', 'd4', 'e3', 'e4',
     * //     'f3', 'f4', 'g3', 'g4', 'h3', 'h4', 'Na3', 'Nc3', 'Nf3', 'Nh3']
     *
     * chess.moves({ square: 'e2' })
     * // -> ['e3', 'e4']
     *
     * chess.moves({ square: 'e9' }) // invalid square
     * // -> []
     * ```
     */
    moves(options?: {
        square?: string;
        verbose?: false;
    }): string[];
    /**
     * Returns a list of legal moves from the current position. The function
     * takes an optional parameter which controls the single-square move
     * generation and verbosity.
     *
     * @example
     * ```js
     * const chess = new Chess()
     * chess.moves({ verbose: true })
     * // -> [{ color: 'w', from: 'a2', to: 'a3',
     * //       flags: 'n', piece: 'p', san 'a3'
     * //       # a captured: key is included when the move is a capture
     * //       # a promotion: key is included when the move is a promotion
     * //     },
     * //     ...
     * //     ]
     * ```
     * {@link Move}
     */
    moves(options: {
        square?: string;
        verbose: true;
    }): Move[];
    /**
     * Returns the FEN string for the current position.
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * // make some moves
     * chess.move('e4')
     * chess.move('e5')
     * chess.move('f4')
     *
     * chess.fen()
     * // -> 'rnbqkbnr/pppp1ppp/8/4p3/4PP2/8/PPPP2PP/RNBQKBNR b KQkq f3 0 2'
     * ```
     */
    fen(): string;
    /**
     * Returns true or false if the side to move is in check.
     *
     * @example
     * ```js
     * const chess = new Chess(
     *     'rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3'
     * )
     * chess.inCheck()
     * // -> true
     * ```
     */
    inCheck(): boolean;
    /**
     * Returns true or false if the side to move has been checkmated.
     *
     * @example
     * ```js
     * const chess = new Chess(
     *     'rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3'
     * )
     * chess.inCheckmate()
     * // -> true
     * ```
     */
    inCheckmate(): boolean;
    /**
     * Returns true or false if the side to move has been stalemated.
     *
     * @example
     * ```js
     * const chess = new Chess('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')
     * chess.inStalemate()
     * // -> true
     * ```
     */
    inStalemate(): boolean;
    /**
     * Returns true if the game is drawn due to insufficient material (K vs. K,
     * K vs. KB, or K vs. KN) otherwise false.
     *
     * @example
     * ```js
     * const chess = new Chess('k7/8/n7/8/8/8/8/7K b - - 0 1')
     * chess.insufficientMaterial()
     * // -> true
     * ```
     */
    insufficientMaterial(): boolean;
    /**
     * Returns true or false if the current board position has occurred three or more
     * times.
     *
     * @example
     * ```js
     * const chess = new Chess('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1')
     * // -> true
     * // rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq occurs 1st time
     * chess.inThreefoldRepetition()
     * // -> false
     *
     * chess.move('Nf3') chess.move('Nf6') chess.move('Ng1') chess.move('Ng8')
     * // rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq occurs 2nd time
     * chess.inThreefoldRepetition()
     * // -> false
     *
     * chess.move('Nf3') chess.move('Nf6') chess.move('Ng1') chess.move('Ng8')
     * // rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq occurs 3rd time
     * chess.inThreefoldRepetition()
     * // -> true
     * ```
     */
    inThreefoldRepetition(): boolean;
    /**
     * Returns true or false if the game is drawn (50-move rule or insufficient material).
     * @example
     * ```js
     * const chess = new Chess('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')
     * chess.inDraw()
     * // -> true
     * ```
     */
    inDraw(): boolean;
    /**
     * Returns true if the game has ended via checkmate, stalemate, draw,
     * threefold repetition, or insufficient material. Otherwise, returns false.
     * @example
     * ```js
     * const chess = new Chess()
     * chess.gameOver()
     * // -> false
     *
     * // stalemate
     * chess.load('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')
     * chess.gameOver()
     * // -> true
     *
     * // checkmate
     * chess.load('rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3')
     * chess.gameOver()
     * // -> true
     * ```
     */
    gameOver(): boolean;
    /**
     * Returns an 2D array representation of the current position. Empty squares
     * are represented by `null`.
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.board()
     * // -> [[{type: 'r', color: 'b'},
     *         {type: 'n', color: 'b'},
     *         {type: 'b', color: 'b'},
     *         {type: 'q', color: 'b'},
     *         {type: 'k', color: 'b'},
     *         {type: 'b', color: 'b'},
     *         {type: 'n', color: 'b'},
     *         {type: 'r', color: 'b'}],
     *         [...],
     *         [...],
     *         [...],
     *         [...],
     *         [...],
     *         [{type: 'r', color: 'w'},
     *          {type: 'n', color: 'w'},
     *          {type: 'b', color: 'w'},
     *          {type: 'q', color: 'w'},
     *          {type: 'k', color: 'w'},
     *          {type: 'b', color: 'w'},
     *          {type: 'n', color: 'w'},
     *          {type: 'r', color: 'w'}]]
     * ```
     */
    board(): (Piece | null)[][];
    /**
     * Returns the game in PGN format. Options is an optional parameter which may include
     * max width and/or a newline character settings.
     *
     * @example
     * ```js
     * const chess = new Chess()
     * chess.header('White', 'Plunky', 'Black', 'Plinkie')
     * chess.move('e4')
     * chess.move('e5')
     * chess.move('Nc3')
     * chess.move('Nc6')
     *
     * chess.pgn({ max_width: 5, newline_char: '<br />' })
     * // -> '[White "Plunky"]<br />[Black "Plinkie"]<br /><br />1. e4 e5<br />2. Nc3 Nc6'
     * ```
     */
    pgn(options?: {
        newline_char?: string;
        max_width?: number;
    }): string;
    /**
     * Load the moves of a game stored in
     * [Portable Game Notation](http://en.wikipedia.org/wiki/Portable_Game_Notation).
     * `pgn` should be a string. Options is an optional `object` which may contain
     * a string `newline_char` and a boolean `sloppy`.
     *
     * The `newline_char` is a string representation of a valid RegExp fragment and is
     * used to process the PGN. It defaults to `\r?\n`. Special characters
     * should not be pre-escaped, but any literal special characters should be escaped
     * as is normal for a RegExp. Keep in mind that backslashes in JavaScript strings
     * must themselves be escaped (see `sloppy_pgn` example below). Avoid using
     * a `newline_char` that may occur elsewhere in a PGN, such as `.` or `x`, as this
     * will result in unexpected behavior.
     *
     * The `sloppy` flag is a boolean that permits chess.js to parse moves in
     * non-standard notations. See `.move` documentation for more information about
     * non-SAN notations.
     *
     * The method will return `true` if the PGN was parsed successfully, otherwise `false`.
     *
     * @example
     * ```js
     * const chess = new Chess()
     * const pgn = [
     *     '[Event "Casual Game"]',
     *     '[Site "Berlin GER"]',
     *     '[Date "1852.??.??"]',
     *     '[EventDate "?"]',
     *     '[Round "?"]',
     *     '[Result "1-0"]',
     *     '[White "Adolf Anderssen"]',
     *     '[Black "Jean Dufresne"]',
     *     '[ECO "C52"]',
     *     '[WhiteElo "?"]',
     *     '[BlackElo "?"]',
     *     '[PlyCount "47"]',
     *     '',
     *     '1.e4 e5 2.Nf3 Nc6 3.Bc4 Bc5 4.b4 Bxb4 5.c3 Ba5 6.d4 exd4 7.O-O',
     *     'd3 8.Qb3 Qf6 9.e5 Qg6 10.Re1 Nge7 11.Ba3 b5 12.Qxb5 Rb8 13.Qa4',
     *     'Bb6 14.Nbd2 Bb7 15.Ne4 Qf5 16.Bxd3 Qh5 17.Nf6+ gxf6 18.exf6',
     *     'Rg8 19.Rad1 Qxf3 20.Rxe7+ Nxe7 21.Qxd7+ Kxd7 22.Bf5+ Ke8',
     *     '23.Bd7+ Kf8 24.Bxe7# 1-0'
     * ]
     *
     * chess.loadPgn(pgn.join('\n'))
     * // -> true
     *
     * chess.fen()
     * // -> 1r3kr1/pbpBBp1p/1b3P2/8/8/2P2q2/P4PPP/3R2K1 b - - 0 24
     *
     * chess.ascii()
     * // -> '  +------------------------+
     * //     8 | .  r  .  .  .  k  r  . |
     * //     7 | p  b  p  B  B  p  .  p |
     * //     6 | .  b  .  .  .  P  .  . |
     * //     5 | .  .  .  .  .  .  .  . |
     * //     4 | .  .  .  .  .  .  .  . |
     * //     3 | .  .  P  .  .  q  .  . |
     * //     2 | P  .  .  .  .  P  P  P |
     * //     1 | .  .  .  R  .  .  K  . |
     * //       +------------------------+
     * //         a  b  c  d  e  f  g  h'
     *
     * // Parse non-standard move formats and unusual line separators
     * const sloppyPgn = [
     *     '[Event "Wijk aan Zee (Netherlands)"]',
     *     '[Date "1971.01.26"]',
     *     '[Result "1-0"]',
     *     '[White "Tigran Vartanovich Petrosian"]',
     *     '[Black "Hans Ree"]',
     *     '[ECO "A29"]',
     *     '',
     *     '1. Pc2c4 Pe7e5', // non-standard
     *     '2. Nc3 Nf6',
     *     '3. Nf3 Nc6',
     *     '4. g2g3 Bb4', // non-standard
     *     '5. Nd5 Nxd5',
     *     '6. c4xd5 e5-e4', // non-standard
     *     '7. dxc6 exf3',
     *     '8. Qb3 1-0'
     * ].join('|')
     *
     * const options = {
     *     newline_char: '\\|', // Literal '|' character escaped
     *     sloppy: true
     * }
     *
     * chess.loadPgn(sloppyPgn)
     * // -> false
     *
     * chess.loadPgn(sloppyPgn, options)
     * // -> true
     *
     * chess.fen()
     * // -> 'r1bqk2r/pppp1ppp/2P5/8/1b6/1Q3pP1/PP1PPP1P/R1B1KB1R b KQkq - 1 8'
     * ```
     */
    loadPgn(pgn: string, options?: {
        newline_char?: string;
        sloppy?: boolean;
    }): boolean;
    /**
     * Returns PGN header information as an object.
     *
     * @example
     * ```js
     * chess.header()
     * // -> { White: 'Morphy', Black: 'Anderssen', Date: '1858-??-??' }
     * ```
     */
    header(): Record<string, string>;
    /**
     * Sets PGN header information.
     *
     * @example
     * ```js
     * chess.setHeader({
     *   'White': 'Robert James Fischer',
     *   'Black': 'Mikhail Tal'
     * })
     * ```
     */
    setHeader(header: Record<string, string>): void;
    /**
     * Adds a PGN header entry
     *
     * @example
     * ```js
     * chess.addHeader('White', 'Robert James Fischer')
     * chess.addHeader('Black', 'Mikhail Tal')
     * ```
     */
    addHeader(key: string, val: string): void;
    /**
     * Removes a PGN header entry
     *
     * @example
     * ```js
     * chess.removeHeader('White')
     * ```
     */
    removeHeader(key: string): void;
    /**
     * Removes all PGN header information.
     *
     * @example
     * ```js
     * chess.setHeader('White', 'Robert James Fischer')
     * chess.setHeader('Black', 'Mikhail Tal')
     * ```
     */
    clearHeader(): void;
    /**
     * Returns a string containing an ASCII diagram of the current position.
     * @example
     * ```js
     * const chess = new Chess()
     *
     * // Make some moves
     * chess.move('e4')
     * chess.move('e5')
     * chess.move('f4')
     *
     * chess.ascii()
     * // -> '   +------------------------+
     * //      8 | r  n  b  q  k  b  n  r |
     * //      7 | p  p  p  p  .  p  p  p |
     * //      6 | .  .  .  .  .  .  .  . |
     * //      5 | .  .  .  .  p  .  .  . |
     * //      4 | .  .  .  .  P  P  .  . |
     * //      3 | .  .  .  .  .  .  .  . |
     * //      2 | P  P  P  P  .  .  P  P |
     * //      1 | R  N  B  Q  K  B  N  R |
     * //        +------------------------+
     * //          a  b  c  d  e  f  g  h'
     * ```
     */
    ascii(eol?: string): string;
    /**
     * Returns the current side to move.
     *
     * @example
     * ```js
     * chess.load('rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1')
     * chess.turn()
     * // -> 'b'
     * ```
     */
    turn(): Color;
    /**
     * Attempts to make a move on the board, returning a move object if the move was
     * legal, otherwise null. The .move function can be called two ways, by passing
     * a string in Standard Algebraic Notation (SAN):
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.move('e4')
     * // -> { color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' }
     *
     * chess.move('nf6') // SAN is case sensitive!!
     * // -> null
     *
     * chess.move('Nf6')
     * // -> { color: 'b', from: 'g8', to: 'f6', flags: 'n', piece: 'n', san: 'Nf6' }
     * ```
     *
     *
     * Or by passing .move() a move object (only the 'to', 'from', and when necessary
     * 'promotion', fields are needed):
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.move({ from: 'g2', to: 'g3' })
     * // -> { color: 'w', from: 'g2', to: 'g3', flags: 'n', piece: 'p', san: 'g3' }
     * ```
     *
     * An optional sloppy flag can be used to parse a variety of non-standard move
     * notations:
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * // various forms of Long Algebraic Notation
     * chess.move('e2e4', { sloppy: true })
     * // -> { color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' }
     * chess.move('e7-e5', { sloppy: true })
     * // -> { color: 'b', from: 'e7', to: 'e5', flags: 'b', piece: 'p', san: 'e5' }
     * chess.move('Pf2f4', { sloppy: true })
     * // -> { color: 'w', from: 'f2', to: 'f4', flags: 'b', piece: 'p', san: 'f4' }
     * chess.move('Pe5xf4', { sloppy: true })
     * // -> { color: 'b', from: 'e5', to: 'f4', flags: 'c', piece: 'p', captured: 'p', san: 'exf4' }
     *
     * // correctly parses incorrectly disambiguated moves
     * chess = new Chess(
     *     'r2qkbnr/ppp2ppp/2n5/1B2pQ2/4P3/8/PPP2PPP/RNB1K2R b KQkq - 3 7'
     * )
     *
     * chess.move('Nge7') // Ne7 is unambiguous because the knight on c6 is pinned
     * // -> null
     *
     * chess.move('Nge7', { sloppy: true })
     * // -> { color: 'b', from: 'g8', to: 'e7', flags: 'n', piece: 'n', san: 'Ne7' }
     * ```
     *
     * @param move - Case-sensitive SAN string or object, e.g. `'Nxb7'` or
     * `{ from: 'h7', to: 'h8', promotion: 'q' }`
     * @param options - Options to enable parsing of a variety of non-standard
     * move notations
     */
    move(move: string | PartialMove, options?: {
        sloppy?: boolean;
        dry_run?: boolean;
    }): Move | null;
    /**
     * Validates a sequence of moves, returning an array of move objects if the
     * moves are all legal, otherwise null.
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.validateMoves(['e4', 'Nf6'])
     * // -> [{ color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' },
     *        { color: 'b', from: 'g8', to: 'f6', flags: 'n', piece: 'n', san: 'Nf6' }]
     *
     * chess.validateMoves(['e4, 'nf6']) // SAN is case sensitive!!
     * // -> null
     * ```
     *
     * @param moves - Array of case-sensitive SAN strings or objects, e.g. `'Nxb7'` or
     * `{ from: 'h7', to: 'h8', promotion: 'q' }`
     * @param options - Options to enable parsing of a variety of non-standard
     * move notations
     */
    validateMoves(moves: string[] | PartialMove[], options?: {
        sloppy?: boolean;
    }): Move[] | null;
    /**
     * Checks if a move results in a promotion.
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.isPromotion('e4')
     * // -> false
     *
     * chess.load('8/2P2k2/8/8/8/5K2/8/8 w - - 0 1')
     * chess.isPromotion('c8')
     * // -> true
     * ```
     *
     * @param move - Case-sensitive SAN string or object, e.g. `'Nxb7'` or
     * `{ from: 'h7', to: 'h8' }`
     * @param options - Options to enable parsing of a variety of non-standard
     * move notations
     */
    isPromotion(move: string | PartialMove, options?: {
        sloppy?: boolean;
    }): boolean;
    /**
     * Takeback the last half-move, returning a move object if successful, otherwise null.
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.fen()
     * // -> 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
     * chess.move('e4')
     * chess.fen()
     * // -> 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1'
     *
     * chess.undo()
     * // -> { color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' }
     * chess.fen()
     * // -> 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
     * chess.undo()
     * // -> null
     * ```
     */
    undo(): Move | null;
    /**
     * Returns the color of the square ('light' or 'dark').
     *
     * @example
     * ```js
     * const chess = Chess()
     * chess.squareColor('h1')
     * // -> 'light'
     * chess.squareColor('a7')
     * // -> 'dark'
     * chess.squareColor('bogus square')
     * // -> null
     * ```
     */
    squareColor(square: string): 'light' | 'dark' | null;
    /**
     * Returns a list containing the moves of the current game.
     *
     * @example
     * ```js
     * const chess = new Chess()
     * chess.move('e4')
     * chess.move('e5')
     * chess.move('f4')
     * chess.move('exf4')
     *
     * chess.history()
     * // -> ['e4', 'e5', 'f4', 'exf4']
     * ```
     */
    history(options?: {
        verbose?: false;
    }): string[];
    /**
     * Returns a list containing the moves of the current game.
     *
     * @example
     * ```js
     * const chess = new Chess()
     * chess.move('e4')
     * chess.move('e5')
     * chess.move('f4')
     * chess.move('exf4')
     *
     * chess.history({ verbose: true })
     * // -> [{ color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' },
     * //     { color: 'b', from: 'e7', to: 'e5', flags: 'b', piece: 'p', san: 'e5' },
     * //     { color: 'w', from: 'f2', to: 'f4', flags: 'b', piece: 'p', san: 'f4' },
     * //     { color: 'b', from: 'e5', to: 'f4', flags: 'c', piece: 'p', captured: 'p', san: 'exf4' }]
     * ```
     */
    history(options: {
        verbose: true;
    }): Move[];
    /**
     * Retrieve the comment for a position, if it exists.
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.loadPgn("1. e4 e5 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *")
     *
     * chess.getComment()
     * // -> "giuoco piano"
     * ```
     *
     * @param fen - Defaults to the current position
     */
    getComment(fen?: string): string | undefined;
    /**
     * Retrieve comments for all positions.
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.loadPgn("1. e4 e5 {king's pawn opening} 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *")
     *
     * chess.getComments()
     * // -> [
     * //     {
     * //       fen: "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2",
     * //       comment: "king's pawn opening"
     * //     },
     * //     {
     * //       fen: "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3",
     * //       comment: "giuoco piano"
     * //     }
     * //    ]
     * ```
     */
    getComments(): FenComment[];
    /**
     * Comment on a position.
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.move("e4")
     * chess.setComment("king's pawn opening")
     *
     * chess.pgn()
     * // -> "1. e4 {king's pawn opening}"
     * ```
     *
     * @param comment
     * @param fen - Defaults to the current position
     */
    setComment(comment: string, fen?: string): void;
    /**
     * Delete and return the comment for a position, if it exists.
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.loadPgn("1. e4 e5 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *")
     *
     * chess.getComment()
     * // -> "giuoco piano"
     *
     * chess.deleteComments()
     * // -> "giuoco piano"
     *
     * chess.getComment()
     * // -> undefined
     * ```
     *
     * @param fen - Defaults to the current position
     */
    deleteComment(fen?: string): string | undefined;
    /**
     * Delete and return comments for all positions.
     *
     * @example
     * ```js
     * const chess = new Chess()
     *
     * chess.loadPgn("1. e4 e5 {king's pawn opening} 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *")
     *
     * chess.deleteComments()
     * // -> [
     * //     {
     * //       fen: "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2",
     * //       comment: "king's pawn opening"
     * //     },
     * //     {
     * //       fen: "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3",
     * //       comment: "giuoco piano"
     * //     }
     * //    ]
     *
     * chess.getComments()
     * // -> []
     * ```
     */
    deleteComments(): FenComment[];
    /**
     * Returns a validation object specifying validity or the errors found
     * within the FEN string.
     *
     * @example
     * ```js
     * chess.validateFen('2n1r3/p1k2pp1/B1p3b1/P7/5bP1/2N1B3/1P2KP2/2R5 b - - 4 25')
     * // -> { valid: true, error_number: 0, error: 'No errors.' }
     *
     * chess.validateFen('4r3/8/X12XPk/1p6/pP2p1R1/P1B5/2P2K2/3r4 w - - 1 45')
     * // -> { valid: false, error_number: 9,
     * //     error: '1st field (piece positions) is invalid [invalid piece].' }
     * ```
     */
    validateFen(fen: string): Validation;
    /** @internal */
    clone(): Chess;
    /** @internal */
    perft(depth: number): number;
    /**
     * Called when the initial board setup is changed with put() or remove().
     * modifies the SetUp and FEN properties of the header object.  if the FEN is
     * equal to the default position, the SetUp and FEN are deleted
     * the setup is only updated if history.length is zero, ie moves haven't been
     * made.
     *
     * @internal
     */
    protected updateSetup(): void;
    /** @internal */
    protected pruneComments(): void;
    /**
     * Parses all of the decorators out of a SAN string
     *
     * @internal
     */
    protected strippedSan(move: string): string;
    /** @internal */
    protected attacked(color: string, square: number): boolean;
    /** @internal */
    protected kingAttacked(color: Color): boolean;
    /** @internal */
    protected makeMove(move: HexMove): void;
    /** @internal */
    protected undoMove(): HexMove | null;
}

/** @public */
export declare type Color = 'w' | 'b';

declare type ColorState = Record<Color, number> & {
    w: number;
    b: number;
};

declare type Comments = Partial<Record<string, string>>;

/** @public */
export declare const EMPTY = -1;

/** @public */
export declare type FenComment = {
    fen: string;
    comment: string;
};

/**
 * Extracts the zero-based file of an 0x88 square.
 * @public
 */
export declare function file(i: number): number;

declare type FlagKey = 'NORMAL' | 'CAPTURE' | 'BIG_PAWN' | 'EP_CAPTURE' | 'PROMOTION' | 'KSIDE_CASTLE' | 'QSIDE_CASTLE';

/** @public */
export declare const FLAGS: Record<FlagKey, string>;

declare type GameHistory = {
    move: HexMove;
    state: State;
};

declare type HexMove = {
    to: number;
    from: number;
    color: Color;
    flags: number;
    piece: PieceSymbol;
    captured?: PieceSymbol;
    promotion?: PieceSymbol;
    san?: string;
};

/** @public */
export declare const KING: PieceSymbol;

/** @public */
export declare const KNIGHT: PieceSymbol;

/**
 * Represents a chess move
 *
 * @remarks
 * The `piece`, `captured`, and `promotion` fields contain the lowercase
 * representation of the applicable piece.
 *
 * The `flags` field in verbose mode may contain one or more of the following values:
 *
 * - `n` - a non-capture
 *
 * - `b` - a pawn push of two squares
 *
 * - `e` - an en passant capture
 *
 * - `c` - a standard capture
 *
 * - `p` - a promotion
 *
 * - `k` - kingside castling
 *
 * - `q` - queenside castling
 *
 * A flag of `pc` would mean that a pawn captured a piece on the 8th rank and promoted.
 *
 * @public
 */
export declare type Move = PartialMove & {
    color: Color;
    flags: string;
    piece: PieceSymbol;
    san: string;
    captured?: PieceSymbol;
};

/** @public */
export declare type PartialMove = {
    to: string;
    from: string;
    promotion?: PieceSymbol;
};

/** @public */
export declare const PAWN: PieceSymbol;

/** @public */
export declare type Piece = {
    color: Color;
    type: PieceSymbol;
};

/** @public */
export declare type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k';

/** @public */
export declare const QUEEN: PieceSymbol;

/**
 * Extracts the zero-based rank of an 0x88 square.
 * @public
 */
export declare function rank(i: number): number;

/** @public */
export declare const ROOK: PieceSymbol;

declare type Square = 'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' | 'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' | 'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' | 'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' | 'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' | 'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' | 'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' | 'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1';

/** @public */
export declare const SQUARES: Record<Square, number>;

/** @public */
export declare class State {
    board: Board;
    kings: ColorState;
    turn: Color;
    castling: ColorState;
    ep_square: number;
    half_moves: number;
    move_number: number;
    constructor(board?: Board, kings?: ColorState, turn?: Color, castling?: ColorState, ep_square?: number, half_moves?: number, move_number?: number);
    clone(): State;
    get fen(): string;
}

/** @public */
export declare type Validation = {
    valid: boolean;
    error_number: number;
    error: string;
};

/** @public */
export declare const WHITE: Color;

export { }
