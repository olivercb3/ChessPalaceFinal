"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMove = exports.getBoard = exports.ascii = exports.buildMove = exports.makeMove = exports.insufficientMaterial = exports.inStalemate = exports.inCheckmate = exports.inCheck = exports.isKingAttacked = exports.isAttacked = exports.makePretty = exports.sanToMove = exports.moveToSan = exports.generateMoves = exports.removePiece = exports.putPiece = exports.clonePiece = exports.cloneMove = exports.getPiece = exports.loadPgn = exports.getPgn = exports.loadFen = exports.getFen = exports.getDisambiguator = void 0;
var constants_1 = require("./constants");
var types_1 = require("./types");
var utils_1 = require("./utils");
/* this function is used to uniquely identify ambiguous moves */
function getDisambiguator(state, move, sloppy) {
    var moves = generateMoves(state, { legal: !sloppy });
    var from = move.from;
    var to = move.to;
    var piece = move.piece;
    var ambiguities = 0;
    var same_rank = 0;
    var same_file = 0;
    for (var i = 0, len = moves.length; i < len; i++) {
        var ambig_from = moves[i].from;
        var ambig_to = moves[i].to;
        var ambig_piece = moves[i].piece;
        /* if a move of the same piece type ends on the same to square, we'll
         * need to add a disambiguator to the algebraic notation
         */
        if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {
            ambiguities++;
            if (utils_1.rank(from) === utils_1.rank(ambig_from)) {
                same_rank++;
            }
            if (utils_1.file(from) === utils_1.file(ambig_from)) {
                same_file++;
            }
        }
    }
    if (ambiguities > 0) {
        /* if there exists a similar moving piece on the same rank and file as
         * the move in question, use the square as the disambiguator
         */
        if (same_rank > 0 && same_file > 0) {
            return utils_1.algebraic(from);
        }
        else if (same_file > 0) {
            /* if the moving piece rests on the same file, use the rank symbol as the
             * disambiguator
             */
            return utils_1.algebraic(from).charAt(1);
        }
        else {
            /* else use the file symbol */
            return utils_1.algebraic(from).charAt(0);
        }
    }
    return '';
}
exports.getDisambiguator = getDisambiguator;
function getFen(state) {
    var empty = 0;
    var fen = '';
    for (var i = constants_1.SQUARES.a8; i <= constants_1.SQUARES.h1; i++) {
        var piece = state.board[i];
        if (!piece) {
            empty++;
        }
        else {
            if (empty > 0) {
                fen += empty;
                empty = 0;
            }
            var color = piece.color;
            var piece_type = piece.type;
            fen += color === constants_1.WHITE ? piece_type.toUpperCase() : piece_type.toLowerCase();
        }
        if ((i + 1) & 0x88) {
            if (empty > 0) {
                fen += empty;
            }
            if (i !== constants_1.SQUARES.h1) {
                fen += '/';
            }
            empty = 0;
            i += 8;
        }
    }
    var cflags = '';
    if (state.castling[constants_1.WHITE] & constants_1.BITS.KSIDE_CASTLE) {
        cflags += 'K';
    }
    if (state.castling[constants_1.WHITE] & constants_1.BITS.QSIDE_CASTLE) {
        cflags += 'Q';
    }
    if (state.castling[constants_1.BLACK] & constants_1.BITS.KSIDE_CASTLE) {
        cflags += 'k';
    }
    if (state.castling[constants_1.BLACK] & constants_1.BITS.QSIDE_CASTLE) {
        cflags += 'q';
    }
    /* do we have an empty castling flag? */
    cflags = cflags || '-';
    var epflags = state.ep_square === constants_1.EMPTY ? '-' : utils_1.algebraic(state.ep_square);
    return [fen, state.turn, cflags, epflags, state.half_moves, state.move_number].join(' ');
}
exports.getFen = getFen;
function loadFen(fen) {
    var tokens = fen.split(/\s+/);
    var position = tokens[0];
    var square = 0;
    if (!utils_1.validateFen(fen).valid) {
        return null;
    }
    var state = new types_1.State();
    for (var i = 0; i < position.length; i++) {
        var piece = position.charAt(i);
        if (piece === '/') {
            square += 8;
        }
        else if (utils_1.isDigit(piece)) {
            square += parseInt(piece, 10);
        }
        else {
            var color = piece < 'a' ? constants_1.WHITE : constants_1.BLACK;
            var newState = putPiece(state, { type: piece.toLowerCase(), color: color }, utils_1.algebraic(square));
            if (!newState) {
                return null;
            }
            state = newState;
            square++;
        }
    }
    state.turn = tokens[1] === constants_1.BLACK ? constants_1.BLACK : constants_1.WHITE;
    if (tokens[2].indexOf('K') > -1) {
        state.castling.w |= constants_1.BITS.KSIDE_CASTLE;
    }
    if (tokens[2].indexOf('Q') > -1) {
        state.castling.w |= constants_1.BITS.QSIDE_CASTLE;
    }
    if (tokens[2].indexOf('k') > -1) {
        state.castling.b |= constants_1.BITS.KSIDE_CASTLE;
    }
    if (tokens[2].indexOf('q') > -1) {
        state.castling.b |= constants_1.BITS.QSIDE_CASTLE;
    }
    state.ep_square = tokens[3] === '-' ? constants_1.EMPTY : constants_1.SQUARES[tokens[3]];
    state.half_moves = parseInt(tokens[4], 10);
    state.move_number = parseInt(tokens[5], 10);
    return state;
}
exports.loadFen = loadFen;
function getPgn(state, header, comments, history, options) {
    if (options === void 0) { options = {}; }
    /* using the specification from http://www.chessclub.com/help/PGN-spec
     * example for html usage: .pgn({ max_width: 72, newline_char: "<br />" })
     */
    var _a = options.newline_char, newline = _a === void 0 ? '\n' : _a, _b = options.max_width, max_width = _b === void 0 ? 0 : _b;
    var result = [];
    var header_exists = false;
    /* add the PGN header headerrmation */
    for (var i in header) {
        /* TODO: order of enumerated properties in header object is not
         * guaranteed, see ECMA-262 spec (section 12.6.4)
         */
        result.push('[' + i + ' "' + header[i] + '"]' + newline);
        header_exists = true;
    }
    if (header_exists && history.length) {
        result.push(newline);
    }
    var appendComment = function (moveStr) {
        var comment = comments[state.fen];
        if (typeof comment !== 'undefined') {
            var delimiter = moveStr.length > 0 ? ' ' : '';
            moveStr = "" + moveStr + delimiter + "{" + comment + "}";
        }
        return moveStr;
    };
    // Set initial state
    if (history[0]) {
        state = history[0].state;
    }
    var moves = [];
    var moveStr = '';
    /* special case of a commented starting position with no moves */
    if (history.length === 0) {
        moves.push(appendComment(''));
    }
    /* build the list of moves.  a move_string looks like: "3. e3 e6" */
    history.forEach(function (historyState, i) {
        var move = historyState.move;
        moveStr = appendComment(moveStr);
        /* if the position started with black to move, start PGN with 1. ... */
        if (i === 0 && move.color === constants_1.BLACK) {
            moveStr = state.move_number + '. ...';
        }
        else if (move.color === constants_1.WHITE) {
            /* store the previous generated move_string if we have one */
            if (moveStr.length) {
                moves.push(moveStr);
            }
            moveStr = state.move_number + '.';
        }
        moveStr = moveStr + ' ' + moveToSan(state, move);
        state = makeMove(state, move);
    });
    // Append leftover moves
    if (moveStr.length) {
        moves.push(appendComment(moveStr));
    }
    /* is there a result? */
    if (typeof header.Result !== 'undefined') {
        moves.push(header.Result);
    }
    /* history should be back to what it was before we started generating PGN,
     * so join together moves
     */
    if (max_width === 0) {
        return result.join('') + moves.join(' ');
    }
    var strip = function () {
        if (result.length > 0 && result[result.length - 1] === ' ') {
            result.pop();
            return true;
        }
        return false;
    };
    /* NB: this does not preserve comment whitespace. */
    var wrapComment = function (width, move) {
        for (var _i = 0, _a = move.split(' '); _i < _a.length; _i++) {
            var token = _a[_i];
            if (!token) {
                continue;
            }
            if (width + token.length > max_width) {
                while (strip()) {
                    width--;
                }
                result.push(newline);
                width = 0;
            }
            result.push(token);
            width += token.length;
            result.push(' ');
            width++;
        }
        if (strip()) {
            width--;
        }
        return width;
    };
    /* wrap the PGN output at max_width */
    var currentWidth = 0;
    for (var i = 0; i < moves.length; i++) {
        if (currentWidth + moves[i].length > max_width) {
            if (moves[i].includes('{')) {
                currentWidth = wrapComment(currentWidth, moves[i]);
                continue;
            }
        }
        /* if the current move will push past max_width */
        if (currentWidth + moves[i].length > max_width && i !== 0) {
            /* don't end the line with whitespace */
            if (result[result.length - 1] === ' ') {
                result.pop();
            }
            result.push(newline);
            currentWidth = 0;
        }
        else if (i !== 0) {
            result.push(' ');
            currentWidth++;
        }
        result.push(moves[i]);
        currentWidth += moves[i].length;
    }
    return result.join('');
}
exports.getPgn = getPgn;
function loadPgn(pgn, options) {
    if (options === void 0) { options = {}; }
    var _a = options.newline_char, newline_char = _a === void 0 ? '\r?\n' : _a, 
    // allow the user to specify the sloppy move parser to work around over
    // disambiguation bugs in Fritz and Chessbase
    _b = options.sloppy, 
    // allow the user to specify the sloppy move parser to work around over
    // disambiguation bugs in Fritz and Chessbase
    sloppy = _b === void 0 ? false : _b;
    var mask = function (str) {
        return str.replace(/\\/g, '\\');
    };
    var parse_pgn_header = function (header, options) {
        var newline_char = options.newline_char;
        var header_obj = {};
        var headers = header.split(new RegExp(mask(newline_char)));
        var key = '';
        var value = '';
        for (var i = 0; i < headers.length; i++) {
            key = headers[i].replace(/^\[([A-Z][A-Za-z]*)\s.*\]$/, '$1');
            value = headers[i].replace(/^\[[A-Za-z]+\s"(.*)" *\]$/, '$1');
            if (key.trim().length > 0) {
                header_obj[key.trim()] = value;
            }
        }
        return header_obj;
    };
    // RegExp to split header. Takes advantage of the fact that header and movetext
    // will always have a blank line between them (ie, two newline_char's).
    // With default newline_char, will equal: /^(\[((?:\r?\n)|.)*\])(?:\r?\n){2}/
    var header_regex = new RegExp('^(\\[((?:' +
        mask(newline_char) +
        ')|.)*\\])' +
        '(?:' +
        mask(newline_char) +
        '){2}');
    // If no header given, begin with moves.
    var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : '';
    // Put the board in the starting position
    var state = loadFen(constants_1.DEFAULT_POSITION);
    /* parse PGN header */
    var header = parse_pgn_header(header_string, { newline_char: newline_char, sloppy: sloppy });
    /* load the starting position indicated by [Setup '1'] and
     * [FEN position] */
    if (header['SetUp'] === '1') {
        if ('FEN' in header) {
            var newState = loadFen(header['FEN']);
            if (!newState) {
                return null;
            }
            state = newState;
        }
    }
    /* NB: the regexes below that delete move numbers, recursive
     * annotations, and numeric annotation glyphs may also match
     * text in comments. To prevent this, we transform comments
     * by hex-encoding them in place and decoding them again after
     * the other tokens have been deleted.
     *
     * While the spec states that PGN files should be ASCII encoded,
     * we use {en,de}codeURIComponent here to support arbitrary UTF8
     * as a convenience for modern users */
    var toHex = function (str) {
        return Array
            .from(str)
            .map(function (c) {
            /* encodeURI doesn't transform most ASCII characters,
             * so we handle these ourselves */
            return c.charCodeAt(0) < 128
                ? c.charCodeAt(0).toString(16)
                : encodeURIComponent(c).replace(/%/g, '').toLowerCase();
        })
            .join('');
    };
    var fromHex = function (str) {
        var _a;
        return str.length == 0
            ? ''
            : decodeURIComponent('%' + ((_a = str === null || str === void 0 ? void 0 : str.match(/.{1,2}/g)) === null || _a === void 0 ? void 0 : _a.join('%')));
    };
    var encodeComment = function (str) {
        str = str.replace(new RegExp(mask(newline_char), 'g'), ' ');
        return "{" + toHex(str.slice(1, str.length - 1)) + "}";
    };
    var decodeComment = function (str) {
        if (str.startsWith('{') && str.endsWith('}')) {
            return fromHex(str.slice(1, str.length - 1));
        }
    };
    /* delete header to get the moves */
    var ms = pgn
        .replace(header_string, '')
        .replace(
    /* encode comments so they don't get deleted below */
    new RegExp("({[^}]*})+?|;([^" + mask(newline_char) + "]*)", 'g'), function (_, bracket, semicolon) {
        return bracket !== undefined
            ? encodeComment(bracket)
            : ' ' + encodeComment("{" + semicolon.slice(1) + "}");
    })
        .replace(new RegExp(mask(newline_char), 'g'), ' ');
    /* delete recursive annotation variations */
    var rav_regex = /(\([^()]+\))+?/g;
    while (rav_regex.test(ms)) {
        ms = ms.replace(rav_regex, '');
    }
    /* delete move numbers */
    ms = ms.replace(/\d+\.(\.\.)?/g, '');
    /* delete ... indicating black to move */
    ms = ms.replace(/\.\.\./g, '');
    /* delete numeric annotation glyphs */
    ms = ms.replace(/\$\d+/g, '');
    /* trim and get array of moves/comments */
    var tokens = ms
        .trim()
        .split(new RegExp(/\s+/))
        .join(',')
        .replace(/,,+/g, ',')
        .split(',');
    var comments = {};
    var history = [];
    for (var half_move = 0; half_move < tokens.length; half_move++) {
        var token = tokens[half_move];
        var comment = decodeComment(token);
        if (comment !== undefined) {
            comments[state.fen] = comment;
            continue;
        }
        if (half_move === tokens.length - 1 && constants_1.POSSIBLE_RESULTS.indexOf(token) !== -1) {
            if (Object.keys(header).length && typeof header.Result === 'undefined') {
                header['Result'] = token;
            }
            continue;
        }
        var move = sanToMove(state, tokens[half_move], { sloppy: sloppy });
        if (move === null) {
            return null;
        }
        else {
            history.push({ move: move, state: state });
            var newState = makeMove(state, move);
            if (!newState) {
                return null;
            }
            state = newState;
        }
    }
    return [state, header, comments, history];
}
exports.loadPgn = loadPgn;
function getPiece(state, square) {
    if (!square)
        return null;
    square = square.toLowerCase();
    if (!utils_1.isSquare(square))
        return null;
    var sq = constants_1.SQUARES[square];
    var piece = state.board[sq];
    if (piece) {
        return clonePiece(piece);
    }
    return null;
}
exports.getPiece = getPiece;
function cloneMove(move) {
    return {
        to: move.to,
        from: move.from,
        color: move.color,
        flags: move.flags,
        piece: move.piece,
        captured: move.captured,
        promotion: move.promotion,
        san: move.san,
    };
}
exports.cloneMove = cloneMove;
function clonePiece(piece) {
    return {
        color: piece.color,
        type: piece.type,
    };
}
exports.clonePiece = clonePiece;
function putPiece(prevState, piece, square) {
    var type = piece.type, color = piece.color;
    /* check for presence */
    if (!type || !color || !square) {
        return null;
    }
    type = type.toLowerCase();
    color = color.toLowerCase();
    square = square.toLowerCase();
    /* check for valid params */
    if (!utils_1.isPieceSymbol(type) || !utils_1.isColor(color) || !utils_1.isSquare(square)) {
        return null;
    }
    var state = prevState.clone();
    /* don't let the user place more than one king */
    var sq = constants_1.SQUARES[square];
    if (type === constants_1.KING &&
        state.kings[color] !== constants_1.EMPTY &&
        state.kings[color] !== sq) {
        return null;
    }
    state.board[sq] = { type: type, color: color };
    if (type === constants_1.KING) {
        state.kings[color] = sq;
    }
    return state;
}
exports.putPiece = putPiece;
function removePiece(prevState, square) {
    if (!square)
        return null;
    square = square.toLowerCase();
    if (!utils_1.isSquare(square))
        return null;
    var sq = constants_1.SQUARES[square];
    var piece = prevState.board[sq];
    if (!piece)
        return null;
    var state = prevState.clone();
    var type = piece.type, color = piece.color;
    if (type === constants_1.KING) {
        state.kings[color] = constants_1.EMPTY;
    }
    delete state.board[sq];
    return state;
}
exports.removePiece = removePiece;
function generateMoves(state, options) {
    var _a, _b;
    if (options === void 0) { options = {}; }
    var _c = options.legal, legal = _c === void 0 ? true : _c;
    var add_move = function (board, moves, from, to, flags) {
        /* if pawn promotion */
        var piece = board[from];
        if (piece &&
            piece.type === constants_1.PAWN &&
            (utils_1.rank(to) === constants_1.RANK_8 || utils_1.rank(to) === constants_1.RANK_1)) {
            var pieces = [constants_1.QUEEN, constants_1.ROOK, constants_1.BISHOP, constants_1.KNIGHT];
            for (var i = 0, len = pieces.length; i < len; i++) {
                moves.push(buildMove(state, from, to, flags, pieces[i]));
            }
        }
        else {
            moves.push(buildMove(state, from, to, flags));
        }
    };
    var moves = [];
    var us = state.turn;
    var them = utils_1.swapColor(us);
    var second_rank = { b: constants_1.RANK_7, w: constants_1.RANK_2 };
    var first_sq = constants_1.SQUARES.a8;
    var last_sq = constants_1.SQUARES.h1;
    var single_square = false;
    /* are we generating moves for a single square? */
    var square = options.square;
    if (square) {
        square = square.toLowerCase();
        if (utils_1.isSquare(square)) {
            first_sq = last_sq = constants_1.SQUARES[square];
            single_square = true;
        }
        else {
            /* invalid square */
            return [];
        }
    }
    for (var i = first_sq; i <= last_sq; i++) {
        /* did we run off the end of the board */
        if (i & 0x88) {
            i += 7;
            continue;
        }
        var piece = state.board[i];
        if (!piece || piece.color !== us) {
            continue;
        }
        if (piece.type === constants_1.PAWN) {
            /* single square, non-capturing */
            var square1 = i + constants_1.PAWN_OFFSETS[us][0];
            if (!state.board[square1]) {
                add_move(state.board, moves, i, square1, constants_1.BITS.NORMAL);
                /* double square */
                var square2 = i + constants_1.PAWN_OFFSETS[us][1];
                if (second_rank[us] === utils_1.rank(i) && !state.board[square2]) {
                    add_move(state.board, moves, i, square2, constants_1.BITS.BIG_PAWN);
                }
            }
            /* pawn captures */
            for (var j = 2; j < 4; j++) {
                var square_1 = i + constants_1.PAWN_OFFSETS[us][j];
                if (square_1 & 0x88)
                    continue;
                if (state.board[square_1] && ((_a = state.board[square_1]) === null || _a === void 0 ? void 0 : _a.color) === them) {
                    add_move(state.board, moves, i, square_1, constants_1.BITS.CAPTURE);
                }
                else if (square_1 === state.ep_square) {
                    add_move(state.board, moves, i, state.ep_square, constants_1.BITS.EP_CAPTURE);
                }
            }
        }
        else {
            for (var j = 0, len = constants_1.PIECE_OFFSETS[piece.type].length; j < len; j++) {
                var offset = constants_1.PIECE_OFFSETS[piece.type][j];
                var square_2 = i;
                while (true) {
                    square_2 += offset;
                    if (square_2 & 0x88)
                        break;
                    if (!state.board[square_2]) {
                        add_move(state.board, moves, i, square_2, constants_1.BITS.NORMAL);
                    }
                    else {
                        if (((_b = state.board[square_2]) === null || _b === void 0 ? void 0 : _b.color) === us)
                            break;
                        add_move(state.board, moves, i, square_2, constants_1.BITS.CAPTURE);
                        break;
                    }
                    /* break, if knight or king */
                    if (piece.type === 'n' || piece.type === 'k')
                        break;
                }
            }
        }
    }
    /* check for castling if: a) we're generating all moves, or b) we're doing
     * single square move generation on the king's square
     */
    if (!single_square || last_sq === state.kings[us]) {
        /* king-side castling */
        if (state.castling[us] & constants_1.BITS.KSIDE_CASTLE) {
            var castling_from = state.kings[us];
            var castling_to = castling_from + 2;
            if (!state.board[castling_from + 1] &&
                !state.board[castling_to] &&
                !isAttacked(state, them, state.kings[us]) &&
                !isAttacked(state, them, castling_from + 1) &&
                !isAttacked(state, them, castling_to)) {
                add_move(state.board, moves, state.kings[us], castling_to, constants_1.BITS.KSIDE_CASTLE);
            }
        }
        /* queen-side castling */
        if (state.castling[us] & constants_1.BITS.QSIDE_CASTLE) {
            var castling_from = state.kings[us];
            var castling_to = castling_from - 2;
            if (!state.board[castling_from - 1] &&
                !state.board[castling_from - 2] &&
                !state.board[castling_from - 3] &&
                !isAttacked(state, them, state.kings[us]) &&
                !isAttacked(state, them, castling_from - 1) &&
                !isAttacked(state, them, castling_to)) {
                add_move(state.board, moves, state.kings[us], castling_to, constants_1.BITS.QSIDE_CASTLE);
            }
        }
    }
    /* return all pseudo-legal moves (this includes moves that allow the king
     * to be captured)
     */
    if (!legal) {
        return moves;
    }
    /* filter out illegal moves */
    var legal_moves = [];
    for (var i = 0, len = moves.length; i < len; i++) {
        var newState = makeMove(state, moves[i]);
        if (!isKingAttacked(newState, us)) {
            legal_moves.push(moves[i]);
        }
    }
    return legal_moves;
}
exports.generateMoves = generateMoves;
/* convert a move from 0x88 coordinates to Standard Algebraic Notation
 * (SAN)
 *
 * @param {boolean} sloppy Use the sloppy SAN generator to work around over
 * disambiguation bugs in Fritz and Chessbase.  See below:
 *
 * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4
 * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned
 * 4. ... Ne7 is technically the valid SAN
 */
function moveToSan(state, move, options) {
    var _a;
    if (options === void 0) { options = {}; }
    var _b = options.sloppy, sloppy = _b === void 0 ? false : _b, _c = options.checkPromotion, checkPromotion = _c === void 0 ? true : _c;
    var output = '';
    if (move.flags & constants_1.BITS.KSIDE_CASTLE) {
        output = 'O-O';
    }
    else if (move.flags & constants_1.BITS.QSIDE_CASTLE) {
        output = 'O-O-O';
    }
    else {
        var disambiguator = getDisambiguator(state, move, sloppy);
        if (move.piece !== constants_1.PAWN) {
            output += move.piece.toUpperCase() + disambiguator;
        }
        if (move.flags & (constants_1.BITS.CAPTURE | constants_1.BITS.EP_CAPTURE)) {
            if (move.piece === constants_1.PAWN) {
                output += utils_1.algebraic(move.from)[0];
            }
            output += 'x';
        }
        output += utils_1.algebraic(move.to);
        if (checkPromotion && move.flags & constants_1.BITS.PROMOTION) {
            output += '=' + ((_a = move.promotion) === null || _a === void 0 ? void 0 : _a.toUpperCase());
        }
    }
    var newState = makeMove(state, move);
    if (inCheck(newState)) {
        if (inCheckmate(newState)) {
            output += '#';
        }
        else {
            output += '+';
        }
    }
    return output;
}
exports.moveToSan = moveToSan;
function sanToMove(state, move, options) {
    if (options === void 0) { options = {}; }
    var _a = options.sloppy, sloppy = _a === void 0 ? false : _a, _b = options.checkPromotion, checkPromotion = _b === void 0 ? true : _b;
    // strip off any move decorations: e.g Nf3+?!
    var cleanMove = utils_1.strippedSan(move);
    var matches, piece, from, to, promotion;
    // if we're using the sloppy parser run a regex to grab piece, to, and from
    // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7
    if (sloppy) {
        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);
        if (matches) {
            piece = matches[1];
            from = matches[2];
            to = matches[3];
            promotion = matches[4];
        }
    }
    var moves = generateMoves(state, { square: from });
    for (var i = 0, len = moves.length; i < len; i++) {
        // try the strict parser first, then the sloppy parser if requested
        // by the user
        var san = moveToSan(state, moves[i], { checkPromotion: checkPromotion });
        if (cleanMove === utils_1.strippedSan(san) ||
            (sloppy && cleanMove === utils_1.strippedSan(moveToSan(state, moves[i], options)))) {
            return moves[i];
        }
        if (from &&
            to &&
            utils_1.isSquare(from) &&
            utils_1.isSquare(to) &&
            matches &&
            (!piece || piece.toLowerCase() == moves[i].piece) &&
            constants_1.SQUARES[from] == moves[i].from &&
            constants_1.SQUARES[to] == moves[i].to &&
            (!checkPromotion || !promotion || promotion.toLowerCase() == moves[i].promotion)) {
            return moves[i];
        }
    }
    return null;
}
exports.sanToMove = sanToMove;
function makePretty(state, ugly_move) {
    var move = cloneMove(ugly_move);
    var flags = '';
    for (var flag in constants_1.BITS) {
        if (utils_1.isFlagKey(flag) && constants_1.BITS[flag] & move.flags) {
            flags += constants_1.FLAGS[flag];
        }
    }
    return {
        to: utils_1.algebraic(move.to),
        from: utils_1.algebraic(move.from),
        color: move.color,
        flags: flags,
        piece: move.piece,
        san: moveToSan(state, move),
        captured: move.captured,
        promotion: move.promotion,
    };
}
exports.makePretty = makePretty;
function isAttacked(state, color, square) {
    var _a;
    for (var i = constants_1.SQUARES.a8; i <= constants_1.SQUARES.h1; i++) {
        /* did we run off the end of the board */
        if (i & 0x88) {
            i += 7;
            continue;
        }
        /* if empty square or wrong color */
        if (state.board[i] == null || ((_a = state.board[i]) === null || _a === void 0 ? void 0 : _a.color) !== color)
            continue;
        var piece = state.board[i];
        var difference = i - square;
        var index = difference + 119;
        if (piece && constants_1.ATTACKS[index] & (1 << constants_1.SHIFTS[piece.type])) {
            if (piece.type === constants_1.PAWN) {
                if (difference > 0) {
                    if (piece.color === constants_1.WHITE)
                        return true;
                }
                else {
                    if (piece.color === constants_1.BLACK)
                        return true;
                }
                continue;
            }
            /* if the piece is a knight or a king */
            if (piece.type === 'n' || piece.type === 'k')
                return true;
            var offset = constants_1.RAYS[index];
            var j = i + offset;
            var blocked = false;
            while (j !== square) {
                if (state.board[j]) {
                    blocked = true;
                    break;
                }
                j += offset;
            }
            if (!blocked)
                return true;
        }
    }
    return false;
}
exports.isAttacked = isAttacked;
function isKingAttacked(state, color) {
    return isAttacked(state, utils_1.swapColor(color), state.kings[color]);
}
exports.isKingAttacked = isKingAttacked;
function inCheck(state) {
    return isKingAttacked(state, state.turn);
}
exports.inCheck = inCheck;
function inCheckmate(state) {
    return inCheck(state) && generateMoves(state).length === 0;
}
exports.inCheckmate = inCheckmate;
function inStalemate(state) {
    return !inCheck(state) && generateMoves(state).length === 0;
}
exports.inStalemate = inStalemate;
function insufficientMaterial(state) {
    var pieces = {};
    var bishops = [];
    var num_pieces = 0;
    var sq_color = 0;
    for (var i = constants_1.SQUARES.a8; i <= constants_1.SQUARES.h1; i++) {
        sq_color = (sq_color + 1) % 2;
        if (i & 0x88) {
            i += 7;
            continue;
        }
        var piece = state.board[i];
        if (piece) {
            pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;
            if (piece.type === constants_1.BISHOP) {
                bishops.push(sq_color);
            }
            num_pieces++;
        }
    }
    /* k vs. k */
    if (num_pieces === 2) {
        return true;
    }
    else if (
    /* k vs. kn .... or .... k vs. kb */
    num_pieces === 3 &&
        (pieces[constants_1.BISHOP] === 1 || pieces[constants_1.KNIGHT] === 1)) {
        return true;
    }
    else if (num_pieces === pieces[constants_1.BISHOP] + 2) {
        /* kb vs. kb where any number of bishops are all on the same color */
        var sum = 0;
        var len = bishops.length;
        for (var i = 0; i < len; i++) {
            sum += bishops[i];
        }
        if (sum === 0 || sum === len) {
            return true;
        }
    }
    return false;
}
exports.insufficientMaterial = insufficientMaterial;
function makeMove(prevState, move) {
    var state = prevState.clone();
    var us = state.turn;
    var them = utils_1.swapColor(us);
    // this.push(move)
    state.board[move.to] = state.board[move.from];
    delete state.board[move.from];
    /* if ep capture, remove the captured pawn */
    if (move.flags & constants_1.BITS.EP_CAPTURE) {
        if (state.turn === constants_1.BLACK) {
            delete state.board[move.to - 16];
        }
        else {
            delete state.board[move.to + 16];
        }
    }
    /* if pawn promotion, replace with new piece */
    if (move.flags & constants_1.BITS.PROMOTION && move.promotion && utils_1.isPieceSymbol(move.promotion)) {
        state.board[move.to] = { type: move.promotion, color: us };
    }
    /* if we moved the king */
    var piece = state.board[move.to];
    if (piece && piece.type === constants_1.KING) {
        state.kings[piece.color] = move.to;
        /* if we castled, move the rook next to the king */
        if (move.flags & constants_1.BITS.KSIDE_CASTLE) {
            var castling_to = move.to - 1;
            var castling_from = move.to + 1;
            state.board[castling_to] = state.board[castling_from];
            delete state.board[castling_from];
        }
        else if (move.flags & constants_1.BITS.QSIDE_CASTLE) {
            var castling_to = move.to + 1;
            var castling_from = move.to - 2;
            state.board[castling_to] = state.board[castling_from];
            delete state.board[castling_from];
        }
        /* turn off castling */
        state.castling[us] = 0;
    }
    /* turn off castling if we move a rook */
    if (state.castling[us]) {
        for (var i = 0, len = constants_1.ROOKS[us].length; i < len; i++) {
            if (move.from === constants_1.ROOKS[us][i].square &&
                state.castling[us] & constants_1.ROOKS[us][i].flag) {
                state.castling[us] ^= constants_1.ROOKS[us][i].flag;
                break;
            }
        }
    }
    /* turn off castling if we capture a rook */
    if (state.castling[them]) {
        for (var i = 0, len = constants_1.ROOKS[them].length; i < len; i++) {
            if (move.to === constants_1.ROOKS[them][i].square &&
                state.castling[them] & constants_1.ROOKS[them][i].flag) {
                state.castling[them] ^= constants_1.ROOKS[them][i].flag;
                break;
            }
        }
    }
    /* if big pawn move, update the en passant square */
    if (move.flags & constants_1.BITS.BIG_PAWN) {
        if (state.turn === 'b') {
            state.ep_square = move.to - 16;
        }
        else {
            state.ep_square = move.to + 16;
        }
    }
    else {
        state.ep_square = constants_1.EMPTY;
    }
    /* reset the 50 move counter if a pawn is moved or a piece is captured */
    if (move.piece === constants_1.PAWN) {
        state.half_moves = 0;
    }
    else if (move.flags & (constants_1.BITS.CAPTURE | constants_1.BITS.EP_CAPTURE)) {
        state.half_moves = 0;
    }
    else {
        state.half_moves++;
    }
    if (state.turn === constants_1.BLACK) {
        state.move_number++;
    }
    state.turn = utils_1.swapColor(state.turn);
    return state;
}
exports.makeMove = makeMove;
function buildMove(state, from, to, flags, promotion) {
    var _a;
    var move = {
        color: state.turn,
        from: from,
        to: to,
        flags: flags,
        piece: state.board[from].type
    };
    if (promotion && utils_1.isPieceSymbol(promotion)) {
        move.flags |= constants_1.BITS.PROMOTION;
        move.promotion = promotion;
    }
    if (state.board[to]) {
        move.captured = (_a = state.board[to]) === null || _a === void 0 ? void 0 : _a.type;
    }
    else if (flags & constants_1.BITS.EP_CAPTURE) {
        move.captured = constants_1.PAWN;
    }
    return move;
}
exports.buildMove = buildMove;
function ascii(board, eol) {
    if (eol === void 0) { eol = '\n'; }
    var pieces = constants_1.RANKS.map(function (rank) {
        var rankPieces = board.slice(rank * 16, rank * 16 + 8);
        // Use a loop because `map` skips empty indexes
        var row = [];
        for (var _i = 0, rankPieces_1 = rankPieces; _i < rankPieces_1.length; _i++) {
            var piece = rankPieces_1[_i];
            row.push(piece ? " " + utils_1.symbol(piece) + " " : ' . ');
        }
        var rankStr = row.join('');
        return '87654321'[rank] + ' |' + rankStr + '|';
    });
    return [
        '  +------------------------+',
        pieces.join(eol),
        '  +------------------------+',
        '    a  b  c  d  e  f  g  h',
    ].join(eol);
}
exports.ascii = ascii;
function getBoard(board) {
    var output = [];
    var row = [];
    for (var i = constants_1.SQUARES.a8; i <= constants_1.SQUARES.h1; i++) {
        var piece = board[i];
        if (piece == null) {
            row.push(null);
        }
        else {
            row.push({ type: piece.type, color: piece.color });
        }
        if ((i + 1) & 0x88) {
            output.push(row);
            row = [];
            i += 8;
        }
    }
    return output;
}
exports.getBoard = getBoard;
function validateMove(state, move, options) {
    if (options === void 0) { options = {}; }
    // Allow the user to specify the sloppy move parser to work around over
    // disambiguation bugs in Fritz and Chessbase
    var _a = options.checkPromotion, checkPromotion = _a === void 0 ? true : _a;
    if (typeof move === 'string') {
        return sanToMove(state, move, options);
    }
    else if (typeof move === 'object') {
        var moves = generateMoves(state, { square: move.from });
        // Find a matching move
        for (var _i = 0, moves_1 = moves; _i < moves_1.length; _i++) {
            var moveObj = moves_1[_i];
            if (move.from === utils_1.algebraic(moveObj.from) &&
                move.to === utils_1.algebraic(moveObj.to) &&
                (!checkPromotion || !('promotion' in moveObj) ||
                    move.promotion === moveObj.promotion)) {
                return moveObj;
            }
        }
    }
    return null;
}
exports.validateMove = validateMove;
