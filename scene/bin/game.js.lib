[
  {
    "path": "node_modules/@dcl/amd/dist/amd.js",
    "content": "\"use strict\";\n// A naive attempt at getting the global `this`. Donâ€™t use `this`!\nconst getGlobalThis = function () {\n    // @ts-ignore\n    if (typeof globalThis !== 'undefined')\n        return globalThis;\n    // @ts-ignore\n    if (typeof self !== 'undefined')\n        return self;\n    // @ts-ignore\n    if (typeof window !== 'undefined')\n        return window;\n    // Note: this might still return the wrong result!\n    // @ts-ignore\n    if (typeof this !== 'undefined')\n        return this;\n    throw new Error('Unable to locate global `this`');\n};\nconst globalObject = getGlobalThis();\nvar loader;\n(function (loader) {\n    'use strict';\n    const MODULE_LOADING = 1;\n    const MODULE_READY = 2;\n    let unnamedModules = 0;\n    const anonymousQueue = [];\n    const cycles = [];\n    const settings = {\n        baseUrl: ''\n    };\n    const registeredModules = {};\n    function config(config) {\n        if (typeof config === 'object') {\n            for (const x in config) {\n                if (config.hasOwnProperty(x)) {\n                    ;\n                    settings[x] = config[x];\n                }\n            }\n        }\n    }\n    loader.config = config;\n    function define(first, second, third) {\n        let moduleToLoad = null;\n        let factory = {};\n        let dependencies = null;\n        if (typeof first === 'function') {\n            factory = first;\n        }\n        else if (typeof first === 'string') {\n            moduleToLoad = first;\n            if (typeof second === 'function') {\n                factory = second;\n            }\n            else if (second instanceof Array) {\n                dependencies = second;\n                factory = third;\n            }\n        }\n        else if (first instanceof Array) {\n            dependencies = first;\n            if (typeof second === 'function') {\n                factory = second;\n            }\n        }\n        dependencies = dependencies || ['require', 'exports', 'module'];\n        if (moduleToLoad === null) {\n            moduleToLoad = `unnamed-module-${unnamedModules++}`;\n        }\n        moduleToLoad = normalizeModuleId(moduleToLoad);\n        function ready(deps) {\n            const module = registeredModules[moduleToLoad];\n            if (!module)\n                throw new Error('Could not access registered module ' + moduleToLoad);\n            let exports = module.exports;\n            exports =\n                typeof factory === 'function'\n                    ? factory.apply(globalObject, deps) || exports\n                    : factory;\n            module.exports = exports;\n            moduleReady(moduleToLoad);\n        }\n        dependencies = (dependencies || []).map((dep) => resolve(moduleToLoad, dep));\n        if (!registeredModules[moduleToLoad]) {\n            registeredModules[moduleToLoad] = {\n                name: moduleToLoad,\n                parent: null,\n                dclamd: MODULE_LOADING,\n                dependencies,\n                handlers: [],\n                exports: {},\n                dependants: new Set()\n            };\n        }\n        registeredModules[moduleToLoad].dependencies = dependencies;\n        require(dependencies, ready, (err) => {\n            if (typeof onerror === 'function') {\n                onerror(err);\n            }\n            else {\n                throw err;\n            }\n        }, moduleToLoad);\n    }\n    loader.define = define;\n    (function (define) {\n        define.amd = {};\n        define.modules = registeredModules;\n    })(define = loader.define || (loader.define = {}));\n    function moduleReady(moduleName) {\n        const module = registeredModules[moduleName];\n        if (!module)\n            throw new Error('Could not access registered module ' + moduleName);\n        module.dclamd = MODULE_READY;\n        const handlers = module.handlers;\n        if (handlers && handlers.length) {\n            for (let x = 0; x < handlers.length; x++) {\n                handlers[x](registeredModules[moduleName]);\n            }\n        }\n    }\n    /**\n     * Walks (recursively) the dependencies of 'from' in search of 'to'.\n     * Returns cycle as array.\n     */\n    function getCyclePath(fromModule, toModule, depth) {\n        if (!registeredModules[fromModule]) {\n            return null;\n        }\n        if (fromModule === toModule || depth === 50)\n            return [fromModule];\n        const dependencies = registeredModules[fromModule].dependencies;\n        for (let i = 0, len = dependencies.length; i < len; i++) {\n            const path = getCyclePath(dependencies[i], toModule, depth + 1);\n            if (path !== null) {\n                path.push(fromModule);\n                return path;\n            }\n        }\n        return null;\n    }\n    /**\n     * Walks (recursively) the dependencies of 'from' in search of 'to'.\n     * Returns true if there is such a path or false otherwise.\n     * @param from Module id to start at\n     * @param to Module id to look for\n     */\n    function hasDependencyPath(fromId, toId) {\n        const from = registeredModules[fromId];\n        if (!from) {\n            return false;\n        }\n        const inQueue = {};\n        for (const i in registeredModules) {\n            inQueue[i] = false;\n        }\n        const queue = [];\n        // Insert 'from' in queue\n        queue.push(from);\n        inQueue[fromId] = true;\n        while (queue.length > 0) {\n            // Pop first inserted element of queue\n            const element = queue.shift();\n            const dependencies = element.dependencies;\n            if (dependencies) {\n                // Walk the element's dependencies\n                for (let i = 0, len = dependencies.length; i < len; i++) {\n                    const dependency = dependencies[i];\n                    if (dependency === toId) {\n                        // There is a path to 'to'\n                        return true;\n                    }\n                    const dependencyModule = registeredModules[dependency];\n                    if (dependencyModule && !inQueue[dependency]) {\n                        // Insert 'dependency' in queue\n                        inQueue[dependency] = true;\n                        queue.push(dependencyModule);\n                    }\n                }\n            }\n        }\n        // There is no path to 'to'\n        return false;\n    }\n    function require(dependencies, callback, errorCallback, parentModule) {\n        const dependenciesResults = new Array(dependencies.length).fill(null);\n        let loadedCount = 0;\n        let hasLoaded = false;\n        if (typeof dependencies === 'string') {\n            if (registeredModules[dependencies]) {\n                if (registeredModules[dependencies].dclamd === MODULE_LOADING) {\n                    throw new Error(`Trying to load ${dependencies} from ${parentModule}. The first module is still loading.`);\n                }\n                return registeredModules[dependencies];\n            }\n            throw new Error(dependencies +\n                ' has not been defined. Please include it as a dependency in ' +\n                parentModule +\n                \"'s define()\");\n        }\n        const depsLength = dependencies.length;\n        for (let index = 0; index < depsLength; index++) {\n            switch (dependencies[index]) {\n                case 'require':\n                    const _require = function (new_module, callback, errorCallback) {\n                        return require(new_module, callback, errorCallback, parentModule);\n                    };\n                    _require.toUrl = function (module) {\n                        return toUrl(module, parentModule);\n                    };\n                    dependenciesResults[index] = _require;\n                    loadedCount++;\n                    break;\n                case 'exports':\n                    if (!registeredModules[parentModule]) {\n                        throw new Error('Parent module ' + parentModule + ' not registered yet');\n                    }\n                    dependenciesResults[index] = registeredModules[parentModule].exports;\n                    loadedCount++;\n                    break;\n                case 'module':\n                    dependenciesResults[index] = {\n                        id: parentModule,\n                        uri: toUrl(parentModule)\n                    };\n                    loadedCount++;\n                    break;\n                default: {\n                    // If we have a circular dependency, then we resolve the module even if it hasn't loaded yet\n                    const dependency = dependencies[index];\n                    const hasCycles = hasDependencyPath(dependency, parentModule);\n                    const handleLoadedModule = () => {\n                        dependenciesResults[index] = registeredModules[dependency].exports;\n                        loadedCount++;\n                        if (loadedCount === depsLength && callback) {\n                            hasLoaded = true;\n                            callback(dependenciesResults);\n                        }\n                    };\n                    if (hasCycles) {\n                        const cyclePath = getCyclePath(dependency, parentModule, 0);\n                        if (cyclePath) {\n                            cyclePath.reverse();\n                            cyclePath.push(dependency);\n                            cycles.push(cyclePath);\n                        }\n                        load(dependency, () => { }, errorCallback, parentModule);\n                        handleLoadedModule();\n                    }\n                    else {\n                        load(dependency, handleLoadedModule, errorCallback, parentModule);\n                    }\n                    break;\n                }\n            }\n        }\n        if (!hasLoaded && loadedCount === depsLength && callback) {\n            callback(dependenciesResults);\n        }\n    }\n    loader.require = require;\n    function createMethodHandler(rpcHandle, method) {\n        return function () {\n            return dcl.callRpc(rpcHandle, method.name, \n            // eslint-disable-next-line prefer-rest-params\n            anonymousQueue.slice.call(arguments, 0));\n        };\n    }\n    // returns: resolvedModuleName\n    function resolve(fromModule, toModule) {\n        return fromModule ? toUrl(toModule, fromModule) : toModule;\n    }\n    function load(moduleName, callback, errorCallback, parentModule) {\n        if (registeredModules[moduleName]) {\n            registeredModules[moduleName].dependants.add(parentModule);\n            if (registeredModules[moduleName].dclamd === MODULE_LOADING) {\n                callback && registeredModules[moduleName].handlers.push(callback);\n            }\n            else {\n                callback && callback(registeredModules[moduleName]);\n            }\n            return;\n        }\n        else {\n            registeredModules[moduleName] = {\n                name: moduleName,\n                parent: parentModule,\n                dclamd: MODULE_LOADING,\n                handlers: [callback],\n                dependencies: [],\n                dependants: new Set([parentModule]),\n                exports: {}\n            };\n        }\n        if (moduleName.indexOf('@') === 0) {\n            const exports = registeredModules[moduleName].exports;\n            if (typeof dcl.loadModule === 'function') {\n                dcl\n                    .loadModule(moduleName, exports)\n                    .then((descriptor) => {\n                    for (const i in descriptor.methods) {\n                        const method = descriptor.methods[i];\n                        exports[method.name] = createMethodHandler(descriptor.rpcHandle, method);\n                    }\n                    moduleReady(moduleName);\n                })\n                    .catch((e) => {\n                    errorCallback(e);\n                });\n            }\n            else {\n                throw new Error('Asynchronous modules will not work because loadModule function is not present');\n            }\n        }\n    }\n    if (typeof dcl !== 'undefined') {\n        dcl.onStart(() => {\n            const unknownModules = new Set();\n            const notLoadedModules = [];\n            for (const i in registeredModules) {\n                if (registeredModules[i]) {\n                    if (registeredModules[i].dclamd === MODULE_LOADING) {\n                        notLoadedModules.push(registeredModules[i]);\n                    }\n                    registeredModules[i].dependencies.forEach(($) => {\n                        if ($ === 'require' || $ === 'exports' || $ === 'module')\n                            return;\n                        if (!registeredModules[$])\n                            unknownModules.add($);\n                    });\n                }\n            }\n            const errorParts = [];\n            if (cycles.length) {\n                errorParts.push(`\\n> Cyclic dependencies: ${cycles\n                    .map(($) => '\\n  - ' + $.join(' -> '))\n                    .join('')}`);\n            }\n            if (unknownModules.size) {\n                errorParts.push(`\\n> Undeclared/unknown modules: ${Array.from(unknownModules)\n                    .map(($) => '\\n  - ' + $)\n                    .join('')}`);\n            }\n            if (notLoadedModules.length) {\n                errorParts.push(`\\n> These modules didn't load: ${notLoadedModules\n                    .map(($) => '\\n  - ' + $.name)\n                    .join('')}.\\n`);\n            }\n            if (errorParts.length) {\n                throw new Error(errorParts.join('\\n'));\n            }\n        });\n    }\n    /**\n     * Normalize 'a/../name' to 'name', etc.\n     */\n    function normalizeModuleId(moduleId) {\n        let r = moduleId, pattern;\n        // replace /./ => /\n        pattern = /\\/\\.\\//;\n        while (pattern.test(r)) {\n            r = r.replace(pattern, '/');\n        }\n        // replace ^./ => nothing\n        r = r.replace(/^\\.\\//g, '');\n        // replace /aa/../ => / (BUT IGNORE /../../)\n        pattern =\n            /\\/(([^\\/])|([^\\/][^\\/\\.])|([^\\/\\.][^\\/])|([^\\/][^\\/][^\\/]+))\\/\\.\\.\\//;\n        while (pattern.test(r)) {\n            r = r.replace(pattern, '/');\n        }\n        // replace ^aa/../ => nothing (BUT IGNORE ../../)\n        r = r.replace(/^(([^\\/])|([^\\/][^\\/\\.])|([^\\/\\.][^\\/])|([^\\/][^\\/][^\\/]+))\\/\\.\\.\\//, '');\n        // replace ^/ => nothing\n        r = r.replace(/^\\//g, '');\n        return r;\n    }\n    /**\n     * Resolve relative module ids\n     */\n    function resolveModule(moduleId, parentModule) {\n        let result = moduleId;\n        if (!result.startsWith('@')) {\n            if (result.startsWith('./') || result.startsWith('../')) {\n                const currentPath = parentModule.split('/');\n                currentPath.pop();\n                result = normalizeModuleId(currentPath.join('/') + '/' + result);\n            }\n        }\n        return result;\n    }\n    function toUrl(moduleName, parentModule) {\n        switch (moduleName) {\n            case 'require':\n            case 'exports':\n            case 'module':\n                return moduleName;\n        }\n        if (parentModule) {\n            return resolveModule(moduleName, parentModule);\n        }\n        return normalizeModuleId(moduleName);\n    }\n    require.toUrl = toUrl;\n})(loader || (loader = {}));\nglobalObject.define = loader.define;\nglobalObject.dclamd = loader;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2FtZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBZ0JBLGtFQUFrRTtBQUNsRSxNQUFNLGFBQWEsR0FBRztJQUNwQixhQUFhO0lBQ2IsSUFBSSxPQUFPLFVBQVUsS0FBSyxXQUFXO1FBQUUsT0FBTyxVQUFVLENBQUE7SUFDeEQsYUFBYTtJQUNiLElBQUksT0FBTyxJQUFJLEtBQUssV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFBO0lBQzVDLGFBQWE7SUFDYixJQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVc7UUFBRSxPQUFPLE1BQU0sQ0FBQTtJQUNoRCxrREFBa0Q7SUFDbEQsYUFBYTtJQUNiLElBQUksT0FBTyxJQUFJLEtBQUssV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFBO0lBQzVDLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQTtBQUNuRCxDQUFDLENBQUE7QUFFRCxNQUFNLFlBQVksR0FBSSxhQUFxQixFQUFFLENBQUE7QUFFN0MsSUFBVSxNQUFNLENBc2ZmO0FBdGZELFdBQVUsTUFBTTtJQUNkLFlBQVksQ0FBQTtJQUVaLE1BQU0sY0FBYyxHQUFHLENBQUMsQ0FBQTtJQUN4QixNQUFNLFlBQVksR0FBRyxDQUFDLENBQUE7SUFFdEIsSUFBSSxjQUFjLEdBQUcsQ0FBQyxDQUFBO0lBRXRCLE1BQU0sY0FBYyxHQUFVLEVBQUUsQ0FBQTtJQUNoQyxNQUFNLE1BQU0sR0FBZSxFQUFFLENBQUE7SUFFN0IsTUFBTSxRQUFRLEdBQUc7UUFDZixPQUFPLEVBQUUsRUFBRTtLQUNaLENBQUE7SUFFRCxNQUFNLGlCQUFpQixHQUEyQixFQUFFLENBQUE7SUFFcEQsU0FBZ0IsTUFBTSxDQUFDLE1BQTJCO1FBQ2hELElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1lBQzlCLEtBQUssTUFBTSxDQUFDLElBQUksTUFBTSxFQUFFO2dCQUN0QixJQUFJLE1BQU0sQ0FBQyxjQUFj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LENBQUMsQ0FBQTtTQUMvQztRQUNELE9BQU8saUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUE7SUFDdEMsQ0FBQztJQUVELE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFBO0FBQ3ZCLENBQUMsRUF0ZlMsTUFBTSxLQUFOLE1BQU0sUUFzZmY7QUFFRCxZQUFZLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUE7QUFDbkMsWUFBWSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXMgKi9cbnR5cGUgTW9kdWxlID0ge1xuICBuYW1lOiBzdHJpbmdcbiAgZGNsYW1kOiAxIHwgMlxuICBwYXJlbnQ6IHN0cmluZyB8IG51bGxcbiAgZGVwZW5kYW50czogU2V0PHN0cmluZz5cbiAgZGVwZW5kZW5jaWVzOiBBcnJheTxzdHJpbmc+XG4gIGhhbmRsZXJzOiBNb2R1bGVMb2FkZWRIYW5kbGVyW11cbiAgZXhwb3J0czogYW55XG59XG5cbnR5cGUgTW9kdWxlTG9hZGVkSGFuZGxlciA9IChtb2R1bGU6IE1vZHVsZSkgPT4gdm9pZFxuXG5kZWNsYXJlIGxldCBvbmVycm9yOiAoKGVycjogRXJyb3IpID0+IHZvaWQpIHwgdW5kZWZpbmVkXG5cbi8vIEEgbmFpdmUgYXR0ZW1wdCBhdCBnZXR0aW5nIHRoZSBnbG9iYWwgYHRoaXNgLiBEb27igJl0IHVzZSBgdGhpc2AhXG5jb25zdCBnZXRHbG9iYWxUaGlzID0gZnVuY3Rpb24gKCkge1xuICAvLyBAdHMtaWdub3JlXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBnbG9iYWxUaGlzXG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHNlbGZcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB3aW5kb3dcbiAgLy8gTm90ZTogdGhpcyBtaWdodCBzdGlsbCByZXR1cm4gdGhlIHdyb25nIHJlc3VsdCFcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gdGhpc1xuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIGB0aGlzYCcpXG59XG5cbmNvbnN0IGdsb2JhbE9iamVjdCA9IChnZXRHbG9iYWxUaGlzIGFzIGFueSkoKVxuXG5uYW1lc3BhY2UgbG9hZGVyIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgY29uc3QgTU9EVUxFX0xPQURJTkcgPSAxXG4gIGNvbnN0IE1PRFVMRV9SRUFEWSA9IDJcblxuICBsZXQgdW5uYW1lZE1vZHVsZXMgPSAwXG5cbiAgY29uc3QgYW5vbnltb3VzUXVldWU6IGFueVtdID0gW11cbiAgY29uc3QgY3ljbGVzOiBzdHJpbmdbXVtdID0gW11cblxuICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICBiYXNlVXJsOiAnJ1xuICB9XG5cbiAgY29uc3QgcmVnaXN0ZXJlZE1vZHVsZXM6IFJlY29yZDxzdHJpbmcsIE1vZHVsZT4gPSB7fVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBjb25maWcoY29uZmlnOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKGNvbnN0IHggaW4gY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoeCkpIHtcbiAgICAgICAgICA7KHNldHRpbmdzIGFzIGFueSlbeF0gPSBjb25maWdbeF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBkZWZpbmUoZmFjdG9yeTogRnVuY3Rpb24pOiB2b2lkXG4gIGV4cG9ydCBmdW5jdGlvbiBkZWZpbmUoaWQ6IHN0cmluZywgZmFjdG9yeTogRnVuY3Rpb24pOiB2b2lkXG4gIGV4cG9ydCBmdW5jdGlvbiBkZWZpbmUoZGVwZW5kZW5jaWVzOiBzdHJpbmdbXSwgZmFjdG9yeTogRnVuY3Rpb24pOiB2b2lkXG4gIGV4cG9ydCBmdW5jdGlvbiBkZWZpbmUoXG4gICAgaWQ6IHN0cmluZyxcbiAgICBkZXBlbmRlbmNpZXM6IHN0cmluZ1tdLFxuICAgIGZhY3Rvcnk6IEZ1bmN0aW9uXG4gICk6IHZvaWRcbiAgZXhwb3J0IGZ1bmN0aW9uIGRlZmluZShcbiAgICBmaXJzdDogc3RyaW5nIHwgRnVuY3Rpb24gfCBzdHJpbmdbXSxcbiAgICBzZWNvbmQ/OiBzdHJpbmdbXSB8IHN0cmluZyB8IEZ1bmN0aW9uLFxuICAgIHRoaXJkPzogRnVuY3Rpb24gfCBvYmplY3RcbiAgKTogdm9pZCB7XG4gICAgbGV0IG1vZHVsZVRvTG9hZDogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgZmFjdG9yeTogRnVuY3Rpb24gfCBvYmplY3QgPSB7fVxuICAgIGxldCBkZXBlbmRlbmNpZXM6IHN0cmluZ1tdIHwgbnVsbCA9IG51bGxcblxuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZhY3RvcnkgPSBmaXJzdFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJykge1xuICAgICAgbW9kdWxlVG9Mb2FkID0gZmlyc3RcblxuICAgICAgaWYgKHR5cGVvZiBzZWNvbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmFjdG9yeSA9IHNlY29uZFxuICAgICAgfSBlbHNlIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBkZXBlbmRlbmNpZXMgPSBzZWNvbmRcbiAgICAgICAgZmFjdG9yeSA9IHRoaXJkIVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmlyc3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZGVwZW5kZW5jaWVzID0gZmlyc3RcbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZhY3RvcnkgPSBzZWNvbmRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMgfHwgWydyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJ11cblxuICAgIGlmIChtb2R1bGVUb0xvYWQgPT09IG51bGwpIHtcbiAgICAgIG1vZHVsZVRvTG9hZCA9IGB1bm5hbWVkLW1vZHVsZS0ke3VubmFtZWRNb2R1bGVzKyt9YFxuICAgIH1cblxuICAgIG1vZHVsZVRvTG9hZCA9IG5vcm1hbGl6ZU1vZHVsZUlkKG1vZHVsZVRvTG9hZClcblxuICAgIGZ1bmN0aW9uIHJlYWR5KGRlcHM6IGFueVtdKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSByZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVUb0xvYWQhXVxuXG4gICAgICBpZiAoIW1vZHVsZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgYWNjZXNzIHJlZ2lzdGVyZWQgbW9kdWxlICcgKyBtb2R1bGVUb0xvYWQpXG5cbiAgICAgIGxldCBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHNcblxuICAgICAgZXhwb3J0cyA9XG4gICAgICAgIHR5cGVvZiBmYWN0b3J5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBmYWN0b3J5LmFwcGx5KGdsb2JhbE9iamVjdCwgZGVwcykgfHwgZXhwb3J0c1xuICAgICAgICAgIDogZmFjdG9yeVxuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNcblxuICAgICAgbW9kdWxlUmVhZHkobW9kdWxlVG9Mb2FkISlcbiAgICB9XG5cbiAgICBkZXBlbmRlbmNpZXMgPSAoZGVwZW5kZW5jaWVzIHx8IFtdKS5tYXAoKGRlcCkgPT5cbiAgICAgIHJlc29sdmUobW9kdWxlVG9Mb2FkISwgZGVwKVxuICAgIClcblxuICAgIGlmICghcmVnaXN0ZXJlZE1vZHVsZXNbbW9kdWxlVG9Mb2FkXSkge1xuICAgICAgcmVnaXN0ZXJlZE1vZHVsZXNbbW9kdWxlVG9Mb2FkXSA9IHtcbiAgICAgICAgbmFtZTogbW9kdWxlVG9Mb2FkISxcbiAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICBkY2xhbWQ6IE1PRFVMRV9MT0FESU5HLFxuICAgICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAgIGhhbmRsZXJzOiBbXSxcbiAgICAgICAgZXhwb3J0czoge30sXG4gICAgICAgIGRlcGVuZGFudHM6IG5ldyBTZXQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyZWRNb2R1bGVzW21vZHVsZVRvTG9hZF0uZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzXG5cbiAgICByZXF1aXJlKGRlcGVuZGVuY2llcywgcmVhZHksIChlcnI6IEVycm9yKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9uZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25lcnJvcihlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9LCBtb2R1bGVUb0xvYWQhKVxuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBkZWZpbmUge1xuICAgIGV4cG9ydCBjb25zdCBhbWQgPSB7fVxuICAgIGV4cG9ydCBjb25zdCBtb2R1bGVzID0gcmVnaXN0ZXJlZE1vZHVsZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vZHVsZVJlYWR5KG1vZHVsZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IG1vZHVsZSA9IHJlZ2lzdGVyZWRNb2R1bGVzW21vZHVsZU5hbWVdXG5cbiAgICBpZiAoIW1vZHVsZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGFjY2VzcyByZWdpc3RlcmVkIG1vZHVsZSAnICsgbW9kdWxlTmFtZSlcblxuICAgIG1vZHVsZS5kY2xhbWQgPSBNT0RVTEVfUkVBRFlcblxuICAgIGNvbnN0IGhhbmRsZXJzOiBNb2R1bGVMb2FkZWRIYW5kbGVyW10gPSBtb2R1bGUuaGFuZGxlcnNcblxuICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgaGFuZGxlcnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgaGFuZGxlcnNbeF0ocmVnaXN0ZXJlZE1vZHVsZXNbbW9kdWxlTmFtZV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdhbGtzIChyZWN1cnNpdmVseSkgdGhlIGRlcGVuZGVuY2llcyBvZiAnZnJvbScgaW4gc2VhcmNoIG9mICd0bycuXG4gICAqIFJldHVybnMgY3ljbGUgYXMgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRDeWNsZVBhdGgoXG4gICAgZnJvbU1vZHVsZTogc3RyaW5nLFxuICAgIHRvTW9kdWxlOiBzdHJpbmcsXG4gICAgZGVwdGg6IG51bWJlclxuICApOiBzdHJpbmdbXSB8IG51bGwge1xuICAgIGlmICghcmVnaXN0ZXJlZE1vZHVsZXNbZnJvbU1vZHVsZV0pIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKGZyb21Nb2R1bGUgPT09IHRvTW9kdWxlIHx8IGRlcHRoID09PSA1MCkgcmV0dXJuIFtmcm9tTW9kdWxlXVxuXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gcmVnaXN0ZXJlZE1vZHVsZXNbZnJvbU1vZHVsZV0uZGVwZW5kZW5jaWVzXG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gZ2V0Q3ljbGVQYXRoKGRlcGVuZGVuY2llc1tpXSwgdG9Nb2R1bGUsIGRlcHRoICsgMSlcbiAgICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICAgIHBhdGgucHVzaChmcm9tTW9kdWxlKVxuICAgICAgICByZXR1cm4gcGF0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogV2Fsa3MgKHJlY3Vyc2l2ZWx5KSB0aGUgZGVwZW5kZW5jaWVzIG9mICdmcm9tJyBpbiBzZWFyY2ggb2YgJ3RvJy5cbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIHN1Y2ggYSBwYXRoIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHBhcmFtIGZyb20gTW9kdWxlIGlkIHRvIHN0YXJ0IGF0XG4gICAqIEBwYXJhbSB0byBNb2R1bGUgaWQgdG8gbG9vayBmb3JcbiAgICovXG4gIGZ1bmN0aW9uIGhhc0RlcGVuZGVuY3lQYXRoKGZyb21JZDogc3RyaW5nLCB0b0lkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBmcm9tID0gcmVnaXN0ZXJlZE1vZHVsZXNbZnJvbUlkXVxuICAgIGlmICghZnJvbSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgaW5RdWV1ZTogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fVxuICAgIGZvciAoY29uc3QgaSBpbiByZWdpc3RlcmVkTW9kdWxlcykge1xuICAgICAgaW5RdWV1ZVtpXSA9IGZhbHNlXG4gICAgfVxuICAgIGNvbnN0IHF1ZXVlOiBNb2R1bGVbXSA9IFtdXG5cbiAgICAvLyBJbnNlcnQgJ2Zyb20nIGluIHF1ZXVlXG4gICAgcXVldWUucHVzaChmcm9tKVxuICAgIGluUXVldWVbZnJvbUlkXSA9IHRydWVcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBQb3AgZmlyc3QgaW5zZXJ0ZWQgZWxlbWVudCBvZiBxdWV1ZVxuICAgICAgY29uc3QgZWxlbWVudCA9IHF1ZXVlLnNoaWZ0KCkhXG4gICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBlbGVtZW50LmRlcGVuZGVuY2llc1xuICAgICAgaWYgKGRlcGVuZGVuY2llcykge1xuICAgICAgICAvLyBXYWxrIHRoZSBlbGVtZW50J3MgZGVwZW5kZW5jaWVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldXG5cbiAgICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9JZCkge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBwYXRoIHRvICd0bydcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGVwZW5kZW5jeU1vZHVsZSA9IHJlZ2lzdGVyZWRNb2R1bGVzW2RlcGVuZGVuY3ldXG4gICAgICAgICAgaWYgKGRlcGVuZGVuY3lNb2R1bGUgJiYgIWluUXVldWVbZGVwZW5kZW5jeV0pIHtcbiAgICAgICAgICAgIC8vIEluc2VydCAnZGVwZW5kZW5jeScgaW4gcXVldWVcbiAgICAgICAgICAgIGluUXVldWVbZGVwZW5kZW5jeV0gPSB0cnVlXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGRlcGVuZGVuY3lNb2R1bGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlcmUgaXMgbm8gcGF0aCB0byAndG8nXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcmVxdWlyZShcbiAgICBkZXBlbmRlbmNpZXM6IHN0cmluZyB8IHN0cmluZ1tdLFxuICAgIGNhbGxiYWNrOiAoZGVwczogYW55W10pID0+IHZvaWQsXG4gICAgZXJyb3JDYWxsYmFjazogRnVuY3Rpb24sXG4gICAgcGFyZW50TW9kdWxlOiBzdHJpbmdcbiAgKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzUmVzdWx0czogYW55W10gPSBuZXcgQXJyYXkoZGVwZW5kZW5jaWVzLmxlbmd0aCkuZmlsbChudWxsKVxuICAgIGxldCBsb2FkZWRDb3VudCA9IDBcbiAgICBsZXQgaGFzTG9hZGVkID0gZmFsc2VcblxuICAgIGlmICh0eXBlb2YgZGVwZW5kZW5jaWVzID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHJlZ2lzdGVyZWRNb2R1bGVzW2RlcGVuZGVuY2llc10pIHtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRNb2R1bGVzW2RlcGVuZGVuY2llc10uZGNsYW1kID09PSBNT0RVTEVfTE9BRElORykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUcnlpbmcgdG8gbG9hZCAke2RlcGVuZGVuY2llc30gZnJvbSAke3BhcmVudE1vZHVsZX0uIFRoZSBmaXJzdCBtb2R1bGUgaXMgc3RpbGwgbG9hZGluZy5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkTW9kdWxlc1tkZXBlbmRlbmNpZXNdXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGRlcGVuZGVuY2llcyArXG4gICAgICAgICAgJyBoYXMgbm90IGJlZW4gZGVmaW5lZC4gUGxlYXNlIGluY2x1ZGUgaXQgYXMgYSBkZXBlbmRlbmN5IGluICcgK1xuICAgICAgICAgIHBhcmVudE1vZHVsZSArXG4gICAgICAgICAgXCIncyBkZWZpbmUoKVwiXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgZGVwc0xlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGhcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkZXBzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBzd2l0Y2ggKGRlcGVuZGVuY2llc1tpbmRleF0pIHtcbiAgICAgICAgY2FzZSAncmVxdWlyZSc6XG4gICAgICAgICAgY29uc3QgX3JlcXVpcmU6IHR5cGVvZiByZXF1aXJlID0gZnVuY3Rpb24gKFxuICAgICAgICAgICAgbmV3X21vZHVsZTogc3RyaW5nIHwgc3RyaW5nW10sXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdm9pZCxcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IEZ1bmN0aW9uXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZShuZXdfbW9kdWxlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaywgcGFyZW50TW9kdWxlKVxuICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgX3JlcXVpcmUudG9VcmwgPSBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9VcmwobW9kdWxlLCBwYXJlbnRNb2R1bGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlcGVuZGVuY2llc1Jlc3VsdHNbaW5kZXhdID0gX3JlcXVpcmVcbiAgICAgICAgICBsb2FkZWRDb3VudCsrXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnZXhwb3J0cyc6XG4gICAgICAgICAgaWYgKCFyZWdpc3RlcmVkTW9kdWxlc1twYXJlbnRNb2R1bGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdQYXJlbnQgbW9kdWxlICcgKyBwYXJlbnRNb2R1bGUgKyAnIG5vdCByZWdpc3RlcmVkIHlldCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXBlbmRlbmNpZXNSZXN1bHRzW2luZGV4XSA9IHJlZ2lzdGVyZWRNb2R1bGVzW3BhcmVudE1vZHVsZV0uZXhwb3J0c1xuICAgICAgICAgIGxvYWRlZENvdW50KytcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdtb2R1bGUnOlxuICAgICAgICAgIGRlcGVuZGVuY2llc1Jlc3VsdHNbaW5kZXhdID0ge1xuICAgICAgICAgICAgaWQ6IHBhcmVudE1vZHVsZSxcbiAgICAgICAgICAgIHVyaTogdG9VcmwocGFyZW50TW9kdWxlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsb2FkZWRDb3VudCsrXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBjaXJjdWxhciBkZXBlbmRlbmN5LCB0aGVuIHdlIHJlc29sdmUgdGhlIG1vZHVsZSBldmVuIGlmIGl0IGhhc24ndCBsb2FkZWQgeWV0XG4gICAgICAgICAgY29uc3QgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpbmRleF1cblxuICAgICAgICAgIGNvbnN0IGhhc0N5Y2xlcyA9IGhhc0RlcGVuZGVuY3lQYXRoKGRlcGVuZGVuY3ksIHBhcmVudE1vZHVsZSlcblxuICAgICAgICAgIGNvbnN0IGhhbmRsZUxvYWRlZE1vZHVsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llc1Jlc3VsdHNbaW5kZXhdID0gcmVnaXN0ZXJlZE1vZHVsZXNbZGVwZW5kZW5jeV0uZXhwb3J0c1xuICAgICAgICAgICAgbG9hZGVkQ291bnQrK1xuICAgICAgICAgICAgaWYgKGxvYWRlZENvdW50ID09PSBkZXBzTGVuZ3RoICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGhhc0xvYWRlZCA9IHRydWVcbiAgICAgICAgICAgICAgY2FsbGJhY2soZGVwZW5kZW5jaWVzUmVzdWx0cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzQ3ljbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBjeWNsZVBhdGggPSBnZXRDeWNsZVBhdGgoZGVwZW5kZW5jeSwgcGFyZW50TW9kdWxlLCAwKVxuICAgICAgICAgICAgaWYgKGN5Y2xlUGF0aCkge1xuICAgICAgICAgICAgICBjeWNsZVBhdGgucmV2ZXJzZSgpXG4gICAgICAgICAgICAgIGN5Y2xlUGF0aC5wdXNoKGRlcGVuZGVuY3kpXG4gICAgICAgICAgICAgIGN5Y2xlcy5wdXNoKGN5Y2xlUGF0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWQoZGVwZW5kZW5jeSwgKCkgPT4ge30sIGVycm9yQ2FsbGJhY2ssIHBhcmVudE1vZHVsZSlcbiAgICAgICAgICAgIGhhbmRsZUxvYWRlZE1vZHVsZSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYWQoZGVwZW5kZW5jeSwgaGFuZGxlTG9hZGVkTW9kdWxlLCBlcnJvckNhbGxiYWNrLCBwYXJlbnRNb2R1bGUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzTG9hZGVkICYmIGxvYWRlZENvdW50ID09PSBkZXBzTGVuZ3RoICYmIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhkZXBlbmRlbmNpZXNSZXN1bHRzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1ldGhvZEhhbmRsZXIocnBjSGFuZGxlOiBzdHJpbmcsIG1ldGhvZDogTWV0aG9kRGVzY3JpcHRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGNsLmNhbGxScGMoXG4gICAgICAgIHJwY0hhbmRsZSxcbiAgICAgICAgbWV0aG9kLm5hbWUsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgYW5vbnltb3VzUXVldWUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJuczogcmVzb2x2ZWRNb2R1bGVOYW1lXG4gIGZ1bmN0aW9uIHJlc29sdmUoZnJvbU1vZHVsZTogc3RyaW5nLCB0b01vZHVsZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZyb21Nb2R1bGUgPyB0b1VybCh0b01vZHVsZSwgZnJvbU1vZHVsZSkgOiB0b01vZHVsZVxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZChcbiAgICBtb2R1bGVOYW1lOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IE1vZHVsZUxvYWRlZEhhbmRsZXIsXG4gICAgZXJyb3JDYWxsYmFjazogRnVuY3Rpb24sXG4gICAgcGFyZW50TW9kdWxlOiBzdHJpbmdcbiAgKSB7XG4gICAgaWYgKHJlZ2lzdGVyZWRNb2R1bGVzW21vZHVsZU5hbWVdKSB7XG4gICAgICByZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVOYW1lXS5kZXBlbmRhbnRzLmFkZChwYXJlbnRNb2R1bGUpXG5cbiAgICAgIGlmIChyZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVOYW1lXS5kY2xhbWQgPT09IE1PRFVMRV9MT0FESU5HKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIHJlZ2lzdGVyZWRNb2R1bGVzW21vZHVsZU5hbWVdLmhhbmRsZXJzLnB1c2goY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVOYW1lXSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2lzdGVyZWRNb2R1bGVzW21vZHVsZU5hbWVdID0ge1xuICAgICAgICBuYW1lOiBtb2R1bGVOYW1lLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudE1vZHVsZSxcbiAgICAgICAgZGNsYW1kOiBNT0RVTEVfTE9BRElORyxcbiAgICAgICAgaGFuZGxlcnM6IFtjYWxsYmFja10sXG4gICAgICAgIGRlcGVuZGVuY2llczogW10sXG4gICAgICAgIGRlcGVuZGFudHM6IG5ldyBTZXQoW3BhcmVudE1vZHVsZV0pLFxuICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2R1bGVOYW1lLmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgY29uc3QgZXhwb3J0cyA9IHJlZ2lzdGVyZWRNb2R1bGVzW21vZHVsZU5hbWVdLmV4cG9ydHNcbiAgICAgIGlmICh0eXBlb2YgZGNsLmxvYWRNb2R1bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGNsXG4gICAgICAgICAgLmxvYWRNb2R1bGUobW9kdWxlTmFtZSwgZXhwb3J0cylcbiAgICAgICAgICAudGhlbigoZGVzY3JpcHRvcjogTW9kdWxlRGVzY3JpcHRvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIGRlc2NyaXB0b3IubWV0aG9kcykge1xuICAgICAgICAgICAgICBjb25zdCBtZXRob2QgPSBkZXNjcmlwdG9yLm1ldGhvZHNbaV1cbiAgICAgICAgICAgICAgZXhwb3J0c1ttZXRob2QubmFtZV0gPSBjcmVhdGVNZXRob2RIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IucnBjSGFuZGxlLFxuICAgICAgICAgICAgICAgIG1ldGhvZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vZHVsZVJlYWR5KG1vZHVsZU5hbWUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlKVxuICAgICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0FzeW5jaHJvbm91cyBtb2R1bGVzIHdpbGwgbm90IHdvcmsgYmVjYXVzZSBsb2FkTW9kdWxlIGZ1bmN0aW9uIGlzIG5vdCBwcmVzZW50J1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGNsLm9uU3RhcnQoKCkgPT4ge1xuICAgICAgY29uc3QgdW5rbm93bk1vZHVsZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICAgICAgY29uc3Qgbm90TG9hZGVkTW9kdWxlczogTW9kdWxlW10gPSBbXVxuXG4gICAgICBmb3IgKGNvbnN0IGkgaW4gcmVnaXN0ZXJlZE1vZHVsZXMpIHtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRNb2R1bGVzW2ldKSB7XG4gICAgICAgICAgaWYgKHJlZ2lzdGVyZWRNb2R1bGVzW2ldLmRjbGFtZCA9PT0gTU9EVUxFX0xPQURJTkcpIHtcbiAgICAgICAgICAgIG5vdExvYWRlZE1vZHVsZXMucHVzaChyZWdpc3RlcmVkTW9kdWxlc1tpXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWdpc3RlcmVkTW9kdWxlc1tpXS5kZXBlbmRlbmNpZXMuZm9yRWFjaCgoJCkgPT4ge1xuICAgICAgICAgICAgaWYgKCQgPT09ICdyZXF1aXJlJyB8fCAkID09PSAnZXhwb3J0cycgfHwgJCA9PT0gJ21vZHVsZScpIHJldHVyblxuICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkTW9kdWxlc1skXSkgdW5rbm93bk1vZHVsZXMuYWRkKCQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlcnJvclBhcnRzOiBzdHJpbmdbXSA9IFtdXG5cbiAgICAgIGlmIChjeWNsZXMubGVuZ3RoKSB7XG4gICAgICAgIGVycm9yUGFydHMucHVzaChcbiAgICAgICAgICBgXFxuPiBDeWNsaWMgZGVwZW5kZW5jaWVzOiAke2N5Y2xlc1xuICAgICAgICAgICAgLm1hcCgoJCkgPT4gJ1xcbiAgLSAnICsgJC5qb2luKCcgLT4gJykpXG4gICAgICAgICAgICAuam9pbignJyl9YFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmICh1bmtub3duTW9kdWxlcy5zaXplKSB7XG4gICAgICAgIGVycm9yUGFydHMucHVzaChcbiAgICAgICAgICBgXFxuPiBVbmRlY2xhcmVkL3Vua25vd24gbW9kdWxlczogJHtBcnJheS5mcm9tKHVua25vd25Nb2R1bGVzKVxuICAgICAgICAgICAgLm1hcCgoJCkgPT4gJ1xcbiAgLSAnICsgJClcbiAgICAgICAgICAgIC5qb2luKCcnKX1gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdExvYWRlZE1vZHVsZXMubGVuZ3RoKSB7XG4gICAgICAgIGVycm9yUGFydHMucHVzaChcbiAgICAgICAgICBgXFxuPiBUaGVzZSBtb2R1bGVzIGRpZG4ndCBsb2FkOiAke25vdExvYWRlZE1vZHVsZXNcbiAgICAgICAgICAgIC5tYXAoKCQpID0+ICdcXG4gIC0gJyArICQubmFtZSlcbiAgICAgICAgICAgIC5qb2luKCcnKX0uXFxuYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvclBhcnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQYXJ0cy5qb2luKCdcXG4nKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSAnYS8uLi9uYW1lJyB0byAnbmFtZScsIGV0Yy5cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1vZHVsZUlkKG1vZHVsZUlkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCByID0gbW9kdWxlSWQsXG4gICAgICBwYXR0ZXJuOiBSZWdFeHBcblxuICAgIC8vIHJlcGxhY2UgLy4vID0+IC9cbiAgICBwYXR0ZXJuID0gL1xcL1xcLlxcLy9cbiAgICB3aGlsZSAocGF0dGVybi50ZXN0KHIpKSB7XG4gICAgICByID0gci5yZXBsYWNlKHBhdHRlcm4sICcvJylcbiAgICB9XG5cbiAgICAvLyByZXBsYWNlIF4uLyA9PiBub3RoaW5nXG4gICAgciA9IHIucmVwbGFjZSgvXlxcLlxcLy9nLCAnJylcblxuICAgIC8vIHJlcGxhY2UgL2FhLy4uLyA9PiAvIChCVVQgSUdOT1JFIC8uLi8uLi8pXG4gICAgcGF0dGVybiA9XG4gICAgICAvXFwvKChbXlxcL10pfChbXlxcL11bXlxcL1xcLl0pfChbXlxcL1xcLl1bXlxcL10pfChbXlxcL11bXlxcL11bXlxcL10rKSlcXC9cXC5cXC5cXC8vXG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdChyKSkge1xuICAgICAgciA9IHIucmVwbGFjZShwYXR0ZXJuLCAnLycpXG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSBeYWEvLi4vID0+IG5vdGhpbmcgKEJVVCBJR05PUkUgLi4vLi4vKVxuICAgIHIgPSByLnJlcGxhY2UoXG4gICAgICAvXigoW15cXC9dKXwoW15cXC9dW15cXC9cXC5dKXwoW15cXC9cXC5dW15cXC9dKXwoW15cXC9dW15cXC9dW15cXC9dKykpXFwvXFwuXFwuXFwvLyxcbiAgICAgICcnXG4gICAgKVxuXG4gICAgLy8gcmVwbGFjZSBeLyA9PiBub3RoaW5nXG4gICAgciA9IHIucmVwbGFjZSgvXlxcLy9nLCAnJylcblxuICAgIHJldHVybiByXG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSByZWxhdGl2ZSBtb2R1bGUgaWRzXG4gICAqL1xuICBmdW5jdGlvbiByZXNvbHZlTW9kdWxlKG1vZHVsZUlkOiBzdHJpbmcsIHBhcmVudE1vZHVsZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBsZXQgcmVzdWx0ID0gbW9kdWxlSWRcblxuICAgIGlmICghcmVzdWx0LnN0YXJ0c1dpdGgoJ0AnKSkge1xuICAgICAgaWYgKHJlc3VsdC5zdGFydHNXaXRoKCcuLycpIHx8IHJlc3VsdC5zdGFydHNXaXRoKCcuLi8nKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50UGF0aCA9IHBhcmVudE1vZHVsZS5zcGxpdCgnLycpXG4gICAgICAgIGN1cnJlbnRQYXRoLnBvcCgpXG4gICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZU1vZHVsZUlkKGN1cnJlbnRQYXRoLmpvaW4oJy8nKSArICcvJyArIHJlc3VsdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiB0b1VybChtb2R1bGVOYW1lOiBzdHJpbmcsIHBhcmVudE1vZHVsZT86IHN0cmluZykge1xuICAgIHN3aXRjaCAobW9kdWxlTmFtZSkge1xuICAgICAgY2FzZSAncmVxdWlyZSc6XG4gICAgICBjYXNlICdleHBvcnRzJzpcbiAgICAgIGNhc2UgJ21vZHVsZSc6XG4gICAgICAgIHJldHVybiBtb2R1bGVOYW1lXG4gICAgfVxuICAgIGlmIChwYXJlbnRNb2R1bGUpIHtcbiAgICAgIHJldHVybiByZXNvbHZlTW9kdWxlKG1vZHVsZU5hbWUsIHBhcmVudE1vZHVsZSlcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZU1vZHVsZUlkKG1vZHVsZU5hbWUpXG4gIH1cblxuICByZXF1aXJlLnRvVXJsID0gdG9Vcmxcbn1cblxuZ2xvYmFsT2JqZWN0LmRlZmluZSA9IGxvYWRlci5kZWZpbmVcbmdsb2JhbE9iamVjdC5kY2xhbWQgPSBsb2FkZXJcbiJdfQ==",
    "sha256": "1fcc2d76805964317daad52b00a258748d14ac85cfd45892dfdb47e8951b1ef1"
  },
  {
    "path": "node_modules/decentraland-ecs/dist/src/index.js",
    "content": "(function (exports) {\n  'use strict';\n\n  /**\r\n   * Entities can be attached to each other by using the `setParent` method. However, there are cases where we might want to attach entities\r\n   * to other objects that are not entities created by the same scene (for example, the player's avatar). For those cases, we have this class.\r\n   * @public\r\n   */\r\n  var Attachable = /** @class */ (function () {\r\n      function Attachable() {\r\n      }\r\n      /** Used to attach entities to the avatar. Entities will follow the avatar when it moves */\r\n      Attachable.AVATAR = {\r\n          getEntityRepresentation: function (engine) { return engine.avatarEntity; }\r\n      };\r\n      /** Used to attach entities to the camera. When in first person mode, the attached entities will also rotate with the camera */\r\n      Attachable.FIRST_PERSON_CAMERA = {\r\n          getEntityRepresentation: function (engine) { return engine.firstPersonCameraEntity; }\r\n      };\r\n      return Attachable;\r\n  }());\n\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation.\r\n\r\n  Permission to use, copy, modify, and/or distribute this software for any\r\n  purpose with or without fee is hereby granted.\r\n\r\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n  PERFORMANCE OF THIS SOFTWARE.\r\n  ***************************************************************************** */\r\n  /* global Reflect, Promise */\r\n\r\n  var extendStatics = function(d, b) {\r\n      extendStatics = Object.setPrototypeOf ||\r\n          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n      return extendStatics(d, b);\r\n  };\r\n\r\n  function __extends(d, b) {\r\n      if (typeof b !== \"function\" && b !== null)\r\n          throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n      extendStatics(d, b);\r\n      function __() { this.constructor = d; }\r\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n  }\r\n\r\n  var __assign = function() {\r\n      __assign = Object.assign || function __assign(t) {\r\n          for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n              s = arguments[i];\r\n              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n          }\r\n          return t;\r\n      };\r\n      return __assign.apply(this, arguments);\r\n  };\r\n\r\n  function __decorate(decorators, target, key, desc) {\r\n      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n      if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n      return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n  }\r\n\r\n  function __metadata(metadataKey, metadataValue) {\r\n      if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n  }\r\n\r\n  function __awaiter(thisArg, _arguments, P, generator) {\r\n      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n      return new (P || (P = Promise))(function (resolve, reject) {\r\n          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n          function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n      });\r\n  }\r\n\r\n  function __generator(thisArg, body) {\r\n      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n      function verb(n) { return function (v) { return step([n, v]); }; }\r\n      function step(op) {\r\n          if (f) throw new TypeError(\"Generator is already executing.\");\r\n          while (_) try {\r\n              if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n              if (y = 0, t) op = [op[0] & 2, t.value];\r\n              switch (op[0]) {\r\n                  case 0: case 1: t = op; break;\r\n                  case 4: _.label++; return { value: op[1], done: false };\r\n                  case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                  case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                  default:\r\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                      if (t[2]) _.ops.pop();\r\n                      _.trys.pop(); continue;\r\n              }\r\n              op = body.call(thisArg, _);\r\n          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n      }\r\n  }\r\n\r\n  function __values(o) {\r\n      var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n      if (m) return m.call(o);\r\n      if (o && typeof o.length === \"number\") return {\r\n          next: function () {\r\n              if (o && i >= o.length) o = void 0;\r\n              return { value: o && o[i++], done: !o };\r\n          }\r\n      };\r\n      throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n  }\r\n\r\n  function __read(o, n) {\r\n      var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n      if (!m) return o;\r\n      var i = m.call(o), r, ar = [], e;\r\n      try {\r\n          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n      }\r\n      catch (error) { e = { error: error }; }\r\n      finally {\r\n          try {\r\n              if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n          }\r\n          finally { if (e) throw e.error; }\r\n      }\r\n      return ar;\r\n  }\r\n\r\n  function __spreadArray(to, from) {\r\n      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n          to[j] = from[i];\r\n      return to;\r\n  }\n\n  var lastGeneratedId = 0;\r\n  /**\r\n   * Log function. Only works in debug mode, otherwise it does nothing.\r\n   * @param args - any loggable parameter\r\n   * @public\r\n   */\r\n  function log() {\r\n      var args = [];\r\n      for (var _i = 0; _i < arguments.length; _i++) {\r\n          args[_i] = arguments[_i];\r\n      }\r\n      if (typeof dcl !== 'undefined') {\r\n          dcl.log.apply(dcl, __spreadArray([], __read(args)));\r\n      }\r\n      else {\r\n          console.log.apply(console, __spreadArray(['DEBUG:'], __read(args)));\r\n      }\r\n  }\r\n  /**\r\n   * Error function. Prints a console error. Only works in debug mode, otherwise it does nothing.\r\n   * @param error - string or Error object.\r\n   * @param data - any debug information.\r\n   * @public\r\n   */\r\n  function error(error, data) {\r\n      if (typeof dcl !== 'undefined') {\r\n          dcl.error(error, data);\r\n      }\r\n      else {\r\n          console.error('ERROR:', error, data);\r\n      }\r\n  }\r\n  /**\r\n   * Generates a new prefixed id\r\n   * @public\r\n   */\r\n  function newId(type) {\r\n      lastGeneratedId++;\r\n      if (type.length === 0)\r\n          throw new Error('newId(type: string): type cannot be empty');\r\n      return type + lastGeneratedId.toString(36);\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  function uuid() {\r\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n          var r = (Math.random() * 16) | 0;\r\n          var v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n          return v.toString(16);\r\n      });\r\n  }\r\n  /**\r\n   * Returns an array of the given size filled with element built from the given constructor and the paramters\r\n   * @param size - the number of element to construct and put in the array\r\n   * @param itemBuilder - a callback responsible for creating new instance of item. Called once per array entry.\r\n   * @returns a new array filled with new objects\r\n   * @internal\r\n   */\r\n  function buildArray$1(size, itemBuilder) {\r\n      var a = [];\r\n      for (var i = 0; i < size; ++i) {\r\n          a.push(itemBuilder());\r\n      }\r\n      return a;\r\n  }\r\n  /**\r\n   * @public\r\n   */\r\n  function openExternalURL(url) {\r\n      if (typeof dcl !== 'undefined') {\r\n          dcl.openExternalUrl(url);\r\n      }\r\n      else {\r\n          error('ERROR: openExternalURL dcl is undefined');\r\n      }\r\n  }\r\n  /**\r\n   * Popup NFT info dialog\r\n   * @param scr - 'ethereum://contractAddress/tokenID'\r\n   * @param comment - optional. add a comment.\r\n   * @public\r\n   */\r\n  function openNFTDialog(scr, comment) {\r\n      if (comment === void 0) { comment = null; }\r\n      if (typeof dcl !== 'undefined') {\r\n          var regex = /ethereum:\\/\\/(.+)\\/(.+)/;\r\n          var matches = scr.match(regex);\r\n          if (!matches || matches.length < 3) {\r\n              return;\r\n          }\r\n          dcl.openNFTDialog(matches[1], matches[2], comment);\r\n      }\r\n      else {\r\n          error('ERROR: openNFTDialog dcl is undefined');\r\n      }\r\n  }\n\n  var eventNameSymbol = '__event_name__';\r\n  var takenEventNames = [];\r\n  function getEventNameFromConstructor(ctor) {\r\n      if (!(eventNameSymbol in ctor) || typeof ctor[eventNameSymbol] !== 'string') {\r\n          throw new Error('The EventConstructor is not registered');\r\n      }\r\n      return ctor[eventNameSymbol];\r\n  }\r\n  /**\r\n   * @public\r\n   */\r\n  var EventManager = /** @class */ (function () {\r\n      function EventManager() {\r\n          this.listeners = {};\r\n      }\r\n      EventManager.prototype.addListener = function (eventClass, listener, listenerFunction) {\r\n          if (!eventClass || typeof eventClass !== 'function') {\r\n              throw new Error('Invalid EventConstructor');\r\n          }\r\n          var eventName = getEventNameFromConstructor(eventClass);\r\n          var listeners = this.listeners[eventName];\r\n          if (!listeners) {\r\n              listeners = this.listeners[eventName] = [];\r\n          }\r\n          for (var i = 0; i < listeners.length; i++) {\r\n              var x = listeners[i];\r\n              if (x.listener === listener) {\r\n                  throw new Error('The provided listener is already registered');\r\n              }\r\n          }\r\n          listeners.push({\r\n              listener: listener,\r\n              fn: listenerFunction\r\n          });\r\n          return this;\r\n      };\r\n      EventManager.prototype.removeListener = function (listener, eventClass) {\r\n          if (!eventClass || typeof eventClass !== 'function') {\r\n              throw new Error('Invalid EventConstructor');\r\n          }\r\n          var eventName = getEventNameFromConstructor(eventClass);\r\n          var listeners = this.listeners[eventName];\r\n          if (!listeners) {\r\n              return false;\r\n          }\r\n          for (var i = 0; i < listeners.length; i++) {\r\n              var x = listeners[i];\r\n              if (x.listener === listener) {\r\n                  listeners.splice(i, 1);\r\n                  return true;\r\n              }\r\n          }\r\n          return false;\r\n      };\r\n      EventManager.prototype.fireEvent = function (event) {\r\n          var eventName = getEventNameFromConstructor(event.constructor);\r\n          var listeners = this.listeners[eventName];\r\n          if (listeners) {\r\n              for (var i = 0; i < listeners.length; i++) {\r\n                  try {\r\n                      var l = listeners[i];\r\n                      l.fn.call(l.listener, event);\r\n                  }\r\n                  catch (e) {\r\n                      // TODO: e may not be an instance of Error\r\n                      error(e);\r\n                  }\r\n              }\r\n          }\r\n          return this;\r\n      };\r\n      return EventManager;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  function EventConstructor() {\r\n      var eventName = newId('EV');\r\n      if (takenEventNames.indexOf(eventName) !== -1) {\r\n          throw new Error(\"The event name \" + eventName + \" is already taken\");\r\n      }\r\n      takenEventNames.push(eventName);\r\n      // eslint-disable-next-line @typescript-eslint/ban-types\r\n      return function (target) {\r\n          target[eventNameSymbol] = eventName;\r\n          return target;\r\n      };\r\n  }\n\n  /**\r\n   * @public\r\n   */\r\n  var ComponentRemoved = /** @class */ (function () {\r\n      function ComponentRemoved(entity, componentName, component) {\r\n          this.entity = entity;\r\n          this.componentName = componentName;\r\n          this.component = component;\r\n          // stub\r\n      }\r\n      ComponentRemoved = __decorate([\r\n          EventConstructor(),\r\n          __metadata(\"design:paramtypes\", [Object, String, Object])\r\n      ], ComponentRemoved);\r\n      return ComponentRemoved;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var ComponentAdded = /** @class */ (function () {\r\n      function ComponentAdded(entity, componentName, classId) {\r\n          this.entity = entity;\r\n          this.componentName = componentName;\r\n          this.classId = classId;\r\n          // stub\r\n      }\r\n      ComponentAdded = __decorate([\r\n          EventConstructor(),\r\n          __metadata(\"design:paramtypes\", [Object, String, Object])\r\n      ], ComponentAdded);\r\n      return ComponentAdded;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var ParentChanged = /** @class */ (function () {\r\n      function ParentChanged(entity, parent) {\r\n          this.entity = entity;\r\n          this.parent = parent;\r\n          // stub\r\n      }\r\n      ParentChanged = __decorate([\r\n          EventConstructor(),\r\n          __metadata(\"design:paramtypes\", [Object, Object])\r\n      ], ParentChanged);\r\n      return ParentChanged;\r\n  }());\n\n  /**\r\n   * @public\r\n   */\r\n  exports.UIValueType = void 0;\r\n  (function (UIValueType) {\r\n      UIValueType[UIValueType[\"PERCENT\"] = 0] = \"PERCENT\";\r\n      UIValueType[UIValueType[\"PIXELS\"] = 1] = \"PIXELS\";\r\n  })(exports.UIValueType || (exports.UIValueType = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  var UIValue = /** @class */ (function () {\r\n      function UIValue(value) {\r\n          this.type = exports.UIValueType.PIXELS;\r\n          if (typeof value === 'string') {\r\n              var valueAsString = value;\r\n              if (valueAsString.indexOf('px') > -1) {\r\n                  this.type = exports.UIValueType.PIXELS;\r\n              }\r\n              else if (valueAsString.indexOf('%') > -1) {\r\n                  this.type = exports.UIValueType.PERCENT;\r\n              }\r\n              this.value = parseFloat(valueAsString);\r\n          }\r\n          else {\r\n              this.value = value;\r\n          }\r\n      }\r\n      UIValue.prototype.toString = function () {\r\n          var result = this.value.toString();\r\n          if (this.type === exports.UIValueType.PERCENT) {\r\n              result += '%';\r\n          }\r\n          else {\r\n              result += 'px';\r\n          }\r\n          return result;\r\n      };\r\n      return UIValue;\r\n  }());\n\n  var componentSymbol = '__name__symbol_';\r\n  var componentClassIdSymbol = '__classId__symbol_';\r\n  var componentIdSymbol = '__component__id_';\r\n  /**\r\n   * @public\r\n   */\r\n  var DisposableComponentCreated = /** @class */ (function () {\r\n      function DisposableComponentCreated(componentId, componentName, classId) {\r\n          this.componentId = componentId;\r\n          this.componentName = componentName;\r\n          this.classId = classId;\r\n          // stub\r\n      }\r\n      DisposableComponentCreated = __decorate([\r\n          EventConstructor(),\r\n          __metadata(\"design:paramtypes\", [String, String, Number])\r\n      ], DisposableComponentCreated);\r\n      return DisposableComponentCreated;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var DisposableComponentRemoved = /** @class */ (function () {\r\n      function DisposableComponentRemoved(componentId) {\r\n          this.componentId = componentId;\r\n          // stub\r\n      }\r\n      DisposableComponentRemoved = __decorate([\r\n          EventConstructor(),\r\n          __metadata(\"design:paramtypes\", [String])\r\n      ], DisposableComponentRemoved);\r\n      return DisposableComponentRemoved;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var DisposableComponentUpdated = /** @class */ (function () {\r\n      function DisposableComponentUpdated(componentId, component) {\r\n          this.componentId = componentId;\r\n          this.component = component;\r\n          // stub\r\n      }\r\n      DisposableComponentUpdated = __decorate([\r\n          EventConstructor(),\r\n          __metadata(\"design:paramtypes\", [String, Object])\r\n      ], DisposableComponentUpdated);\r\n      return DisposableComponentUpdated;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  function Component(componentName, classId) {\r\n      return function (target) {\r\n          if (target.isComponent) {\r\n              throw new TypeError(\"You cannot extend a component. Trying to extend \" + target.originalClassName + \" with: \" + componentName);\r\n          }\r\n          var extendedClass = target;\r\n          var RegisteredComponent = function RegisteredComponent() {\r\n              // eslint-disable-next-line prefer-rest-params\r\n              var args = Array.prototype.slice.call(arguments);\r\n              var ret = new (extendedClass.bind.apply(extendedClass, __spreadArray([void 0], __read(args))))();\r\n              Object.defineProperty(ret, componentSymbol, {\r\n                  enumerable: false,\r\n                  writable: false,\r\n                  configurable: false,\r\n                  value: componentName\r\n              });\r\n              if (classId !== undefined) {\r\n                  Object.defineProperty(ret, componentClassIdSymbol, {\r\n                      enumerable: false,\r\n                      writable: false,\r\n                      configurable: false,\r\n                      value: classId\r\n                  });\r\n              }\r\n              return ret;\r\n          };\r\n          if (classId !== undefined) {\r\n              RegisteredComponent[componentClassIdSymbol] = classId;\r\n          }\r\n          RegisteredComponent[componentSymbol] = componentName;\r\n          RegisteredComponent.isComponent = true;\r\n          RegisteredComponent.originalClassName = componentName;\r\n          RegisteredComponent.prototype = target.prototype;\r\n          RegisteredComponent.prototype.constructor = target;\r\n          return RegisteredComponent;\r\n      };\r\n  }\r\n  /**\r\n   * @public\r\n   */\r\n  function DisposableComponent(componentName, classId) {\r\n      return function (target) {\r\n          if (target.isComponent) {\r\n              throw new TypeError(\"You cannot extend a component. Trying to extend \" + target.originalClassName + \" with: \" + componentName);\r\n          }\r\n          if (typeof classId !== 'number' || isNaN(classId)) {\r\n              throw new Error(\"classId: \" + classId + \" is an invalid integer\");\r\n          }\r\n          var extendedClass = target;\r\n          var RegisteredComponent = function RegisteredComponent() {\r\n              if (!DisposableComponent.engine) {\r\n                  throw new Error('You need to set a DisposableComponent.engine before creating disposable components');\r\n              }\r\n              // eslint-disable-next-line prefer-rest-params\r\n              var args = Array.prototype.slice.call(arguments);\r\n              var ret = new (extendedClass.bind.apply(extendedClass, __spreadArray([void 0], __read(args))))();\r\n              var id = newId('C');\r\n              Object.defineProperty(ret, componentSymbol, {\r\n                  enumerable: false,\r\n                  writable: false,\r\n                  configurable: false,\r\n                  value: componentName\r\n              });\r\n              Object.defineProperty(ret, componentIdSymbol, {\r\n                  enumerable: false,\r\n                  writable: false,\r\n                  configurable: false,\r\n                  value: id\r\n              });\r\n              if (classId !== undefined) {\r\n                  Object.defineProperty(ret, componentClassIdSymbol, {\r\n                      enumerable: false,\r\n                      writable: false,\r\n                      configurable: false,\r\n                      value: classId\r\n                  });\r\n              }\r\n              if (DisposableComponent.engine) {\r\n                  DisposableComponent.engine.registerComponent(ret);\r\n              }\r\n              return ret;\r\n          };\r\n          if (classId !== undefined) {\r\n              RegisteredComponent[componentClassIdSymbol] = classId;\r\n          }\r\n          RegisteredComponent[componentSymbol] = componentName;\r\n          RegisteredComponent.isComponent = true;\r\n          RegisteredComponent.isDisposableComponent = true;\r\n          RegisteredComponent.originalClassName = componentName;\r\n          RegisteredComponent.prototype = target.prototype;\r\n          RegisteredComponent.prototype.constructor = target;\r\n          return RegisteredComponent;\r\n      };\r\n  }\r\n  /** @internal */\r\n  (function (DisposableComponent) {\r\n      /** @internal */\r\n      // eslint-disable-next-line prefer-const\r\n      DisposableComponent.engine = null;\r\n  })(DisposableComponent || (DisposableComponent = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  function getComponentName(component) {\r\n      if (!component) {\r\n          throw new TypeError(component + ' is not a component.');\r\n      }\r\n      if (component[componentSymbol]) {\r\n          return component[componentSymbol];\r\n      }\r\n      throw new TypeError(component + ' is not a registered component.');\r\n  }\r\n  /**\r\n   * @public\r\n   */\r\n  function getComponentClassId(component) {\r\n      if (!component) {\r\n          throw new TypeError(component + ' is not a component.');\r\n      }\r\n      if (component[componentClassIdSymbol]) {\r\n          return component[componentClassIdSymbol];\r\n      }\r\n      if (!component[componentSymbol]) {\r\n          throw new TypeError(component + ' is not a registered component.');\r\n      }\r\n      return null;\r\n  }\r\n  /**\r\n   * @public\r\n   */\r\n  function getComponentId(component) {\r\n      if (!component) {\r\n          throw new TypeError(component + ' is not a component.');\r\n      }\r\n      if (component[componentIdSymbol]) {\r\n          return component[componentIdSymbol];\r\n      }\r\n      throw new TypeError(component + ' is not a registered disposable component.');\r\n  }\r\n  /**\r\n   * @public\r\n   */\r\n  var ObservableComponent = /** @class */ (function () {\r\n      function ObservableComponent() {\r\n          // @internal\r\n          this.dirty = false;\r\n          // @internal\r\n          this.data = {};\r\n          this.subscriptions = [];\r\n      }\r\n      ObservableComponent.component = function (target, propertyKey) {\r\n          if (delete target[propertyKey]) {\r\n              var componentSymbol_1 = propertyKey + '_' + Math.random();\r\n              target[componentSymbol_1] = undefined;\r\n              Object.defineProperty(target, componentSymbol_1, __assign(__assign({}, Object.getOwnPropertyDescriptor(target, componentSymbol_1)), { enumerable: false }));\r\n              Object.defineProperty(target, propertyKey.toString(), {\r\n                  get: function () {\r\n                      return this[componentSymbol_1];\r\n                  },\r\n                  set: function (value) {\r\n                      var oldValue = this[componentSymbol_1];\r\n                      if (value) {\r\n                          this.data[propertyKey] = getComponentId(value);\r\n                      }\r\n                      else {\r\n                          this.data[propertyKey] = null;\r\n                      }\r\n                      this[componentSymbol_1] = value;\r\n                      if (value !== oldValue) {\r\n                          this.dirty = true;\r\n                          for (var i = 0; i < this.subscriptions.length; i++) {\r\n                              this.subscriptions[i](propertyKey, value, oldValue);\r\n                          }\r\n                      }\r\n                  },\r\n                  enumerable: true\r\n              });\r\n          }\r\n      };\r\n      ObservableComponent.field = function (target, propertyKey) {\r\n          if (delete target[propertyKey]) {\r\n              Object.defineProperty(target, propertyKey.toString(), {\r\n                  get: function () {\r\n                      return this.data[propertyKey];\r\n                  },\r\n                  set: function (value) {\r\n                      var oldValue = this.data[propertyKey];\r\n                      this.data[propertyKey] = value;\r\n                      if (value !== oldValue) {\r\n                          this.dirty = true;\r\n                          for (var i = 0; i < this.subscriptions.length; i++) {\r\n                              this.subscriptions[i](propertyKey, value, oldValue);\r\n                          }\r\n                      }\r\n                  },\r\n                  enumerable: true\r\n              });\r\n          }\r\n      };\r\n      ObservableComponent.uiValue = function (target, propertyKey) {\r\n          if (delete target[propertyKey]) {\r\n              Object.defineProperty(target, propertyKey.toString(), {\r\n                  get: function () {\r\n                      return this.data[propertyKey].toString();\r\n                  },\r\n                  set: function (value) {\r\n                      var oldValue = this.data[propertyKey];\r\n                      var finalValue = new UIValue(value);\r\n                      this.data[propertyKey] = finalValue;\r\n                      if (finalValue !== oldValue) {\r\n                          this.dirty = true;\r\n                          for (var i = 0; i < this.subscriptions.length; i++) {\r\n                              this.subscriptions[i](propertyKey, finalValue, oldValue);\r\n                          }\r\n                      }\r\n                  },\r\n                  enumerable: true\r\n              });\r\n          }\r\n      };\r\n      ObservableComponent.readonly = function (target, propertyKey) {\r\n          if (delete target[propertyKey]) {\r\n              Object.defineProperty(target, propertyKey.toString(), {\r\n                  get: function () {\r\n                      if (propertyKey in this.data === false) {\r\n                          throw new Error(\"The field \" + propertyKey + \" is uninitialized\");\r\n                      }\r\n                      return this.data[propertyKey];\r\n                  },\r\n                  set: function (value) {\r\n                      if (propertyKey in this.data) {\r\n                          throw new Error(\"The field \" + propertyKey + \" is readonly\");\r\n                      }\r\n                      this.data[propertyKey] = value;\r\n                      this.dirty = true;\r\n                  },\r\n                  enumerable: true,\r\n                  configurable: false\r\n              });\r\n          }\r\n      };\r\n      ObservableComponent.prototype.onChange = function (fn) {\r\n          this.subscriptions.push(fn);\r\n          return this;\r\n      };\r\n      ObservableComponent.prototype.toJSON = function () {\r\n          return this.data;\r\n      };\r\n      return ObservableComponent;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  function isDisposableComponent(component) {\r\n      return componentIdSymbol in component;\r\n  }\n\n  /**\r\n   * @public\r\n   */\r\n  var ComponentGroup = /** @class */ (function () {\r\n      function ComponentGroup() {\r\n          var requires = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n              requires[_i] = arguments[_i];\r\n          }\r\n          this.entities = [];\r\n          this.active = false;\r\n          this._requiresNames = [];\r\n          // validate requires list\r\n          if (!requires) {\r\n              throw new Error('ComponentGroup: Could not load the requires list');\r\n          }\r\n          if (!(requires instanceof Array)) {\r\n              throw new Error('ComponentGroup: requires list is not an Array');\r\n          }\r\n          Object.defineProperty(this, 'requires', {\r\n              get: function () {\r\n                  return requires.slice();\r\n              }\r\n          });\r\n          Object.defineProperty(this, 'requiresNames', {\r\n              get: function () {\r\n                  return this._requiresNames.slice();\r\n              }\r\n          });\r\n          var _loop_1 = function (ix) {\r\n              var component = requires[ix];\r\n              var name = null;\r\n              if (!component) {\r\n                  throw new Error(\"ComponentGroup: the required component at location \" + ix + \" is invalid\");\r\n              }\r\n              try {\r\n                  name = getComponentName(component);\r\n              }\r\n              catch (e) {\r\n                  throw new Error(\"ComponentGroup: the required component at location \" + ix + \" is not registered as a @Component. Remember to provide the class of the component, not the name\");\r\n              }\r\n              if (this_1._requiresNames.some(function ($) { return $ === name; })) {\r\n                  throw new Error(\"ComponentGroup: the required component list has a repeated name \" + name);\r\n              }\r\n              this_1._requiresNames.push(name);\r\n          };\r\n          var this_1 = this;\r\n          for (var ix = 0; ix < requires.length; ix++) {\r\n              _loop_1(ix);\r\n          }\r\n      }\r\n      ComponentGroup.prototype.hasEntity = function (entity) {\r\n          if (!entity.isAddedToEngine())\r\n              return false;\r\n          return this.entities.indexOf(entity) !== -1;\r\n      };\r\n      // @internal\r\n      ComponentGroup.prototype.addEntity = function (entity) {\r\n          if (!entity.isAddedToEngine()) {\r\n              throw new TypeError('ComponentGroup: Cannot add a entity that is not added to the engine');\r\n          }\r\n          if (this.entities.indexOf(entity) === -1) {\r\n              this.entities.push(entity);\r\n          }\r\n      };\r\n      // @internal\r\n      ComponentGroup.prototype.removeEntity = function (entity) {\r\n          var id = this.entities.indexOf(entity);\r\n          if (id !== -1) {\r\n              this.entities.splice(id, 1);\r\n          }\r\n      };\r\n      // @internal\r\n      ComponentGroup.prototype.componentRemoved = function (entity, component) {\r\n          if (this._requiresNames.indexOf(component) !== -1) {\r\n              this.removeEntity(entity);\r\n          }\r\n      };\r\n      // @internal\r\n      ComponentGroup.prototype.meetsRequirements = function (entity) {\r\n          for (var i = 0; i < this._requiresNames.length; i++) {\r\n              var componentName = this._requiresNames[i];\r\n              if (!(componentName in entity.components)) {\r\n                  return false;\r\n              }\r\n          }\r\n          return true;\r\n      };\r\n      return ComponentGroup;\r\n  }());\n\n  /**\r\n   * @public\r\n   */\r\n  var Entity = /** @class */ (function () {\r\n      function Entity(name) {\r\n          this.name = name;\r\n          this.children = {};\r\n          this.eventManager = null;\r\n          this.alive = false;\r\n          this.uuid = newId('E');\r\n          this.components = {};\r\n          // @internal\r\n          this.engine = null;\r\n          // @internal\r\n          this._parent = null;\r\n          // stub\r\n      }\r\n      /**\r\n       * Adds or replaces a component in the entity.\r\n       * @param component - component instance.\r\n       */\r\n      Entity.prototype.addComponentOrReplace = function (component) {\r\n          if (typeof component === 'function') {\r\n              throw new Error('You passed a function or class as a component, an instance of component is expected');\r\n          }\r\n          if (typeof component !== 'object') {\r\n              throw new Error(\"You passed a \" + typeof component + \", an instance of component is expected\");\r\n          }\r\n          var componentName = getComponentName(component);\r\n          if (this.components[componentName]) {\r\n              if (this.components[componentName] === component) {\r\n                  return component;\r\n              }\r\n              this.removeComponent(this.components[componentName], false);\r\n          }\r\n          return this.addComponent(component);\r\n      };\r\n      Entity.prototype.hasComponent = function (component) {\r\n          var typeOfComponent = typeof component;\r\n          if (typeOfComponent !== 'string' &&\r\n              typeOfComponent !== 'object' &&\r\n              typeOfComponent !== 'function') {\r\n              throw new Error('Entity#has(component): component is not a class, name or instance');\r\n          }\r\n          if (component === null)\r\n              return false;\r\n          var componentName = typeOfComponent === 'string'\r\n              ? component\r\n              : getComponentName(component);\r\n          var storedComponent = this.components[componentName];\r\n          if (!storedComponent) {\r\n              return false;\r\n          }\r\n          if (typeOfComponent === 'object') {\r\n              return storedComponent === component;\r\n          }\r\n          if (typeOfComponent === 'function') {\r\n              return storedComponent instanceof component;\r\n          }\r\n          return true;\r\n      };\r\n      Entity.prototype.getComponent = function (component) {\r\n          var typeOfComponent = typeof component;\r\n          if (typeOfComponent !== 'string' && typeOfComponent !== 'function') {\r\n              throw new Error('Entity#get(component): component is not a class or name');\r\n          }\r\n          var componentName = typeOfComponent === 'string'\r\n              ? component\r\n              : getComponentName(component);\r\n          var storedComponent = this.components[componentName];\r\n          if (!storedComponent) {\r\n              throw new Error(\"Can not get component \\\"\" + componentName + \"\\\" from entity \\\"\" + this.identifier + \"\\\"\");\r\n          }\r\n          if (typeOfComponent === 'function') {\r\n              if (storedComponent instanceof component) {\r\n                  return storedComponent;\r\n              }\r\n              else {\r\n                  throw new Error(\"Can not get component \\\"\" + componentName + \"\\\" from entity \\\"\" + this.identifier + \"\\\" (by instance)\");\r\n              }\r\n          }\r\n          return storedComponent;\r\n      };\r\n      Entity.prototype.getComponentOrNull = function (component) {\r\n          var typeOfComponent = typeof component;\r\n          if (typeOfComponent !== 'string' && typeOfComponent !== 'function') {\r\n              throw new Error('Entity#getOrNull(component): component is not a class or name');\r\n          }\r\n          var componentName = typeOfComponent === 'string'\r\n              ? component\r\n              : getComponentName(component);\r\n          var storedComponent = this.components[componentName];\r\n          if (!storedComponent) {\r\n              return null;\r\n          }\r\n          if (typeOfComponent === 'function') {\r\n              if (storedComponent instanceof component) {\r\n                  return storedComponent;\r\n              }\r\n              else {\r\n                  return null;\r\n              }\r\n          }\r\n          return storedComponent;\r\n      };\r\n      /**\r\n       * Gets a component, if it doesn't exist, it creates the component and returns it.\r\n       * @param component - component class\r\n       */\r\n      Entity.prototype.getComponentOrCreate = function (component) {\r\n          if (typeof component !== 'function') {\r\n              throw new Error('Entity#getOrCreate(component): component is not a class');\r\n          }\r\n          var ret = this.getComponentOrNull(component);\r\n          if (!ret) {\r\n              ret = new component();\r\n              // Safe-guard to only add registered components to entities\r\n              getComponentName(ret);\r\n              this.addComponentOrReplace(ret);\r\n          }\r\n          return ret;\r\n      };\r\n      /**\r\n       * Adds a component. If the component already exist, it throws an Error.\r\n       * @param component - component instance.\r\n       */\r\n      Entity.prototype.addComponent = function (component) {\r\n          if (typeof component !== 'object') {\r\n              throw new Error('Entity#add(component): You passed a function or class as a component, an instance of component is expected');\r\n          }\r\n          var componentName = getComponentName(component);\r\n          var classId = getComponentClassId(component);\r\n          if (this.components[componentName]) {\r\n              throw new Error(\"A component of type \\\"\" + componentName + \"\\\" is already present in entity \\\"\" + this.identifier + \"\\\"\");\r\n          }\r\n          this.components[componentName] = component;\r\n          if (this.eventManager) {\r\n              this.eventManager.fireEvent(new ComponentAdded(this, componentName, classId));\r\n          }\r\n          var storedComponent = component;\r\n          if (typeof storedComponent.addedToEntity === 'function') {\r\n              storedComponent.addedToEntity(this);\r\n          }\r\n          return component;\r\n      };\r\n      Entity.prototype.removeComponent = function (\r\n      // eslint-disable-next-line @typescript-eslint/ban-types\r\n      component, triggerRemovedEvent) {\r\n          if (triggerRemovedEvent === void 0) { triggerRemovedEvent = true; }\r\n          var typeOfComponent = typeof component;\r\n          if (typeOfComponent !== 'string' &&\r\n              typeOfComponent !== 'function' &&\r\n              typeOfComponent !== 'object') {\r\n              throw new Error('Entity#remove(component): component is not a class, class or name');\r\n          }\r\n          var componentName = typeOfComponent === 'string'\r\n              ? component\r\n              : getComponentName(component);\r\n          var storedComponent = this.components[componentName];\r\n          if (!storedComponent) {\r\n              log(\"Entity Warning: Trying to remove inexisting component \\\"\" + componentName + \"\\\" from entity \\\"\" + this.identifier + \"\\\"\");\r\n              return;\r\n          }\r\n          if (typeOfComponent === 'function') {\r\n              if (storedComponent instanceof component) {\r\n                  delete this.components[componentName];\r\n                  if (storedComponent) {\r\n                      if (triggerRemovedEvent && this.eventManager) {\r\n                          this.eventManager.fireEvent(new ComponentRemoved(this, componentName, storedComponent));\r\n                      }\r\n                      if (typeof storedComponent.removedFromEntity === 'function') {\r\n                          storedComponent.removedFromEntity(this);\r\n                      }\r\n                  }\r\n                  return;\r\n              }\r\n              else {\r\n                  log(\"Entity Warning: Trying to remove wrong (by constructor) component \\\"\" + componentName + \"\\\" from entity \\\"\" + this.identifier + \"\\\"\");\r\n                  return;\r\n              }\r\n          }\r\n          delete this.components[componentName];\r\n          if (storedComponent) {\r\n              if (triggerRemovedEvent && this.eventManager) {\r\n                  this.eventManager.fireEvent(new ComponentRemoved(this, componentName, storedComponent));\r\n              }\r\n              if (typeof storedComponent.removedFromEntity === 'function') {\r\n                  storedComponent.removedFromEntity(this);\r\n              }\r\n          }\r\n          return;\r\n      };\r\n      /**\r\n       * Returns true if the entity is already added to the engine.\r\n       * Returns false if no engine was defined.\r\n       */\r\n      Entity.prototype.isAddedToEngine = function () {\r\n          if (this.engine &&\r\n              (this.uuid in this.engine.entities || this.engine.rootEntity === this)) {\r\n              return true;\r\n          }\r\n          return false;\r\n      };\r\n      /**\r\n       * Sets the parent entity\r\n       */\r\n      Entity.prototype.setParent = function (_parent) {\r\n          var newParent;\r\n          // Check if parent is of type Attachable\r\n          if (_parent && 'getEntityRepresentation' in _parent) {\r\n              if (!this.engine) {\r\n                  throw new Error(\"In order to set an attachable as parent, you first need to add the entity to the engine.\");\r\n              }\r\n              newParent = _parent.getEntityRepresentation(this.engine);\r\n          }\r\n          else {\r\n              newParent = !_parent && this.engine ? this.engine.rootEntity : _parent;\r\n          }\r\n          var currentParent = this.getParent();\r\n          if (newParent === this) {\r\n              throw new Error(\"Failed to set parent for entity \\\"\" + this.identifier + \"\\\": An entity can't set itself as a its own parent\");\r\n          }\r\n          if (newParent === currentParent) {\r\n              return this;\r\n          }\r\n          var circularAncestor = this.getCircularAncestor(newParent);\r\n          if (circularAncestor) {\r\n              throw new Error(\"Failed to set parent for entity \\\"\" + this.identifier + \"\\\": Circular parent references are not allowed (See entity \\\"\" + circularAncestor + \"\\\")\");\r\n          }\r\n          if (currentParent) {\r\n              delete currentParent.children[this.uuid];\r\n          }\r\n          // Make sure that the parent and child are both on the engine, or off the engine, together\r\n          if (newParent !== null && newParent.uuid !== '0') {\r\n              if (!newParent.isAddedToEngine() && this.isAddedToEngine()) {\r\n                  this.engine.removeEntity(this);\r\n              }\r\n              if (newParent.isAddedToEngine() && !this.isAddedToEngine()) {\r\n                  newParent.engine.addEntity(this);\r\n              }\r\n          }\r\n          this._parent = newParent || null;\r\n          this.registerAsChild();\r\n          if (this.eventManager && this.engine) {\r\n              this.eventManager.fireEvent(new ParentChanged(this, newParent));\r\n          }\r\n          return this;\r\n      };\r\n      /**\r\n       * Gets the parent entity\r\n       */\r\n      Entity.prototype.getParent = function () {\r\n          return this._parent;\r\n      };\r\n      Object.defineProperty(Entity.prototype, \"identifier\", {\r\n          get: function () {\r\n              return this.name || this.uuid;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      Entity.prototype.getCircularAncestor = function (ent) {\r\n          var root = this.engine ? this.engine.rootEntity : null;\r\n          var e = ent;\r\n          while (e && e !== root) {\r\n              var parent = e.getParent();\r\n              if (parent === this) {\r\n                  return e.uuid;\r\n              }\r\n              e = parent;\r\n          }\r\n          return null;\r\n      };\r\n      Entity.prototype.registerAsChild = function () {\r\n          var parent = this.getParent();\r\n          if (this.uuid && parent) {\r\n              parent.children[this.uuid] = this;\r\n          }\r\n      };\r\n      return Entity;\r\n  }());\n\n  /**\r\n   * @public\r\n   */\r\n  var Engine = /** @class */ (function () {\r\n      function Engine(rootEntity) {\r\n          this.eventManager = new EventManager();\r\n          // @internal\r\n          this.systems = [];\r\n          // @internal\r\n          this.entityLists = {};\r\n          // @internal\r\n          this.addedSystems = [];\r\n          this._entities = {};\r\n          this._disposableComponents = {};\r\n          this._componentGroups = {};\r\n          // systems that doesn't require any component or handle their own logic\r\n          this.simpleSystems = [];\r\n          this.eventManager.addListener(ComponentAdded, this, this.componentAddedHandler);\r\n          this.eventManager.addListener(ComponentRemoved, this, this.componentRemovedHandler);\r\n          this.rootEntity = rootEntity;\r\n          this.firstPersonCameraEntity = new Entity();\r\n          this.firstPersonCameraEntity.uuid =\r\n              'FirstPersonCameraEntityReference';\r\n          this.addEntity(this.firstPersonCameraEntity);\r\n          this.avatarEntity = new Entity();\r\n          this.avatarEntity.uuid = 'AvatarEntityReference';\r\n          this.addEntity(this.avatarEntity);\r\n      }\r\n      Object.defineProperty(Engine.prototype, \"entities\", {\r\n          get: function () {\r\n              return this._entities;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      Object.defineProperty(Engine.prototype, \"disposableComponents\", {\r\n          get: function () {\r\n              return this._disposableComponents;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      Engine.prototype.addEntity = function (entity) {\r\n          var parent = entity.getParent();\r\n          if (entity.isAddedToEngine()) {\r\n              return entity;\r\n          }\r\n          entity.eventManager = this.eventManager;\r\n          entity.engine = this;\r\n          this._entities[entity.uuid] = entity;\r\n          this.checkRequirementsAndAdd(entity);\r\n          if (!parent) {\r\n              entity.setParent(this.rootEntity);\r\n          }\r\n          else {\r\n              if (!parent.isAddedToEngine() && parent !== this.rootEntity) {\r\n                  log('Engine: warning, added an entity with a parent not present in the engine. Parent id: ' +\r\n                      parent.uuid);\r\n              }\r\n          }\r\n          entity.alive = true;\r\n          for (var i in entity.children) {\r\n              var child = entity.children[i];\r\n              if (child) {\r\n                  if (!child.isAddedToEngine()) {\r\n                      this.addEntity(child);\r\n                  }\r\n              }\r\n          }\r\n          return entity;\r\n      };\r\n      Engine.prototype.removeEntity = function (entity) {\r\n          var id = entity.uuid;\r\n          if (entity.isAddedToEngine()) {\r\n              for (var componentName in entity.components) {\r\n                  var componentGroups = this._componentGroups[componentName];\r\n                  if (componentGroups) {\r\n                      for (var groupIndex in componentGroups) {\r\n                          componentGroups[groupIndex].removeEntity(entity);\r\n                      }\r\n                  }\r\n                  delete this.entityLists[componentName][id];\r\n              }\r\n              for (var i = 0; i < this.simpleSystems.length; i++) {\r\n                  var system = this.simpleSystems[i];\r\n                  if (system.onRemoveEntity) {\r\n                      system.onRemoveEntity(entity);\r\n                  }\r\n              }\r\n              for (var i in entity.children) {\r\n                  var child = entity.children[i];\r\n                  if (child) {\r\n                      this.removeEntity(child);\r\n                  }\r\n              }\r\n              entity.alive = false;\r\n              entity.eventManager = null;\r\n              delete this._entities[id];\r\n              return true;\r\n          }\r\n          else {\r\n              log('Engine: Trying to remove non existent entity from engine.');\r\n              if (!entity.isAddedToEngine()) {\r\n                  log(\"Engine: Entity \\\"\" + entity.uuid + \"\\\" has not been added to any engine yet.\");\r\n              }\r\n              else {\r\n                  log('Engine: Entity id: ' + id);\r\n              }\r\n              log(\"Engine: Entity's components:\");\r\n              for (var componentName in entity.components) {\r\n                  log(componentName);\r\n              }\r\n              return false;\r\n          }\r\n      };\r\n      Engine.prototype.addSystem = function (system, priority) {\r\n          if (priority === void 0) { priority = 0; }\r\n          if (this.addedSystems.indexOf(system) !== -1) {\r\n              log('Engine: Trying to add a system that is already added. Aborting');\r\n              return system;\r\n          }\r\n          if (this.systems.length > 0) {\r\n              for (var i = 0; i < this.systems.length; i++) {\r\n                  var entry = this.systems[i];\r\n                  var isLast = i === this.systems.length - 1;\r\n                  if (entry.priority > priority) {\r\n                      this.addedSystems.push(system);\r\n                      this.systems.splice(i, 0, { system: system, priority: priority });\r\n                      break;\r\n                  }\r\n                  else if (isLast) {\r\n                      this.addedSystems.push(system);\r\n                      this.systems.splice(i + 1, 0, { system: system, priority: priority });\r\n                      break;\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              this.addedSystems.push(system);\r\n              this.systems.splice(1, 0, { system: system, priority: priority });\r\n          }\r\n          this.registerSystem(system);\r\n          return system;\r\n      };\r\n      Engine.prototype.removeSystem = function (system) {\r\n          var idx = this.addedSystems.indexOf(system);\r\n          if (idx !== -1) {\r\n              system.active = false;\r\n              if (system.deactivate) {\r\n                  system.deactivate();\r\n              }\r\n              this.addedSystems.splice(idx, 1);\r\n              for (var i = 0; i < this.systems.length; i++) {\r\n                  var sys = this.systems[i].system;\r\n                  if (sys === system) {\r\n                      this.systems.splice(i, 1);\r\n                  }\r\n              }\r\n              return true;\r\n          }\r\n          return false;\r\n      };\r\n      Engine.prototype.update = function (dt) {\r\n          for (var i in this.systems) {\r\n              var system = this.systems[i].system;\r\n              if (system.active && system.update) {\r\n                  try {\r\n                      system.update(dt);\r\n                  }\r\n                  catch (e) {\r\n                      // TODO: e may not be an Error\r\n                      error(e);\r\n                  }\r\n              }\r\n          }\r\n          return this;\r\n      };\r\n      Engine.prototype.getEntitiesWithComponent = function (component) {\r\n          var componentName = typeof component === 'string' ? component : getComponentName(component);\r\n          if (componentName in this.entityLists) {\r\n              return this.entityLists[componentName];\r\n          }\r\n          else {\r\n              return (this.entityLists[componentName] = {});\r\n          }\r\n      };\r\n      Engine.prototype.registerComponent = function (component) {\r\n          var id = getComponentId(component);\r\n          var name = getComponentName(component);\r\n          var classId = getComponentClassId(component);\r\n          this._disposableComponents[id] = component;\r\n          if (classId !== null) {\r\n              this.eventManager.fireEvent(new DisposableComponentCreated(id, name, classId));\r\n              this.eventManager.fireEvent(new DisposableComponentUpdated(id, component));\r\n          }\r\n      };\r\n      Engine.prototype.disposeComponent = function (component) {\r\n          var id = getComponentId(component);\r\n          if (delete this._disposableComponents[id]) {\r\n              this.eventManager.fireEvent(new DisposableComponentRemoved(id));\r\n              if (component.onDispose) {\r\n                  component.onDispose();\r\n              }\r\n              return true;\r\n          }\r\n          return false;\r\n      };\r\n      Engine.prototype.updateComponent = function (component) {\r\n          this.eventManager.fireEvent(new DisposableComponentUpdated(getComponentId(component), component));\r\n      };\r\n      Engine.prototype.getComponentGroup = function () {\r\n          var requires = [];\r\n          for (var _i = 0; _i < arguments.length; _i++) {\r\n              requires[_i] = arguments[_i];\r\n          }\r\n          var componentGroup = undefined;\r\n          // Return an already created component-group if it already exists\r\n          if (requires.length > 0) {\r\n              // 1. get component groups for first require\r\n              var componentGroups = this._componentGroups[getComponentName(requires[0])];\r\n              if (componentGroups) {\r\n                  var components = requires.slice();\r\n                  // 2. search for a component group that has all the same requirements\r\n                  for (var i = 0; i < componentGroups.length; i++) {\r\n                      var traversedComponentGroup = componentGroups[i];\r\n                      if (components.length === traversedComponentGroup.requires.length) {\r\n                          for (var j = 0; j < components.length; j++) {\r\n                              if (traversedComponentGroup.requires.indexOf(components[j]) === -1)\r\n                                  break;\r\n                              if (j === components.length - 1) {\r\n                                  componentGroup = traversedComponentGroup;\r\n                              }\r\n                          }\r\n                          if (componentGroup)\r\n                              break;\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n          if (componentGroup) {\r\n              // 3. Found an existent component group with the exact same requirements\r\n              return componentGroup;\r\n          }\r\n          // Otherwise create and store it\r\n          componentGroup = new (ComponentGroup.bind.apply(ComponentGroup, __spreadArray([void 0], __read(requires))))();\r\n          componentGroup.active = true;\r\n          var requiresNames = componentGroup.requiresNames;\r\n          for (var i = 0; i < requiresNames.length; i++) {\r\n              var componentName = requiresNames[i];\r\n              var componentGroups = this._componentGroups[componentName];\r\n              if (!componentGroups) {\r\n                  this._componentGroups[componentName] = componentGroups = [];\r\n              }\r\n              if (componentGroups.indexOf(componentGroup) === -1) {\r\n                  componentGroups.push(componentGroup);\r\n              }\r\n          }\r\n          for (var entityId in this._entities) {\r\n              this.checkRequirements(this._entities[entityId], componentGroup);\r\n          }\r\n          return componentGroup;\r\n      };\r\n      Engine.prototype.removeComponentGroup = function (componentGroup) {\r\n          if (componentGroup.active) {\r\n              componentGroup.active = false;\r\n              var requiresNames = componentGroup.requiresNames;\r\n              for (var i = 0; i < requiresNames.length; i++) {\r\n                  var componentName = requiresNames[i];\r\n                  var componentGroups = this._componentGroups[componentName];\r\n                  if (componentGroups) {\r\n                      var idx = componentGroups.indexOf(componentGroup);\r\n                      if (idx !== -1) {\r\n                          componentGroups.splice(idx, 1);\r\n                      }\r\n                  }\r\n              }\r\n              return true;\r\n          }\r\n          return false;\r\n      };\r\n      Engine.prototype.registerSystem = function (system) {\r\n          system.active = true;\r\n          if (system.activate) {\r\n              system.activate(this);\r\n          }\r\n          this.simpleSystems.push(system);\r\n      };\r\n      Engine.prototype.checkRequirementsAndAdd = function (entity) {\r\n          if (!entity.isAddedToEngine())\r\n              return;\r\n          for (var componentName in entity.components) {\r\n              if (!(componentName in this.entityLists)) {\r\n                  this.entityLists[componentName] = {};\r\n              }\r\n              this.entityLists[componentName][entity.uuid] = entity;\r\n              var componentGroups = this._componentGroups[componentName];\r\n              if (componentGroups) {\r\n                  for (var systemIndex in componentGroups) {\r\n                      this.checkRequirements(entity, componentGroups[systemIndex]);\r\n                  }\r\n              }\r\n          }\r\n          for (var i = 0; i < this.simpleSystems.length; i++) {\r\n              var system = this.simpleSystems[i];\r\n              if (system.onAddEntity) {\r\n                  system.onAddEntity(entity);\r\n              }\r\n          }\r\n      };\r\n      Engine.prototype.checkRequirements = function (entity, system) {\r\n          if (system.meetsRequirements(entity)) {\r\n              if (!system.hasEntity(entity)) {\r\n                  system.addEntity(entity);\r\n              }\r\n          }\r\n          else {\r\n              if (system.hasEntity(entity)) {\r\n                  system.removeEntity(entity);\r\n              }\r\n          }\r\n      };\r\n      Engine.prototype.componentAddedHandler = function (event) {\r\n          var _a;\r\n          var entity = event.entity, componentName = event.componentName;\r\n          if (!entity.isAddedToEngine())\r\n              return;\r\n          if (!this.entityLists[componentName]) {\r\n              this.entityLists[componentName] = (_a = {}, _a[entity.uuid] = entity, _a);\r\n          }\r\n          else {\r\n              this.entityLists[componentName][entity.uuid] = entity;\r\n          }\r\n          var componentGroups = this._componentGroups[componentName];\r\n          if (componentGroups) {\r\n              for (var i in componentGroups) {\r\n                  this.checkRequirements(entity, componentGroups[i]);\r\n              }\r\n          }\r\n      };\r\n      Engine.prototype.componentRemovedHandler = function (event) {\r\n          // In case a single component gets removed from an entity, we inform\r\n          // all systems that this entity lost this specific component.\r\n          var entity = event.entity, componentName = event.componentName;\r\n          if (!entity.isAddedToEngine())\r\n              return;\r\n          delete this.entityLists[componentName][entity.uuid];\r\n          var componentGroups = this._componentGroups[componentName];\r\n          if (componentGroups) {\r\n              for (var i in componentGroups) {\r\n                  this.checkRequirements(entity, componentGroups[i]);\r\n              }\r\n          }\r\n      };\r\n      return Engine;\r\n  }());\n\n  var _defer = Promise.resolve().then.bind(Promise.resolve());\r\n  /**\r\n   * Executes an asynchronous task\r\n   * @param task - the task to execute\r\n   * @public\r\n   */\r\n  function executeTask(task) {\r\n      var result = _defer(task);\r\n      result.isComplete = false;\r\n      result\r\n          .then(function ($) {\r\n          result.isComplete = true;\r\n          result.result = $;\r\n          result.didFail = false;\r\n      })\r\n          .catch(function ($) {\r\n          result.isComplete = true;\r\n          result.error = $;\r\n          result.didFail = true;\r\n          error('executeTask: FAILED ' + $.toString(), $);\r\n      });\r\n      return result;\r\n  }\n\n  /**\r\n   * A class serves as a medium between the observable and its observers\r\n   * @public\r\n   */\r\n  var ObserverEventState = /** @class */ (function () {\r\n      /**\r\n       * Create a new EventState\r\n       * @param mask - defines the mask associated with this state\r\n       * @param skipNextObservers - defines a flag which will instruct the observable to skip following observers when set to true\r\n       * @param target - defines the original target of the state\r\n       * @param currentTarget - defines the current target of the state\r\n       */\r\n      function ObserverEventState(mask, skipNextObservers, target, currentTarget) {\r\n          if (skipNextObservers === void 0) { skipNextObservers = false; }\r\n          this.initalize(mask, skipNextObservers, target, currentTarget);\r\n      }\r\n      /**\r\n       * Initialize the current event state\r\n       * @param mask - defines the mask associated with this state\r\n       * @param skipNextObservers - defines a flag which will instruct the observable to skip following observers when set to true\r\n       * @param target - defines the original target of the state\r\n       * @param currentTarget - defines the current target of the state\r\n       * @returns the current event state\r\n       */\r\n      ObserverEventState.prototype.initalize = function (mask, skipNextObservers, target, currentTarget) {\r\n          if (skipNextObservers === void 0) { skipNextObservers = false; }\r\n          this.mask = mask;\r\n          this.skipNextObservers = skipNextObservers;\r\n          this.target = target;\r\n          this.currentTarget = currentTarget;\r\n          return this;\r\n      };\r\n      return ObserverEventState;\r\n  }());\r\n  /**\r\n   * Represent an Observer registered to a given Observable object.\r\n   * @public\r\n   */\r\n  var Observer = /** @class */ (function () {\r\n      /**\r\n       * Creates a new observer\r\n       * @param callback - defines the callback to call when the observer is notified\r\n       * @param mask - defines the mask of the observer (used to filter notifications)\r\n       * @param scope - defines the current scope used to restore the JS context\r\n       */\r\n      function Observer(\r\n      /**\r\n       * Defines the callback to call when the observer is notified\r\n       */\r\n      callback, \r\n      /**\r\n       * Defines the mask of the observer (used to filter notifications)\r\n       */\r\n      mask, \r\n      /**\r\n       * Defines the current scope used to restore the JS context\r\n       */\r\n      scope) {\r\n          if (scope === void 0) { scope = null; }\r\n          this.callback = callback;\r\n          this.mask = mask;\r\n          this.scope = scope;\r\n          /**\r\n           * Gets or sets a property defining that the observer as to be unregistered after the next notification\r\n           */\r\n          this.unregisterOnNextCall = false;\r\n          /** For internal usage */\r\n          this._willBeUnregistered = false;\r\n      }\r\n      return Observer;\r\n  }());\r\n  /**\r\n   * Represent a list of observers registered to multiple Observables object.\r\n   * @public\r\n   */\r\n  var MultiObserver = /** @class */ (function () {\r\n      function MultiObserver() {\r\n          this._observers = null;\r\n          this._observables = null;\r\n      }\r\n      /**\r\n       * Raise a callback when one of the observable will notify\r\n       * @param observables - defines a list of observables to watch\r\n       * @param callback - defines the callback to call on notification\r\n       * @param mask - defines the mask used to filter notifications\r\n       * @param scope - defines the current scope used to restore the JS context\r\n       * @returns the new MultiObserver\r\n       */\r\n      MultiObserver.Watch = function (observables, callback, mask, scope) {\r\n          var e_1, _a;\r\n          if (mask === void 0) { mask = -1; }\r\n          if (scope === void 0) { scope = null; }\r\n          var result = new MultiObserver();\r\n          result._observers = new Array();\r\n          result._observables = observables;\r\n          try {\r\n              for (var observables_1 = __values(observables), observables_1_1 = observables_1.next(); !observables_1_1.done; observables_1_1 = observables_1.next()) {\r\n                  var observable = observables_1_1.value;\r\n                  var observer = observable.add(callback, mask, false, scope);\r\n                  if (observer) {\r\n                      result._observers.push(observer);\r\n                  }\r\n              }\r\n          }\r\n          catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n          finally {\r\n              try {\r\n                  if (observables_1_1 && !observables_1_1.done && (_a = observables_1.return)) _a.call(observables_1);\r\n              }\r\n              finally { if (e_1) throw e_1.error; }\r\n          }\r\n          return result;\r\n      };\r\n      /**\r\n       * Release associated resources\r\n       */\r\n      MultiObserver.prototype.dispose = function () {\r\n          if (this._observers && this._observables) {\r\n              for (var index = 0; index < this._observers.length; index++) {\r\n                  this._observables[index].remove(this._observers[index]);\r\n              }\r\n          }\r\n          this._observers = null;\r\n          this._observables = null;\r\n      };\r\n      return MultiObserver;\r\n  }());\r\n  /**\r\n   * The Observable class is a simple implementation of the Observable pattern.\r\n   *\r\n   * There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.\r\n   * This enable a more fine grained execution without having to rely on multiple different Observable objects.\r\n   * For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).\r\n   * A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.\r\n   *\r\n   * @public\r\n   */\r\n  var Observable = /** @class */ (function () {\r\n      /**\r\n       * Creates a new observable\r\n       * @param onObserverAdded - defines a callback to call when a new observer is added\r\n       */\r\n      function Observable(onObserverAdded) {\r\n          this._observers = new Array();\r\n          this._onObserverAdded = null;\r\n          this._eventState = new ObserverEventState(0);\r\n          if (onObserverAdded) {\r\n              this._onObserverAdded = onObserverAdded;\r\n          }\r\n      }\r\n      /**\r\n       * Create a new Observer with the specified callback\r\n       * @param callback - the callback that will be executed for that Observer\r\n       * @param mask - the mask used to filter observers\r\n       * @param insertFirst - if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.\r\n       * @param scope - optional scope for the callback to be called from\r\n       * @param unregisterOnFirstCall - defines if the observer as to be unregistered after the next notification\r\n       * @returns the new observer created for the callback\r\n       */\r\n      Observable.prototype.add = function (callback, mask, insertFirst, scope, unregisterOnFirstCall) {\r\n          if (mask === void 0) { mask = -1; }\r\n          if (insertFirst === void 0) { insertFirst = false; }\r\n          if (scope === void 0) { scope = null; }\r\n          if (unregisterOnFirstCall === void 0) { unregisterOnFirstCall = false; }\r\n          if (!callback) {\r\n              return null;\r\n          }\r\n          var observer = new Observer(callback, mask, scope);\r\n          observer.unregisterOnNextCall = unregisterOnFirstCall;\r\n          if (insertFirst) {\r\n              this._observers.unshift(observer);\r\n          }\r\n          else {\r\n              this._observers.push(observer);\r\n          }\r\n          if (this._onObserverAdded) {\r\n              this._onObserverAdded(observer);\r\n          }\r\n          return observer;\r\n      };\r\n      /**\r\n       * Create a new Observer with the specified callback and unregisters after the next notification\r\n       * @param callback - the callback that will be executed for that Observer\r\n       * @returns the new observer created for the callback\r\n       */\r\n      Observable.prototype.addOnce = function (callback) {\r\n          return this.add(callback, undefined, undefined, undefined, true);\r\n      };\r\n      /**\r\n       * Remove an Observer from the Observable object\r\n       * @param observer - the instance of the Observer to remove\r\n       * @returns false if it doesn't belong to this Observable\r\n       */\r\n      Observable.prototype.remove = function (observer) {\r\n          if (!observer) {\r\n              return false;\r\n          }\r\n          var index = this._observers.indexOf(observer);\r\n          if (index !== -1) {\r\n              this._deferUnregister(observer);\r\n              return true;\r\n          }\r\n          return false;\r\n      };\r\n      /**\r\n       * Remove a callback from the Observable object\r\n       * @param callback - the callback to remove\r\n       * @param scope - optional scope. If used only the callbacks with this scope will be removed\r\n       * @returns false if it doesn't belong to this Observable\r\n       */\r\n      Observable.prototype.removeCallback = function (callback, scope) {\r\n          for (var index = 0; index < this._observers.length; index++) {\r\n              if (this._observers[index].callback === callback &&\r\n                  (!scope || scope === this._observers[index].scope)) {\r\n                  this._deferUnregister(this._observers[index]);\r\n                  return true;\r\n              }\r\n          }\r\n          return false;\r\n      };\r\n      /**\r\n       * Notify all Observers by calling their respective callback with the given data\r\n       * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute\r\n       * @param eventData - defines the data to send to all observers\r\n       * @param mask - defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)\r\n       * @param target - defines the original target of the state\r\n       * @param currentTarget - defines the current target of the state\r\n       * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)\r\n       */\r\n      Observable.prototype.notifyObservers = function (eventData, mask, target, currentTarget) {\r\n          var e_2, _a;\r\n          if (mask === void 0) { mask = -1; }\r\n          if (!this._observers.length) {\r\n              return true;\r\n          }\r\n          var state = this._eventState;\r\n          state.mask = mask;\r\n          state.target = target;\r\n          state.currentTarget = currentTarget;\r\n          state.skipNextObservers = false;\r\n          state.lastReturnValue = eventData;\r\n          try {\r\n              for (var _b = __values(this._observers), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                  var obs = _c.value;\r\n                  if (obs._willBeUnregistered) {\r\n                      continue;\r\n                  }\r\n                  if (obs.mask & mask) {\r\n                      if (obs.scope) {\r\n                          state.lastReturnValue = obs.callback.apply(obs.scope, [\r\n                              eventData,\r\n                              state\r\n                          ]);\r\n                      }\r\n                      else {\r\n                          state.lastReturnValue = obs.callback(eventData, state);\r\n                      }\r\n                      if (obs.unregisterOnNextCall) {\r\n                          this._deferUnregister(obs);\r\n                      }\r\n                  }\r\n                  if (state.skipNextObservers) {\r\n                      return false;\r\n                  }\r\n              }\r\n          }\r\n          catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n          finally {\r\n              try {\r\n                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n              }\r\n              finally { if (e_2) throw e_2.error; }\r\n          }\r\n          return true;\r\n      };\r\n      /**\r\n       * Calling this will execute each callback, expecting it to be a promise or return a value.\r\n       * If at any point in the chain one function fails, the promise will fail and the execution will not continue.\r\n       * This is useful when a chain of events (sometimes async events) is needed to initialize a certain object\r\n       * and it is crucial that all callbacks will be executed.\r\n       * The order of the callbacks is kept, callbacks are not executed parallel.\r\n       *\r\n       * @param eventData - The data to be sent to each callback\r\n       * @param mask - is used to filter observers defaults to -1\r\n       * @param target - defines the callback target (see EventState)\r\n       * @param currentTarget - defines he current object in the bubbling phase\r\n       * @returns will return a Promise than resolves when all callbacks executed successfully.\r\n       */\r\n      Observable.prototype.notifyObserversWithPromise = function (eventData, mask, target, currentTarget) {\r\n          var _this = this;\r\n          if (mask === void 0) { mask = -1; }\r\n          // create an empty promise\r\n          var p = Promise.resolve(eventData);\r\n          // no observers? return this promise.\r\n          if (!this._observers.length) {\r\n              return p;\r\n          }\r\n          var state = this._eventState;\r\n          state.mask = mask;\r\n          state.target = target;\r\n          state.currentTarget = currentTarget;\r\n          state.skipNextObservers = false;\r\n          // execute one callback after another (not using Promise.all, the order is important)\r\n          this._observers.forEach(function (obs) {\r\n              if (state.skipNextObservers) {\r\n                  return;\r\n              }\r\n              if (obs._willBeUnregistered) {\r\n                  return;\r\n              }\r\n              if (obs.mask & mask) {\r\n                  if (obs.scope) {\r\n                      p = p.then(function (lastReturnedValue) {\r\n                          state.lastReturnValue = lastReturnedValue;\r\n                          return obs.callback.apply(obs.scope, [eventData, state]);\r\n                      });\r\n                  }\r\n                  else {\r\n                      p = p.then(function (lastReturnedValue) {\r\n                          state.lastReturnValue = lastReturnedValue;\r\n                          return obs.callback(eventData, state);\r\n                      });\r\n                  }\r\n                  if (obs.unregisterOnNextCall) {\r\n                      _this._deferUnregister(obs);\r\n                  }\r\n              }\r\n          });\r\n          // return the eventData\r\n          return p.then(function () {\r\n              return eventData;\r\n          });\r\n      };\r\n      /**\r\n       * Notify a specific observer\r\n       * @param observer - defines the observer to notify\r\n       * @param eventData - defines the data to be sent to each callback\r\n       * @param mask - is used to filter observers defaults to -1\r\n       */\r\n      Observable.prototype.notifyObserver = function (observer, eventData, mask) {\r\n          if (mask === void 0) { mask = -1; }\r\n          var state = this._eventState;\r\n          state.mask = mask;\r\n          state.skipNextObservers = false;\r\n          observer.callback(eventData, state);\r\n      };\r\n      /**\r\n       * Gets a boolean indicating if the observable has at least one observer\r\n       * @returns true is the Observable has at least one Observer registered\r\n       */\r\n      Observable.prototype.hasObservers = function () {\r\n          return this._observers.length > 0;\r\n      };\r\n      /**\r\n       * Clear the list of observers\r\n       */\r\n      Observable.prototype.clear = function () {\r\n          this._observers = new Array();\r\n          this._onObserverAdded = null;\r\n      };\r\n      /**\r\n       * Clone the current observable\r\n       * @returns a new observable\r\n       */\r\n      Observable.prototype.clone = function () {\r\n          var result = new Observable();\r\n          result._observers = this._observers.slice(0);\r\n          return result;\r\n      };\r\n      /**\r\n       * Does this observable handles observer registered with a given mask\r\n       * @param mask - defines the mask to be tested\r\n       * @returns whether or not one observer registered with the given mask is handeled\r\n       */\r\n      Observable.prototype.hasSpecificMask = function (mask) {\r\n          var e_3, _a;\r\n          if (mask === void 0) { mask = -1; }\r\n          try {\r\n              for (var _b = __values(this._observers), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                  var obs = _c.value;\r\n                  if (obs.mask & mask || obs.mask === mask) {\r\n                      return true;\r\n                  }\r\n              }\r\n          }\r\n          catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n          finally {\r\n              try {\r\n                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n              }\r\n              finally { if (e_3) throw e_3.error; }\r\n          }\r\n          return false;\r\n      };\r\n      Observable.prototype._deferUnregister = function (observer) {\r\n          var _this = this;\r\n          observer.unregisterOnNextCall = false;\r\n          observer._willBeUnregistered = true;\r\n          void executeTask(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\r\n              return [2 /*return*/, this._remove(observer)];\r\n          }); }); });\r\n      };\r\n      // This should only be called when not iterating over _observers to avoid callback skipping.\r\n      // Removes an observer from the _observer Array.\r\n      Observable.prototype._remove = function (observer) {\r\n          if (!observer) {\r\n              return false;\r\n          }\r\n          var index = this._observers.indexOf(observer);\r\n          if (index !== -1) {\r\n              this._observers.splice(index, 1);\r\n              return true;\r\n          }\r\n          return false;\r\n      };\r\n      return Observable;\r\n  }());\n\n  var modulePromise;\r\n  /**\r\n   * teleport player to a destination\r\n   * @param destination - \"coordX,coordY\", \"magic\", \"crowd\"\r\n   * @public\r\n   */\r\n  function teleportTo(destination) {\r\n      // error(`teleportTo(destination) was deprecated. Please use:\r\n      // import {requestTeleport} from '@decentraland/UserActionModule'\r\n      // executeTask(async () => {\r\n      //   await requestTeleport(destination)\r\n      // })`)\r\n      callModuleRpc('requestTeleport', [destination]);\r\n  }\r\n  function ensureModule() {\r\n      if (typeof modulePromise === 'undefined' && typeof dcl !== 'undefined') {\r\n          modulePromise = dcl.loadModule('@decentraland/UserActionModule', {});\r\n      }\r\n      return typeof modulePromise !== 'undefined' && typeof dcl !== 'undefined';\r\n  }\r\n  function callModuleRpc(methodName, args) {\r\n      if (ensureModule()) {\r\n          modulePromise.then(function ($) {\r\n              void dcl.callRpc($.rpcHandle, methodName, args);\r\n          });\r\n      }\r\n  }\n\n  /**\r\n   * @public\r\n   */\r\n  var UUIDEvent = /** @class */ (function () {\r\n      function UUIDEvent(uuid, payload) {\r\n          this.uuid = uuid;\r\n          this.payload = payload;\r\n      }\r\n      UUIDEvent = __decorate([\r\n          EventConstructor(),\r\n          __metadata(\"design:paramtypes\", [String, Object])\r\n      ], UUIDEvent);\r\n      return UUIDEvent;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var RaycastResponse = /** @class */ (function () {\r\n      function RaycastResponse(payload) {\r\n          this.payload = payload;\r\n      }\r\n      RaycastResponse = __decorate([\r\n          EventConstructor(),\r\n          __metadata(\"design:paramtypes\", [Object])\r\n      ], RaycastResponse);\r\n      return RaycastResponse;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var PointerEvent = /** @class */ (function () {\r\n      function PointerEvent(payload) {\r\n          this.payload = payload;\r\n      }\r\n      PointerEvent = __decorate([\r\n          EventConstructor(),\r\n          __metadata(\"design:paramtypes\", [Object])\r\n      ], PointerEvent);\r\n      return PointerEvent;\r\n  }());\r\n  var internalDcl;\r\n  /**\r\n   * @internal\r\n   * This function generates a callback that is passed to the Observable\r\n   * constructor to subscribe to the events of the DecentralandInterface\r\n   */\r\n  function createSubscriber(eventName) {\r\n      return function () {\r\n          if (internalDcl) {\r\n              internalDcl.subscribe(eventName);\r\n          }\r\n      };\r\n  }\r\n  /**\r\n   * This event is triggered when you change your camera between 1st and 3rd person\r\n   * @public\r\n   */\r\n  var onCameraModeChangedObservable = new Observable(createSubscriber('cameraModeChanged'));\r\n  /**\r\n   * This event is triggered when you change your camera between 1st and 3rd person\r\n   * @public\r\n   */\r\n  var onIdleStateChangedObservable = new Observable(createSubscriber('idleStateChanged'));\r\n  /**\r\n   * These events are triggered after your character enters the scene.\r\n   * @public\r\n   */\r\n  var onEnterSceneObservable = new Observable(createSubscriber('onEnterScene'));\r\n  /** @public @deprecated Use onEnterSceneObservable instead. */\r\n  var onEnterScene = onEnterSceneObservable;\r\n  /**\r\n   * These events are triggered after your character leaves the scene.\r\n   * @public\r\n   */\r\n  var onLeaveSceneObservable = new Observable(createSubscriber('onLeaveScene'));\r\n  /** @public @deprecated Use onLeaveSceneObservable instead. */\r\n  var onLeaveScene = onLeaveSceneObservable;\r\n  /**\r\n   * This event is triggered after all the resources of the scene were loaded (models, textures, etc...)\r\n   * @public\r\n   */\r\n  var onSceneReadyObservable = new Observable(createSubscriber('sceneStart'));\r\n  /**\r\n   * @public\r\n   */\r\n  var onPlayerExpressionObservable = new Observable(createSubscriber('playerExpression'));\r\n  /**\r\n   * @public\r\n   */\r\n  var onPointerLockedStateChange = new Observable(createSubscriber('onPointerLock'));\r\n  /**\r\n   * @public\r\n   */\r\n  var onVideoEvent = new Observable(createSubscriber('videoEvent'));\r\n  /**\r\n   * @public\r\n   */\r\n  var onProfileChanged = new Observable(createSubscriber('profileChanged'));\r\n  /**\r\n   * @public\r\n   */\r\n  var onPlayerConnectedObservable = new Observable(createSubscriber('playerConnected'));\r\n  /**\r\n   * @public\r\n   */\r\n  var onPlayerDisconnectedObservable = new Observable(createSubscriber('playerDisconnected'));\r\n  /**\r\n   * @public\r\n   */\r\n  var onRealmChangedObservable = new Observable(createSubscriber('onRealmChanged'));\r\n  /**\r\n   * @public\r\n   */\r\n  var onPlayerClickedObservable = new Observable(createSubscriber('playerClicked'));\r\n  /**\r\n   * @internal\r\n   * This function adds _one_ listener to the onEvent event of dcl interface.\r\n   * Leveraging a switch to route events to the Observable handlers.\r\n   */\r\n  function _initEventObservables(dcl) {\r\n      // store internal reference to dcl, it is going to be used to subscribe to the events\r\n      internalDcl = dcl;\r\n      if (internalDcl) {\r\n          internalDcl.onEvent(function (event) {\r\n              switch (event.type) {\r\n                  case 'onEnterScene': {\r\n                      onEnterSceneObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'onLeaveScene': {\r\n                      onLeaveSceneObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'cameraModeChanged': {\r\n                      onCameraModeChangedObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'idleStateChanged': {\r\n                      onIdleStateChangedObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'sceneStart': {\r\n                      onSceneReadyObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'playerExpression': {\r\n                      onPlayerExpressionObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'videoEvent': {\r\n                      var videoData = event.data;\r\n                      var component = DisposableComponent.engine.disposableComponents[videoData.componentId];\r\n                      if (component) {\r\n                          component.update(videoData);\r\n                      }\r\n                      onVideoEvent.notifyObservers(videoData);\r\n                      return;\r\n                  }\r\n                  case 'profileChanged': {\r\n                      onProfileChanged.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'onPointerLock': {\r\n                      onPointerLockedStateChange.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'playerConnected': {\r\n                      onPlayerConnectedObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'playerDisconnected': {\r\n                      onPlayerDisconnectedObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'onRealmChanged': {\r\n                      onRealmChangedObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n                  case 'playerClicked': {\r\n                      onPlayerClickedObservable.notifyObservers(event.data);\r\n                      return;\r\n                  }\r\n              }\r\n          });\r\n      }\r\n  }\n\n  // This number is defined in the protocol ECS.SetEntityParent.3\r\n  var ROOT_ENTITY_ID = '0';\r\n  var DecentralandSynchronizationSystem = /** @class */ (function () {\r\n      function DecentralandSynchronizationSystem(dcl) {\r\n          this.dcl = dcl;\r\n          this.cachedComponents = {};\r\n      }\r\n      DecentralandSynchronizationSystem.prototype.activate = function (engine) {\r\n          var _this = this;\r\n          this.engine = engine;\r\n          engine.eventManager.addListener(ComponentAdded, this, this.componentAdded);\r\n          engine.eventManager.addListener(ComponentRemoved, this, this.componentRemoved);\r\n          engine.eventManager.addListener(DisposableComponentCreated, this, this.disposableComponentCreated);\r\n          engine.eventManager.addListener(DisposableComponentRemoved, this, this.disposableComponentRemoved);\r\n          engine.eventManager.addListener(DisposableComponentUpdated, this, this.disposableComponentUpdated);\r\n          engine.eventManager.addListener(ParentChanged, this, this.parentChanged);\r\n          var rootId = engine.rootEntity.uuid;\r\n          this.dcl.addEntity(rootId);\r\n          // TODO(agus): send disposableComponents if exist\r\n          this.dcl.onUpdate(function (dt) {\r\n              engine.update(dt);\r\n              _this.presentEntities();\r\n          });\r\n          this.dcl.onEvent(function (event) {\r\n              var data = event.data;\r\n              switch (event.type) {\r\n                  case 'uuidEvent':\r\n                      engine.eventManager.fireEvent(new UUIDEvent(data.uuid, data.payload));\r\n                      break;\r\n                  case 'raycastResponse':\r\n                      if (data.queryType === 'HitFirst') {\r\n                          engine.eventManager.fireEvent(new RaycastResponse(data));\r\n                      }\r\n                      else if (data.queryType === 'HitAll') {\r\n                          engine.eventManager.fireEvent(new RaycastResponse(data));\r\n                      }\r\n                      break;\r\n                  case 'actionButtonEvent':\r\n                      engine.eventManager.fireEvent(new PointerEvent(data.payload));\r\n                      break;\r\n              }\r\n          });\r\n      };\r\n      /**\r\n       * system.onAddEntity is called by the engine when a entity is added to the\r\n       * engine.\r\n       */\r\n      DecentralandSynchronizationSystem.prototype.onAddEntity = function (entity) {\r\n          if (entity && entity.isAddedToEngine()) {\r\n              var entityId = entity.uuid;\r\n              var parent = entity.getParent();\r\n              this.dcl.addEntity(entityId);\r\n              if (parent) {\r\n                  // If the entity has a parent, we send the the enparenting signal\r\n                  // otherwise the engine will know the entity is set as a child of\r\n                  // engine.rootEntity by default\r\n                  this.dcl.setParent(entityId, parent.uuid);\r\n              }\r\n              // This creates a cache dictionary to avoid send redundant information to\r\n              // the engine in order to avoid unnecessary work in the main thread.\r\n              this.cachedComponents[entityId] = {};\r\n              // this iterator sends the current components of te engine at the moment\r\n              // of addition\r\n              for (var componentName in entity.components) {\r\n                  var component = entity.components[componentName];\r\n                  var classId = getComponentClassId(component);\r\n                  if (classId !== null) {\r\n                      if (isDisposableComponent(component)) {\r\n                          // Send the attach component signal\r\n                          this.dcl.attachEntityComponent(entity.uuid, componentName, getComponentId(component));\r\n                      }\r\n                      else {\r\n                          var componentJson = JSON.stringify(component);\r\n                          // Send the updated component\r\n                          this.dcl.updateEntityComponent(entityId, componentName, classId, componentJson);\r\n                          // Update the cached copy of the sent component\r\n                          this.cachedComponents[entityId][componentName] = componentJson;\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n      };\r\n      /**\r\n       * system.onRemoveEntity is called by the engine when a entity gets removed\r\n       * from the engine.\r\n       */\r\n      DecentralandSynchronizationSystem.prototype.onRemoveEntity = function (entity) {\r\n          if (entity.isAddedToEngine()) {\r\n              var entityId = entity.uuid;\r\n              // Send the removeEntity signal\r\n              this.dcl.removeEntity(entityId);\r\n              // Remove the caches from local memory\r\n              delete this.cachedComponents[entityId];\r\n          }\r\n      };\r\n      /**\r\n       * This method is called at the end of every update cycle.\r\n       * It finds and sends updates in components of the engine entities.\r\n       */\r\n      DecentralandSynchronizationSystem.prototype.presentEntities = function () {\r\n          for (var i in this.engine.entities) {\r\n              var entity = this.engine.entities[i];\r\n              for (var componentName in entity.components) {\r\n                  var component = entity.components[componentName];\r\n                  var classId = getComponentClassId(component);\r\n                  if (classId !== null && !isDisposableComponent(component)) {\r\n                      var jsonRepresentation = this.getJsonIfDirty(entity.uuid, componentName, component);\r\n                      if (jsonRepresentation) {\r\n                          // Send the updated component\r\n                          this.dcl.updateEntityComponent(entity.uuid, componentName, classId, jsonRepresentation);\r\n                          this.clearDirty(entity.uuid, componentName, component, jsonRepresentation);\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n          for (var id in this.engine.disposableComponents) {\r\n              var component = this.engine.disposableComponents[id];\r\n              if (component instanceof ObservableComponent && component.dirty) {\r\n                  this.dcl.componentUpdated(id, JSON.stringify(component));\r\n                  component.dirty = false;\r\n              }\r\n          }\r\n      };\r\n      /**\r\n       * This method is called after a component is added to an entity. The event\r\n       * (param 1) contains the necessary information to notify the engine about the\r\n       * component that was added and the entity.\r\n       */\r\n      DecentralandSynchronizationSystem.prototype.componentAdded = function (event) {\r\n          if (event.entity.isAddedToEngine()) {\r\n              var component = event.entity.components[event.componentName];\r\n              if (isDisposableComponent(component)) {\r\n                  this.dcl.attachEntityComponent(event.entity.uuid, event.componentName, getComponentId(component));\r\n              }\r\n              else if (event.classId !== null) {\r\n                  var componentJson = JSON.stringify(component);\r\n                  // Send the updated component\r\n                  this.dcl.updateEntityComponent(event.entity.uuid, event.componentName, event.classId, componentJson);\r\n                  // Update the cached copy of the sent component\r\n                  this.cachedComponents[event.entity.uuid][event.componentName] =\r\n                      componentJson;\r\n              }\r\n          }\r\n      };\r\n      /**\r\n       * This method is called when a component is removed from an entity.\r\n       */\r\n      DecentralandSynchronizationSystem.prototype.componentRemoved = function (event) {\r\n          if (event.entity.isAddedToEngine()) {\r\n              this.dcl.removeEntityComponent(event.entity.uuid, event.componentName);\r\n              // Remove the cached component so we can send it again when re-adding\r\n              delete this.cachedComponents[event.entity.uuid][event.componentName];\r\n          }\r\n      };\r\n      /**\r\n       * This method is called after a disposableComponent is created.\r\n       * It instantiates the component in the engine, the event that updates the\r\n       * created component is fired immediatly after.\r\n       */\r\n      DecentralandSynchronizationSystem.prototype.disposableComponentCreated = function (event) {\r\n          this.dcl.componentCreated(event.componentId, event.componentName, event.classId);\r\n      };\r\n      /**\r\n       * This method is called after a disposableComponent is updated, once per\r\n       * update cycle and once after creation.\r\n       */\r\n      DecentralandSynchronizationSystem.prototype.disposableComponentRemoved = function (event) {\r\n          this.dcl.componentDisposed(event.componentId);\r\n      };\r\n      /**\r\n       * This method is called right after a diposableComponent gets disposed. That\r\n       * process is manual.\r\n       *\r\n       * TODO(menduz,dani): What happens if a disposableComponent gets disposed and\r\n       * it remains attached to some entities?\r\n       */\r\n      DecentralandSynchronizationSystem.prototype.disposableComponentUpdated = function (event) {\r\n          this.dcl.componentUpdated(event.componentId, JSON.stringify(event.component));\r\n      };\r\n      /**\r\n       * This method is called when a parent changes in an entity.\r\n       */\r\n      DecentralandSynchronizationSystem.prototype.parentChanged = function (event) {\r\n          this.dcl.setParent(event.entity.uuid, event.parent ? event.parent.uuid : ROOT_ENTITY_ID);\r\n      };\r\n      DecentralandSynchronizationSystem.prototype.getJsonIfDirty = function (entityId, componentName, component) {\r\n          var jsonRepresentation = JSON.stringify(component);\r\n          return (jsonRepresentation !== this.cachedComponents[entityId][componentName] &&\r\n              jsonRepresentation);\r\n      };\r\n      DecentralandSynchronizationSystem.prototype.clearDirty = function (entityId, componentName, component, jsonRepresentation) {\r\n          this.cachedComponents[entityId][componentName] = jsonRepresentation;\r\n      };\r\n      return DecentralandSynchronizationSystem;\r\n  }());\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  var dist = {};\n\n  var types = {};\n\n  (function (exports) {\n  Object.defineProperty(exports, \"__esModule\", { value: true });\n  exports.RAD2DEG = exports.DEG2RAD = exports.Epsilon = exports.ToLinearSpace = exports.ToGammaSpace = exports.Space = exports.Orientation = void 0;\n  (function (Orientation) {\n      /**\n       * Clockwise\n       */\n      Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n      /** Counter clockwise */\n      Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n  })(exports.Orientation || (exports.Orientation = {}));\n  (function (Space) {\n      /** Local (object) space */\n      Space[Space[\"LOCAL\"] = 0] = \"LOCAL\";\n      /** World space */\n      Space[Space[\"WORLD\"] = 1] = \"WORLD\";\n      /** Bone space */\n      Space[Space[\"BONE\"] = 2] = \"BONE\";\n  })(exports.Space || (exports.Space = {}));\n  /**\n   * Constant used to convert a value to gamma space\n   * @public\n   */\n  exports.ToGammaSpace = 1 / 2.2;\n  /**\n   * Constant used to convert a value to linear space\n   * @public\n   */\n  exports.ToLinearSpace = 2.2;\n  /**\n   * Constant used to define the minimal number value in Babylon.js\n   * @public\n   */\n  exports.Epsilon = 0.000001;\n  /**\n   * Constant used to convert from Euler degrees to radians\n   * @public\n   */\n  exports.DEG2RAD = Math.PI / 180;\n  /**\n   * Constant used to convert from radians to Euler degrees\n   * @public\n   */\n  exports.RAD2DEG = 360 / (Math.PI * 2);\n\n  }(types));\n\n  var preallocatedVariables = {};\n\n  var utils = {};\n\n  Object.defineProperty(utils, \"__esModule\", { value: true });\n  utils.buildArray = void 0;\n  /**\n   * @internal\n   * Returns an array of the given size filled with element built from the given constructor and the paramters\n   * @param size - the number of element to construct and put in the array\n   * @param itemBuilder - a callback responsible for creating new instance of item. Called once per array entry.\n   * @returns a new array filled with new objects\n   * @internal\n   */\n  function buildArray(size, itemBuilder) {\n      const a = [];\n      for (let i = 0; i < size; ++i) {\n          a.push(itemBuilder());\n      }\n      return a;\n  }\n  utils.buildArray = buildArray;\n\n  var Vector3$1 = {};\n\n  var Quaternion$1 = {};\n\n  var Matrix$1 = {};\n\n  var Vector4$1 = {};\n\n  var Scalar$1 = {};\n\n  Object.defineProperty(Scalar$1, \"__esModule\", { value: true });\n  Scalar$1.Scalar = void 0;\n  /**\n   * Scalar computation library\n   * @public\n   */\n  class Scalar {\n      /**\n       * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n       * @param a - number\n       * @param b - number\n       * @param epsilon - (default = 1.401298E-45)\n       * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n       */\n      static WithinEpsilon(a, b, epsilon = 1.401298e-45) {\n          const num = a - b;\n          return -epsilon <= num && num <= epsilon;\n      }\n      /**\n       * Returns a string : the upper case translation of the number i to hexadecimal.\n       * @param i - number\n       * @returns the upper case translation of the number i to hexadecimal.\n       */\n      static ToHex(i) {\n          const str = i.toString(16);\n          if (i <= 15) {\n              return ('0' + str).toUpperCase();\n          }\n          return str.toUpperCase();\n      }\n      /**\n       * Returns -1 if value is negative and +1 is value is positive.\n       * @param _value - the value\n       * @returns the value itself if it's equal to zero.\n       */\n      static Sign(value) {\n          const _value = +value; // convert to a number\n          if (_value === 0 || isNaN(_value)) {\n              return _value;\n          }\n          return _value > 0 ? 1 : -1;\n      }\n      /**\n       * Returns the value itself if it's between min and max.\n       * Returns min if the value is lower than min.\n       * Returns max if the value is greater than max.\n       * @param value - the value to clmap\n       * @param min - the min value to clamp to (default: 0)\n       * @param max - the max value to clamp to (default: 1)\n       * @returns the clamped value\n       */\n      static Clamp(value, min = 0, max = 1) {\n          return Math.min(max, Math.max(min, value));\n      }\n      /**\n       * the log2 of value.\n       * @param value - the value to compute log2 of\n       * @returns the log2 of value.\n       */\n      static Log2(value) {\n          return Math.log(value) * Math.LOG2E;\n      }\n      /**\n       * Loops the value, so that it is never larger than length and never smaller than 0.\n       *\n       * This is similar to the modulo operator but it works with floating point numbers.\n       * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\n       * With t = 5 and length = 2.5, the result would be 0.0.\n       * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\n       * @param value - the value\n       * @param length - the length\n       * @returns the looped value\n       */\n      static Repeat(value, length) {\n          return value - Math.floor(value / length) * length;\n      }\n      /**\n       * Normalize the value between 0.0 and 1.0 using min and max values\n       * @param value - value to normalize\n       * @param min - max to normalize between\n       * @param max - min to normalize between\n       * @returns the normalized value\n       */\n      static Normalize(value, min, max) {\n          return (value - min) / (max - min);\n      }\n      /**\n       * Denormalize the value from 0.0 and 1.0 using min and max values\n       * @param normalized - value to denormalize\n       * @param min - max to denormalize between\n       * @param max - min to denormalize between\n       * @returns the denormalized value\n       */\n      static Denormalize(normalized, min, max) {\n          return normalized * (max - min) + min;\n      }\n      /**\n       * Calculates the shortest difference between two given angles given in degrees.\n       * @param current - current angle in degrees\n       * @param target - target angle in degrees\n       * @returns the delta\n       */\n      static DeltaAngle(current, target) {\n          let num = Scalar.Repeat(target - current, 360.0);\n          if (num > 180.0) {\n              num -= 360.0;\n          }\n          return num;\n      }\n      /**\n       * PingPongs the value t, so that it is never larger than length and never smaller than 0.\n       * @param tx - value\n       * @param length - length\n       * @returns The returned value will move back and forth between 0 and length\n       */\n      static PingPong(tx, length) {\n          const t = Scalar.Repeat(tx, length * 2.0);\n          return length - Math.abs(t - length);\n      }\n      /**\n       * Interpolates between min and max with smoothing at the limits.\n       *\n       * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\n       * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\n       * @param from - from\n       * @param to - to\n       * @param tx - value\n       * @returns the smooth stepped value\n       */\n      static SmoothStep(from, to, tx) {\n          let t = Scalar.Clamp(tx);\n          t = -2.0 * t * t * t + 3.0 * t * t;\n          return to * t + from * (1.0 - t);\n      }\n      /**\n       * Moves a value current towards target.\n       *\n       * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\n       * Negative values of maxDelta pushes the value away from target.\n       * @param current - current value\n       * @param target - target value\n       * @param maxDelta - max distance to move\n       * @returns resulting value\n       */\n      static MoveTowards(current, target, maxDelta) {\n          let result = 0;\n          if (Math.abs(target - current) <= maxDelta) {\n              result = target;\n          }\n          else {\n              result = current + Scalar.Sign(target - current) * maxDelta;\n          }\n          return result;\n      }\n      /**\n       * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\n       *\n       * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\n       *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\n       * @param current - current value\n       * @param target - target value\n       * @param maxDelta - max distance to move\n       * @returns resulting angle\n       */\n      static MoveTowardsAngle(current, target, maxDelta) {\n          const num = Scalar.DeltaAngle(current, target);\n          let result = 0;\n          if (-maxDelta < num && num < maxDelta) {\n              result = target;\n          }\n          else {\n              result = Scalar.MoveTowards(current, current + num, maxDelta);\n          }\n          return result;\n      }\n      /**\n       * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n       * @param start - start value\n       * @param end - target value\n       * @param amount - amount to lerp between\n       * @returns the lerped value\n       */\n      static Lerp(start, end, amount) {\n          return start + (end - start) * amount;\n      }\n      /**\n       * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\n       * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\n       * @param start - start value\n       * @param end - target value\n       * @param amount - amount to lerp between\n       * @returns the lerped value\n       */\n      static LerpAngle(start, end, amount) {\n          let num = Scalar.Repeat(end - start, 360.0);\n          if (num > 180.0) {\n              num -= 360.0;\n          }\n          return start + num * Scalar.Clamp(amount);\n      }\n      /**\n       * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\n       * @param a - start value\n       * @param b - target value\n       * @param value - value between a and b\n       * @returns the inverseLerp value\n       */\n      static InverseLerp(a, b, value) {\n          let result = 0;\n          if (a !== b) {\n              result = Scalar.Clamp((value - a) / (b - a));\n          }\n          else {\n              result = 0.0;\n          }\n          return result;\n      }\n      /**\n       * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n       * {@link http://mathworld.wolfram.com/HermitePolynomial.html}\n       * @param value1 - spline value\n       * @param tangent1 - spline value\n       * @param value2 - spline value\n       * @param tangent2 - spline value\n       * @param amount - input value\n       * @returns hermite result\n       */\n      static Hermite(value1, tangent1, value2, tangent2, amount) {\n          const squared = amount * amount;\n          const cubed = amount * squared;\n          const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n          const part2 = -2.0 * cubed + 3.0 * squared;\n          const part3 = cubed - 2.0 * squared + amount;\n          const part4 = cubed - squared;\n          return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\n      }\n      /**\n       * Returns a random float number between and min and max values\n       * @param min - min value of random\n       * @param max - max value of random\n       * @returns random value\n       */\n      static RandomRange(min, max) {\n          if (min === max) {\n              return min;\n          }\n          return Math.random() * (max - min) + min;\n      }\n      /**\n       * This function returns percentage of a number in a given range.\n       *\n       * RangeToPercent(40,20,60) will return 0.5 (50%)\n       * RangeToPercent(34,0,100) will return 0.34 (34%)\n       * @param num - to convert to percentage\n       * @param min - min range\n       * @param max - max range\n       * @returns the percentage\n       */\n      static RangeToPercent(num, min, max) {\n          return (num - min) / (max - min);\n      }\n      /**\n       * This function returns number that corresponds to the percentage in a given range.\n       *\n       * PercentToRange(0.34,0,100) will return 34.\n       * @param percent - to convert to number\n       * @param min - min range\n       * @param max - max range\n       * @returns the number\n       */\n      static PercentToRange(percent, min, max) {\n          return (max - min) * percent + min;\n      }\n      /**\n       * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n       * @param angle - The angle to normalize in radian.\n       * @returns The converted angle.\n       */\n      static NormalizeRadians(angle) {\n          // More precise but slower version kept for reference.\n          // tslint:disable:no-commented-out-code\n          /*\n            // angle = angle % Tools.TwoPi;\n            // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n      \n            //if (angle > Math.PI) {\n            //\tangle -= Tools.TwoPi;\n            //}\n             */\n          return angle - Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\n      }\n  }\n  Scalar$1.Scalar = Scalar;\n  /**\n   * Two pi constants convenient for computation.\n   */\n  Scalar.TwoPi = Math.PI * 2;\n\n  Object.defineProperty(Vector4$1, \"__esModule\", { value: true });\n  Vector4$1.Vector4 = void 0;\n  const types_1$8 = types;\n  const Scalar_1$6 = Scalar$1;\n  const Vector3_1$7 = Vector3$1;\n  /**\n   * Vector4 class created for EulerAngle class conversion to Quaternion\n   * @public\n   */\n  class Vector4 {\n      /**\n       * Creates a Vector4 object from the given floats.\n       * @param x - x value of the vector\n       * @param y - y value of the vector\n       * @param z - z value of the vector\n       * @param w - w value of the vector\n       */\n      constructor(\n      /** x value of the vector */\n      x, \n      /** y value of the vector */\n      y, \n      /** z value of the vector */\n      z, \n      /** w value of the vector */\n      w) {\n          this.x = x;\n          this.y = y;\n          this.z = z;\n          this.w = w;\n      }\n      // Statics\n      /**\n       * Returns a new Vector4 as the result of the addition of the two given vectors.\n       * @param vector1 - the first vector\n       * @param vector2 - the second vector\n       * @returns the resulting vector\n       */\n      static Add(vector1, vector2) {\n          return new Vector4(vector1.x, vector1.y, vector1.z, vector1.w).addInPlace(vector2);\n      }\n      /**\n       * Returns a new Vector4 set from the starting index of the given array.\n       * @param array - the array to pull values from\n       * @param offset - the offset into the array to start at\n       * @returns the new vector\n       */\n      static FromArray(array, offset = 0) {\n          return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n      }\n      /**\n       * Updates the given vector \"result\" from the starting index of the given array.\n       * @param array - the array to pull values from\n       * @param offset - the offset into the array to start at\n       * @param result - the vector to store the result in\n       */\n      static FromArrayToRef(array, offset, result) {\n          result.x = array[offset];\n          result.y = array[offset + 1];\n          result.z = array[offset + 2];\n          result.w = array[offset + 3];\n      }\n      /**\n       * Updates the given vector \"result\" from the starting index of the given FloatArray.\n       * @param array - the array to pull values from\n       * @param offset - the offset into the array to start at\n       * @param result - the vector to store the result in\n       */\n      static FromFloatArrayToRef(array, offset, result) {\n          Vector4.FromArrayToRef(array, offset, result);\n      }\n      /**\n       * Updates the given vector \"result\" coordinates from the given floats.\n       * @param x - float to set from\n       * @param y - float to set from\n       * @param z - float to set from\n       * @param w - float to set from\n       * @param result - the vector to the floats in\n       */\n      static FromFloatsToRef(x, y, z, w, result) {\n          result.x = x;\n          result.y = y;\n          result.z = z;\n          result.w = w;\n      }\n      /**\n       * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\n       * @returns the new vector\n       */\n      static Zero() {\n          return new Vector4(0.0, 0.0, 0.0, 0.0);\n      }\n      /**\n       * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\n       * @returns the new vector\n       */\n      static One() {\n          return new Vector4(1.0, 1.0, 1.0, 1.0);\n      }\n      /**\n       * Returns a new normalized Vector4 from the given one.\n       * @param vector - the vector to normalize\n       * @returns the vector\n       */\n      static Normalize(vector) {\n          const result = Vector4.Zero();\n          Vector4.NormalizeToRef(vector, result);\n          return result;\n      }\n      /**\n       * Updates the given vector \"result\" from the normalization of the given one.\n       * @param vector - the vector to normalize\n       * @param result - the vector to store the result in\n       */\n      static NormalizeToRef(vector, result) {\n          result.copyFrom(vector);\n          result.normalize();\n      }\n      /**\n       * Returns a vector with the minimum values from the left and right vectors\n       * @param left - left vector to minimize\n       * @param right - right vector to minimize\n       * @returns a new vector with the minimum of the left and right vector values\n       */\n      static Minimize(left, right) {\n          const min = new Vector4(left.x, left.y, left.z, left.w);\n          min.minimizeInPlace(right);\n          return min;\n      }\n      /**\n       * Returns a vector with the maximum values from the left and right vectors\n       * @param left - left vector to maximize\n       * @param right - right vector to maximize\n       * @returns a new vector with the maximum of the left and right vector values\n       */\n      static Maximize(left, right) {\n          const max = new Vector4(left.x, left.y, left.z, left.w);\n          max.maximizeInPlace(right);\n          return max;\n      }\n      /**\n       * Returns the distance (float) between the vectors \"value1\" and \"value2\".\n       * @param value1 - value to calulate the distance between\n       * @param value2 - value to calulate the distance between\n       * @returns the distance between the two vectors\n       */\n      static Distance(value1, value2) {\n          return Math.sqrt(Vector4.DistanceSquared(value1, value2));\n      }\n      /**\n       * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\n       * @param value1 - value to calulate the distance between\n       * @param value2 - value to calulate the distance between\n       * @returns the distance between the two vectors squared\n       */\n      static DistanceSquared(value1, value2) {\n          const x = value1.x - value2.x;\n          const y = value1.y - value2.y;\n          const z = value1.z - value2.z;\n          const w = value1.w - value2.w;\n          return x * x + y * y + z * z + w * w;\n      }\n      /**\n       * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\n       * @param value1 - value to calulate the center between\n       * @param value2 - value to calulate the center between\n       * @returns the center between the two vectors\n       */\n      static Center(value1, value2) {\n          const center = Vector4.Add(value1, value2);\n          center.scaleInPlace(0.5);\n          return center;\n      }\n      /**\n       * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.\n       * This methods computes transformed normalized direction vectors only.\n       * @param vector - the vector to transform\n       * @param transformation - the transformation matrix to apply\n       * @returns the new vector\n       */\n      static TransformNormal(vector, transformation) {\n          const result = Vector4.Zero();\n          Vector4.TransformNormalToRef(vector, transformation, result);\n          return result;\n      }\n      /**\n       * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector.\n       * This methods computes transformed normalized direction vectors only.\n       * @param vector - the vector to transform\n       * @param transformation - the transformation matrix to apply\n       * @param result - the vector to store the result in\n       */\n      static TransformNormalToRef(vector, transformation, result) {\n          const m = transformation.m;\n          const x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];\n          const y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];\n          const z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];\n          result.x = x;\n          result.y = y;\n          result.z = z;\n          result.w = vector.w;\n      }\n      /**\n       * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).\n       * This methods computes transformed normalized direction vectors only.\n       * @param x - value to transform\n       * @param y - value to transform\n       * @param z - value to transform\n       * @param w - value to transform\n       * @param transformation - the transformation matrix to apply\n       * @param result - the vector to store the results in\n       */\n      static TransformNormalFromFloatsToRef(x, y, z, w, transformation, result) {\n          const m = transformation.m;\n          result.x = x * m[0] + y * m[4] + z * m[8];\n          result.y = x * m[1] + y * m[5] + z * m[9];\n          result.z = x * m[2] + y * m[6] + z * m[10];\n          result.w = w;\n      }\n      /**\n       * Returns the string with the Vector4 coordinates.\n       * @returns a string containing all the vector values\n       */\n      toString() {\n          return ('{X: ' + this.x + ' Y:' + this.y + ' Z:' + this.z + ' W:' + this.w + '}');\n      }\n      /**\n       * Returns the string \"Vector4\".\n       * @returns \"Vector4\"\n       */\n      getClassName() {\n          return 'Vector4';\n      }\n      /**\n       * Returns the Vector4 hash code.\n       * @returns a unique hash code\n       */\n      getHashCode() {\n          let hash = this.x || 0;\n          hash = (hash * 397) ^ (this.y || 0);\n          hash = (hash * 397) ^ (this.z || 0);\n          hash = (hash * 397) ^ (this.w || 0);\n          return hash;\n      }\n      // Operators\n      /**\n       * Returns a new array populated with 4 elements : the Vector4 coordinates.\n       * @returns the resulting array\n       */\n      asArray() {\n          const result = new Array();\n          this.toArray(result, 0);\n          return result;\n      }\n      /**\n       * Populates the given array from the given index with the Vector4 coordinates.\n       * @param array - array to populate\n       * @param index - index of the array to start at (default: 0)\n       * @returns the Vector4.\n       */\n      toArray(array, index = 0) {\n          array[index] = this.x;\n          array[index + 1] = this.y;\n          array[index + 2] = this.z;\n          array[index + 3] = this.w;\n          return this;\n      }\n      /**\n       * Adds the given vector to the current Vector4.\n       * @param otherVector - the vector to add\n       * @returns the updated Vector4.\n       */\n      addInPlace(otherVector) {\n          this.x += otherVector.x;\n          this.y += otherVector.y;\n          this.z += otherVector.z;\n          this.w += otherVector.w;\n          return this;\n      }\n      /**\n       * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.\n       * @param otherVector - the vector to add\n       * @returns the resulting vector\n       */\n      add(otherVector) {\n          return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\n      }\n      /**\n       * Updates the given vector \"result\" with the result of the addition of the current Vector4 and the given one.\n       * @param otherVector - the vector to add\n       * @param result - the vector to store the result\n       * @returns the current Vector4.\n       */\n      addToRef(otherVector, result) {\n          result.x = this.x + otherVector.x;\n          result.y = this.y + otherVector.y;\n          result.z = this.z + otherVector.z;\n          result.w = this.w + otherVector.w;\n          return this;\n      }\n      /**\n       * Subtract in place the given vector from the current Vector4.\n       * @param otherVector - the vector to subtract\n       * @returns the updated Vector4.\n       */\n      subtractInPlace(otherVector) {\n          this.x -= otherVector.x;\n          this.y -= otherVector.y;\n          this.z -= otherVector.z;\n          this.w -= otherVector.w;\n          return this;\n      }\n      /**\n       * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.\n       * @param otherVector - the vector to add\n       * @returns the new vector with the result\n       */\n      subtract(otherVector) {\n          return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\n      }\n      /**\n       * Sets the given vector \"result\" with the result of the subtraction of the given vector from the current Vector4.\n       * @param otherVector - the vector to subtract\n       * @param result - the vector to store the result\n       * @returns the current Vector4.\n       */\n      subtractToRef(otherVector, result) {\n          result.x = this.x - otherVector.x;\n          result.y = this.y - otherVector.y;\n          result.z = this.z - otherVector.z;\n          result.w = this.w - otherVector.w;\n          return this;\n      }\n      /**\n       * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n       */\n      /**\n       * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n       * @param x - value to subtract\n       * @param y - value to subtract\n       * @param z - value to subtract\n       * @param w - value to subtract\n       * @returns new vector containing the result\n       */\n      subtractFromFloats(x, y, z, w) {\n          return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\n      }\n      /**\n       * Sets the given vector \"result\" set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n       * @param x - value to subtract\n       * @param y - value to subtract\n       * @param z - value to subtract\n       * @param w - value to subtract\n       * @param result - the vector to store the result in\n       * @returns the current Vector4.\n       */\n      subtractFromFloatsToRef(x, y, z, w, result) {\n          result.x = this.x - x;\n          result.y = this.y - y;\n          result.z = this.z - z;\n          result.w = this.w - w;\n          return this;\n      }\n      /**\n       * Returns a new Vector4 set with the current Vector4 negated coordinates.\n       * @returns a new vector with the negated values\n       */\n      negate() {\n          return new Vector4(-this.x, -this.y, -this.z, -this.w);\n      }\n      /**\n       * Multiplies the current Vector4 coordinates by scale (float).\n       * @param scale - the number to scale with\n       * @returns the updated Vector4.\n       */\n      scaleInPlace(scale) {\n          this.x *= scale;\n          this.y *= scale;\n          this.z *= scale;\n          this.w *= scale;\n          return this;\n      }\n      /**\n       * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\n       * @param scale - the number to scale with\n       * @returns a new vector with the result\n       */\n      scale(scale) {\n          return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\n      }\n      /**\n       * Sets the given vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\n       * @param scale - the number to scale with\n       * @param result - a vector to store the result in\n       * @returns the current Vector4.\n       */\n      scaleToRef(scale, result) {\n          result.x = this.x * scale;\n          result.y = this.y * scale;\n          result.z = this.z * scale;\n          result.w = this.w * scale;\n          return this;\n      }\n      /**\n       * Scale the current Vector4 values by a factor and add the result to a given Vector4\n       * @param scale - defines the scale factor\n       * @param result - defines the Vector4 object where to store the result\n       * @returns the unmodified current Vector4\n       */\n      scaleAndAddToRef(scale, result) {\n          result.x += this.x * scale;\n          result.y += this.y * scale;\n          result.z += this.z * scale;\n          result.w += this.w * scale;\n          return this;\n      }\n      /**\n       * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.\n       * @param otherVector - the vector to compare against\n       * @returns true if they are equal\n       */\n      equals(otherVector) {\n          return (otherVector &&\n              this.x === otherVector.x &&\n              this.y === otherVector.y &&\n              this.z === otherVector.z &&\n              this.w === otherVector.w);\n      }\n      /**\n       * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the given vector ones.\n       * @param otherVector - vector to compare against\n       * @param epsilon - (Default: very small number)\n       * @returns true if they are equal\n       */\n      equalsWithEpsilon(otherVector, epsilon = types_1$8.Epsilon) {\n          return (otherVector &&\n              Scalar_1$6.Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) &&\n              Scalar_1$6.Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) &&\n              Scalar_1$6.Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) &&\n              Scalar_1$6.Scalar.WithinEpsilon(this.w, otherVector.w, epsilon));\n      }\n      /**\n       * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.\n       * @param x - x value to compare against\n       * @param y - y value to compare against\n       * @param z - z value to compare against\n       * @param w - w value to compare against\n       * @returns true if equal\n       */\n      equalsToFloats(x, y, z, w) {\n          return this.x === x && this.y === y && this.z === z && this.w === w;\n      }\n      /**\n       * Multiplies in place the current Vector4 by the given one.\n       * @param otherVector - vector to multiple with\n       * @returns the updated Vector4.\n       */\n      multiplyInPlace(otherVector) {\n          this.x *= otherVector.x;\n          this.y *= otherVector.y;\n          this.z *= otherVector.z;\n          this.w *= otherVector.w;\n          return this;\n      }\n      /**\n       * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.\n       * @param otherVector - vector to multiple with\n       * @returns resulting new vector\n       */\n      multiply(otherVector) {\n          return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\n      }\n      /**\n       * Updates the given vector \"result\" with the multiplication result of the current Vector4 and the given one.\n       * @param otherVector - vector to multiple with\n       * @param result - vector to store the result\n       * @returns the current Vector4.\n       */\n      multiplyToRef(otherVector, result) {\n          result.x = this.x * otherVector.x;\n          result.y = this.y * otherVector.y;\n          result.z = this.z * otherVector.z;\n          result.w = this.w * otherVector.w;\n          return this;\n      }\n      /**\n       * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.\n       * @param x - x value multiply with\n       * @param y - y value multiply with\n       * @param z - z value multiply with\n       * @param w - w value multiply with\n       * @returns resulting new vector\n       */\n      multiplyByFloats(x, y, z, w) {\n          return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\n      }\n      /**\n       * Returns a new Vector4 set with the division result of the current Vector4 by the given one.\n       * @param otherVector - vector to devide with\n       * @returns resulting new vector\n       */\n      divide(otherVector) {\n          return new Vector4(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\n      }\n      /**\n       * Updates the given vector \"result\" with the division result of the current Vector4 by the given one.\n       * @param otherVector - vector to devide with\n       * @param result - vector to store the result\n       * @returns the current Vector4.\n       */\n      divideToRef(otherVector, result) {\n          result.x = this.x / otherVector.x;\n          result.y = this.y / otherVector.y;\n          result.z = this.z / otherVector.z;\n          result.w = this.w / otherVector.w;\n          return this;\n      }\n      /**\n       * Divides the current Vector3 coordinates by the given ones.\n       * @param otherVector - vector to devide with\n       * @returns the updated Vector3.\n       */\n      divideInPlace(otherVector) {\n          return this.divideToRef(otherVector, this);\n      }\n      /**\n       * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones\n       * @param other - defines the second operand\n       * @returns the current updated Vector4\n       */\n      minimizeInPlace(other) {\n          if (other.x < this.x) {\n              this.x = other.x;\n          }\n          if (other.y < this.y) {\n              this.y = other.y;\n          }\n          if (other.z < this.z) {\n              this.z = other.z;\n          }\n          if (other.w < this.w) {\n              this.w = other.w;\n          }\n          return this;\n      }\n      /**\n       * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones\n       * @param other - defines the second operand\n       * @returns the current updated Vector4\n       */\n      maximizeInPlace(other) {\n          if (other.x > this.x) {\n              this.x = other.x;\n          }\n          if (other.y > this.y) {\n              this.y = other.y;\n          }\n          if (other.z > this.z) {\n              this.z = other.z;\n          }\n          if (other.w > this.w) {\n              this.w = other.w;\n          }\n          return this;\n      }\n      /**\n       * Gets a new Vector4 from current Vector4 floored values\n       * @returns a new Vector4\n       */\n      floor() {\n          return new Vector4(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\n      }\n      /**\n       * Gets a new Vector4 from current Vector3 floored values\n       * @returns a new Vector4\n       */\n      fract() {\n          return new Vector4(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\n      }\n      // Properties\n      /**\n       * Returns the Vector4 length (float).\n       * @returns the length\n       */\n      length() {\n          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n      }\n      /**\n       * Returns the Vector4 squared length (float).\n       * @returns the length squared\n       */\n      lengthSquared() {\n          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n      }\n      // Methods\n      /**\n       * Normalizes in place the Vector4.\n       * @returns the updated Vector4.\n       */\n      normalize() {\n          const len = this.length();\n          if (len === 0) {\n              return this;\n          }\n          return this.scaleInPlace(1.0 / len);\n      }\n      /**\n       * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\n       * @returns this converted to a new vector3\n       */\n      toVector3() {\n          return new Vector3_1$7.Vector3(this.x, this.y, this.z);\n      }\n      /**\n       * Returns a new Vector4 copied from the current one.\n       * @returns the new cloned vector\n       */\n      clone() {\n          return new Vector4(this.x, this.y, this.z, this.w);\n      }\n      /**\n       * Updates the current Vector4 with the given one coordinates.\n       * @param source - the source vector to copy from\n       * @returns the updated Vector4.\n       */\n      copyFrom(source) {\n          this.x = source.x;\n          this.y = source.y;\n          this.z = source.z;\n          this.w = source.w;\n          return this;\n      }\n      /**\n       * Updates the current Vector4 coordinates with the given floats.\n       * @param x - float to copy from\n       * @param y - float to copy from\n       * @param z - float to copy from\n       * @param w - float to copy from\n       * @returns the updated Vector4.\n       */\n      copyFromFloats(x, y, z, w) {\n          this.x = x;\n          this.y = y;\n          this.z = z;\n          this.w = w;\n          return this;\n      }\n      /**\n       * Updates the current Vector4 coordinates with the given floats.\n       * @param x - float to set from\n       * @param y - float to set from\n       * @param z - float to set from\n       * @param w - float to set from\n       * @returns the updated Vector4.\n       */\n      set(x, y, z, w) {\n          return this.copyFromFloats(x, y, z, w);\n      }\n      /**\n       * Copies the given float to the current Vector3 coordinates\n       * @param v - defines the x, y, z and w coordinates of the operand\n       * @returns the current updated Vector3\n       */\n      setAll(v) {\n          this.x = this.y = this.z = this.w = v;\n          return this;\n      }\n  }\n  Vector4$1.Vector4 = Vector4;\n\n  Object.defineProperty(Matrix$1, \"__esModule\", { value: true });\n  Matrix$1.Matrix = void 0;\n  const Vector3_1$6 = Vector3$1;\n  const Quaternion_1$2 = Quaternion$1;\n  const preallocatedVariables_1$3 = preallocatedVariables;\n  const Vector4_1 = Vector4$1;\n  /**\n   * Class used to store matrix data (4x4)\n   * @public\n   */\n  class Matrix {\n      /**\n       * Creates an empty matrix (filled with zeros)\n       */\n      constructor() {\n          this._isIdentity = false;\n          this._isIdentityDirty = true;\n          this._isIdentity3x2 = true;\n          this._isIdentity3x2Dirty = true;\n          this._m = [\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n          ];\n          this._updateIdentityStatus(false);\n      }\n      /**\n       * Gets the internal data of the matrix\n       */\n      get m() {\n          return this._m;\n      }\n      /**\n       * Gets an identity matrix that must not be updated\n       */\n      static get IdentityReadOnly() {\n          return Matrix._identityReadOnly;\n      }\n      // Statics\n      /**\n       * Creates a matrix from an array\n       * @param array - defines the source array\n       * @param offset - defines an offset in the source array\n       * @returns a new Matrix set from the starting index of the given array\n       */\n      static FromArray(array, offset = 0) {\n          const result = new Matrix();\n          Matrix.FromArrayToRef(array, offset, result);\n          return result;\n      }\n      /**\n       * Copy the content of an array into a given matrix\n       * @param array - defines the source array\n       * @param offset - defines an offset in the source array\n       * @param result - defines the target matrix\n       */\n      static FromArrayToRef(array, offset, result) {\n          for (let index = 0; index < 16; index++) {\n              result._m[index] = array[index + offset];\n          }\n          result._markAsUpdated();\n      }\n      /**\n       * Stores an array into a matrix after having multiplied each component by a given factor\n       * @param array - defines the source array\n       * @param offset - defines the offset in the source array\n       * @param scale - defines the scaling factor\n       * @param result - defines the target matrix\n       */\n      static FromFloatArrayToRefScaled(array, offset, scale, result) {\n          for (let index = 0; index < 16; index++) {\n              result._m[index] = array[index + offset] * scale;\n          }\n          result._markAsUpdated();\n      }\n      /**\n       * Stores a list of values (16) inside a given matrix\n       * @param initialM11 - defines 1st value of 1st row\n       * @param initialM12 - defines 2nd value of 1st row\n       * @param initialM13 - defines 3rd value of 1st row\n       * @param initialM14 - defines 4th value of 1st row\n       * @param initialM21 - defines 1st value of 2nd row\n       * @param initialM22 - defines 2nd value of 2nd row\n       * @param initialM23 - defines 3rd value of 2nd row\n       * @param initialM24 - defines 4th value of 2nd row\n       * @param initialM31 - defines 1st value of 3rd row\n       * @param initialM32 - defines 2nd value of 3rd row\n       * @param initialM33 - defines 3rd value of 3rd row\n       * @param initialM34 - defines 4th value of 3rd row\n       * @param initialM41 - defines 1st value of 4th row\n       * @param initialM42 - defines 2nd value of 4th row\n       * @param initialM43 - defines 3rd value of 4th row\n       * @param initialM44 - defines 4th value of 4th row\n       * @param result - defines the target matrix\n       */\n      static FromValuesToRef(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {\n          const m = result._m;\n          m[0] = initialM11;\n          m[1] = initialM12;\n          m[2] = initialM13;\n          m[3] = initialM14;\n          m[4] = initialM21;\n          m[5] = initialM22;\n          m[6] = initialM23;\n          m[7] = initialM24;\n          m[8] = initialM31;\n          m[9] = initialM32;\n          m[10] = initialM33;\n          m[11] = initialM34;\n          m[12] = initialM41;\n          m[13] = initialM42;\n          m[14] = initialM43;\n          m[15] = initialM44;\n          result._markAsUpdated();\n      }\n      /**\n       * Creates new matrix from a list of values (16)\n       * @param initialM11 - defines 1st value of 1st row\n       * @param initialM12 - defines 2nd value of 1st row\n       * @param initialM13 - defines 3rd value of 1st row\n       * @param initialM14 - defines 4th value of 1st row\n       * @param initialM21 - defines 1st value of 2nd row\n       * @param initialM22 - defines 2nd value of 2nd row\n       * @param initialM23 - defines 3rd value of 2nd row\n       * @param initialM24 - defines 4th value of 2nd row\n       * @param initialM31 - defines 1st value of 3rd row\n       * @param initialM32 - defines 2nd value of 3rd row\n       * @param initialM33 - defines 3rd value of 3rd row\n       * @param initialM34 - defines 4th value of 3rd row\n       * @param initialM41 - defines 1st value of 4th row\n       * @param initialM42 - defines 2nd value of 4th row\n       * @param initialM43 - defines 3rd value of 4th row\n       * @param initialM44 - defines 4th value of 4th row\n       * @returns the new matrix\n       */\n      static FromValues(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {\n          const result = new Matrix();\n          const m = result._m;\n          m[0] = initialM11;\n          m[1] = initialM12;\n          m[2] = initialM13;\n          m[3] = initialM14;\n          m[4] = initialM21;\n          m[5] = initialM22;\n          m[6] = initialM23;\n          m[7] = initialM24;\n          m[8] = initialM31;\n          m[9] = initialM32;\n          m[10] = initialM33;\n          m[11] = initialM34;\n          m[12] = initialM41;\n          m[13] = initialM42;\n          m[14] = initialM43;\n          m[15] = initialM44;\n          result._markAsUpdated();\n          return result;\n      }\n      /**\n       * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n       * @param scale - defines the scale vector3\n       * @param rotation - defines the rotation quaternion\n       * @param translation - defines the translation vector3\n       * @returns a new matrix\n       */\n      static Compose(scale, rotation, translation) {\n          const result = new Matrix();\n          Matrix.ComposeToRef(scale, rotation, translation, result);\n          return result;\n      }\n      /**\n       * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n       * @param scale - defines the scale vector3\n       * @param rotation - defines the rotation quaternion\n       * @param translation - defines the translation vector3\n       * @param result - defines the target matrix\n       */\n      static ComposeToRef(scale, rotation, translation, result) {\n          Matrix.ScalingToRef(scale.x, scale.y, scale.z, preallocatedVariables_1$3.MathTmp.Matrix[1]);\n          rotation.toRotationMatrix(preallocatedVariables_1$3.MathTmp.Matrix[0]);\n          preallocatedVariables_1$3.MathTmp.Matrix[1].multiplyToRef(preallocatedVariables_1$3.MathTmp.Matrix[0], result);\n          result.setTranslation(translation);\n      }\n      /**\n       * Creates a new identity matrix\n       * @returns a new identity matrix\n       */\n      static Identity() {\n          const identity = Matrix.FromValues(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n          identity._updateIdentityStatus(true);\n          return identity;\n      }\n      /**\n       * Creates a new identity matrix and stores the result in a given matrix\n       * @param result - defines the target matrix\n       */\n      static IdentityToRef(result) {\n          Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n          result._updateIdentityStatus(true);\n      }\n      /**\n       * Creates a new zero matrix\n       * @returns a new zero matrix\n       */\n      static Zero() {\n          const zero = Matrix.FromValues(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n          zero._updateIdentityStatus(false);\n          return zero;\n      }\n      /**\n       * Creates a new rotation matrix for \"angle\" radians around the X axis\n       * @param angle - defines the angle (in radians) to use\n       * @returns the new matrix\n       */\n      static RotationX(angle) {\n          const result = new Matrix();\n          Matrix.RotationXToRef(angle, result);\n          return result;\n      }\n      /**\n       * Creates a new matrix as the invert of a given matrix\n       * @param source - defines the source matrix\n       * @returns the new matrix\n       */\n      static Invert(source) {\n          const result = new Matrix();\n          source.invertToRef(result);\n          return result;\n      }\n      /**\n       * Creates a new rotation matrix for \"angle\" radians around the X axis and stores it in a given matrix\n       * @param angle - defines the angle (in radians) to use\n       * @param result - defines the target matrix\n       */\n      static RotationXToRef(angle, result) {\n          const s = Math.sin(angle);\n          const c = Math.cos(angle);\n          Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n          result._updateIdentityStatus(c === 1 && s === 0);\n      }\n      /**\n       * Creates a new rotation matrix for \"angle\" radians around the Y axis\n       * @param angle - defines the angle (in radians) to use\n       * @returns the new matrix\n       */\n      static RotationY(angle) {\n          const result = new Matrix();\n          Matrix.RotationYToRef(angle, result);\n          return result;\n      }\n      /**\n       * Creates a new rotation matrix for \"angle\" radians around the Y axis and stores it in a given matrix\n       * @param angle - defines the angle (in radians) to use\n       * @param result - defines the target matrix\n       */\n      static RotationYToRef(angle, result) {\n          const s = Math.sin(angle);\n          const c = Math.cos(angle);\n          Matrix.FromValuesToRef(c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n          result._updateIdentityStatus(c === 1 && s === 0);\n      }\n      /**\n       * Creates a new rotation matrix for \"angle\" radians around the Z axis\n       * @param angle - defines the angle (in radians) to use\n       * @returns the new matrix\n       */\n      static RotationZ(angle) {\n          const result = new Matrix();\n          Matrix.RotationZToRef(angle, result);\n          return result;\n      }\n      /**\n       * Creates a new rotation matrix for \"angle\" radians around the Z axis and stores it in a given matrix\n       * @param angle - defines the angle (in radians) to use\n       * @param result - defines the target matrix\n       */\n      static RotationZToRef(angle, result) {\n          const s = Math.sin(angle);\n          const c = Math.cos(angle);\n          Matrix.FromValuesToRef(c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n          result._updateIdentityStatus(c === 1 && s === 0);\n      }\n      /**\n       * Creates a new rotation matrix for \"angle\" radians around the given axis\n       * @param axis - defines the axis to use\n       * @param angle - defines the angle (in radians) to use\n       * @returns the new matrix\n       */\n      static RotationAxis(axis, angle) {\n          const result = new Matrix();\n          Matrix.RotationAxisToRef(axis, angle, result);\n          return result;\n      }\n      /**\n       * Creates a new rotation matrix for \"angle\" radians around the given axis and stores it in a given matrix\n       * @param axis - defines the axis to use\n       * @param angle - defines the angle (in radians) to use\n       * @param result - defines the target matrix\n       */\n      static RotationAxisToRef(axis, angle, result) {\n          const s = Math.sin(-angle);\n          const c = Math.cos(-angle);\n          const c1 = 1 - c;\n          axis.normalize();\n          const m = result._m;\n          m[0] = axis.x * axis.x * c1 + c;\n          m[1] = axis.x * axis.y * c1 - axis.z * s;\n          m[2] = axis.x * axis.z * c1 + axis.y * s;\n          m[3] = 0.0;\n          m[4] = axis.y * axis.x * c1 + axis.z * s;\n          m[5] = axis.y * axis.y * c1 + c;\n          m[6] = axis.y * axis.z * c1 - axis.x * s;\n          m[7] = 0.0;\n          m[8] = axis.z * axis.x * c1 - axis.y * s;\n          m[9] = axis.z * axis.y * c1 + axis.x * s;\n          m[10] = axis.z * axis.z * c1 + c;\n          m[11] = 0.0;\n          m[12] = 0.0;\n          m[13] = 0.0;\n          m[14] = 0.0;\n          m[15] = 1.0;\n          result._markAsUpdated();\n      }\n      /**\n       * Creates a rotation matrix\n       * @param yaw - defines the yaw angle in radians (Y axis)\n       * @param pitch - defines the pitch angle in radians (X axis)\n       * @param roll - defines the roll angle in radians (X axis)\n       * @returns the new rotation matrix\n       */\n      static RotationYawPitchRoll(yaw, pitch, roll) {\n          const result = new Matrix();\n          Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\n          return result;\n      }\n      /**\n       * Creates a rotation matrix and stores it in a given matrix\n       * @param yaw - defines the yaw angle in radians (Y axis)\n       * @param pitch - defines the pitch angle in radians (X axis)\n       * @param roll - defines the roll angle in radians (X axis)\n       * @param result - defines the target matrix\n       */\n      static RotationYawPitchRollToRef(yaw, pitch, roll, result) {\n          Quaternion_1$2.Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, preallocatedVariables_1$3.MathTmp.Quaternion[0]);\n          preallocatedVariables_1$3.MathTmp.Quaternion[0].toRotationMatrix(result);\n      }\n      /**\n       * Creates a scaling matrix\n       * @param x - defines the scale factor on X axis\n       * @param y - defines the scale factor on Y axis\n       * @param z - defines the scale factor on Z axis\n       * @returns the new matrix\n       */\n      static Scaling(x, y, z) {\n          const result = new Matrix();\n          Matrix.ScalingToRef(x, y, z, result);\n          return result;\n      }\n      /**\n       * Creates a scaling matrix and stores it in a given matrix\n       * @param x - defines the scale factor on X axis\n       * @param y - defines the scale factor on Y axis\n       * @param z - defines the scale factor on Z axis\n       * @param result - defines the target matrix\n       */\n      static ScalingToRef(x, y, z, result) {\n          Matrix.FromValuesToRef(x, 0.0, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 0.0, z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n          result._updateIdentityStatus(x === 1 && y === 1 && z === 1);\n      }\n      /**\n       * Creates a translation matrix\n       * @param x - defines the translation on X axis\n       * @param y - defines the translation on Y axis\n       * @param z - defines the translationon Z axis\n       * @returns the new matrix\n       */\n      static Translation(x, y, z) {\n          const result = new Matrix();\n          Matrix.TranslationToRef(x, y, z, result);\n          return result;\n      }\n      /**\n       * Creates a translation matrix and stores it in a given matrix\n       * @param x - defines the translation on X axis\n       * @param y - defines the translation on Y axis\n       * @param z - defines the translationon Z axis\n       * @param result - defines the target matrix\n       */\n      static TranslationToRef(x, y, z, result) {\n          Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0, result);\n          result._updateIdentityStatus(x === 0 && y === 0 && z === 0);\n      }\n      /**\n       * Returns a new Matrix whose values are the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n       * @param startValue - defines the start value\n       * @param endValue - defines the end value\n       * @param gradient - defines the gradient factor\n       * @returns the new matrix\n       */\n      static Lerp(startValue, endValue, gradient) {\n          const result = new Matrix();\n          Matrix.LerpToRef(startValue, endValue, gradient, result);\n          return result;\n      }\n      /**\n       * Set the given matrix \"result\" as the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n       * @param startValue - defines the start value\n       * @param endValue - defines the end value\n       * @param gradient - defines the gradient factor\n       * @param result - defines the Matrix object where to store data\n       */\n      static LerpToRef(startValue, endValue, gradient, result) {\n          for (let index = 0; index < 16; index++) {\n              result._m[index] =\n                  startValue._m[index] * (1.0 - gradient) + endValue._m[index] * gradient;\n          }\n          result._markAsUpdated();\n      }\n      /**\n       * Builds a new matrix whose values are computed by:\n       * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n       * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n       * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n       * @param startValue - defines the first matrix\n       * @param endValue - defines the second matrix\n       * @param gradient - defines the gradient between the two matrices\n       * @returns the new matrix\n       */\n      static DecomposeLerp(startValue, endValue, gradient) {\n          const result = new Matrix();\n          Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n          return result;\n      }\n      /**\n       * Update a matrix to values which are computed by:\n       * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n       * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n       * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n       * @param startValue - defines the first matrix\n       * @param endValue - defines the second matrix\n       * @param gradient - defines the gradient between the two matrices\n       * @param result - defines the target matrix\n       */\n      static DecomposeLerpToRef(startValue, endValue, gradient, result) {\n          const startScale = preallocatedVariables_1$3.MathTmp.Vector3[0];\n          const startRotation = preallocatedVariables_1$3.MathTmp.Quaternion[0];\n          const startTranslation = preallocatedVariables_1$3.MathTmp.Vector3[1];\n          startValue.decompose(startScale, startRotation, startTranslation);\n          const endScale = preallocatedVariables_1$3.MathTmp.Vector3[2];\n          const endRotation = preallocatedVariables_1$3.MathTmp.Quaternion[1];\n          const endTranslation = preallocatedVariables_1$3.MathTmp.Vector3[3];\n          endValue.decompose(endScale, endRotation, endTranslation);\n          const resultScale = preallocatedVariables_1$3.MathTmp.Vector3[4];\n          Vector3_1$6.Vector3.LerpToRef(startScale, endScale, gradient, resultScale);\n          const resultRotation = preallocatedVariables_1$3.MathTmp.Quaternion[2];\n          Quaternion_1$2.Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);\n          const resultTranslation = preallocatedVariables_1$3.MathTmp.Vector3[5];\n          Vector3_1$6.Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);\n          Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);\n      }\n      /**\n       * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\n       * This function works in left handed mode\n       * @param eye - defines the final position of the entity\n       * @param target - defines where the entity should look at\n       * @param up - defines the up vector for the entity\n       * @returns the new matrix\n       */\n      static LookAtLH(eye, target, up) {\n          const result = new Matrix();\n          Matrix.LookAtLHToRef(eye, target, up, result);\n          return result;\n      }\n      /**\n       * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\n       * This function works in left handed mode\n       * @param eye - defines the final position of the entity\n       * @param target - defines where the entity should look at\n       * @param up - defines the up vector for the entity\n       * @param result - defines the target matrix\n       */\n      static LookAtLHToRef(eye, target, up, result) {\n          const xAxis = preallocatedVariables_1$3.MathTmp.Vector3[0];\n          const yAxis = preallocatedVariables_1$3.MathTmp.Vector3[1];\n          const zAxis = preallocatedVariables_1$3.MathTmp.Vector3[2];\n          // Z axis\n          target.subtractToRef(eye, zAxis);\n          zAxis.normalize();\n          // X axis\n          Vector3_1$6.Vector3.CrossToRef(up, zAxis, xAxis);\n          const xSquareLength = xAxis.lengthSquared();\n          if (xSquareLength === 0) {\n              xAxis.x = 1.0;\n          }\n          else {\n              xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n          }\n          // Y axis\n          Vector3_1$6.Vector3.CrossToRef(zAxis, xAxis, yAxis);\n          yAxis.normalize();\n          // Eye angles\n          const ex = -Vector3_1$6.Vector3.Dot(xAxis, eye);\n          const ey = -Vector3_1$6.Vector3.Dot(yAxis, eye);\n          const ez = -Vector3_1$6.Vector3.Dot(zAxis, eye);\n          Matrix.FromValuesToRef(xAxis.x, yAxis.x, zAxis.x, 0.0, xAxis.y, yAxis.y, zAxis.y, 0.0, xAxis.z, yAxis.z, zAxis.z, 0.0, ex, ey, ez, 1.0, result);\n      }\n      /**\n       * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\n       * This function works in right handed mode\n       * @param eye - defines the final position of the entity\n       * @param target - defines where the entity should look at\n       * @param up - defines the up vector for the entity\n       * @returns the new matrix\n       */\n      static LookAtRH(eye, target, up) {\n          const result = new Matrix();\n          Matrix.LookAtRHToRef(eye, target, up, result);\n          return result;\n      }\n      /**\n       * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\n       * This function works in right handed mode\n       * @param eye - defines the final position of the entity\n       * @param target - defines where the entity should look at\n       * @param up - defines the up vector for the entity\n       * @param result - defines the target matrix\n       */\n      static LookAtRHToRef(eye, target, up, result) {\n          const xAxis = preallocatedVariables_1$3.MathTmp.Vector3[0];\n          const yAxis = preallocatedVariables_1$3.MathTmp.Vector3[1];\n          const zAxis = preallocatedVariables_1$3.MathTmp.Vector3[2];\n          // Z axis\n          eye.subtractToRef(target, zAxis);\n          zAxis.normalize();\n          // X axis\n          Vector3_1$6.Vector3.CrossToRef(up, zAxis, xAxis);\n          const xSquareLength = xAxis.lengthSquared();\n          if (xSquareLength === 0) {\n              xAxis.x = 1.0;\n          }\n          else {\n              xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n          }\n          // Y axis\n          Vector3_1$6.Vector3.CrossToRef(zAxis, xAxis, yAxis);\n          yAxis.normalize();\n          // Eye angles\n          const ex = -Vector3_1$6.Vector3.Dot(xAxis, eye);\n          const ey = -Vector3_1$6.Vector3.Dot(yAxis, eye);\n          const ez = -Vector3_1$6.Vector3.Dot(zAxis, eye);\n          Matrix.FromValuesToRef(xAxis.x, yAxis.x, zAxis.x, 0.0, xAxis.y, yAxis.y, zAxis.y, 0.0, xAxis.z, yAxis.z, zAxis.z, 0.0, ex, ey, ez, 1.0, result);\n      }\n      /**\n       * Create a left-handed orthographic projection matrix\n       * @param width - defines the viewport width\n       * @param height - defines the viewport height\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @returns a new matrix as a left-handed orthographic projection matrix\n       */\n      static OrthoLH(width, height, znear, zfar) {\n          const matrix = new Matrix();\n          Matrix.OrthoLHToRef(width, height, znear, zfar, matrix);\n          return matrix;\n      }\n      /**\n       * Store a left-handed orthographic projection to a given matrix\n       * @param width - defines the viewport width\n       * @param height - defines the viewport height\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @param result - defines the target matrix\n       */\n      static OrthoLHToRef(width, height, znear, zfar, result) {\n          const n = znear;\n          const f = zfar;\n          const a = 2.0 / width;\n          const b = 2.0 / height;\n          const c = 2.0 / (f - n);\n          const d = -(f + n) / (f - n);\n          Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, 0.0, 0.0, d, 1.0, result);\n          result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);\n      }\n      /**\n       * Create a left-handed orthographic projection matrix\n       * @param left - defines the viewport left coordinate\n       * @param right - defines the viewport right coordinate\n       * @param bottom - defines the viewport bottom coordinate\n       * @param top - defines the viewport top coordinate\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @returns a new matrix as a left-handed orthographic projection matrix\n       */\n      static OrthoOffCenterLH(left, right, bottom, top, znear, zfar) {\n          const matrix = new Matrix();\n          Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix);\n          return matrix;\n      }\n      /**\n       * Stores a left-handed orthographic projection into a given matrix\n       * @param left - defines the viewport left coordinate\n       * @param right - defines the viewport right coordinate\n       * @param bottom - defines the viewport bottom coordinate\n       * @param top - defines the viewport top coordinate\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @param result - defines the target matrix\n       */\n      static OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result) {\n          const n = znear;\n          const f = zfar;\n          const a = 2.0 / (right - left);\n          const b = 2.0 / (top - bottom);\n          const c = 2.0 / (f - n);\n          const d = -(f + n) / (f - n);\n          const i0 = (left + right) / (left - right);\n          const i1 = (top + bottom) / (bottom - top);\n          Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, i0, i1, d, 1.0, result);\n          result._markAsUpdated();\n      }\n      /**\n       * Creates a right-handed orthographic projection matrix\n       * @param left - defines the viewport left coordinate\n       * @param right - defines the viewport right coordinate\n       * @param bottom - defines the viewport bottom coordinate\n       * @param top - defines the viewport top coordinate\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @returns a new matrix as a right-handed orthographic projection matrix\n       */\n      static OrthoOffCenterRH(left, right, bottom, top, znear, zfar) {\n          const matrix = new Matrix();\n          Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix);\n          return matrix;\n      }\n      /**\n       * Stores a right-handed orthographic projection into a given matrix\n       * @param left - defines the viewport left coordinate\n       * @param right - defines the viewport right coordinate\n       * @param bottom - defines the viewport bottom coordinate\n       * @param top - defines the viewport top coordinate\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @param result - defines the target matrix\n       */\n      static OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, result) {\n          Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result);\n          result._m[10] *= -1; // No need to call _markAsUpdated as previous function already called it and let _isIdentityDirty to true\n      }\n      /**\n       * Creates a left-handed perspective projection matrix\n       * @param width - defines the viewport width\n       * @param height - defines the viewport height\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @returns a new matrix as a left-handed perspective projection matrix\n       */\n      static PerspectiveLH(width, height, znear, zfar) {\n          const matrix = new Matrix();\n          const n = znear;\n          const f = zfar;\n          const a = (2.0 * n) / width;\n          const b = (2.0 * n) / height;\n          const c = (f + n) / (f - n);\n          const d = (-2.0 * f * n) / (f - n);\n          Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, matrix);\n          matrix._updateIdentityStatus(false);\n          return matrix;\n      }\n      /**\n       * Creates a left-handed perspective projection matrix\n       * @param fov - defines the horizontal field of view\n       * @param aspect - defines the aspect ratio\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @returns a new matrix as a left-handed perspective projection matrix\n       */\n      static PerspectiveFovLH(fov, aspect, znear, zfar) {\n          const matrix = new Matrix();\n          Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix);\n          return matrix;\n      }\n      /**\n       * Stores a left-handed perspective projection into a given matrix\n       * @param fov - defines the horizontal field of view\n       * @param aspect - defines the aspect ratio\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @param result - defines the target matrix\n       * @param isVerticalFovFixed - defines it the fov is vertically fixed (default) or horizontally\n       */\n      static PerspectiveFovLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true) {\n          const n = znear;\n          const f = zfar;\n          const t = 1.0 / Math.tan(fov * 0.5);\n          const a = isVerticalFovFixed ? t / aspect : t;\n          const b = isVerticalFovFixed ? t : t * aspect;\n          const c = (f + n) / (f - n);\n          const d = (-2.0 * f * n) / (f - n);\n          Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, result);\n          result._updateIdentityStatus(false);\n      }\n      /**\n       * Creates a right-handed perspective projection matrix\n       * @param fov - defines the horizontal field of view\n       * @param aspect - defines the aspect ratio\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @returns a new matrix as a right-handed perspective projection matrix\n       */\n      static PerspectiveFovRH(fov, aspect, znear, zfar) {\n          const matrix = new Matrix();\n          Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix);\n          return matrix;\n      }\n      /**\n       * Stores a right-handed perspective projection into a given matrix\n       * @param fov - defines the horizontal field of view\n       * @param aspect - defines the aspect ratio\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @param result - defines the target matrix\n       * @param isVerticalFovFixed - defines it the fov is vertically fixed (default) or horizontally\n       */\n      static PerspectiveFovRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true) {\n          /* alternatively this could be expressed as:\n          //    m = PerspectiveFovLHToRef\n          //    m[10] *= -1.0;\n          //    m[11] *= -1.0;\n          */\n          const n = znear;\n          const f = zfar;\n          const t = 1.0 / Math.tan(fov * 0.5);\n          const a = isVerticalFovFixed ? t / aspect : t;\n          const b = isVerticalFovFixed ? t : t * aspect;\n          const c = -(f + n) / (f - n);\n          const d = (-2 * f * n) / (f - n);\n          Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, -1.0, 0.0, 0.0, d, 0.0, result);\n          result._updateIdentityStatus(false);\n      }\n      /**\n       * Stores a perspective projection for WebVR info a given matrix\n       * @param fov - defines the field of view\n       * @param znear - defines the near clip plane\n       * @param zfar - defines the far clip plane\n       * @param result - defines the target matrix\n       * @param rightHanded - defines if the matrix must be in right-handed mode (false by default)\n       */\n      static PerspectiveFovWebVRToRef(fov, znear, zfar, result, rightHanded = false) {\n          const rightHandedFactor = rightHanded ? -1 : 1;\n          const upTan = Math.tan((fov.upDegrees * Math.PI) / 180.0);\n          const downTan = Math.tan((fov.downDegrees * Math.PI) / 180.0);\n          const leftTan = Math.tan((fov.leftDegrees * Math.PI) / 180.0);\n          const rightTan = Math.tan((fov.rightDegrees * Math.PI) / 180.0);\n          const xScale = 2.0 / (leftTan + rightTan);\n          const yScale = 2.0 / (upTan + downTan);\n          const m = result._m;\n          m[0] = xScale;\n          m[1] = m[2] = m[3] = m[4] = 0.0;\n          m[5] = yScale;\n          m[6] = m[7] = 0.0;\n          m[8] = (leftTan - rightTan) * xScale * 0.5;\n          m[9] = -((upTan - downTan) * yScale * 0.5);\n          m[10] = -zfar / (znear - zfar);\n          m[11] = 1.0 * rightHandedFactor;\n          m[12] = m[13] = m[15] = 0.0;\n          m[14] = -(2.0 * zfar * znear) / (zfar - znear);\n          result._markAsUpdated();\n      }\n      /**\n       * Extracts a 2x2 matrix from a given matrix and store the result in a FloatArray\n       * @param matrix - defines the matrix to use\n       * @returns a new FloatArray array with 4 elements : the 2x2 matrix extracted from the given matrix\n       */\n      static GetAsMatrix2x2(matrix) {\n          return [matrix._m[0], matrix._m[1], matrix._m[4], matrix._m[5]];\n      }\n      /**\n       * Extracts a 3x3 matrix from a given matrix and store the result in a FloatArray\n       * @param matrix - defines the matrix to use\n       * @returns a new FloatArray array with 9 elements : the 3x3 matrix extracted from the given matrix\n       */\n      static GetAsMatrix3x3(matrix) {\n          return [\n              matrix._m[0],\n              matrix._m[1],\n              matrix._m[2],\n              matrix._m[4],\n              matrix._m[5],\n              matrix._m[6],\n              matrix._m[8],\n              matrix._m[9],\n              matrix._m[10]\n          ];\n      }\n      /**\n       * Compute the transpose of a given matrix\n       * @param matrix - defines the matrix to transpose\n       * @returns the new matrix\n       */\n      static Transpose(matrix) {\n          const result = new Matrix();\n          Matrix.TransposeToRef(matrix, result);\n          return result;\n      }\n      /**\n       * Compute the transpose of a matrix and store it in a target matrix\n       * @param matrix - defines the matrix to transpose\n       * @param result - defines the target matrix\n       */\n      static TransposeToRef(matrix, result) {\n          const rm = result._m;\n          const mm = matrix._m;\n          rm[0] = mm[0];\n          rm[1] = mm[4];\n          rm[2] = mm[8];\n          rm[3] = mm[12];\n          rm[4] = mm[1];\n          rm[5] = mm[5];\n          rm[6] = mm[9];\n          rm[7] = mm[13];\n          rm[8] = mm[2];\n          rm[9] = mm[6];\n          rm[10] = mm[10];\n          rm[11] = mm[14];\n          rm[12] = mm[3];\n          rm[13] = mm[7];\n          rm[14] = mm[11];\n          rm[15] = mm[15];\n          // identity-ness does not change when transposing\n          result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);\n      }\n      /**\n       * Computes a reflection matrix from a plane\n       * @param plane - defines the reflection plane\n       * @returns a new matrix\n       */\n      static Reflection(plane) {\n          const matrix = new Matrix();\n          Matrix.ReflectionToRef(plane, matrix);\n          return matrix;\n      }\n      /**\n       * Computes a reflection matrix from a plane\n       * @param plane - defines the reflection plane\n       * @param result - defines the target matrix\n       */\n      static ReflectionToRef(plane, result) {\n          plane.normalize();\n          const x = plane.normal.x;\n          const y = plane.normal.y;\n          const z = plane.normal.z;\n          const temp = -2 * x;\n          const temp2 = -2 * y;\n          const temp3 = -2 * z;\n          Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0.0, temp * y, temp2 * y + 1, temp3 * y, 0.0, temp * z, temp2 * z, temp3 * z + 1, 0.0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1.0, result);\n      }\n      /**\n       * Sets the given matrix as a rotation matrix composed from the 3 left handed axes\n       * @param xaxis - defines the value of the 1st axis\n       * @param yaxis - defines the value of the 2nd axis\n       * @param zaxis - defines the value of the 3rd axis\n       * @param result - defines the target matrix\n       */\n      static FromXYZAxesToRef(xaxis, yaxis, zaxis, result) {\n          Matrix.FromValuesToRef(xaxis.x, xaxis.y, xaxis.z, 0.0, yaxis.x, yaxis.y, yaxis.z, 0.0, zaxis.x, zaxis.y, zaxis.z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n      }\n      /**\n       * Creates a rotation matrix from a quaternion and stores it in a target matrix\n       * @param quat - defines the quaternion to use\n       * @param result - defines the target matrix\n       */\n      static FromQuaternionToRef(quat, result) {\n          const xx = quat.x * quat.x;\n          const yy = quat.y * quat.y;\n          const zz = quat.z * quat.z;\n          const xy = quat.x * quat.y;\n          const zw = quat.z * quat.w;\n          const zx = quat.z * quat.x;\n          const yw = quat.y * quat.w;\n          const yz = quat.y * quat.z;\n          const xw = quat.x * quat.w;\n          result._m[0] = 1.0 - 2.0 * (yy + zz);\n          result._m[1] = 2.0 * (xy + zw);\n          result._m[2] = 2.0 * (zx - yw);\n          result._m[3] = 0.0;\n          result._m[4] = 2.0 * (xy - zw);\n          result._m[5] = 1.0 - 2.0 * (zz + xx);\n          result._m[6] = 2.0 * (yz + xw);\n          result._m[7] = 0.0;\n          result._m[8] = 2.0 * (zx + yw);\n          result._m[9] = 2.0 * (yz - xw);\n          result._m[10] = 1.0 - 2.0 * (yy + xx);\n          result._m[11] = 0.0;\n          result._m[12] = 0.0;\n          result._m[13] = 0.0;\n          result._m[14] = 0.0;\n          result._m[15] = 1.0;\n          result._markAsUpdated();\n      }\n      /** @internal */\n      _markAsUpdated() {\n          this.updateFlag = Matrix._updateFlagSeed++;\n          this._isIdentity = false;\n          this._isIdentity3x2 = false;\n          this._isIdentityDirty = true;\n          this._isIdentity3x2Dirty = true;\n      }\n      // Properties\n      /**\n       * Check if the current matrix is identity\n       * @returns true is the matrix is the identity matrix\n       */\n      isIdentity() {\n          if (this._isIdentityDirty) {\n              this._isIdentityDirty = false;\n              const m = this._m;\n              this._isIdentity =\n                  m[0] === 1.0 &&\n                      m[1] === 0.0 &&\n                      m[2] === 0.0 &&\n                      m[3] === 0.0 &&\n                      m[4] === 0.0 &&\n                      m[5] === 1.0 &&\n                      m[6] === 0.0 &&\n                      m[7] === 0.0 &&\n                      m[8] === 0.0 &&\n                      m[9] === 0.0 &&\n                      m[10] === 1.0 &&\n                      m[11] === 0.0 &&\n                      m[12] === 0.0 &&\n                      m[13] === 0.0 &&\n                      m[14] === 0.0 &&\n                      m[15] === 1.0;\n          }\n          return this._isIdentity;\n      }\n      /**\n       * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)\n       * @returns true is the matrix is the identity matrix\n       */\n      isIdentityAs3x2() {\n          if (this._isIdentity3x2Dirty) {\n              this._isIdentity3x2Dirty = false;\n              if (this._m[0] !== 1.0 || this._m[5] !== 1.0 || this._m[15] !== 1.0) {\n                  this._isIdentity3x2 = false;\n              }\n              else if (this._m[1] !== 0.0 ||\n                  this._m[2] !== 0.0 ||\n                  this._m[3] !== 0.0 ||\n                  this._m[4] !== 0.0 ||\n                  this._m[6] !== 0.0 ||\n                  this._m[7] !== 0.0 ||\n                  this._m[8] !== 0.0 ||\n                  this._m[9] !== 0.0 ||\n                  this._m[10] !== 0.0 ||\n                  this._m[11] !== 0.0 ||\n                  this._m[12] !== 0.0 ||\n                  this._m[13] !== 0.0 ||\n                  this._m[14] !== 0.0) {\n                  this._isIdentity3x2 = false;\n              }\n              else {\n                  this._isIdentity3x2 = true;\n              }\n          }\n          return this._isIdentity3x2;\n      }\n      /**\n       * Gets the determinant of the matrix\n       * @returns the matrix determinant\n       */\n      determinant() {\n          if (this._isIdentity === true) {\n              return 1;\n          }\n          const m = this._m;\n          // tslint:disable-next-line:one-variable-per-declaration\n          const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\n          // tslint:disable-next-line:one-variable-per-declaration\n          const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\n          // tslint:disable-next-line:one-variable-per-declaration\n          const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\n          // tslint:disable-next-line:one-variable-per-declaration\n          const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\n          /*\n          // https://en.wikipedia.org/wiki/Laplace_expansion\n          // to compute the deterrminant of a 4x4 Matrix we compute the cofactors of any row or column,\n          // then we multiply each Cofactor by its corresponding matrix value and sum them all to get the determinant\n          // Cofactor(i, j) = sign(i,j) * det(Minor(i, j))\n          // where\n          //  - sign(i,j) = (i+j) % 2 === 0 ? 1 : -1\n          //  - Minor(i, j) is the 3x3 matrix we get by removing row i and column j from current Matrix\n          //\n          // Here we do that for the 1st row.\n          */\n          // tslint:disable:variable-name\n          const det_22_33 = m22 * m33 - m32 * m23;\n          const det_21_33 = m21 * m33 - m31 * m23;\n          const det_21_32 = m21 * m32 - m31 * m22;\n          const det_20_33 = m20 * m33 - m30 * m23;\n          const det_20_32 = m20 * m32 - m22 * m30;\n          const det_20_31 = m20 * m31 - m30 * m21;\n          const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n          const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n          const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n          const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n          // tslint:enable:variable-name\n          return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n      }\n      // Methods\n      /**\n       * Returns the matrix as a FloatArray\n       * @returns the matrix underlying array\n       */\n      toArray() {\n          return this._m;\n      }\n      /**\n       * Returns the matrix as a FloatArray\n       * @returns the matrix underlying array.\n       */\n      asArray() {\n          return this._m;\n      }\n      /**\n       * Inverts the current matrix in place\n       * @returns the current inverted matrix\n       */\n      invert() {\n          this.invertToRef(this);\n          return this;\n      }\n      /**\n       * Sets all the matrix elements to zero\n       * @returns the current matrix\n       */\n      reset() {\n          Matrix.FromValuesToRef(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, this);\n          this._updateIdentityStatus(false);\n          return this;\n      }\n      /**\n       * Adds the current matrix with a second one\n       * @param other - defines the matrix to add\n       * @returns a new matrix as the addition of the current matrix and the given one\n       */\n      add(other) {\n          const result = new Matrix();\n          this.addToRef(other, result);\n          return result;\n      }\n      /**\n       * Sets the given matrix \"result\" to the addition of the current matrix and the given one\n       * @param other - defines the matrix to add\n       * @param result - defines the target matrix\n       * @returns the current matrix\n       */\n      addToRef(other, result) {\n          for (let index = 0; index < 16; index++) {\n              result._m[index] = this._m[index] + other._m[index];\n          }\n          result._markAsUpdated();\n          return this;\n      }\n      /**\n       * Adds in place the given matrix to the current matrix\n       * @param other - defines the second operand\n       * @returns the current updated matrix\n       */\n      addToSelf(other) {\n          for (let index = 0; index < 16; index++) {\n              this._m[index] += other._m[index];\n          }\n          this._markAsUpdated();\n          return this;\n      }\n      /**\n       * Sets the given matrix to the current inverted Matrix\n       * @param other - defines the target matrix\n       * @returns the unmodified current matrix\n       */\n      invertToRef(other) {\n          if (this._isIdentity === true) {\n              Matrix.IdentityToRef(other);\n              return this;\n          }\n          // the inverse of a Matrix is the transpose of cofactor matrix divided by the determinant\n          const m = this._m;\n          // tslint:disable:one-variable-per-declaration\n          const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\n          const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\n          const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\n          const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\n          // tslint:enable:one-variable-per-declaration\n          // tslint:disable:variable-name\n          const det_22_33 = m22 * m33 - m32 * m23;\n          const det_21_33 = m21 * m33 - m31 * m23;\n          const det_21_32 = m21 * m32 - m31 * m22;\n          const det_20_33 = m20 * m33 - m30 * m23;\n          const det_20_32 = m20 * m32 - m22 * m30;\n          const det_20_31 = m20 * m31 - m30 * m21;\n          const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n          const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n          const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n          const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n          const det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n          if (det === 0) {\n              // not invertible\n              other.copyFrom(this);\n              return this;\n          }\n          const detInv = 1 / det;\n          const det_12_33 = m12 * m33 - m32 * m13;\n          const det_11_33 = m11 * m33 - m31 * m13;\n          const det_11_32 = m11 * m32 - m31 * m12;\n          const det_10_33 = m10 * m33 - m30 * m13;\n          const det_10_32 = m10 * m32 - m30 * m12;\n          const det_10_31 = m10 * m31 - m30 * m11;\n          const det_12_23 = m12 * m23 - m22 * m13;\n          const det_11_23 = m11 * m23 - m21 * m13;\n          const det_11_22 = m11 * m22 - m21 * m12;\n          const det_10_23 = m10 * m23 - m20 * m13;\n          const det_10_22 = m10 * m22 - m20 * m12;\n          const det_10_21 = m10 * m21 - m20 * m11;\n          const cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);\n          const cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);\n          const cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);\n          const cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);\n          const cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);\n          const cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);\n          const cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);\n          const cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);\n          const cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);\n          const cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);\n          const cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);\n          const cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);\n          Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);\n          // tslint:enable:variable-name\n          return this;\n      }\n      /**\n       * add a value at the specified position in the current Matrix\n       * @param index - the index of the value within the matrix. between 0 and 15.\n       * @param value - the value to be added\n       * @returns the current updated matrix\n       */\n      addAtIndex(index, value) {\n          this._m[index] += value;\n          this._markAsUpdated();\n          return this;\n      }\n      /**\n       * mutiply the specified position in the current Matrix by a value\n       * @param index - the index of the value within the matrix. between 0 and 15.\n       * @param value - the value to be added\n       * @returns the current updated matrix\n       */\n      multiplyAtIndex(index, value) {\n          this._m[index] *= value;\n          this._markAsUpdated();\n          return this;\n      }\n      /**\n       * Inserts the translation vector (using 3 floats) in the current matrix\n       * @param x - defines the 1st component of the translation\n       * @param y - defines the 2nd component of the translation\n       * @param z - defines the 3rd component of the translation\n       * @returns the current updated matrix\n       */\n      setTranslationFromFloats(x, y, z) {\n          this._m[12] = x;\n          this._m[13] = y;\n          this._m[14] = z;\n          this._markAsUpdated();\n          return this;\n      }\n      /**\n       * Inserts the translation vector in the current matrix\n       * @param vector3 - defines the translation to insert\n       * @returns the current updated matrix\n       */\n      setTranslation(vector3) {\n          return this.setTranslationFromFloats(vector3.x, vector3.y, vector3.z);\n      }\n      /**\n       * Gets the translation value of the current matrix\n       * @returns a new Vector3 as the extracted translation from the matrix\n       */\n      getTranslation() {\n          return new Vector3_1$6.Vector3(this._m[12], this._m[13], this._m[14]);\n      }\n      /**\n       * Fill a Vector3 with the extracted translation from the matrix\n       * @param result - defines the Vector3 where to store the translation\n       * @returns the current matrix\n       */\n      getTranslationToRef(result) {\n          result.x = this._m[12];\n          result.y = this._m[13];\n          result.z = this._m[14];\n          return this;\n      }\n      /**\n       * Remove rotation and scaling part from the matrix\n       * @returns the updated matrix\n       */\n      removeRotationAndScaling() {\n          const m = this.m;\n          Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, m[12], m[13], m[14], m[15], this);\n          this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);\n          return this;\n      }\n      /**\n       * Multiply two matrices\n       * @param other - defines the second operand\n       * @returns a new matrix set with the multiplication result of the current Matrix and the given one\n       */\n      multiply(other) {\n          const result = new Matrix();\n          this.multiplyToRef(other, result);\n          return result;\n      }\n      /**\n       * Copy the current matrix from the given one\n       * @param other - defines the source matrix\n       * @returns the current updated matrix\n       */\n      copyFrom(other) {\n          other.copyToArray(this._m);\n          const o = other;\n          this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);\n          return this;\n      }\n      /**\n       * Populates the given array from the starting index with the current matrix values\n       * @param array - defines the target array\n       * @param offset - defines the offset in the target array where to start storing values\n       * @returns the current matrix\n       */\n      copyToArray(array, offset = 0) {\n          for (let index = 0; index < 16; index++) {\n              array[offset + index] = this._m[index];\n          }\n          return this;\n      }\n      /**\n       * Sets the given matrix \"result\" with the multiplication result of the current Matrix and the given one\n       * @param other - defines the second operand\n       * @param result - defines the matrix where to store the multiplication\n       * @returns the current matrix\n       */\n      multiplyToRef(other, result) {\n          if (this._isIdentity) {\n              result.copyFrom(other);\n              return this;\n          }\n          if (other._isIdentity) {\n              result.copyFrom(this);\n              return this;\n          }\n          this.multiplyToArray(other, result._m, 0);\n          result._markAsUpdated();\n          return this;\n      }\n      /**\n       * Sets the FloatArray \"result\" from the given index \"offset\" with the multiplication of the current matrix and the given one\n       * @param other - defines the second operand\n       * @param result - defines the array where to store the multiplication\n       * @param offset - defines the offset in the target array where to start storing values\n       * @returns the current matrix\n       */\n      multiplyToArray(other, result, offset) {\n          const m = this._m;\n          const otherM = other.m;\n          // tslint:disable:one-variable-per-declaration\n          const tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];\n          const tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];\n          const tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];\n          const tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];\n          const om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];\n          const om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];\n          const om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];\n          const om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];\n          // tslint:enable:one-variable-per-declaration\n          result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\n          result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\n          result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\n          result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\n          result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\n          result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\n          result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\n          result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\n          result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\n          result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\n          result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\n          result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\n          result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\n          result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\n          result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\n          result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\n          return this;\n      }\n      /**\n       * Check equality between this matrix and a second one\n       * @param value - defines the second matrix to compare\n       * @returns true is the current matrix and the given one values are strictly equal\n       */\n      equals(value) {\n          const other = value;\n          if (!other) {\n              return false;\n          }\n          if (this._isIdentity || other._isIdentity) {\n              if (!this._isIdentityDirty && !other._isIdentityDirty) {\n                  return this._isIdentity && other._isIdentity;\n              }\n          }\n          const m = this.m;\n          const om = other.m;\n          return (m[0] === om[0] &&\n              m[1] === om[1] &&\n              m[2] === om[2] &&\n              m[3] === om[3] &&\n              m[4] === om[4] &&\n              m[5] === om[5] &&\n              m[6] === om[6] &&\n              m[7] === om[7] &&\n              m[8] === om[8] &&\n              m[9] === om[9] &&\n              m[10] === om[10] &&\n              m[11] === om[11] &&\n              m[12] === om[12] &&\n              m[13] === om[13] &&\n              m[14] === om[14] &&\n              m[15] === om[15]);\n      }\n      /**\n       * Clone the current matrix\n       * @returns a new matrix from the current matrix\n       */\n      clone() {\n          const matrix = new Matrix();\n          matrix.copyFrom(this);\n          return matrix;\n      }\n      /**\n       * Returns the name of the current matrix class\n       * @returns the string \"Matrix\"\n       */\n      getClassName() {\n          return 'Matrix';\n      }\n      /**\n       * Gets the hash code of the current matrix\n       * @returns the hash code\n       */\n      getHashCode() {\n          let hash = this._m[0] || 0;\n          for (let i = 1; i < 16; i++) {\n              hash = (hash * 397) ^ (this._m[i] || 0);\n          }\n          return hash;\n      }\n      /**\n       * Decomposes the current Matrix into a translation, rotation and scaling components\n       * @param scale - defines the scale vector3 given as a reference to update\n       * @param rotation - defines the rotation quaternion given as a reference to update\n       * @param translation - defines the translation vector3 given as a reference to update\n       * @returns true if operation was successful\n       */\n      decompose(scale, rotation, translation) {\n          if (this._isIdentity) {\n              if (translation) {\n                  translation.setAll(0);\n              }\n              if (scale) {\n                  scale.setAll(1);\n              }\n              if (rotation) {\n                  rotation.copyFromFloats(0, 0, 0, 1);\n              }\n              return true;\n          }\n          const m = this._m;\n          if (translation) {\n              translation.copyFromFloats(m[12], m[13], m[14]);\n          }\n          const usedScale = scale || preallocatedVariables_1$3.MathTmp.Vector3[0];\n          usedScale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\n          usedScale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\n          usedScale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\n          if (this.determinant() <= 0) {\n              usedScale.y *= -1;\n          }\n          if (usedScale.x === 0 || usedScale.y === 0 || usedScale.z === 0) {\n              if (rotation) {\n                  rotation.copyFromFloats(0.0, 0.0, 0.0, 1.0);\n              }\n              return false;\n          }\n          if (rotation) {\n              // tslint:disable-next-line:one-variable-per-declaration\n              const sx = 1 / usedScale.x, sy = 1 / usedScale.y, sz = 1 / usedScale.z;\n              Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, preallocatedVariables_1$3.MathTmp.Matrix[0]);\n              Quaternion_1$2.Quaternion.FromRotationMatrixToRef(preallocatedVariables_1$3.MathTmp.Matrix[0], rotation);\n          }\n          return true;\n      }\n      /**\n       * Gets specific row of the matrix\n       * @param index - defines the number of the row to get\n       * @returns the index-th row of the current matrix as a new Vector4\n       */\n      getRow(index) {\n          if (index < 0 || index > 3) {\n              return null;\n          }\n          const i = index * 4;\n          return new Vector4_1.Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);\n      }\n      /**\n       * Sets the index-th row of the current matrix to the vector4 values\n       * @param index - defines the number of the row to set\n       * @param row - defines the target vector4\n       * @returns the updated current matrix\n       */\n      setRow(index, row) {\n          return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);\n      }\n      /**\n       * Compute the transpose of the matrix\n       * @returns the new transposed matrix\n       */\n      transpose() {\n          return Matrix.Transpose(this);\n      }\n      /**\n       * Compute the transpose of the matrix and store it in a given matrix\n       * @param result - defines the target matrix\n       * @returns the current matrix\n       */\n      transposeToRef(result) {\n          Matrix.TransposeToRef(this, result);\n          return this;\n      }\n      /**\n       * Sets the index-th row of the current matrix with the given 4 x float values\n       * @param index - defines the row index\n       * @param x - defines the x component to set\n       * @param y - defines the y component to set\n       * @param z - defines the z component to set\n       * @param w - defines the w component to set\n       * @returns the updated current matrix\n       */\n      setRowFromFloats(index, x, y, z, w) {\n          if (index < 0 || index > 3) {\n              return this;\n          }\n          const i = index * 4;\n          this._m[i + 0] = x;\n          this._m[i + 1] = y;\n          this._m[i + 2] = z;\n          this._m[i + 3] = w;\n          this._markAsUpdated();\n          return this;\n      }\n      /**\n       * Compute a new matrix set with the current matrix values multiplied by scale (float)\n       * @param scale - defines the scale factor\n       * @returns a new matrix\n       */\n      scale(scale) {\n          const result = new Matrix();\n          this.scaleToRef(scale, result);\n          return result;\n      }\n      /**\n       * Scale the current matrix values by a factor to a given result matrix\n       * @param scale - defines the scale factor\n       * @param result - defines the matrix to store the result\n       * @returns the current matrix\n       */\n      scaleToRef(scale, result) {\n          for (let index = 0; index < 16; index++) {\n              result._m[index] = this._m[index] * scale;\n          }\n          result._markAsUpdated();\n          return this;\n      }\n      /**\n       * Scale the current matrix values by a factor and add the result to a given matrix\n       * @param scale - defines the scale factor\n       * @param result - defines the Matrix to store the result\n       * @returns the current matrix\n       */\n      scaleAndAddToRef(scale, result) {\n          for (let index = 0; index < 16; index++) {\n              result._m[index] += this._m[index] * scale;\n          }\n          result._markAsUpdated();\n          return this;\n      }\n      /**\n       * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).\n       * @param ref - matrix to store the result\n       */\n      toNormalMatrix(ref) {\n          const tmp = preallocatedVariables_1$3.MathTmp.Matrix[0];\n          this.invertToRef(tmp);\n          tmp.transposeToRef(ref);\n          const m = ref._m;\n          Matrix.FromValuesToRef(m[0], m[1], m[2], 0.0, m[4], m[5], m[6], 0.0, m[8], m[9], m[10], 0.0, 0.0, 0.0, 0.0, 1.0, ref);\n      }\n      /**\n       * Gets only rotation part of the current matrix\n       * @returns a new matrix sets to the extracted rotation matrix from the current one\n       */\n      getRotationMatrix() {\n          const result = new Matrix();\n          this.getRotationMatrixToRef(result);\n          return result;\n      }\n      /**\n       * Extracts the rotation matrix from the current one and sets it as the given \"result\"\n       * @param result - defines the target matrix to store data to\n       * @returns the current matrix\n       */\n      getRotationMatrixToRef(result) {\n          const scale = preallocatedVariables_1$3.MathTmp.Vector3[0];\n          if (!this.decompose(scale)) {\n              Matrix.IdentityToRef(result);\n              return this;\n          }\n          const m = this._m;\n          // tslint:disable-next-line:one-variable-per-declaration\n          const sx = 1 / scale.x, sy = 1 / scale.y, sz = 1 / scale.z;\n          Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n          return this;\n      }\n      /**\n       * Toggles model matrix from being right handed to left handed in place and vice versa\n       */\n      toggleModelMatrixHandInPlace() {\n          const m = this._m;\n          m[2] *= -1;\n          m[6] *= -1;\n          m[8] *= -1;\n          m[9] *= -1;\n          m[14] *= -1;\n          this._markAsUpdated();\n      }\n      /**\n       * Toggles projection matrix from being right handed to left handed in place and vice versa\n       */\n      toggleProjectionMatrixHandInPlace() {\n          const m = this._m;\n          m[8] *= -1;\n          m[9] *= -1;\n          m[10] *= -1;\n          m[11] *= -1;\n          this._markAsUpdated();\n      }\n      /** @internal */\n      _updateIdentityStatus(isIdentity, isIdentityDirty = false, isIdentity3x2 = false, isIdentity3x2Dirty = true) {\n          this.updateFlag = Matrix._updateFlagSeed++;\n          this._isIdentity = isIdentity;\n          this._isIdentity3x2 = isIdentity || isIdentity3x2;\n          this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;\n          this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;\n      }\n  }\n  Matrix$1.Matrix = Matrix;\n  Matrix._updateFlagSeed = 0;\n  Matrix._identityReadOnly = Matrix.Identity();\n\n  Object.defineProperty(Quaternion$1, \"__esModule\", { value: true });\n  Quaternion$1.Quaternion = void 0;\n  const Matrix_1$2 = Matrix$1;\n  const Vector3_1$5 = Vector3$1;\n  const preallocatedVariables_1$2 = preallocatedVariables;\n  const types_1$7 = types;\n  const Scalar_1$5 = Scalar$1;\n  /**\n   * Class used to store quaternion data\n   * {@link https://en.wikipedia.org/wiki/Quaternion }\n   * {@link http://doc.babylonjs.com/features/position,_rotation,_scaling }\n   * @public\n   */\n  class Quaternion {\n      /**\n       * Creates a new Quaternion from the given floats\n       * @param x - defines the first component (0 by default)\n       * @param y - defines the second component (0 by default)\n       * @param z - defines the third component (0 by default)\n       * @param w - defines the fourth component (1.0 by default)\n       */\n      constructor(\n      /** defines the first component (0 by default) */\n      x = 0.0, \n      /** defines the second component (0 by default) */\n      y = 0.0, \n      /** defines the third component (0 by default) */\n      z = 0.0, \n      /** defines the fourth component (1.0 by default) */\n      w = 1.0) {\n          this.x = x;\n          this.y = y;\n          this.z = z;\n          this.w = w;\n      }\n      // Statics\n      /**\n       * Creates a new quaternion from a rotation matrix\n       * @param matrix - defines the source matrix\n       * @returns a new quaternion created from the given rotation matrix values\n       */\n      static FromRotationMatrix(matrix) {\n          const result = new Quaternion();\n          Quaternion.FromRotationMatrixToRef(matrix, result);\n          return result;\n      }\n      /**\n       * Updates the given quaternion with the given rotation matrix values\n       * @param matrix - defines the source matrix\n       * @param result - defines the target quaternion\n       */\n      static FromRotationMatrixToRef(matrix, result) {\n          const data = matrix.m;\n          // tslint:disable:one-variable-per-declaration\n          const m11 = data[0], m12 = data[4], m13 = data[8];\n          const m21 = data[1], m22 = data[5], m23 = data[9];\n          const m31 = data[2], m32 = data[6], m33 = data[10];\n          // tslint:enable:one-variable-per-declaration\n          const trace = m11 + m22 + m33;\n          let s;\n          if (trace > 0) {\n              s = 0.5 / Math.sqrt(trace + 1.0);\n              result.w = 0.25 / s;\n              result.x = (m32 - m23) * s;\n              result.y = (m13 - m31) * s;\n              result.z = (m21 - m12) * s;\n          }\n          else if (m11 > m22 && m11 > m33) {\n              s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n              result.w = (m32 - m23) / s;\n              result.x = 0.25 * s;\n              result.y = (m12 + m21) / s;\n              result.z = (m13 + m31) / s;\n          }\n          else if (m22 > m33) {\n              s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n              result.w = (m13 - m31) / s;\n              result.x = (m12 + m21) / s;\n              result.y = 0.25 * s;\n              result.z = (m23 + m32) / s;\n          }\n          else {\n              s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n              result.w = (m21 - m12) / s;\n              result.x = (m13 + m31) / s;\n              result.y = (m23 + m32) / s;\n              result.z = 0.25 * s;\n          }\n      }\n      /**\n       * Returns the dot product (float) between the quaternions \"left\" and \"right\"\n       * @param left - defines the left operand\n       * @param right - defines the right operand\n       * @returns the dot product\n       */\n      static Dot(left, right) {\n          return (left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w);\n      }\n      /**\n       * Checks if the two quaternions are close to each other\n       * @param quat0 - defines the first quaternion to check\n       * @param quat1 - defines the second quaternion to check\n       * @returns true if the two quaternions are close to each other\n       */\n      static AreClose(quat0, quat1) {\n          const dot = Quaternion.Dot(quat0, quat1);\n          return dot >= 0;\n      }\n      /**\n       * Creates an empty quaternion\n       * @returns a new quaternion set to (0.0, 0.0, 0.0)\n       */\n      static Zero() {\n          return new Quaternion(0.0, 0.0, 0.0, 0.0);\n      }\n      /**\n       * Inverse a given quaternion\n       * @param q - defines the source quaternion\n       * @returns a new quaternion as the inverted current quaternion\n       */\n      static Inverse(q) {\n          return new Quaternion(-q.x, -q.y, -q.z, q.w);\n      }\n      /**\n       * Gets a boolean indicating if the given quaternion is identity\n       * @param quaternion - defines the quaternion to check\n       * @returns true if the quaternion is identity\n       */\n      static IsIdentity(quaternion) {\n          return (quaternion &&\n              quaternion.x === 0 &&\n              quaternion.y === 0 &&\n              quaternion.z === 0 &&\n              quaternion.w === 1);\n      }\n      /**\n       * Creates a quaternion from a rotation around an axis\n       * @param axis - defines the axis to use\n       * @param angle - defines the angle to use (in Euler degrees)\n       * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)\n       */\n      static RotationAxis(axis, angle) {\n          const angleRad = angle * types_1$7.DEG2RAD;\n          return Quaternion.RotationAxisToRef(axis, angleRad, new Quaternion());\n      }\n      /**\n       * Creates a rotation around an axis and stores it into the given quaternion\n       * @param axis - defines the axis to use\n       * @param angle - defines the angle to use (in Euler degrees)\n       * @param result - defines the target quaternion\n       * @returns the target quaternion\n       */\n      static RotationAxisToRef(axis, angle, result) {\n          const angleRad = angle * types_1$7.DEG2RAD;\n          const sin = Math.sin(angleRad / 2);\n          axis.normalize();\n          result.w = Math.cos(angleRad / 2);\n          result.x = axis.x * sin;\n          result.y = axis.y * sin;\n          result.z = axis.z * sin;\n          return result;\n      }\n      /**\n       * Creates a new quaternion from data stored into an array\n       * @param array - defines the data source\n       * @param offset - defines the offset in the source array where the data starts\n       * @returns a new quaternion\n       */\n      static FromArray(array, offset = 0) {\n          return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n      }\n      /**\n       * Creates a new quaternion from a set of euler angles and stores it in the target quaternion\n       */\n      static FromEulerAnglesRef(x, y, z, result) {\n          return Quaternion.RotationYawPitchRollToRef(y * types_1$7.DEG2RAD, x * types_1$7.DEG2RAD, z * types_1$7.DEG2RAD, result);\n      }\n      /**\n       * Creates a new quaternion from the given Euler float angles (y, x, z)\n       * @param yaw - defines the rotation around Y axis\n       * @param pitch - defines the rotation around X axis\n       * @param roll - defines the rotation around Z axis\n       * @returns the new quaternion\n       */\n      static RotationYawPitchRoll(yaw, pitch, roll) {\n          const q = new Quaternion();\n          Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\n          return q;\n      }\n      /**\n       * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion\n       * @param yaw - defines the rotation around Y axis\n       * @param pitch - defines the rotation around X axis\n       * @param roll - defines the rotation around Z axis\n       * @param result - defines the target quaternion\n       */\n      static RotationYawPitchRollToRef(yaw, pitch, roll, result) {\n          // Implemented unity-based calculations from: https://stackoverflow.com/a/56055813\n          const halfPitch = pitch * 0.5;\n          const halfYaw = yaw * 0.5;\n          const halfRoll = roll * 0.5;\n          const c1 = Math.cos(halfPitch);\n          const c2 = Math.cos(halfYaw);\n          const c3 = Math.cos(halfRoll);\n          const s1 = Math.sin(halfPitch);\n          const s2 = Math.sin(halfYaw);\n          const s3 = Math.sin(halfRoll);\n          result.x = c2 * s1 * c3 + s2 * c1 * s3;\n          result.y = s2 * c1 * c3 - c2 * s1 * s3;\n          result.z = c2 * c1 * s3 - s2 * s1 * c3;\n          result.w = c2 * c1 * c3 + s2 * s1 * s3;\n      }\n      /**\n       * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation\n       * @param alpha - defines the rotation around first axis\n       * @param beta - defines the rotation around second axis\n       * @param gamma - defines the rotation around third axis\n       * @returns the new quaternion\n       */\n      static RotationAlphaBetaGamma(alpha, beta, gamma) {\n          const result = new Quaternion();\n          Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\n          return result;\n      }\n      /**\n       * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion\n       * @param alpha - defines the rotation around first axis\n       * @param beta - defines the rotation around second axis\n       * @param gamma - defines the rotation around third axis\n       * @param result - defines the target quaternion\n       */\n      static RotationAlphaBetaGammaToRef(alpha, beta, gamma, result) {\n          // Produces a quaternion from Euler angles in the z-x-z orientation\n          const halfGammaPlusAlpha = (gamma + alpha) * 0.5;\n          const halfGammaMinusAlpha = (gamma - alpha) * 0.5;\n          const halfBeta = beta * 0.5;\n          result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\n          result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\n          result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\n          result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\n      }\n      /**\n       * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)\n       * @param axis1 - defines the first axis\n       * @param axis2 - defines the second axis\n       * @param axis3 - defines the third axis\n       * @returns the new quaternion\n       */\n      static RotationQuaternionFromAxis(axis1, axis2, axis3) {\n          const quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\n          Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n          return quat;\n      }\n      /**\n       * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion\n       * @param axis1 - defines the first axis\n       * @param axis2 - defines the second axis\n       * @param axis3 - defines the third axis\n       * @param ref - defines the target quaternion\n       */\n      static RotationQuaternionFromAxisToRef(axis1, axis2, axis3, ref) {\n          const rotMat = preallocatedVariables_1$2.MathTmp.Matrix[0];\n          Matrix_1$2.Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\n          Quaternion.FromRotationMatrixToRef(rotMat, ref);\n      }\n      /**\n       * Interpolates between two quaternions\n       * @param left - defines first quaternion\n       * @param right - defines second quaternion\n       * @param amount - defines the gradient to use\n       * @returns the new interpolated quaternion\n       */\n      static Slerp(left, right, amount) {\n          const result = Quaternion.Identity;\n          Quaternion.SlerpToRef(left, right, amount, result);\n          return result;\n      }\n      /**\n       * Interpolates between two quaternions and stores it into a target quaternion\n       * @param left - defines first quaternion\n       * @param right - defines second quaternion\n       * @param amount - defines the gradient to use\n       * @param result - defines the target quaternion\n       */\n      static SlerpToRef(left, right, amount, result) {\n          let num2;\n          let num3;\n          let num4 = left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n          let flag = false;\n          if (num4 < 0) {\n              flag = true;\n              num4 = -num4;\n          }\n          if (num4 > 0.999999) {\n              num3 = 1 - amount;\n              num2 = flag ? -amount : amount;\n          }\n          else {\n              const num5 = Math.acos(num4);\n              const num6 = 1.0 / Math.sin(num5);\n              num3 = Math.sin((1.0 - amount) * num5) * num6;\n              num2 = flag\n                  ? -Math.sin(amount * num5) * num6\n                  : Math.sin(amount * num5) * num6;\n          }\n          result.x = num3 * left.x + num2 * right.x;\n          result.y = num3 * left.y + num2 * right.y;\n          result.z = num3 * left.z + num2 * right.z;\n          result.w = num3 * left.w + num2 * right.w;\n      }\n      /**\n       * Interpolate between two quaternions using Hermite interpolation\n       * @param value1 - defines first quaternion\n       * @param tangent1 - defines the incoming tangent\n       * @param value2 - defines second quaternion\n       * @param tangent2 - defines the outgoing tangent\n       * @param amount - defines the target quaternion\n       * @returns the new interpolated quaternion\n       */\n      static Hermite(value1, tangent1, value2, tangent2, amount) {\n          const squared = amount * amount;\n          const cubed = amount * squared;\n          const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n          const part2 = -2.0 * cubed + 3.0 * squared;\n          const part3 = cubed - 2.0 * squared + amount;\n          const part4 = cubed - squared;\n          const x = value1.x * part1 +\n              value2.x * part2 +\n              tangent1.x * part3 +\n              tangent2.x * part4;\n          const y = value1.y * part1 +\n              value2.y * part2 +\n              tangent1.y * part3 +\n              tangent2.y * part4;\n          const z = value1.z * part1 +\n              value2.z * part2 +\n              tangent1.z * part3 +\n              tangent2.z * part4;\n          const w = value1.w * part1 +\n              value2.w * part2 +\n              tangent1.w * part3 +\n              tangent2.w * part4;\n          return new Quaternion(x, y, z, w);\n      }\n      /**\n       * Creates an identity quaternion\n       * @returns - the identity quaternion\n       */\n      static get Identity() {\n          return new Quaternion(0.0, 0.0, 0.0, 1.0);\n      }\n      /**\n       * Returns the angle in degrees between two rotations a and b.\n       * @param quat1 - defines the first quaternion\n       * @param quat2 - defines the second quaternion\n       */\n      static Angle(quat1, quat2) {\n          const dot = Quaternion.Dot(quat1, quat2);\n          return Math.acos(Math.min(Math.abs(dot), 1)) * 2 * types_1$7.RAD2DEG;\n      }\n      /**\n       * Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis.\n       * @param x - the rotation on the x axis in euler degrees\n       * @param y - the rotation on the y axis in euler degrees\n       * @param z - the rotation on the z axis in euler degrees\n       */\n      static Euler(x, y, z) {\n          return Quaternion.RotationYawPitchRoll(y * types_1$7.DEG2RAD, x * types_1$7.DEG2RAD, z * types_1$7.DEG2RAD);\n      }\n      /**\n       * Creates a rotation with the specified forward and upwards directions.\n       * @param forward - the direction to look in\n       * @param up - the vector that defines in which direction up is\n       */\n      static LookRotation(forward, up = preallocatedVariables_1$2.MathTmp.staticUp) {\n          const forwardNew = Vector3_1$5.Vector3.Normalize(forward);\n          const right = Vector3_1$5.Vector3.Normalize(Vector3_1$5.Vector3.Cross(up, forwardNew));\n          const upNew = Vector3_1$5.Vector3.Cross(forwardNew, right);\n          const m00 = right.x;\n          const m01 = right.y;\n          const m02 = right.z;\n          const m10 = upNew.x;\n          const m11 = upNew.y;\n          const m12 = upNew.z;\n          const m20 = forwardNew.x;\n          const m21 = forwardNew.y;\n          const m22 = forwardNew.z;\n          const num8 = m00 + m11 + m22;\n          const quaternion = new Quaternion();\n          if (num8 > 0) {\n              let num = Math.sqrt(num8 + 1);\n              quaternion.w = num * 0.5;\n              num = 0.5 / num;\n              quaternion.x = (m12 - m21) * num;\n              quaternion.y = (m20 - m02) * num;\n              quaternion.z = (m01 - m10) * num;\n              return quaternion;\n          }\n          if (m00 >= m11 && m00 >= m22) {\n              const num7 = Math.sqrt(1 + m00 - m11 - m22);\n              const num4 = 0.5 / num7;\n              quaternion.x = 0.5 * num7;\n              quaternion.y = (m01 + m10) * num4;\n              quaternion.z = (m02 + m20) * num4;\n              quaternion.w = (m12 - m21) * num4;\n              return quaternion;\n          }\n          if (m11 > m22) {\n              const num6 = Math.sqrt(1 + m11 - m00 - m22);\n              const num3 = 0.5 / num6;\n              quaternion.x = (m10 + m01) * num3;\n              quaternion.y = 0.5 * num6;\n              quaternion.z = (m21 + m12) * num3;\n              quaternion.w = (m20 - m02) * num3;\n              return quaternion;\n          }\n          const num5 = Math.sqrt(1 + m22 - m00 - m11);\n          const num2 = 0.5 / num5;\n          quaternion.x = (m20 + m02) * num2;\n          quaternion.y = (m21 + m12) * num2;\n          quaternion.z = 0.5 * num5;\n          quaternion.w = (m01 - m10) * num2;\n          return quaternion;\n      }\n      /**\n       * The from quaternion is rotated towards to by an angular step of maxDegreesDelta.\n       * @param from - defines the first quaternion\n       * @param to - defines the second quaternion\n       * @param maxDegreesDelta - the interval step\n       */\n      static RotateTowards(from, to, maxDegreesDelta) {\n          const num = Quaternion.Angle(from, to);\n          if (num === 0) {\n              return to;\n          }\n          const t = Math.min(1, maxDegreesDelta / num);\n          return Quaternion.Slerp(from, to, t);\n      }\n      /**\n       * Creates a rotation which rotates from fromDirection to toDirection.\n       * @param from - defines the first direction Vector\n       * @param to - defines the target direction Vector\n       */\n      static FromToRotation(from, to, up = preallocatedVariables_1$2.MathTmp.staticUp) {\n          // Unity-based calculations implemented from https://forum.unity.com/threads/quaternion-lookrotation-around-an-axis.608470/#post-4069888\n          const v0 = from.normalize();\n          const v1 = to.normalize();\n          const a = Vector3_1$5.Vector3.Cross(v0, v1);\n          const w = Math.sqrt(v0.lengthSquared() * v1.lengthSquared()) + Vector3_1$5.Vector3.Dot(v0, v1);\n          if (a.lengthSquared() < 0.0001) {\n              // the vectors are parallel, check w to find direction\n              // if w is 0 then values are opposite, and we sould rotate 180 degrees around the supplied axis\n              // otherwise the vectors in the same direction and no rotation should occur\n              return Math.abs(w) < 0.0001\n                  ? new Quaternion(up.x, up.y, up.z, 0).normalized\n                  : Quaternion.Identity;\n          }\n          else {\n              return new Quaternion(a.x, a.y, a.z, w).normalized;\n          }\n      }\n      /**\n       * Converts this quaternion to one with the same orientation but with a magnitude of 1.\n       */\n      get normalized() {\n          return this.normalize();\n      }\n      /**\n       * Creates a rotation which rotates from fromDirection to toDirection.\n       * @param from - defines the first Vector\n       * @param to - defines the second Vector\n       * @param up - defines the direction\n       */\n      setFromToRotation(from, to, up = preallocatedVariables_1$2.MathTmp.staticUp) {\n          const result = Quaternion.FromToRotation(from, to, up);\n          this.x = result.x;\n          this.y = result.y;\n          this.z = result.z;\n          this.w = result.w;\n      }\n      set eulerAngles(euler) {\n          this.setEuler(euler.x, euler.y, euler.z);\n      }\n      /**\n       * Gets or sets the euler angle representation of the rotation.\n       * Implemented unity-based calculations from: https://stackoverflow.com/a/56055813\n       */\n      get eulerAngles() {\n          const out = new Vector3_1$5.Vector3();\n          // if the input quaternion is normalized, this is exactly one. Otherwise, this acts as a correction factor for the quaternion's not-normalizedness\n          const unit = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n          // this will have a magnitude of 0.5 or greater if and only if this is a singularity case\n          const test = this.x * this.w - this.y * this.z;\n          if (test > 0.4995 * unit) {\n              // singularity at north pole\n              out.x = Math.PI / 2;\n              out.y = 2 * Math.atan2(this.y, this.x);\n              out.z = 0;\n          }\n          else if (test < -0.4995 * unit) {\n              // singularity at south pole\n              out.x = -Math.PI / 2;\n              out.y = -2 * Math.atan2(this.y, this.x);\n              out.z = 0;\n          }\n          else {\n              // no singularity - this is the majority of cases\n              out.x = Math.asin(2 * (this.w * this.x - this.y * this.z));\n              out.y = Math.atan2(2 * this.w * this.y + 2 * this.z * this.x, 1 - 2 * (this.x * this.x + this.y * this.y));\n              out.z = Math.atan2(2 * this.w * this.z + 2 * this.x * this.y, 1 - 2 * (this.z * this.z + this.x * this.x));\n          }\n          out.x *= types_1$7.RAD2DEG;\n          out.y *= types_1$7.RAD2DEG;\n          out.z *= types_1$7.RAD2DEG;\n          // ensure the degree values are between 0 and 360\n          out.x = Scalar_1$5.Scalar.Repeat(out.x, 360);\n          out.y = Scalar_1$5.Scalar.Repeat(out.y, 360);\n          out.z = Scalar_1$5.Scalar.Repeat(out.z, 360);\n          return out;\n      }\n      /**\n       * Gets a string representation for the current quaternion\n       * @returns a string with the Quaternion coordinates\n       */\n      toString() {\n          return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n      }\n      /**\n       * Gets length of current quaternion\n       * @returns the quaternion length (float)\n       */\n      get length() {\n          return Math.sqrt(this.lengthSquared);\n      }\n      /**\n       * Gets length of current quaternion\n       * @returns the quaternion length (float)\n       */\n      get lengthSquared() {\n          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n      }\n      /**\n       * Gets the class name of the quaternion\n       * @returns the string \"Quaternion\"\n       */\n      getClassName() {\n          return 'Quaternion';\n      }\n      /**\n       * Gets a hash code for this quaternion\n       * @returns the quaternion hash code\n       */\n      getHashCode() {\n          let hash = this.x || 0;\n          hash = (hash * 397) ^ (this.y || 0);\n          hash = (hash * 397) ^ (this.z || 0);\n          hash = (hash * 397) ^ (this.w || 0);\n          return hash;\n      }\n      /**\n       * Copy the quaternion to an array\n       * @returns a new array populated with 4 elements from the quaternion coordinates\n       */\n      asArray() {\n          return [this.x, this.y, this.z, this.w];\n      }\n      /**\n       * Check if two quaternions are equals\n       * @param otherQuaternion - defines the second operand\n       * @returns true if the current quaternion and the given one coordinates are strictly equals\n       */\n      equals(otherQuaternion) {\n          return (otherQuaternion &&\n              this.x === otherQuaternion.x &&\n              this.y === otherQuaternion.y &&\n              this.z === otherQuaternion.z &&\n              this.w === otherQuaternion.w);\n      }\n      /**\n       * Clone the current quaternion\n       * @returns a new quaternion copied from the current one\n       */\n      clone() {\n          return new Quaternion(this.x, this.y, this.z, this.w);\n      }\n      /**\n       * Copy a quaternion to the current one\n       * @param other - defines the other quaternion\n       * @returns the updated current quaternion\n       */\n      copyFrom(other) {\n          this.x = other.x;\n          this.y = other.y;\n          this.z = other.z;\n          this.w = other.w;\n          return this;\n      }\n      /**\n       * Updates the current quaternion with the given float coordinates\n       * @param x - defines the x coordinate\n       * @param y - defines the y coordinate\n       * @param z - defines the z coordinate\n       * @param w - defines the w coordinate\n       * @returns the updated current quaternion\n       */\n      copyFromFloats(x, y, z, w) {\n          this.x = x;\n          this.y = y;\n          this.z = z;\n          this.w = w;\n          return this;\n      }\n      /**\n       * Updates the current quaternion from the given float coordinates\n       * @param x - defines the x coordinate\n       * @param y - defines the y coordinate\n       * @param z - defines the z coordinate\n       * @param w - defines the w coordinate\n       * @returns the updated current quaternion\n       */\n      set(x, y, z, w) {\n          return this.copyFromFloats(x, y, z, w);\n      }\n      /**\n       * Updates the current quaternion from the given euler angles\n       * @returns the updated current quaternion\n       */\n      setEuler(x, y, z) {\n          Quaternion.RotationYawPitchRollToRef(y * types_1$7.DEG2RAD, x * types_1$7.DEG2RAD, z * types_1$7.DEG2RAD, this);\n          return this;\n      }\n      /**\n       * @internal\n       * Adds two quaternions\n       * @param other - defines the second operand\n       * @returns a new quaternion as the addition result of the given one and the current quaternion\n       */\n      add(other) {\n          return new Quaternion(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);\n      }\n      /**\n       * @internal\n       * Add a quaternion to the current one\n       * @param other - defines the quaternion to add\n       * @returns the current quaternion\n       */\n      addInPlace(other) {\n          this.x += other.x;\n          this.y += other.y;\n          this.z += other.z;\n          this.w += other.w;\n          return this;\n      }\n      /**\n       * Subtract two quaternions\n       * @param other - defines the second operand\n       * @returns a new quaternion as the subtraction result of the given one from the current one\n       */\n      subtract(other) {\n          return new Quaternion(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);\n      }\n      /**\n       * Multiplies the current quaternion by a scale factor\n       * @param value - defines the scale factor\n       * @returns a new quaternion set by multiplying the current quaternion coordinates by the float \"scale\"\n       */\n      scale(value) {\n          return new Quaternion(this.x * value, this.y * value, this.z * value, this.w * value);\n      }\n      /**\n       * Scale the current quaternion values by a factor and stores the result to a given quaternion\n       * @param scale - defines the scale factor\n       * @param result - defines the Quaternion object where to store the result\n       * @returns the unmodified current quaternion\n       */\n      scaleToRef(scale, result) {\n          result.x = this.x * scale;\n          result.y = this.y * scale;\n          result.z = this.z * scale;\n          result.w = this.w * scale;\n          return this;\n      }\n      /**\n       * Multiplies in place the current quaternion by a scale factor\n       * @param value - defines the scale factor\n       * @returns the current modified quaternion\n       */\n      scaleInPlace(value) {\n          this.x *= value;\n          this.y *= value;\n          this.z *= value;\n          this.w *= value;\n          return this;\n      }\n      /**\n       * Scale the current quaternion values by a factor and add the result to a given quaternion\n       * @param scale - defines the scale factor\n       * @param result - defines the Quaternion object where to store the result\n       * @returns the unmodified current quaternion\n       */\n      scaleAndAddToRef(scale, result) {\n          result.x += this.x * scale;\n          result.y += this.y * scale;\n          result.z += this.z * scale;\n          result.w += this.w * scale;\n          return this;\n      }\n      /**\n       * Multiplies two quaternions\n       * @param q1 - defines the second operand\n       * @returns a new quaternion set as the multiplication result of the current one with the given one \"q1\"\n       */\n      multiply(q1) {\n          const result = new Quaternion(0, 0, 0, 1.0);\n          this.multiplyToRef(q1, result);\n          return result;\n      }\n      /**\n       * Sets the given \"result\" as the the multiplication result of the current one with the given one \"q1\"\n       * @param q1 - defines the second operand\n       * @param result - defines the target quaternion\n       * @returns the current quaternion\n       */\n      multiplyToRef(q1, result) {\n          const x = this.x * q1.w + this.y * q1.z - this.z * q1.y + this.w * q1.x;\n          const y = -this.x * q1.z + this.y * q1.w + this.z * q1.x + this.w * q1.y;\n          const z = this.x * q1.y - this.y * q1.x + this.z * q1.w + this.w * q1.z;\n          const w = -this.x * q1.x - this.y * q1.y - this.z * q1.z + this.w * q1.w;\n          result.copyFromFloats(x, y, z, w);\n          return this;\n      }\n      /**\n       * Updates the current quaternion with the multiplication of itself with the given one \"q1\"\n       * @param q1 - defines the second operand\n       * @returns the currentupdated quaternion\n       */\n      multiplyInPlace(q1) {\n          this.multiplyToRef(q1, this);\n          return this;\n      }\n      /**\n       * Conjugates (1-q) the current quaternion and stores the result in the given quaternion\n       * @param ref - defines the target quaternion\n       * @returns the current quaternion\n       */\n      conjugateToRef(ref) {\n          ref.copyFromFloats(-this.x, -this.y, -this.z, this.w);\n          return this;\n      }\n      /**\n       * Conjugates in place (1-q) the current quaternion\n       * @returns the current updated quaternion\n       */\n      conjugateInPlace() {\n          this.x *= -1;\n          this.y *= -1;\n          this.z *= -1;\n          return this;\n      }\n      /**\n       * Conjugates in place (1-q) the current quaternion\n       * @returns a new quaternion\n       */\n      conjugate() {\n          const result = new Quaternion(-this.x, -this.y, -this.z, this.w);\n          return result;\n      }\n      /**\n       * Normalize in place the current quaternion\n       * @returns the current updated quaternion\n       */\n      normalize() {\n          const length = 1.0 / this.length;\n          this.x *= length;\n          this.y *= length;\n          this.z *= length;\n          this.w *= length;\n          return this;\n      }\n      angleAxis(degress, axis) {\n          if (axis.lengthSquared() === 0) {\n              return Quaternion.Identity;\n          }\n          const result = Quaternion.Identity;\n          let radians = degress * types_1$7.DEG2RAD;\n          radians *= 0.5;\n          let a2 = axis.normalize();\n          a2 = axis.scaleInPlace(Math.sin(radians));\n          result.x = a2.x;\n          result.y = a2.y;\n          result.z = a2.z;\n          result.w = Math.cos(radians);\n          return result.normalize();\n      }\n      /**\n       * Updates the given rotation matrix with the current quaternion values\n       * @param result - defines the target matrix\n       * @returns the current unchanged quaternion\n       */\n      toRotationMatrix(result) {\n          Matrix_1$2.Matrix.FromQuaternionToRef(this, result);\n          return this;\n      }\n      /**\n       * Updates the current quaternion from the given rotation matrix values\n       * @param matrix - defines the source matrix\n       * @returns the current updated quaternion\n       */\n      fromRotationMatrix(matrix) {\n          Quaternion.FromRotationMatrixToRef(matrix, this);\n          return this;\n      }\n  }\n  Quaternion$1.Quaternion = Quaternion;\n\n  Object.defineProperty(Vector3$1, \"__esModule\", { value: true });\n  Vector3$1.Vector3 = void 0;\n  const preallocatedVariables_1$1 = preallocatedVariables;\n  const types_1$6 = types;\n  const Quaternion_1$1 = Quaternion$1;\n  const Scalar_1$4 = Scalar$1;\n  /**\n   * Classed used to store (x,y,z) vector representation\n   * A Vector3 is the main object used in 3D geometry\n   * It can represent etiher the coordinates of a point the space, either a direction\n   * Reminder: Babylon.js uses a left handed forward facing system\n   * @public\n   */\n  class Vector3 {\n      /**\n       * Creates a new Vector3 object from the given x, y, z (floats) coordinates.\n       * @param x - defines the first coordinates (on X axis)\n       * @param y - defines the second coordinates (on Y axis)\n       * @param z - defines the third coordinates (on Z axis)\n       */\n      constructor(\n      /**\n       * Defines the first coordinates (on X axis)\n       */\n      x = 0, \n      /**\n       * Defines the second coordinates (on Y axis)\n       */\n      y = 0, \n      /**\n       * Defines the third coordinates (on Z axis)\n       */\n      z = 0) {\n          this.x = x;\n          this.y = y;\n          this.z = z;\n      }\n      /**\n       * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same\n       */\n      get isNonUniform() {\n          const absX = Math.abs(this.x);\n          const absY = Math.abs(this.y);\n          if (absX !== absY) {\n              return true;\n          }\n          const absZ = Math.abs(this.z);\n          if (absX !== absZ) {\n              return true;\n          }\n          if (absY !== absZ) {\n              return true;\n          }\n          return false;\n      }\n      // Statics\n      /**\n       * Returns a new Vector3 as the result of the addition of the two given vectors.\n       * @param vector1 - the first vector\n       * @param vector2 - the second vector\n       * @returns the resulting vector\n       */\n      static Add(vector1, vector2) {\n          return new Vector3(vector1.x, vector1.y, vector1.z).addInPlace(vector2);\n      }\n      /**\n       * Get the clip factor between two vectors\n       * @param vector0 - defines the first operand\n       * @param vector1 - defines the second operand\n       * @param axis - defines the axis to use\n       * @param size - defines the size along the axis\n       * @returns the clip factor\n       */\n      static GetClipFactor(vector0, vector1, axis, size) {\n          const d0 = Vector3.Dot(vector0, axis) - size;\n          const d1 = Vector3.Dot(vector1, axis) - size;\n          const s = d0 / (d0 - d1);\n          return s;\n      }\n      /**\n       * Get angle between two vectors\n       * @param vector0 - angle between vector0 and vector1\n       * @param vector1 - angle between vector0 and vector1\n       * @param normal - direction of the normal\n       * @returns the angle between vector0 and vector1\n       */\n      static GetAngleBetweenVectors(vector0, vector1, normal) {\n          const v0 = vector0.normalizeToRef(preallocatedVariables_1$1.MathTmp.Vector3[1]);\n          const v1 = vector1.normalizeToRef(preallocatedVariables_1$1.MathTmp.Vector3[2]);\n          const dot = Vector3.Dot(v0, v1);\n          const n = preallocatedVariables_1$1.MathTmp.Vector3[3];\n          Vector3.CrossToRef(v0, v1, n);\n          if (Vector3.Dot(n, normal) > 0) {\n              return Math.acos(dot);\n          }\n          return -Math.acos(dot);\n      }\n      /**\n       * Returns a new Vector3 set from the index \"offset\" of the given array\n       * @param array - defines the source array\n       * @param offset - defines the offset in the source array\n       * @returns the new Vector3\n       */\n      static FromArray(array, offset = 0) {\n          return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\n      }\n      /**\n       * Returns a new Vector3 set from the index \"offset\" of the given FloatArray\n       * This function is deprecated.  Use FromArray instead\n       * @param array - defines the source array\n       * @param offset - defines the offset in the source array\n       * @returns the new Vector3\n       */\n      static FromFloatArray(array, offset) {\n          return Vector3.FromArray(array, offset);\n      }\n      /**\n       * Sets the given vector \"result\" with the element values from the index \"offset\" of the given array\n       * @param array - defines the source array\n       * @param offset - defines the offset in the source array\n       * @param result - defines the Vector3 where to store the result\n       */\n      static FromArrayToRef(array, offset, result) {\n          result.x = array[offset];\n          result.y = array[offset + 1];\n          result.z = array[offset + 2];\n      }\n      /**\n       * Sets the given vector \"result\" with the element values from the index \"offset\" of the given FloatArray\n       * This function is deprecated.  Use FromArrayToRef instead.\n       * @param array - defines the source array\n       * @param offset - defines the offset in the source array\n       * @param result - defines the Vector3 where to store the result\n       */\n      static FromFloatArrayToRef(array, offset, result) {\n          return Vector3.FromArrayToRef(array, offset, result);\n      }\n      /**\n       * Sets the given vector \"result\" with the given floats.\n       * @param x - defines the x coordinate of the source\n       * @param y - defines the y coordinate of the source\n       * @param z - defines the z coordinate of the source\n       * @param result - defines the Vector3 where to store the result\n       */\n      static FromFloatsToRef(x, y, z, result) {\n          result.copyFromFloats(x, y, z);\n      }\n      /**\n       * Returns a new Vector3 set to (0.0, 0.0, 0.0)\n       * @returns a new empty Vector3\n       */\n      static Zero() {\n          return new Vector3(0.0, 0.0, 0.0);\n      }\n      /**\n       * Returns a new Vector3 set to (1.0, 1.0, 1.0)\n       * @returns a new unit Vector3\n       */\n      static One() {\n          return new Vector3(1.0, 1.0, 1.0);\n      }\n      /**\n       * Returns a new Vector3 set to (0.0, 1.0, 0.0)\n       * @returns a new up Vector3\n       */\n      static Up() {\n          return new Vector3(0.0, 1.0, 0.0);\n      }\n      /**\n       * Returns a new Vector3 set to (0.0, -1.0, 0.0)\n       * @returns a new down Vector3\n       */\n      static Down() {\n          return new Vector3(0.0, -1.0, 0.0);\n      }\n      /**\n       * Returns a new Vector3 set to (0.0, 0.0, 1.0)\n       * @returns a new forward Vector3\n       */\n      static Forward() {\n          return new Vector3(0.0, 0.0, 1.0);\n      }\n      /**\n       * Returns a new Vector3 set to (0.0, 0.0, -1.0)\n       * @returns a new forward Vector3\n       */\n      static Backward() {\n          return new Vector3(0.0, 0.0, -1.0);\n      }\n      /**\n       * Returns a new Vector3 set to (1.0, 0.0, 0.0)\n       * @returns a new right Vector3\n       */\n      static Right() {\n          return new Vector3(1.0, 0.0, 0.0);\n      }\n      /**\n       * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\n       * @returns a new left Vector3\n       */\n      static Left() {\n          return new Vector3(-1.0, 0.0, 0.0);\n      }\n      /**\n       * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.\n       * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n       * @param vector - defines the Vector3 to transform\n       * @param transformation - defines the transformation matrix\n       * @returns the transformed Vector3\n       */\n      static TransformCoordinates(vector, transformation) {\n          const result = Vector3.Zero();\n          Vector3.TransformCoordinatesToRef(vector, transformation, result);\n          return result;\n      }\n      /**\n       * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\n       * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n       * @param vector - defines the Vector3 to transform\n       * @param transformation - defines the transformation matrix\n       * @param result - defines the Vector3 where to store the result\n       */\n      static TransformCoordinatesToRef(vector, transformation, result) {\n          return Vector3.TransformCoordinatesFromFloatsToRef(vector.x, vector.y, vector.z, transformation, result);\n      }\n      /**\n       * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\n       * This method computes tranformed coordinates only, not transformed direction vectors\n       * @param x - define the x coordinate of the source vector\n       * @param y - define the y coordinate of the source vector\n       * @param z - define the z coordinate of the source vector\n       * @param transformation - defines the transformation matrix\n       * @param result - defines the Vector3 where to store the result\n       */\n      static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {\n          const m = transformation.m;\n          const rx = x * m[0] + y * m[4] + z * m[8] + m[12];\n          const ry = x * m[1] + y * m[5] + z * m[9] + m[13];\n          const rz = x * m[2] + y * m[6] + z * m[10] + m[14];\n          const rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\n          result.x = rx * rw;\n          result.y = ry * rw;\n          result.z = rz * rw;\n      }\n      /**\n       * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector\n       * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n       * @param vector - defines the Vector3 to transform\n       * @param transformation - defines the transformation matrix\n       * @returns the new Vector3\n       */\n      static TransformNormal(vector, transformation) {\n          const result = Vector3.Zero();\n          Vector3.TransformNormalToRef(vector, transformation, result);\n          return result;\n      }\n      /**\n       * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector\n       * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n       * @param vector - defines the Vector3 to transform\n       * @param transformation - defines the transformation matrix\n       * @param result - defines the Vector3 where to store the result\n       */\n      static TransformNormalToRef(vector, transformation, result) {\n          this.TransformNormalFromFloatsToRef(vector.x, vector.y, vector.z, transformation, result);\n      }\n      /**\n       * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z)\n       * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n       * @param x - define the x coordinate of the source vector\n       * @param y - define the y coordinate of the source vector\n       * @param z - define the z coordinate of the source vector\n       * @param transformation - defines the transformation matrix\n       * @param result - defines the Vector3 where to store the result\n       */\n      static TransformNormalFromFloatsToRef(x, y, z, transformation, result) {\n          const m = transformation.m;\n          result.x = x * m[0] + y * m[4] + z * m[8];\n          result.y = x * m[1] + y * m[5] + z * m[9];\n          result.z = x * m[2] + y * m[6] + z * m[10];\n      }\n      /**\n       * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\"\n       * @param value1 - defines the first control point\n       * @param value2 - defines the second control point\n       * @param value3 - defines the third control point\n       * @param value4 - defines the fourth control point\n       * @param amount - defines the amount on the spline to use\n       * @returns the new Vector3\n       */\n      static CatmullRom(value1, value2, value3, value4, amount) {\n          const squared = amount * amount;\n          const cubed = amount * squared;\n          const x = 0.5 *\n              (2.0 * value2.x +\n                  (-value1.x + value3.x) * amount +\n                  (2.0 * value1.x - 5.0 * value2.x + 4.0 * value3.x - value4.x) *\n                      squared +\n                  (-value1.x + 3.0 * value2.x - 3.0 * value3.x + value4.x) * cubed);\n          const y = 0.5 *\n              (2.0 * value2.y +\n                  (-value1.y + value3.y) * amount +\n                  (2.0 * value1.y - 5.0 * value2.y + 4.0 * value3.y - value4.y) *\n                      squared +\n                  (-value1.y + 3.0 * value2.y - 3.0 * value3.y + value4.y) * cubed);\n          const z = 0.5 *\n              (2.0 * value2.z +\n                  (-value1.z + value3.z) * amount +\n                  (2.0 * value1.z - 5.0 * value2.z + 4.0 * value3.z - value4.z) *\n                      squared +\n                  (-value1.z + 3.0 * value2.z - 3.0 * value3.z + value4.z) * cubed);\n          return new Vector3(x, y, z);\n      }\n      /**\n       * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n       * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n       * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n       * @param value - defines the current value\n       * @param min - defines the lower range value\n       * @param max - defines the upper range value\n       * @returns the new Vector3\n       */\n      static Clamp(value, min, max) {\n          const v = new Vector3();\n          Vector3.ClampToRef(value, min, max, v);\n          return v;\n      }\n      /**\n       * Sets the given vector \"result\" with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n       * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n       * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n       * @param value - defines the current value\n       * @param min - defines the lower range value\n       * @param max - defines the upper range value\n       * @param result - defines the Vector3 where to store the result\n       */\n      static ClampToRef(value, min, max, result) {\n          let x = value.x;\n          x = x > max.x ? max.x : x;\n          x = x < min.x ? min.x : x;\n          let y = value.y;\n          y = y > max.y ? max.y : y;\n          y = y < min.y ? min.y : y;\n          let z = value.z;\n          z = z > max.z ? max.z : z;\n          z = z < min.z ? min.z : z;\n          result.copyFromFloats(x, y, z);\n      }\n      /**\n       * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n       * @param value1 - defines the first control point\n       * @param tangent1 - defines the first tangent vector\n       * @param value2 - defines the second control point\n       * @param tangent2 - defines the second tangent vector\n       * @param amount - defines the amount on the interpolation spline (between 0 and 1)\n       * @returns the new Vector3\n       */\n      static Hermite(value1, tangent1, value2, tangent2, amount) {\n          const squared = amount * amount;\n          const cubed = amount * squared;\n          const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n          const part2 = -2.0 * cubed + 3.0 * squared;\n          const part3 = cubed - 2.0 * squared + amount;\n          const part4 = cubed - squared;\n          const x = value1.x * part1 +\n              value2.x * part2 +\n              tangent1.x * part3 +\n              tangent2.x * part4;\n          const y = value1.y * part1 +\n              value2.y * part2 +\n              tangent1.y * part3 +\n              tangent2.y * part4;\n          const z = value1.z * part1 +\n              value2.z * part2 +\n              tangent1.z * part3 +\n              tangent2.z * part4;\n          return new Vector3(x, y, z);\n      }\n      /**\n       * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\"\n       * @param start - defines the start value\n       * @param end - defines the end value\n       * @param amount - max defines amount between both (between 0 and 1)\n       * @returns the new Vector3\n       */\n      static Lerp(start, end, amount) {\n          const result = new Vector3(0, 0, 0);\n          Vector3.LerpToRef(start, end, amount, result);\n          return result;\n      }\n      /**\n       * Sets the given vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\"\n       * @param start - defines the start value\n       * @param end - defines the end value\n       * @param amount - max defines amount between both (between 0 and 1)\n       * @param result - defines the Vector3 where to store the result\n       */\n      static LerpToRef(start, end, amount, result) {\n          result.x = start.x + (end.x - start.x) * amount;\n          result.y = start.y + (end.y - start.y) * amount;\n          result.z = start.z + (end.z - start.z) * amount;\n      }\n      /**\n       * Returns the dot product (float) between the vectors \"left\" and \"right\"\n       * @param left - defines the left operand\n       * @param right - defines the right operand\n       * @returns the dot product\n       */\n      static Dot(left, right) {\n          return left.x * right.x + left.y * right.y + left.z * right.z;\n      }\n      /**\n       * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\"\n       * The cross product is then orthogonal to both \"left\" and \"right\"\n       * @param left - defines the left operand\n       * @param right - defines the right operand\n       * @returns the cross product\n       */\n      static Cross(left, right) {\n          const result = Vector3.Zero();\n          Vector3.CrossToRef(left, right, result);\n          return result;\n      }\n      /**\n       * Sets the given vector \"result\" with the cross product of \"left\" and \"right\"\n       * The cross product is then orthogonal to both \"left\" and \"right\"\n       * @param left - defines the left operand\n       * @param right - defines the right operand\n       * @param result - defines the Vector3 where to store the result\n       */\n      static CrossToRef(left, right, result) {\n          const x = left.y * right.z - left.z * right.y;\n          const y = left.z * right.x - left.x * right.z;\n          const z = left.x * right.y - left.y * right.x;\n          result.copyFromFloats(x, y, z);\n      }\n      /**\n       * Returns a new Vector3 as the normalization of the given vector\n       * @param vector - defines the Vector3 to normalize\n       * @returns the new Vector3\n       */\n      static Normalize(vector) {\n          const result = Vector3.Zero();\n          Vector3.NormalizeToRef(vector, result);\n          return result;\n      }\n      /**\n       * Sets the given vector \"result\" with the normalization of the given first vector\n       * @param vector - defines the Vector3 to normalize\n       * @param result - defines the Vector3 where to store the result\n       */\n      static NormalizeToRef(vector, result) {\n          vector.normalizeToRef(result);\n      }\n      /**\n       * Gets the minimal coordinate values between two Vector3\n       * @param left - defines the first operand\n       * @param right - defines the second operand\n       * @returns the new Vector3\n       */\n      static Minimize(left, right) {\n          const min = new Vector3(left.x, left.y, left.z);\n          min.minimizeInPlace(right);\n          return min;\n      }\n      /**\n       * Gets the maximal coordinate values between two Vector3\n       * @param left - defines the first operand\n       * @param right - defines the second operand\n       * @returns the new Vector3\n       */\n      static Maximize(left, right) {\n          const max = new Vector3(left.x, left.y, left.z);\n          max.maximizeInPlace(right);\n          return max;\n      }\n      /**\n       * Returns the distance between the vectors \"value1\" and \"value2\"\n       * @param value1 - defines the first operand\n       * @param value2 - defines the second operand\n       * @returns the distance\n       */\n      static Distance(value1, value2) {\n          return Math.sqrt(Vector3.DistanceSquared(value1, value2));\n      }\n      /**\n       * Returns the squared distance between the vectors \"value1\" and \"value2\"\n       * @param value1 - defines the first operand\n       * @param value2 - defines the second operand\n       * @returns the squared distance\n       */\n      static DistanceSquared(value1, value2) {\n          const x = value1.x - value2.x;\n          const y = value1.y - value2.y;\n          const z = value1.z - value2.z;\n          return x * x + y * y + z * z;\n      }\n      /**\n       * Returns a new Vector3 located at the center between \"value1\" and \"value2\"\n       * @param value1 - defines the first operand\n       * @param value2 - defines the second operand\n       * @returns the new Vector3\n       */\n      static Center(value1, value2) {\n          const center = Vector3.Add(value1, value2);\n          center.scaleInPlace(0.5);\n          return center;\n      }\n      /**\n       * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\n       * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\n       * to something in order to rotate it from its local system to the given target system\n       * Note: axis1, axis2 and axis3 are normalized during this operation\n       * @param axis1 - defines the first axis\n       * @param axis2 - defines the second axis\n       * @param axis3 - defines the third axis\n       * @returns a new Vector3\n       */\n      static RotationFromAxis(axis1, axis2, axis3) {\n          const rotation = Vector3.Zero();\n          Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\n          return rotation;\n      }\n      /**\n       * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3\n       * @param axis1 - defines the first axis\n       * @param axis2 - defines the second axis\n       * @param axis3 - defines the third axis\n       * @param ref - defines the Vector3 where to store the result\n       */\n      static RotationFromAxisToRef(axis1, axis2, axis3, ref) {\n          const quat = preallocatedVariables_1$1.MathTmp.Quaternion[0];\n          Quaternion_1$1.Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n          ref.copyFrom(quat.eulerAngles);\n      }\n      /**\n       * Creates a string representation of the Vector3\n       * @returns a string with the Vector3 coordinates.\n       */\n      toString() {\n          return `(${this.x}, ${this.y}, ${this.z})`;\n      }\n      /**\n       * Gets the class name\n       * @returns the string \"Vector3\"\n       */\n      getClassName() {\n          return 'Vector3';\n      }\n      /**\n       * Creates the Vector3 hash code\n       * @returns a number which tends to be unique between Vector3 instances\n       */\n      getHashCode() {\n          let hash = this.x || 0;\n          hash = (hash * 397) ^ (this.y || 0);\n          hash = (hash * 397) ^ (this.z || 0);\n          return hash;\n      }\n      // Operators\n      /**\n       * Creates an array containing three elements : the coordinates of the Vector3\n       * @returns a new array of numbers\n       */\n      asArray() {\n          const result = [];\n          this.toArray(result, 0);\n          return result;\n      }\n      /**\n       * Populates the given array or FloatArray from the given index with the successive coordinates of the Vector3\n       * @param array - defines the destination array\n       * @param index - defines the offset in the destination array\n       * @returns the current Vector3\n       */\n      toArray(array, index = 0) {\n          array[index] = this.x;\n          array[index + 1] = this.y;\n          array[index + 2] = this.z;\n          return this;\n      }\n      /**\n       * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)\n       * @returns a new Quaternion object, computed from the Vector3 coordinates\n       */\n      toQuaternion() {\n          return Quaternion_1$1.Quaternion.Identity.setEuler(this.y, this.x, this.z);\n      }\n      /**\n       * Adds the given vector to the current Vector3\n       * @param otherVector - defines the second operand\n       * @returns the current updated Vector3\n       */\n      addInPlace(otherVector) {\n          return this.addInPlaceFromFloats(otherVector.x, otherVector.y, otherVector.z);\n      }\n      /**\n       * Adds the given coordinates to the current Vector3\n       * @param x - defines the x coordinate of the operand\n       * @param y - defines the y coordinate of the operand\n       * @param z - defines the z coordinate of the operand\n       * @returns the current updated Vector3\n       */\n      addInPlaceFromFloats(x, y, z) {\n          this.x += x;\n          this.y += y;\n          this.z += z;\n          return this;\n      }\n      /**\n       * Gets a new Vector3, result of the addition the current Vector3 and the given vector\n       * @param otherVector - defines the second operand\n       * @returns the resulting Vector3\n       */\n      add(otherVector) {\n          return new Vector3(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z);\n      }\n      /**\n       * Adds the current Vector3 to the given one and stores the result in the vector \"result\"\n       * @param otherVector - defines the second operand\n       * @param result - defines the Vector3 object where to store the result\n       * @returns the current Vector3\n       */\n      addToRef(otherVector, result) {\n          return result.copyFromFloats(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z);\n      }\n      /**\n       * Subtract the given vector from the current Vector3\n       * @param otherVector - defines the second operand\n       * @returns the current updated Vector3\n       */\n      subtractInPlace(otherVector) {\n          this.x -= otherVector.x;\n          this.y -= otherVector.y;\n          this.z -= otherVector.z;\n          return this;\n      }\n      /**\n       * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3\n       * @param otherVector - defines the second operand\n       * @returns the resulting Vector3\n       */\n      subtract(otherVector) {\n          return new Vector3(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z);\n      }\n      /**\n       * Subtracts the given vector from the current Vector3 and stores the result in the vector \"result\".\n       * @param otherVector - defines the second operand\n       * @param result - defines the Vector3 object where to store the result\n       * @returns the current Vector3\n       */\n      subtractToRef(otherVector, result) {\n          return this.subtractFromFloatsToRef(otherVector.x, otherVector.y, otherVector.z, result);\n      }\n      /**\n       * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates\n       * @param x - defines the x coordinate of the operand\n       * @param y - defines the y coordinate of the operand\n       * @param z - defines the z coordinate of the operand\n       * @returns the resulting Vector3\n       */\n      subtractFromFloats(x, y, z) {\n          return new Vector3(this.x - x, this.y - y, this.z - z);\n      }\n      /**\n       * Subtracts the given floats from the current Vector3 coordinates and set the given vector \"result\" with this result\n       * @param x - defines the x coordinate of the operand\n       * @param y - defines the y coordinate of the operand\n       * @param z - defines the z coordinate of the operand\n       * @param result - defines the Vector3 object where to store the result\n       * @returns the current Vector3\n       */\n      subtractFromFloatsToRef(x, y, z, result) {\n          return result.copyFromFloats(this.x - x, this.y - y, this.z - z);\n      }\n      /**\n       * Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective\n       * @param matrix - The transformation matrix\n       */\n      applyMatrix4(matrix) {\n          this.applyMatrix4ToRef(matrix, this);\n      }\n      /**\n       * Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective and set the given vector \"result\" with this result\n       * @param matrix - The transformation matrix\n       * @param result - defines the Vector3 object where to store the result\n       * @returns the current Vector3\n       */\n      applyMatrix4ToRef(matrix, result) {\n          const { x, y, z } = this;\n          const { m } = matrix;\n          const w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);\n          result.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;\n          result.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;\n          result.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;\n          return result;\n      }\n      /**\n       * Rotates the current Vector3 based on the given quaternion\n       * @param q - defines the Quaternion\n       * @returns the current Vector3\n       */\n      rotate(q) {\n          return this.rotateToRef(q, this);\n      }\n      /**\n       * Rotates current Vector3 based on the given quaternion, but applies the rotation to target Vector3.\n       * @param q - defines the Quaternion\n       * @param result - defines the target Vector3\n       * @returns the current Vector3\n       */\n      rotateToRef(q, result) {\n          const { x, y, z } = this;\n          const { x: qx, y: qy, z: qz, w: qw } = q;\n          // calculate quat * vector\n          const ix = qw * x + qy * z - qz * y;\n          const iy = qw * y + qz * x - qx * z;\n          const iz = qw * z + qx * y - qy * x;\n          const iw = -qx * x - qy * y - qz * z;\n          // calculate result * inverse quat\n          result.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n          result.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n          result.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n          return result;\n      }\n      /**\n       * Gets a new Vector3 set with the current Vector3 negated coordinates\n       * @returns a new Vector3\n       */\n      negate() {\n          return new Vector3(-this.x, -this.y, -this.z);\n      }\n      /**\n       * Multiplies the Vector3 coordinates by the float \"scale\"\n       * @param scale - defines the multiplier factor\n       * @returns the current updated Vector3\n       */\n      scaleInPlace(scale) {\n          this.x *= scale;\n          this.y *= scale;\n          this.z *= scale;\n          return this;\n      }\n      /**\n       * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\"\n       * @param scale - defines the multiplier factor\n       * @returns a new Vector3\n       */\n      scale(scale) {\n          return new Vector3(this.x * scale, this.y * scale, this.z * scale);\n      }\n      /**\n       * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the given vector \"result\" coordinates\n       * @param scale - defines the multiplier factor\n       * @param result - defines the Vector3 object where to store the result\n       * @returns the current Vector3\n       */\n      scaleToRef(scale, result) {\n          return result.copyFromFloats(this.x * scale, this.y * scale, this.z * scale);\n      }\n      /**\n       * Scale the current Vector3 values by a factor and add the result to a given Vector3\n       * @param scale - defines the scale factor\n       * @param result - defines the Vector3 object where to store the result\n       * @returns the unmodified current Vector3\n       */\n      scaleAndAddToRef(scale, result) {\n          return result.addInPlaceFromFloats(this.x * scale, this.y * scale, this.z * scale);\n      }\n      /**\n       * Returns true if the current Vector3 and the given vector coordinates are strictly equal\n       * @param otherVector - defines the second operand\n       * @returns true if both vectors are equals\n       */\n      equals(otherVector) {\n          return (otherVector &&\n              this.x === otherVector.x &&\n              this.y === otherVector.y &&\n              this.z === otherVector.z);\n      }\n      /**\n       * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon\n       * @param otherVector - defines the second operand\n       * @param epsilon - defines the minimal distance to define values as equals\n       * @returns true if both vectors are distant less than epsilon\n       */\n      equalsWithEpsilon(otherVector, epsilon = types_1$6.Epsilon) {\n          return (otherVector &&\n              Scalar_1$4.Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) &&\n              Scalar_1$4.Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) &&\n              Scalar_1$4.Scalar.WithinEpsilon(this.z, otherVector.z, epsilon));\n      }\n      /**\n       * Returns true if the current Vector3 coordinates equals the given floats\n       * @param x - defines the x coordinate of the operand\n       * @param y - defines the y coordinate of the operand\n       * @param z - defines the z coordinate of the operand\n       * @returns true if both vectors are equals\n       */\n      equalsToFloats(x, y, z) {\n          return this.x === x && this.y === y && this.z === z;\n      }\n      /**\n       * Multiplies the current Vector3 coordinates by the given ones\n       * @param otherVector - defines the second operand\n       * @returns the current updated Vector3\n       */\n      multiplyInPlace(otherVector) {\n          this.x *= otherVector.x;\n          this.y *= otherVector.y;\n          this.z *= otherVector.z;\n          return this;\n      }\n      /**\n       * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector\n       * @param otherVector - defines the second operand\n       * @returns the new Vector3\n       */\n      multiply(otherVector) {\n          return this.multiplyByFloats(otherVector.x, otherVector.y, otherVector.z);\n      }\n      /**\n       * Multiplies the current Vector3 by the given one and stores the result in the given vector \"result\"\n       * @param otherVector - defines the second operand\n       * @param result - defines the Vector3 object where to store the result\n       * @returns the current Vector3\n       */\n      multiplyToRef(otherVector, result) {\n          return result.copyFromFloats(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z);\n      }\n      /**\n       * Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats\n       * @param x - defines the x coordinate of the operand\n       * @param y - defines the y coordinate of the operand\n       * @param z - defines the z coordinate of the operand\n       * @returns the new Vector3\n       */\n      multiplyByFloats(x, y, z) {\n          return new Vector3(this.x * x, this.y * y, this.z * z);\n      }\n      /**\n       * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones\n       * @param otherVector - defines the second operand\n       * @returns the new Vector3\n       */\n      divide(otherVector) {\n          return new Vector3(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z);\n      }\n      /**\n       * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector \"result\"\n       * @param otherVector - defines the second operand\n       * @param result - defines the Vector3 object where to store the result\n       * @returns the current Vector3\n       */\n      divideToRef(otherVector, result) {\n          return result.copyFromFloats(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z);\n      }\n      /**\n       * Divides the current Vector3 coordinates by the given ones.\n       * @param otherVector - defines the second operand\n       * @returns the current updated Vector3\n       */\n      divideInPlace(otherVector) {\n          return this.divideToRef(otherVector, this);\n      }\n      /**\n       * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones\n       * @param other - defines the second operand\n       * @returns the current updated Vector3\n       */\n      minimizeInPlace(other) {\n          return this.minimizeInPlaceFromFloats(other.x, other.y, other.z);\n      }\n      /**\n       * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.\n       * @param other - defines the second operand\n       * @returns the current updated Vector3\n       */\n      maximizeInPlace(other) {\n          return this.maximizeInPlaceFromFloats(other.x, other.y, other.z);\n      }\n      /**\n       * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates\n       * @param x - defines the x coordinate of the operand\n       * @param y - defines the y coordinate of the operand\n       * @param z - defines the z coordinate of the operand\n       * @returns the current updated Vector3\n       */\n      minimizeInPlaceFromFloats(x, y, z) {\n          if (x < this.x) {\n              this.x = x;\n          }\n          if (y < this.y) {\n              this.y = y;\n          }\n          if (z < this.z) {\n              this.z = z;\n          }\n          return this;\n      }\n      /**\n       * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.\n       * @param x - defines the x coordinate of the operand\n       * @param y - defines the y coordinate of the operand\n       * @param z - defines the z coordinate of the operand\n       * @returns the current updated Vector3\n       */\n      maximizeInPlaceFromFloats(x, y, z) {\n          if (x > this.x) {\n              this.x = x;\n          }\n          if (y > this.y) {\n              this.y = y;\n          }\n          if (z > this.z) {\n              this.z = z;\n          }\n          return this;\n      }\n      /**\n       * Gets a new Vector3 from current Vector3 floored values\n       * @returns a new Vector3\n       */\n      floor() {\n          return new Vector3(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));\n      }\n      /**\n       * Gets a new Vector3 from current Vector3 floored values\n       * @returns a new Vector3\n       */\n      fract() {\n          return new Vector3(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z));\n      }\n      // Properties\n      /**\n       * Gets the length of the Vector3\n       * @returns the length of the Vecto3\n       */\n      length() {\n          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n      }\n      /**\n       * Gets the squared length of the Vector3\n       * @returns squared length of the Vector3\n       */\n      lengthSquared() {\n          return this.x * this.x + this.y * this.y + this.z * this.z;\n      }\n      /**\n       * Normalize the current Vector3.\n       * Please note that this is an in place operation.\n       * @returns the current updated Vector3\n       */\n      normalize() {\n          return this.normalizeFromLength(this.length());\n      }\n      /**\n       * Normalize the current Vector3 with the given input length.\n       * Please note that this is an in place operation.\n       * @param len - the length of the vector\n       * @returns the current updated Vector3\n       */\n      normalizeFromLength(len) {\n          if (len === 0 || len === 1.0) {\n              return this;\n          }\n          return this.scaleInPlace(1.0 / len);\n      }\n      /**\n       * Normalize the current Vector3 to a new vector\n       * @returns the new Vector3\n       */\n      normalizeToNew() {\n          const normalized = new Vector3(0, 0, 0);\n          this.normalizeToRef(normalized);\n          return normalized;\n      }\n      /**\n       * Normalize the current Vector3 to the reference\n       * @param reference - define the Vector3 to update\n       * @returns the updated Vector3\n       */\n      normalizeToRef(reference) {\n          const len = this.length();\n          if (len === 0 || len === 1.0) {\n              return reference.copyFromFloats(this.x, this.y, this.z);\n          }\n          return this.scaleToRef(1.0 / len, reference);\n      }\n      /**\n       * Creates a new Vector3 copied from the current Vector3\n       * @returns the new Vector3\n       */\n      clone() {\n          return new Vector3(this.x, this.y, this.z);\n      }\n      /**\n       * Copies the given vector coordinates to the current Vector3 ones\n       * @param source - defines the source Vector3\n       * @returns the current updated Vector3\n       */\n      copyFrom(source) {\n          return this.copyFromFloats(source.x, source.y, source.z);\n      }\n      /**\n       * Copies the given floats to the current Vector3 coordinates\n       * @param x - defines the x coordinate of the operand\n       * @param y - defines the y coordinate of the operand\n       * @param z - defines the z coordinate of the operand\n       * @returns the current updated Vector3\n       */\n      copyFromFloats(x, y, z) {\n          this.x = x;\n          this.y = y;\n          this.z = z;\n          return this;\n      }\n      /**\n       * Copies the given floats to the current Vector3 coordinates\n       * @param x - defines the x coordinate of the operand\n       * @param y - defines the y coordinate of the operand\n       * @param z - defines the z coordinate of the operand\n       * @returns the current updated Vector3\n       */\n      set(x, y, z) {\n          return this.copyFromFloats(x, y, z);\n      }\n      /**\n       * Copies the given float to the current Vector3 coordinates\n       * @param v - defines the x, y and z coordinates of the operand\n       * @returns the current updated Vector3\n       */\n      setAll(v) {\n          this.x = this.y = this.z = v;\n          return this;\n      }\n  }\n  Vector3$1.Vector3 = Vector3;\n\n  Object.defineProperty(preallocatedVariables, \"__esModule\", { value: true });\n  preallocatedVariables.MathTmp = void 0;\n  const utils_1 = utils;\n  const Vector3_1$4 = Vector3$1;\n  const Quaternion_1 = Quaternion$1;\n  const Matrix_1$1 = Matrix$1;\n  // Temporary pre-allocated objects for engine internal use\n  // usage in any internal function :\n  // var tmp = Tmp.Vector3[0];   <= gets access to the first pre-created Vector3\n  // There's a Tmp array per object type : int, float, Vector2, Vector3, Vector4, Quaternion, Matrix\n  /**\n   * @public\n   * Same as Tmp but not exported to keep it only for math functions to avoid conflicts\n   */\n  preallocatedVariables.MathTmp = {\n      Vector3: (0, utils_1.buildArray)(6, Vector3_1$4.Vector3.Zero),\n      Matrix: (0, utils_1.buildArray)(2, Matrix_1$1.Matrix.Identity),\n      Quaternion: (0, utils_1.buildArray)(3, Quaternion_1.Quaternion.Zero),\n      staticUp: Vector3_1$4.Vector3.Up(),\n      tmpMatrix: Matrix_1$1.Matrix.Zero()\n  };\n\n  var Angle$1 = {};\n\n  Object.defineProperty(Angle$1, \"__esModule\", { value: true });\n  Angle$1.Angle = void 0;\n  /**\n   * Defines angle representation\n   * @public\n   */\n  class Angle {\n      /**\n       * Creates an Angle object of \"radians\" radians (float).\n       */\n      constructor(radians) {\n          this._radians = radians;\n          if (this._radians < 0.0) {\n              this._radians += 2.0 * Math.PI;\n          }\n      }\n      /**\n       * Gets a new Angle object valued with the angle value in radians between the two given vectors\n       * @param a - defines first vector\n       * @param b - defines second vector\n       * @returns a new Angle\n       */\n      static BetweenTwoPoints(a, b) {\n          const delta = b.subtract(a);\n          const theta = Math.atan2(delta.y, delta.x);\n          return new Angle(theta);\n      }\n      /**\n       * Gets a new Angle object from the given float in radians\n       * @param radians - defines the angle value in radians\n       * @returns a new Angle\n       */\n      static FromRadians(radians) {\n          return new Angle(radians);\n      }\n      /**\n       * Gets a new Angle object from the given float in degrees\n       * @param degrees - defines the angle value in degrees\n       * @returns a new Angle\n       */\n      static FromDegrees(degrees) {\n          return new Angle((degrees * Math.PI) / 180.0);\n      }\n      /**\n       * Get value in degrees\n       * @returns the Angle value in degrees (float)\n       */\n      degrees() {\n          return (this._radians * 180.0) / Math.PI;\n      }\n      /**\n       * Get value in radians\n       * @returns the Angle value in radians (float)\n       */\n      radians() {\n          return this._radians;\n      }\n  }\n  Angle$1.Angle = Angle;\n\n  var Arc2$1 = {};\n\n  var Vector2$1 = {};\n\n  Object.defineProperty(Vector2$1, \"__esModule\", { value: true });\n  Vector2$1.Vector2 = void 0;\n  const types_1$5 = types;\n  const Scalar_1$3 = Scalar$1;\n  /**\n   * Class representing a vector containing 2 coordinates\n   * @public\n   */\n  class Vector2 {\n      /**\n       * Creates a new Vector2 from the given x and y coordinates\n       * @param x - defines the first coordinate\n       * @param y - defines the second coordinate\n       */\n      constructor(\n      /** defines the first coordinate */\n      x = 0, \n      /** defines the second coordinate */\n      y = 0) {\n          this.x = x;\n          this.y = y;\n      }\n      /**\n       * Gets a new Vector2(0, 0)\n       * @returns a new Vector2\n       */\n      static Zero() {\n          return new Vector2(0, 0);\n      }\n      /**\n       * Gets a new Vector2(1, 1)\n       * @returns a new Vector2\n       */\n      static One() {\n          return new Vector2(1, 1);\n      }\n      /**\n       * Returns a new Vector2 as the result of the addition of the two given vectors.\n       * @param vector1 - the first vector\n       * @param vector2 - the second vector\n       * @returns the resulting vector\n       */\n      static Add(vector1, vector2) {\n          return new Vector2(vector1.x, vector1.y).addInPlace(vector2);\n      }\n      /**\n       * Gets a new Vector2 set from the given index element of the given array\n       * @param array - defines the data source\n       * @param offset - defines the offset in the data source\n       * @returns a new Vector2\n       */\n      static FromArray(array, offset = 0) {\n          return new Vector2(array[offset], array[offset + 1]);\n      }\n      /**\n       * Sets \"result\" from the given index element of the given array\n       * @param array - defines the data source\n       * @param offset - defines the offset in the data source\n       * @param result - defines the target vector\n       */\n      static FromArrayToRef(array, offset, result) {\n          result.x = array[offset];\n          result.y = array[offset + 1];\n      }\n      /**\n       * Gets a new Vector2 located for \"amount\" (float) on the CatmullRom spline defined by the given four Vector2\n       * @param value1 - defines 1st point of control\n       * @param value2 - defines 2nd point of control\n       * @param value3 - defines 3rd point of control\n       * @param value4 - defines 4th point of control\n       * @param amount - defines the interpolation factor\n       * @returns a new Vector2\n       */\n      static CatmullRom(value1, value2, value3, value4, amount) {\n          const squared = amount * amount;\n          const cubed = amount * squared;\n          const x = 0.5 *\n              (2.0 * value2.x +\n                  (-value1.x + value3.x) * amount +\n                  (2.0 * value1.x - 5.0 * value2.x + 4.0 * value3.x - value4.x) *\n                      squared +\n                  (-value1.x + 3.0 * value2.x - 3.0 * value3.x + value4.x) * cubed);\n          const y = 0.5 *\n              (2.0 * value2.y +\n                  (-value1.y + value3.y) * amount +\n                  (2.0 * value1.y - 5.0 * value2.y + 4.0 * value3.y - value4.y) *\n                      squared +\n                  (-value1.y + 3.0 * value2.y - 3.0 * value3.y + value4.y) * cubed);\n          return new Vector2(x, y);\n      }\n      /**\n       * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\n       * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\n       * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate\n       * @param value - defines the value to clamp\n       * @param min - defines the lower limit\n       * @param max - defines the upper limit\n       * @returns a new Vector2\n       */\n      static Clamp(value, min, max) {\n          let x = value.x;\n          x = x > max.x ? max.x : x;\n          x = x < min.x ? min.x : x;\n          let y = value.y;\n          y = y > max.y ? max.y : y;\n          y = y < min.y ? min.y : y;\n          return new Vector2(x, y);\n      }\n      /**\n       * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value3\", \"tangent1\", \"tangent2\"\n       * @param value1 - defines the 1st control point\n       * @param tangent1 - defines the outgoing tangent\n       * @param value2 - defines the 2nd control point\n       * @param tangent2 - defines the incoming tangent\n       * @param amount - defines the interpolation factor\n       * @returns a new Vector2\n       */\n      static Hermite(value1, tangent1, value2, tangent2, amount) {\n          const squared = amount * amount;\n          const cubed = amount * squared;\n          const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n          const part2 = -2.0 * cubed + 3.0 * squared;\n          const part3 = cubed - 2.0 * squared + amount;\n          const part4 = cubed - squared;\n          const x = value1.x * part1 +\n              value2.x * part2 +\n              tangent1.x * part3 +\n              tangent2.x * part4;\n          const y = value1.y * part1 +\n              value2.y * part2 +\n              tangent1.y * part3 +\n              tangent2.y * part4;\n          return new Vector2(x, y);\n      }\n      /**\n       * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\n       * @param start - defines the start vector\n       * @param end - defines the end vector\n       * @param amount - defines the interpolation factor\n       * @returns a new Vector2\n       */\n      static Lerp(start, end, amount) {\n          const x = start.x + (end.x - start.x) * amount;\n          const y = start.y + (end.y - start.y) * amount;\n          return new Vector2(x, y);\n      }\n      /**\n       * Gets the dot product of the vector \"left\" and the vector \"right\"\n       * @param left - defines first vector\n       * @param right - defines second vector\n       * @returns the dot product (float)\n       */\n      static Dot(left, right) {\n          return left.x * right.x + left.y * right.y;\n      }\n      /**\n       * Returns a new Vector2 equal to the normalized given vector\n       * @param vector - defines the vector to normalize\n       * @returns a new Vector2\n       */\n      static Normalize(vector) {\n          const newVector = new Vector2(vector.x, vector.y);\n          newVector.normalize();\n          return newVector;\n      }\n      /**\n       * Gets a new Vector2 set with the minimal coordinate values from the \"left\" and \"right\" vectors\n       * @param left - defines 1st vector\n       * @param right - defines 2nd vector\n       * @returns a new Vector2\n       */\n      static Minimize(left, right) {\n          const x = left.x < right.x ? left.x : right.x;\n          const y = left.y < right.y ? left.y : right.y;\n          return new Vector2(x, y);\n      }\n      /**\n       * Gets a new Vecto2 set with the maximal coordinate values from the \"left\" and \"right\" vectors\n       * @param left - defines 1st vector\n       * @param right - defines 2nd vector\n       * @returns a new Vector2\n       */\n      static Maximize(left, right) {\n          const x = left.x > right.x ? left.x : right.x;\n          const y = left.y > right.y ? left.y : right.y;\n          return new Vector2(x, y);\n      }\n      /**\n       * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix\n       * @param vector - defines the vector to transform\n       * @param transformation - defines the matrix to apply\n       * @returns a new Vector2\n       */\n      static Transform(vector, transformation) {\n          const r = Vector2.Zero();\n          Vector2.TransformToRef(vector, transformation, r);\n          return r;\n      }\n      /**\n       * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector \"result\" coordinates\n       * @param vector - defines the vector to transform\n       * @param transformation - defines the matrix to apply\n       * @param result - defines the target vector\n       */\n      static TransformToRef(vector, transformation, result) {\n          const m = transformation.m;\n          const x = vector.x * m[0] + vector.y * m[4] + m[12];\n          const y = vector.x * m[1] + vector.y * m[5] + m[13];\n          result.x = x;\n          result.y = y;\n      }\n      /**\n       * Determines if a given vector is included in a triangle\n       * @param p - defines the vector to test\n       * @param p0 - defines 1st triangle point\n       * @param p1 - defines 2nd triangle point\n       * @param p2 - defines 3rd triangle point\n       * @returns true if the point \"p\" is in the triangle defined by the vertors \"p0\", \"p1\", \"p2\"\n       */\n      static PointInTriangle(p, p0, p1, p2) {\n          const a = (1 / 2) *\n              (-p1.y * p2.x +\n                  p0.y * (-p1.x + p2.x) +\n                  p0.x * (p1.y - p2.y) +\n                  p1.x * p2.y);\n          const sign = a < 0 ? -1 : 1;\n          const s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) *\n              sign;\n          const t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) *\n              sign;\n          return s > 0 && t > 0 && s + t < 2 * a * sign;\n      }\n      /**\n       * Gets the distance between the vectors \"value1\" and \"value2\"\n       * @param value1 - defines first vector\n       * @param value2 - defines second vector\n       * @returns the distance between vectors\n       */\n      static Distance(value1, value2) {\n          return Math.sqrt(Vector2.DistanceSquared(value1, value2));\n      }\n      /**\n       * Returns the squared distance between the vectors \"value1\" and \"value2\"\n       * @param value1 - defines first vector\n       * @param value2 - defines second vector\n       * @returns the squared distance between vectors\n       */\n      static DistanceSquared(value1, value2) {\n          const x = value1.x - value2.x;\n          const y = value1.y - value2.y;\n          return x * x + y * y;\n      }\n      /**\n       * Gets a new Vector2 located at the center of the vectors \"value1\" and \"value2\"\n       * @param value1 - defines first vector\n       * @param value2 - defines second vector\n       * @returns a new Vector2\n       */\n      static Center(value1, value2) {\n          const center = Vector2.Add(value1, value2);\n          center.scaleInPlace(0.5);\n          return center;\n      }\n      /**\n       * Gets the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\n       * @param p - defines the middle point\n       * @param segA - defines one point of the segment\n       * @param segB - defines the other point of the segment\n       * @returns the shortest distance\n       */\n      static DistanceOfPointFromSegment(p, segA, segB) {\n          const l2 = Vector2.DistanceSquared(segA, segB);\n          if (l2 === 0.0) {\n              return Vector2.Distance(p, segA);\n          }\n          const v = segB.subtract(segA);\n          const t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\n          const proj = segA.add(v.multiplyByFloats(t, t));\n          return Vector2.Distance(p, proj);\n      }\n      /**\n       * Gets a string with the Vector2 coordinates\n       * @returns a string with the Vector2 coordinates\n       */\n      toString() {\n          return '{X: ' + this.x + ' Y:' + this.y + '}';\n      }\n      /**\n       * Gets class name\n       * @returns the string \"Vector2\"\n       */\n      getClassName() {\n          return 'Vector2';\n      }\n      /**\n       * Gets current vector hash code\n       * @returns the Vector2 hash code as a number\n       */\n      getHashCode() {\n          let hash = this.x || 0;\n          hash = (hash * 397) ^ (this.y || 0);\n          return hash;\n      }\n      // Operators\n      /**\n       * Sets the Vector2 coordinates in the given array or FloatArray from the given index.\n       * @param array - defines the source array\n       * @param index - defines the offset in source array\n       * @returns the current Vector2\n       */\n      toArray(array, index = 0) {\n          array[index] = this.x;\n          array[index + 1] = this.y;\n          return this;\n      }\n      /**\n       * Copy the current vector to an array\n       * @returns a new array with 2 elements: the Vector2 coordinates.\n       */\n      asArray() {\n          const result = new Array();\n          this.toArray(result, 0);\n          return result;\n      }\n      /**\n       * Sets the Vector2 coordinates with the given Vector2 coordinates\n       * @param source - defines the source Vector2\n       * @returns the current updated Vector2\n       */\n      copyFrom(source) {\n          this.x = source.x;\n          this.y = source.y;\n          return this;\n      }\n      /**\n       * Sets the Vector2 coordinates with the given floats\n       * @param x - defines the first coordinate\n       * @param y - defines the second coordinate\n       * @returns the current updated Vector2\n       */\n      copyFromFloats(x, y) {\n          this.x = x;\n          this.y = y;\n          return this;\n      }\n      /**\n       * Sets the Vector2 coordinates with the given floats\n       * @param x - defines the first coordinate\n       * @param y - defines the second coordinate\n       * @returns the current updated Vector2\n       */\n      set(x, y) {\n          return this.copyFromFloats(x, y);\n      }\n      /**\n       * Add another vector with the current one\n       * @param otherVector - defines the other vector\n       * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates\n       */\n      add(otherVector) {\n          return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n      }\n      /**\n       * Sets the \"result\" coordinates with the addition of the current Vector2 and the given one coordinates\n       * @param otherVector - defines the other vector\n       * @param result - defines the target vector\n       * @returns the unmodified current Vector2\n       */\n      addToRef(otherVector, result) {\n          result.x = this.x + otherVector.x;\n          result.y = this.y + otherVector.y;\n          return this;\n      }\n      /**\n       * Set the Vector2 coordinates by adding the given Vector2 coordinates\n       * @param otherVector - defines the other vector\n       * @returns the current updated Vector2\n       */\n      addInPlace(otherVector) {\n          this.x += otherVector.x;\n          this.y += otherVector.y;\n          return this;\n      }\n      /**\n       * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates\n       * @param otherVector - defines the other vector\n       * @returns a new Vector2\n       */\n      addVector3(otherVector) {\n          return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n      }\n      /**\n       * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2\n       * @param otherVector - defines the other vector\n       * @returns a new Vector2\n       */\n      subtract(otherVector) {\n          return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\n      }\n      /**\n       * Sets the \"result\" coordinates with the subtraction of the given one from the current Vector2 coordinates.\n       * @param otherVector - defines the other vector\n       * @param result - defines the target vector\n       * @returns the unmodified current Vector2\n       */\n      subtractToRef(otherVector, result) {\n          result.x = this.x - otherVector.x;\n          result.y = this.y - otherVector.y;\n          return this;\n      }\n      /**\n       * Sets the current Vector2 coordinates by subtracting from it the given one coordinates\n       * @param otherVector - defines the other vector\n       * @returns the current updated Vector2\n       */\n      subtractInPlace(otherVector) {\n          this.x -= otherVector.x;\n          this.y -= otherVector.y;\n          return this;\n      }\n      /**\n       * Multiplies in place the current Vector2 coordinates by the given ones\n       * @param otherVector - defines the other vector\n       * @returns the current updated Vector2\n       */\n      multiplyInPlace(otherVector) {\n          this.x *= otherVector.x;\n          this.y *= otherVector.y;\n          return this;\n      }\n      /**\n       * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates\n       * @param otherVector - defines the other vector\n       * @returns a new Vector2\n       */\n      multiply(otherVector) {\n          return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\n      }\n      /**\n       * Sets \"result\" coordinates with the multiplication of the current Vector2 and the given one coordinates\n       * @param otherVector - defines the other vector\n       * @param result - defines the target vector\n       * @returns the unmodified current Vector2\n       */\n      multiplyToRef(otherVector, result) {\n          result.x = this.x * otherVector.x;\n          result.y = this.y * otherVector.y;\n          return this;\n      }\n      /**\n       * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats\n       * @param x - defines the first coordinate\n       * @param y - defines the second coordinate\n       * @returns a new Vector2\n       */\n      multiplyByFloats(x, y) {\n          return new Vector2(this.x * x, this.y * y);\n      }\n      /**\n       * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates\n       * @param otherVector - defines the other vector\n       * @returns a new Vector2\n       */\n      divide(otherVector) {\n          return new Vector2(this.x / otherVector.x, this.y / otherVector.y);\n      }\n      /**\n       * Sets the \"result\" coordinates with the Vector2 divided by the given one coordinates\n       * @param otherVector - defines the other vector\n       * @param result - defines the target vector\n       * @returns the unmodified current Vector2\n       */\n      divideToRef(otherVector, result) {\n          result.x = this.x / otherVector.x;\n          result.y = this.y / otherVector.y;\n          return this;\n      }\n      /**\n       * Divides the current Vector2 coordinates by the given ones\n       * @param otherVector - defines the other vector\n       * @returns the current updated Vector2\n       */\n      divideInPlace(otherVector) {\n          return this.divideToRef(otherVector, this);\n      }\n      /**\n       * Gets a new Vector2 with current Vector2 negated coordinates\n       * @returns a new Vector2\n       */\n      negate() {\n          return new Vector2(-this.x, -this.y);\n      }\n      /**\n       * Multiply the Vector2 coordinates by scale\n       * @param scale - defines the scaling factor\n       * @returns the current updated Vector2\n       */\n      scaleInPlace(scale) {\n          this.x *= scale;\n          this.y *= scale;\n          return this;\n      }\n      /**\n       * Returns a new Vector2 scaled by \"scale\" from the current Vector2\n       * @param scale - defines the scaling factor\n       * @returns a new Vector2\n       */\n      scale(scale) {\n          const result = new Vector2(0, 0);\n          this.scaleToRef(scale, result);\n          return result;\n      }\n      /**\n       * Scale the current Vector2 values by a factor to a given Vector2\n       * @param scale - defines the scale factor\n       * @param result - defines the Vector2 object where to store the result\n       * @returns the unmodified current Vector2\n       */\n      scaleToRef(scale, result) {\n          result.x = this.x * scale;\n          result.y = this.y * scale;\n          return this;\n      }\n      /**\n       * Scale the current Vector2 values by a factor and add the result to a given Vector2\n       * @param scale - defines the scale factor\n       * @param result - defines the Vector2 object where to store the result\n       * @returns the unmodified current Vector2\n       */\n      scaleAndAddToRef(scale, result) {\n          result.x += this.x * scale;\n          result.y += this.y * scale;\n          return this;\n      }\n      /**\n       * Gets a boolean if two vectors are equals\n       * @param otherVector - defines the other vector\n       * @returns true if the given vector coordinates strictly equal the current Vector2 ones\n       */\n      equals(otherVector) {\n          return otherVector && this.x === otherVector.x && this.y === otherVector.y;\n      }\n      /**\n       * Gets a boolean if two vectors are equals (using an epsilon value)\n       * @param otherVector - defines the other vector\n       * @param epsilon - defines the minimal distance to consider equality\n       * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.\n       */\n      equalsWithEpsilon(otherVector, epsilon = types_1$5.Epsilon) {\n          return (otherVector &&\n              Scalar_1$3.Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) &&\n              Scalar_1$3.Scalar.WithinEpsilon(this.y, otherVector.y, epsilon));\n      }\n      /**\n       * Gets a new Vector2 from current Vector2 floored values\n       * @returns a new Vector2\n       */\n      floor() {\n          return new Vector2(Math.floor(this.x), Math.floor(this.y));\n      }\n      /**\n       * Gets a new Vector2 from current Vector2 floored values\n       * @returns a new Vector2\n       */\n      fract() {\n          return new Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\n      }\n      // Properties\n      /**\n       * Gets the length of the vector\n       * @returns the vector length (float)\n       */\n      length() {\n          return Math.sqrt(this.x * this.x + this.y * this.y);\n      }\n      /**\n       * Gets the vector squared length\n       * @returns the vector squared length (float)\n       */\n      lengthSquared() {\n          return this.x * this.x + this.y * this.y;\n      }\n      // Methods\n      /**\n       * Normalize the vector\n       * @returns the current updated Vector2\n       */\n      normalize() {\n          const len = this.length();\n          if (len === 0) {\n              return this;\n          }\n          const num = 1.0 / len;\n          this.x *= num;\n          this.y *= num;\n          return this;\n      }\n      /**\n       * Gets a new Vector2 copied from the Vector2\n       * @returns a new Vector2\n       */\n      clone() {\n          return new Vector2(this.x, this.y);\n      }\n  }\n  Vector2$1.Vector2 = Vector2;\n\n  Object.defineProperty(Arc2$1, \"__esModule\", { value: true });\n  Arc2$1.Arc2 = void 0;\n  const Angle_1 = Angle$1;\n  const Vector2_1$1 = Vector2$1;\n  const types_1$4 = types;\n  /**\n   * This represents an arc in a 2d space.\n   * @public\n   */\n  class Arc2 {\n      /**\n       * Creates an Arc object from the three given points : start, middle and end.\n       * @param startPoint - Defines the start point of the arc\n       * @param midPoint - Defines the midlle point of the arc\n       * @param endPoint - Defines the end point of the arc\n       */\n      constructor(\n      /** Defines the start point of the arc */\n      startPoint, \n      /** Defines the mid point of the arc */\n      midPoint, \n      /** Defines the end point of the arc */\n      endPoint) {\n          this.startPoint = startPoint;\n          this.midPoint = midPoint;\n          this.endPoint = endPoint;\n          const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n          const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\n          const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\n          const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) -\n              (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n          this.centerPoint = new Vector2_1$1.Vector2((startToMid * (midPoint.y - endPoint.y) -\n              midToEnd * (startPoint.y - midPoint.y)) /\n              det, ((startPoint.x - midPoint.x) * midToEnd -\n              (midPoint.x - endPoint.x) * startToMid) /\n              det);\n          this.radius = this.centerPoint.subtract(this.startPoint).length();\n          this.startAngle = Angle_1.Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n          const a1 = this.startAngle.degrees();\n          let a2 = Angle_1.Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n          let a3 = Angle_1.Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\n          // angles correction\n          if (a2 - a1 > +180.0) {\n              a2 -= 360.0;\n          }\n          if (a2 - a1 < -180.0) {\n              a2 += 360.0;\n          }\n          if (a3 - a2 > +180.0) {\n              a3 -= 360.0;\n          }\n          if (a3 - a2 < -180.0) {\n              a3 += 360.0;\n          }\n          this.orientation = a2 - a1 < 0 ? types_1$4.Orientation.CW : types_1$4.Orientation.CCW;\n          this.angle = Angle_1.Angle.FromDegrees(this.orientation === types_1$4.Orientation.CW ? a1 - a3 : a3 - a1);\n      }\n  }\n  Arc2$1.Arc2 = Arc2;\n\n  var Axis$1 = {};\n\n  Object.defineProperty(Axis$1, \"__esModule\", { value: true });\n  Axis$1.Axis = void 0;\n  const Vector3_1$3 = Vector3$1;\n  /**\n   * Defines the 3 main axes\n   * @public\n   */\n  class Axis {\n  }\n  Axis$1.Axis = Axis;\n  /** X axis */\n  Axis.X = new Vector3_1$3.Vector3(1.0, 0.0, 0.0);\n  /** Y axis */\n  Axis.Y = new Vector3_1$3.Vector3(0.0, 1.0, 0.0);\n  /** Z axis */\n  Axis.Z = new Vector3_1$3.Vector3(0.0, 0.0, 1.0);\n\n  var BezierCurve$1 = {};\n\n  Object.defineProperty(BezierCurve$1, \"__esModule\", { value: true });\n  BezierCurve$1.BezierCurve = void 0;\n  /**\n   * Class used to represent a Bezier curve\n   * @public\n   */\n  class BezierCurve {\n      /**\n       * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\n       * @param t - defines the time\n       * @param x1 - defines the left coordinate on X axis\n       * @param y1 - defines the left coordinate on Y axis\n       * @param x2 - defines the right coordinate on X axis\n       * @param y2 - defines the right coordinate on Y axis\n       * @returns the interpolated value\n       */\n      static Interpolate(t, x1, y1, x2, y2) {\n          // Extract X (which is equal to time here)\n          const f0 = 1 - 3 * x2 + 3 * x1;\n          const f1 = 3 * x2 - 6 * x1;\n          const f2 = 3 * x1;\n          let refinedT = t;\n          for (let i = 0; i < 5; i++) {\n              const refinedT2 = refinedT * refinedT;\n              const refinedT3 = refinedT2 * refinedT;\n              const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n              const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n              refinedT -= (x - t) * slope;\n              refinedT = Math.min(1, Math.max(0, refinedT));\n          }\n          // Resolve cubic bezier for the given x\n          return (3 * Math.pow(1 - refinedT, 2) * refinedT * y1 +\n              3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 +\n              Math.pow(refinedT, 3));\n      }\n  }\n  BezierCurve$1.BezierCurve = BezierCurve;\n\n  var Color3$1 = {};\n\n  var Color4$1 = {};\n\n  Object.defineProperty(Color4$1, \"__esModule\", { value: true });\n  Color4$1.Color4 = void 0;\n  const Scalar_1$2 = Scalar$1;\n  const types_1$3 = types;\n  /**\n   * Class used to hold a RBGA color\n   * @public\n   */\n  class Color4 {\n      /**\n       * Creates a new Color4 object from red, green, blue values, all between 0 and 1\n       * @param r - defines the red component (between 0 and 1, default is 0)\n       * @param g - defines the green component (between 0 and 1, default is 0)\n       * @param b - defines the blue component (between 0 and 1, default is 0)\n       * @param a - defines the alpha component (between 0 and 1, default is 1)\n       */\n      constructor(\n      /**\n       * Defines the red component (between 0 and 1, default is 0)\n       */\n      r = 0, \n      /**\n       * Defines the green component (between 0 and 1, default is 0)\n       */\n      g = 0, \n      /**\n       * Defines the blue component (between 0 and 1, default is 0)\n       */\n      b = 0, \n      /**\n       * Defines the alpha component (between 0 and 1, default is 1)\n       */\n      a = 1) {\n          this.r = r;\n          this.g = g;\n          this.b = b;\n          this.a = a;\n      }\n      // Statics\n      /**\n       * Creates a new Color4 from the string containing valid hexadecimal values\n       * @param hex - defines a string containing valid hexadecimal values\n       * @returns a new Color4 object\n       */\n      static FromHexString(hex) {\n          if (hex.substring(0, 1) !== '#' || hex.length !== 9) {\n              return new Color4(0.0, 0.0, 0.0, 0.0);\n          }\n          const r = parseInt(hex.substring(1, 3), 16);\n          const g = parseInt(hex.substring(3, 5), 16);\n          const b = parseInt(hex.substring(5, 7), 16);\n          const a = parseInt(hex.substring(7, 9), 16);\n          return Color4.FromInts(r, g, b, a);\n      }\n      /**\n       * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n       * @param left - defines the start value\n       * @param right - defines the end value\n       * @param amount - defines the gradient factor\n       * @returns a new Color4 object\n       */\n      static Lerp(left, right, amount) {\n          const result = new Color4(0.0, 0.0, 0.0, 0.0);\n          Color4.LerpToRef(left, right, amount, result);\n          return result;\n      }\n      /**\n       * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n       * @param left - defines the start value\n       * @param right - defines the end value\n       * @param amount - defines the gradient factor\n       * @param result - defines the Color4 object where to store data\n       */\n      static LerpToRef(left, right, amount, result) {\n          result.r = left.r + (right.r - left.r) * amount;\n          result.g = left.g + (right.g - left.g) * amount;\n          result.b = left.b + (right.b - left.b) * amount;\n          result.a = left.a + (right.a - left.a) * amount;\n      }\n      /**\n       * Returns a Color4 value containing a red color\n       * @returns a new Color3 object\n       */\n      static Red() {\n          return new Color4(1.0, 0, 0, 1.0);\n      }\n      /**\n       * Returns a Color4 value containing a green color\n       * @returns a new Color4 object\n       */\n      static Green() {\n          return new Color4(0, 1.0, 0, 1.0);\n      }\n      /**\n       * Returns a Color4 value containing a blue color\n       * @returns a new Color4 object\n       */\n      static Blue() {\n          return new Color4(0, 0, 1.0, 1.0);\n      }\n      /**\n       * Returns a Color4 value containing a black color\n       * @returns a new Color4 object\n       */\n      static Black() {\n          return new Color4(0, 0, 0, 1);\n      }\n      /**\n       * Returns a Color4 value containing a white color\n       * @returns a new Color4 object\n       */\n      static White() {\n          return new Color4(1, 1, 1, 1);\n      }\n      /**\n       * Returns a Color4 value containing a purple color\n       * @returns a new Color4 object\n       */\n      static Purple() {\n          return new Color4(0.5, 0, 0.5, 1);\n      }\n      /**\n       * Returns a Color4 value containing a magenta color\n       * @returns a new Color4 object\n       */\n      static Magenta() {\n          return new Color4(1, 0, 1, 1);\n      }\n      /**\n       * Returns a Color4 value containing a yellow color\n       * @returns a new Color4 object\n       */\n      static Yellow() {\n          return new Color4(1, 1, 0, 1);\n      }\n      /**\n       * Returns a Color4 value containing a gray color\n       * @returns a new Color4 object\n       */\n      static Gray() {\n          return new Color4(0.5, 0.5, 0.5, 1.0);\n      }\n      /**\n       * Returns a Color4 value containing a teal color\n       * @returns a new Color4 object\n       */\n      static Teal() {\n          return new Color4(0, 1.0, 1.0, 1.0);\n      }\n      /**\n       * Returns a Color4 value containing a transparent color\n       * @returns a new Color4 object\n       */\n      static Clear() {\n          return new Color4(0, 0, 0, 0);\n      }\n      /**\n       * Creates a new Color4 from a Color3 and an alpha value\n       * @param color3 - defines the source Color3 to read from\n       * @param alpha - defines the alpha component (1.0 by default)\n       * @returns a new Color4 object\n       */\n      static FromColor3(color3, alpha = 1.0) {\n          return new Color4(color3.r, color3.g, color3.b, alpha);\n      }\n      /**\n       * Creates a new Color4 from the starting index element of the given array\n       * @param array - defines the source array to read from\n       * @param offset - defines the offset in the source array\n       * @returns a new Color4 object\n       */\n      static FromArray(array, offset = 0) {\n          return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n      }\n      /**\n       * Creates a new Color3 from integer values (less than 256)\n       * @param r - defines the red component to read from (value between 0 and 255)\n       * @param g - defines the green component to read from (value between 0 and 255)\n       * @param b - defines the blue component to read from (value between 0 and 255)\n       * @param a - defines the alpha component to read from (value between 0 and 255)\n       * @returns a new Color3 object\n       */\n      static FromInts(r, g, b, a) {\n          return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n      }\n      /**\n       * Check the content of a given array and convert it to an array containing RGBA data\n       * If the original array was already containing count * 4 values then it is returned directly\n       * @param colors - defines the array to check\n       * @param count - defines the number of RGBA data to expect\n       * @returns an array containing count * 4 values (RGBA)\n       */\n      static CheckColors4(colors, count) {\n          // Check if color3 was used\n          if (colors.length === count * 3) {\n              const colors4 = [];\n              for (let index = 0; index < colors.length; index += 3) {\n                  const newIndex = (index / 3) * 4;\n                  colors4[newIndex] = colors[index];\n                  colors4[newIndex + 1] = colors[index + 1];\n                  colors4[newIndex + 2] = colors[index + 2];\n                  colors4[newIndex + 3] = 1.0;\n              }\n              return colors4;\n          }\n          return colors;\n      }\n      // Operators\n      /**\n       * Adds in place the given Color4 values to the current Color4 object\n       * @param right - defines the second operand\n       * @returns the current updated Color4 object\n       */\n      addInPlace(right) {\n          this.r += right.r;\n          this.g += right.g;\n          this.b += right.b;\n          this.a += right.a;\n          return this;\n      }\n      /**\n       * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\n       * @returns the new array\n       */\n      asArray() {\n          const result = new Array();\n          this.toArray(result, 0);\n          return result;\n      }\n      /**\n       * Stores from the starting index in the given array the Color4 successive values\n       * @param array - defines the array where to store the r,g,b components\n       * @param index - defines an optional index in the target array to define where to start storing values\n       * @returns the current Color4 object\n       */\n      toArray(array, index = 0) {\n          array[index] = this.r;\n          array[index + 1] = this.g;\n          array[index + 2] = this.b;\n          array[index + 3] = this.a;\n          return this;\n      }\n      /**\n       * Creates a new Color4 set with the added values of the current Color4 and of the given one\n       * @param right - defines the second operand\n       * @returns a new Color4 object\n       */\n      add(right) {\n          return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n      }\n      /**\n       * Creates a new Color4 set with the subtracted values of the given one from the current Color4\n       * @param right - defines the second operand\n       * @returns a new Color4 object\n       */\n      subtract(right) {\n          return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n      }\n      /**\n       * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\n       * @param right - defines the second operand\n       * @param result - defines the Color4 object where to store the result\n       * @returns the current Color4 object\n       */\n      subtractToRef(right, result) {\n          result.r = this.r - right.r;\n          result.g = this.g - right.g;\n          result.b = this.b - right.b;\n          result.a = this.a - right.a;\n          return this;\n      }\n      /**\n       * Creates a new Color4 with the current Color4 values multiplied by scale\n       * @param scale - defines the scaling factor to apply\n       * @returns a new Color4 object\n       */\n      scale(scale) {\n          return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n      }\n      /**\n       * Multiplies the current Color4 values by scale and stores the result in \"result\"\n       * @param scale - defines the scaling factor to apply\n       * @param result - defines the Color4 object where to store the result\n       * @returns the current unmodified Color4\n       */\n      scaleToRef(scale, result) {\n          result.r = this.r * scale;\n          result.g = this.g * scale;\n          result.b = this.b * scale;\n          result.a = this.a * scale;\n          return this;\n      }\n      /**\n       * Scale the current Color4 values by a factor and add the result to a given Color4\n       * @param scale - defines the scale factor\n       * @param result - defines the Color4 object where to store the result\n       * @returns the unmodified current Color4\n       */\n      scaleAndAddToRef(scale, result) {\n          result.r += this.r * scale;\n          result.g += this.g * scale;\n          result.b += this.b * scale;\n          result.a += this.a * scale;\n          return this;\n      }\n      /**\n       * Clamps the rgb values by the min and max values and stores the result into \"result\"\n       * @param min - defines minimum clamping value (default is 0)\n       * @param max - defines maximum clamping value (default is 1)\n       * @param result - defines color to store the result into.\n       * @returns the cuurent Color4\n       */\n      clampToRef(min = 0, max = 1, result) {\n          result.r = Scalar_1$2.Scalar.Clamp(this.r, min, max);\n          result.g = Scalar_1$2.Scalar.Clamp(this.g, min, max);\n          result.b = Scalar_1$2.Scalar.Clamp(this.b, min, max);\n          result.a = Scalar_1$2.Scalar.Clamp(this.a, min, max);\n          return this;\n      }\n      /**\n       * Multipy an Color4 value by another and return a new Color4 object\n       * @param color - defines the Color4 value to multiply by\n       * @returns a new Color4 object\n       */\n      multiply(color) {\n          return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n      }\n      /**\n       * Multipy a Color4 value by another and push the result in a reference value\n       * @param color - defines the Color4 value to multiply by\n       * @param result - defines the Color4 to fill the result in\n       * @returns the result Color4\n       */\n      multiplyToRef(color, result) {\n          result.r = this.r * color.r;\n          result.g = this.g * color.g;\n          result.b = this.b * color.b;\n          result.a = this.a * color.a;\n          return result;\n      }\n      /**\n       * Creates a string with the Color4 current values\n       * @returns the string representation of the Color4 object\n       */\n      toString() {\n          return ('{R: ' + this.r + ' G:' + this.g + ' B:' + this.b + ' A:' + this.a + '}');\n      }\n      /**\n       * Returns the string \"Color4\"\n       * @returns \"Color4\"\n       */\n      getClassName() {\n          return 'Color4';\n      }\n      /**\n       * Compute the Color4 hash code\n       * @returns an unique number that can be used to hash Color4 objects\n       */\n      getHashCode() {\n          let hash = this.r || 0;\n          hash = (hash * 397) ^ (this.g || 0);\n          hash = (hash * 397) ^ (this.b || 0);\n          hash = (hash * 397) ^ (this.a || 0);\n          return hash;\n      }\n      /**\n       * Creates a new Color4 copied from the current one\n       * @returns a new Color4 object\n       */\n      clone() {\n          return new Color4(this.r, this.g, this.b, this.a);\n      }\n      /**\n       * Copies the given Color4 values into the current one\n       * @param source - defines the source Color4 object\n       * @returns the current updated Color4 object\n       */\n      copyFrom(source) {\n          this.r = source.r;\n          this.g = source.g;\n          this.b = source.b;\n          this.a = source.a;\n          return this;\n      }\n      /**\n       * Copies the given float values into the current one\n       * @param r - defines the red component to read from\n       * @param g - defines the green component to read from\n       * @param b - defines the blue component to read from\n       * @param a - defines the alpha component to read from\n       * @returns the current updated Color4 object\n       */\n      copyFromFloats(r, g, b, a) {\n          this.r = r;\n          this.g = g;\n          this.b = b;\n          this.a = a;\n          return this;\n      }\n      /**\n       * Copies the given float values into the current one\n       * @param r - defines the red component to read from\n       * @param g - defines the green component to read from\n       * @param b - defines the blue component to read from\n       * @param a - defines the alpha component to read from\n       * @returns the current updated Color4 object\n       */\n      set(r, g, b, a) {\n          return this.copyFromFloats(r, g, b, a);\n      }\n      /**\n       * Compute the Color4 hexadecimal code as a string\n       * @returns a string containing the hexadecimal representation of the Color4 object\n       */\n      toHexString() {\n          const intR = (this.r * 255) | 0;\n          const intG = (this.g * 255) | 0;\n          const intB = (this.b * 255) | 0;\n          const intA = (this.a * 255) | 0;\n          return ('#' +\n              Scalar_1$2.Scalar.ToHex(intR) +\n              Scalar_1$2.Scalar.ToHex(intG) +\n              Scalar_1$2.Scalar.ToHex(intB) +\n              Scalar_1$2.Scalar.ToHex(intA));\n      }\n      /**\n       * Computes a new Color4 converted from the current one to linear space\n       * @returns a new Color4 object\n       */\n      toLinearSpace() {\n          const convertedColor = new Color4();\n          this.toLinearSpaceToRef(convertedColor);\n          return convertedColor;\n      }\n      /**\n       * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\n       * @param convertedColor - defines the Color4 object where to store the linear space version\n       * @returns the unmodified Color4\n       */\n      toLinearSpaceToRef(convertedColor) {\n          convertedColor.r = Math.pow(this.r, types_1$3.ToLinearSpace);\n          convertedColor.g = Math.pow(this.g, types_1$3.ToLinearSpace);\n          convertedColor.b = Math.pow(this.b, types_1$3.ToLinearSpace);\n          convertedColor.a = this.a;\n          return this;\n      }\n      /**\n       * Computes a new Color4 converted from the current one to gamma space\n       * @returns a new Color4 object\n       */\n      toGammaSpace() {\n          const convertedColor = new Color4();\n          this.toGammaSpaceToRef(convertedColor);\n          return convertedColor;\n      }\n      /**\n       * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\n       * @param convertedColor - defines the Color4 object where to store the gamma space version\n       * @returns the unmodified Color4\n       */\n      toGammaSpaceToRef(convertedColor) {\n          convertedColor.r = Math.pow(this.r, types_1$3.ToGammaSpace);\n          convertedColor.g = Math.pow(this.g, types_1$3.ToGammaSpace);\n          convertedColor.b = Math.pow(this.b, types_1$3.ToGammaSpace);\n          convertedColor.a = this.a;\n          return this;\n      }\n  }\n  Color4$1.Color4 = Color4;\n\n  Object.defineProperty(Color3$1, \"__esModule\", { value: true });\n  Color3$1.Color3 = void 0;\n  const types_1$2 = types;\n  const Color4_1 = Color4$1;\n  const Scalar_1$1 = Scalar$1;\n  /**\n   * Class used to hold a RBG color\n   * @public\n   */\n  class Color3 {\n      /**\n       * Creates a new Color3 object from red, green, blue values, all between 0 and 1\n       * @param r - defines the red component (between 0 and 1, default is 0)\n       * @param g - defines the green component (between 0 and 1, default is 0)\n       * @param b - defines the blue component (between 0 and 1, default is 0)\n       */\n      constructor(\n      /**\n       * Defines the red component (between 0 and 1, default is 0)\n       */\n      r = 0, \n      /**\n       * Defines the green component (between 0 and 1, default is 0)\n       */\n      g = 0, \n      /**\n       * Defines the blue component (between 0 and 1, default is 0)\n       */\n      b = 0) {\n          this.r = r;\n          this.g = g;\n          this.b = b;\n      }\n      // Statics\n      /**\n       * Creates a new Color3 from the string containing valid hexadecimal values\n       * @param hex - defines a string containing valid hexadecimal values\n       * @returns a new Color3 object\n       */\n      static FromHexString(hex) {\n          if (hex.substring(0, 1) !== '#' || hex.length !== 7) {\n              return new Color3(0, 0, 0);\n          }\n          const r = parseInt(hex.substring(1, 3), 16);\n          const g = parseInt(hex.substring(3, 5), 16);\n          const b = parseInt(hex.substring(5, 7), 16);\n          return Color3.FromInts(r, g, b);\n      }\n      /**\n       * Creates a new Vector3 from the starting index of the given array\n       * @param array - defines the source array\n       * @param offset - defines an offset in the source array\n       * @returns a new Color3 object\n       */\n      static FromArray(array, offset = 0) {\n          return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n      }\n      /**\n       * Creates a new Color3 from integer values (less than 256)\n       * @param r - defines the red component to read from (value between 0 and 255)\n       * @param g - defines the green component to read from (value between 0 and 255)\n       * @param b - defines the blue component to read from (value between 0 and 255)\n       * @returns a new Color3 object\n       */\n      static FromInts(r, g, b) {\n          return new Color3(r / 255.0, g / 255.0, b / 255.0);\n      }\n      /**\n       * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n       * @param start - defines the start Color3 value\n       * @param end - defines the end Color3 value\n       * @param amount - defines the gradient value between start and end\n       * @returns a new Color3 object\n       */\n      static Lerp(start, end, amount) {\n          const result = new Color3(0.0, 0.0, 0.0);\n          Color3.LerpToRef(start, end, amount, result);\n          return result;\n      }\n      /**\n       * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n       * @param left - defines the start value\n       * @param right - defines the end value\n       * @param amount - defines the gradient factor\n       * @param result - defines the Color3 object where to store the result\n       */\n      static LerpToRef(left, right, amount, result) {\n          result.r = left.r + (right.r - left.r) * amount;\n          result.g = left.g + (right.g - left.g) * amount;\n          result.b = left.b + (right.b - left.b) * amount;\n      }\n      /**\n       * Returns a Color3 value containing a red color\n       * @returns a new Color3 object\n       */\n      static Red() {\n          return new Color3(1, 0, 0);\n      }\n      /**\n       * Returns a Color3 value containing a green color\n       * @returns a new Color3 object\n       */\n      static Green() {\n          return new Color3(0, 1, 0);\n      }\n      /**\n       * Returns a Color3 value containing a blue color\n       * @returns a new Color3 object\n       */\n      static Blue() {\n          return new Color3(0, 0, 1);\n      }\n      /**\n       * Returns a Color3 value containing a black color\n       * @returns a new Color3 object\n       */\n      static Black() {\n          return new Color3(0, 0, 0);\n      }\n      /**\n       * Returns a Color3 value containing a white color\n       * @returns a new Color3 object\n       */\n      static White() {\n          return new Color3(1, 1, 1);\n      }\n      /**\n       * Returns a Color3 value containing a purple color\n       * @returns a new Color3 object\n       */\n      static Purple() {\n          return new Color3(0.5, 0, 0.5);\n      }\n      /**\n       * Returns a Color3 value containing a magenta color\n       * @returns a new Color3 object\n       */\n      static Magenta() {\n          return new Color3(1, 0, 1);\n      }\n      /**\n       * Returns a Color3 value containing a yellow color\n       * @returns a new Color3 object\n       */\n      static Yellow() {\n          return new Color3(1, 1, 0);\n      }\n      /**\n       * Returns a Color3 value containing a gray color\n       * @returns a new Color3 object\n       */\n      static Gray() {\n          return new Color3(0.5, 0.5, 0.5);\n      }\n      /**\n       * Returns a Color3 value containing a teal color\n       * @returns a new Color3 object\n       */\n      static Teal() {\n          return new Color3(0, 1.0, 1.0);\n      }\n      /**\n       * Returns a Color3 value containing a random color\n       * @returns a new Color3 object\n       */\n      static Random() {\n          return new Color3(Math.random(), Math.random(), Math.random());\n      }\n      /**\n       * Creates a string with the Color3 current values\n       * @returns the string representation of the Color3 object\n       */\n      toString() {\n          return '{R: ' + this.r + ' G:' + this.g + ' B:' + this.b + '}';\n      }\n      /**\n       * Returns the string \"Color3\"\n       * @returns \"Color3\"\n       */\n      getClassName() {\n          return 'Color3';\n      }\n      /**\n       * Compute the Color3 hash code\n       * @returns an unique number that can be used to hash Color3 objects\n       */\n      getHashCode() {\n          let hash = this.r || 0;\n          hash = (hash * 397) ^ (this.g || 0);\n          hash = (hash * 397) ^ (this.b || 0);\n          return hash;\n      }\n      // Operators\n      /**\n       * Stores in the given array from the given starting index the red, green, blue values as successive elements\n       * @param array - defines the array where to store the r,g,b components\n       * @param index - defines an optional index in the target array to define where to start storing values\n       * @returns the current Color3 object\n       */\n      toArray(array, index = 0) {\n          array[index] = this.r;\n          array[index + 1] = this.g;\n          array[index + 2] = this.b;\n          return this;\n      }\n      /**\n       * Returns a new Color4 object from the current Color3 and the given alpha\n       * @param alpha - defines the alpha component on the new Color4 object (default is 1)\n       * @returns a new Color4 object\n       */\n      toColor4(alpha = 1) {\n          return new Color4_1.Color4(this.r, this.g, this.b, alpha);\n      }\n      /**\n       * Returns a new array populated with 3 numeric elements : red, green and blue values\n       * @returns the new array\n       */\n      asArray() {\n          const result = new Array();\n          this.toArray(result, 0);\n          return result;\n      }\n      /**\n       * Returns the luminance value\n       * @returns a float value\n       */\n      toLuminance() {\n          return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n      }\n      /**\n       * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\n       * @param otherColor - defines the second operand\n       * @returns the new Color3 object\n       */\n      multiply(otherColor) {\n          return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n      }\n      /**\n       * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\n       * @param otherColor - defines the second operand\n       * @param result - defines the Color3 object where to store the result\n       * @returns the current Color3\n       */\n      multiplyToRef(otherColor, result) {\n          result.r = this.r * otherColor.r;\n          result.g = this.g * otherColor.g;\n          result.b = this.b * otherColor.b;\n          return this;\n      }\n      /**\n       * Determines equality between Color3 objects\n       * @param otherColor - defines the second operand\n       * @returns true if the rgb values are equal to the given ones\n       */\n      equals(otherColor) {\n          return (otherColor &&\n              this.r === otherColor.r &&\n              this.g === otherColor.g &&\n              this.b === otherColor.b);\n      }\n      /**\n       * Determines equality between the current Color3 object and a set of r,b,g values\n       * @param r - defines the red component to check\n       * @param g - defines the green component to check\n       * @param b - defines the blue component to check\n       * @returns true if the rgb values are equal to the given ones\n       */\n      equalsFloats(r, g, b) {\n          return this.r === r && this.g === g && this.b === b;\n      }\n      /**\n       * Multiplies in place each rgb value by scale\n       * @param scale - defines the scaling factor\n       * @returns the updated Color3\n       */\n      scale(scale) {\n          return new Color3(this.r * scale, this.g * scale, this.b * scale);\n      }\n      /**\n       * Multiplies the rgb values by scale and stores the result into \"result\"\n       * @param scale - defines the scaling factor\n       * @param result - defines the Color3 object where to store the result\n       * @returns the unmodified current Color3\n       */\n      scaleToRef(scale, result) {\n          result.r = this.r * scale;\n          result.g = this.g * scale;\n          result.b = this.b * scale;\n          return this;\n      }\n      /**\n       * Scale the current Color3 values by a factor and add the result to a given Color3\n       * @param scale - defines the scale factor\n       * @param result - defines color to store the result into\n       * @returns the unmodified current Color3\n       */\n      scaleAndAddToRef(scale, result) {\n          result.r += this.r * scale;\n          result.g += this.g * scale;\n          result.b += this.b * scale;\n          return this;\n      }\n      /**\n       * Clamps the rgb values by the min and max values and stores the result into \"result\"\n       * @param min - defines minimum clamping value (default is 0)\n       * @param max - defines maximum clamping value (default is 1)\n       * @param result - defines color to store the result into\n       * @returns the original Color3\n       */\n      clampToRef(min = 0, max = 1, result) {\n          result.r = Scalar_1$1.Scalar.Clamp(this.r, min, max);\n          result.g = Scalar_1$1.Scalar.Clamp(this.g, min, max);\n          result.b = Scalar_1$1.Scalar.Clamp(this.b, min, max);\n          return this;\n      }\n      /**\n       * Creates a new Color3 set with the added values of the current Color3 and of the given one\n       * @param otherColor - defines the second operand\n       * @returns the new Color3\n       */\n      add(otherColor) {\n          return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n      }\n      /**\n       * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\n       * @param otherColor - defines the second operand\n       * @param result - defines Color3 object to store the result into\n       * @returns the unmodified current Color3\n       */\n      addToRef(otherColor, result) {\n          result.r = this.r + otherColor.r;\n          result.g = this.g + otherColor.g;\n          result.b = this.b + otherColor.b;\n          return this;\n      }\n      /**\n       * Returns a new Color3 set with the subtracted values of the given one from the current Color3\n       * @param otherColor - defines the second operand\n       * @returns the new Color3\n       */\n      subtract(otherColor) {\n          return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n      }\n      /**\n       * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\n       * @param otherColor - defines the second operand\n       * @param result - defines Color3 object to store the result into\n       * @returns the unmodified current Color3\n       */\n      subtractToRef(otherColor, result) {\n          result.r = this.r - otherColor.r;\n          result.g = this.g - otherColor.g;\n          result.b = this.b - otherColor.b;\n          return this;\n      }\n      /**\n       * Copy the current object\n       * @returns a new Color3 copied the current one\n       */\n      clone() {\n          return new Color3(this.r, this.g, this.b);\n      }\n      /**\n       * Copies the rgb values from the source in the current Color3\n       * @param source - defines the source Color3 object\n       * @returns the updated Color3 object\n       */\n      copyFrom(source) {\n          this.r = source.r;\n          this.g = source.g;\n          this.b = source.b;\n          return this;\n      }\n      /**\n       * Updates the Color3 rgb values from the given floats\n       * @param r - defines the red component to read from\n       * @param g - defines the green component to read from\n       * @param b - defines the blue component to read from\n       * @returns the current Color3 object\n       */\n      copyFromFloats(r, g, b) {\n          this.r = r;\n          this.g = g;\n          this.b = b;\n          return this;\n      }\n      /**\n       * Updates the Color3 rgb values from the given floats\n       * @param r - defines the red component to read from\n       * @param g - defines the green component to read from\n       * @param b - defines the blue component to read from\n       * @returns the current Color3 object\n       */\n      set(r, g, b) {\n          return this.copyFromFloats(r, g, b);\n      }\n      /**\n       * Compute the Color3 hexadecimal code as a string\n       * @returns a string containing the hexadecimal representation of the Color3 object\n       */\n      toHexString() {\n          const intR = (this.r * 255) | 0;\n          const intG = (this.g * 255) | 0;\n          const intB = (this.b * 255) | 0;\n          return '#' + Scalar_1$1.Scalar.ToHex(intR) + Scalar_1$1.Scalar.ToHex(intG) + Scalar_1$1.Scalar.ToHex(intB);\n      }\n      /**\n       * Computes a new Color3 converted from the current one to linear space\n       * @returns a new Color3 object\n       */\n      toLinearSpace() {\n          const convertedColor = new Color3();\n          this.toLinearSpaceToRef(convertedColor);\n          return convertedColor;\n      }\n      /**\n       * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\n       * @param convertedColor - defines the Color3 object where to store the linear space version\n       * @returns the unmodified Color3\n       */\n      toLinearSpaceToRef(convertedColor) {\n          convertedColor.r = Math.pow(this.r, types_1$2.ToLinearSpace);\n          convertedColor.g = Math.pow(this.g, types_1$2.ToLinearSpace);\n          convertedColor.b = Math.pow(this.b, types_1$2.ToLinearSpace);\n          return this;\n      }\n      /**\n       * Computes a new Color3 converted from the current one to gamma space\n       * @returns a new Color3 object\n       */\n      toGammaSpace() {\n          const convertedColor = new Color3();\n          this.toGammaSpaceToRef(convertedColor);\n          return convertedColor;\n      }\n      /**\n       * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\n       * @param convertedColor - defines the Color3 object where to store the gamma space version\n       * @returns the unmodified Color3\n       */\n      toGammaSpaceToRef(convertedColor) {\n          convertedColor.r = Math.pow(this.r, types_1$2.ToGammaSpace);\n          convertedColor.g = Math.pow(this.g, types_1$2.ToGammaSpace);\n          convertedColor.b = Math.pow(this.b, types_1$2.ToGammaSpace);\n          return this;\n      }\n      /**\n       * Serializes Color3\n       */\n      toJSON() {\n          return {\n              r: this.r,\n              g: this.g,\n              b: this.b\n          };\n      }\n  }\n  Color3$1.Color3 = Color3;\n\n  var Curve3d = {};\n\n  Object.defineProperty(Curve3d, \"__esModule\", { value: true });\n  Curve3d.Curve3 = void 0;\n  const Vector3_1$2 = Vector3$1;\n  /**\n   * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n   * A Curve3 is designed from a series of successive Vector3.\n   * {@link https://doc.babylonjs.com/how_to/how_to_use_curve3 }\n   * @public\n   */\n  class Curve3 {\n      /**\n       * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n       * A Curve3 is designed from a series of successive Vector3.\n       * {@link http://doc.babylonjs.com/tutorials/How_to_use_Curve3#curve3-object | Tutorial }\n       * @param points - points which make up the curve\n       */\n      constructor(points) {\n          this._length = 0.0;\n          this._points = points;\n          this._length = this._computeLength(points);\n      }\n      /**\n       * Returns a Curve3 object along a Quadratic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#quadratic-bezier-curve\n       * @param v0 - (Vector3) the origin point of the Quadratic Bezier\n       * @param v1 - (Vector3) the control point\n       * @param v2 - (Vector3) the end point of the Quadratic Bezier\n       * @param nbPoints - (integer) the wanted number of points in the curve\n       * @returns the created Curve3\n       */\n      static CreateQuadraticBezier(v0, v1, v2, nbPoints) {\n          // tslint:disable-next-line:no-parameter-reassignment\n          nbPoints = nbPoints > 2 ? nbPoints : 3;\n          const bez = new Array();\n          const equation = (t, val0, val1, val2) => {\n              const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n              return res;\n          };\n          for (let i = 0; i <= nbPoints; i++) {\n              bez.push(new Vector3_1$2.Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\n          }\n          return new Curve3(bez);\n      }\n      /**\n       * Returns a Curve3 object along a Cubic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#cubic-bezier-curve\n       * @param v0 - (Vector3) the origin point of the Cubic Bezier\n       * @param v1 - (Vector3) the first control point\n       * @param v2 - (Vector3) the second control point\n       * @param v3 - (Vector3) the end point of the Cubic Bezier\n       * @param nbPoints - (integer) the wanted number of points in the curve\n       * @returns the created Curve3\n       */\n      static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {\n          // tslint:disable-next-line:no-parameter-reassignment\n          nbPoints = nbPoints > 3 ? nbPoints : 4;\n          const bez = new Array();\n          const equation = (t, val0, val1, val2, val3) => {\n              const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 +\n                  3.0 * t * (1.0 - t) * (1.0 - t) * val1 +\n                  3.0 * t * t * (1.0 - t) * val2 +\n                  t * t * t * val3;\n              return res;\n          };\n          for (let i = 0; i <= nbPoints; i++) {\n              bez.push(new Vector3_1$2.Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\n          }\n          return new Curve3(bez);\n      }\n      /**\n       * Returns a Curve3 object along a Hermite Spline curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#hermite-spline\n       * @param p1 - (Vector3) the origin point of the Hermite Spline\n       * @param t1 - (Vector3) the tangent vector at the origin point\n       * @param p2 - (Vector3) the end point of the Hermite Spline\n       * @param t2 - (Vector3) the tangent vector at the end point\n       * @param nbPoints - (integer) the wanted number of points in the curve\n       * @returns the created Curve3\n       */\n      static CreateHermiteSpline(p1, t1, p2, t2, nbPoints) {\n          const hermite = new Array();\n          const step = 1.0 / nbPoints;\n          for (let i = 0; i <= nbPoints; i++) {\n              hermite.push(Vector3_1$2.Vector3.Hermite(p1, t1, p2, t2, i * step));\n          }\n          return new Curve3(hermite);\n      }\n      /**\n       * Returns a Curve3 object along a CatmullRom Spline curve :\n       * @param points - (array of Vector3) the points the spline must pass through. At least, four points required\n       * @param nbPoints - (integer) the wanted number of points between each curve control points\n       * @param closed - (boolean) optional with default false, when true forms a closed loop from the points\n       * @returns the created Curve3\n       */\n      static CreateCatmullRomSpline(points, nbPoints, closed) {\n          const catmullRom = new Array();\n          const step = 1.0 / nbPoints;\n          let amount = 0.0;\n          if (closed) {\n              const pointsCount = points.length;\n              for (let i = 0; i < pointsCount; i++) {\n                  amount = 0;\n                  for (let c = 0; c < nbPoints; c++) {\n                      catmullRom.push(Vector3_1$2.Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\n                      amount += step;\n                  }\n              }\n              catmullRom.push(catmullRom[0]);\n          }\n          else {\n              const totalPoints = new Array();\n              totalPoints.push(points[0].clone());\n              Array.prototype.push.apply(totalPoints, points);\n              totalPoints.push(points[points.length - 1].clone());\n              let i = 0;\n              for (i = 0; i < totalPoints.length - 3; i++) {\n                  amount = 0;\n                  for (let c = 0; c < nbPoints; c++) {\n                      catmullRom.push(Vector3_1$2.Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n                      amount += step;\n                  }\n              }\n              i--;\n              catmullRom.push(Vector3_1$2.Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n          }\n          return new Curve3(catmullRom);\n      }\n      /**\n       * @returns the Curve3 stored array of successive Vector3\n       */\n      getPoints() {\n          return this._points;\n      }\n      /**\n       * @returns the computed length (float) of the curve.\n       */\n      length() {\n          return this._length;\n      }\n      /**\n       * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\n       * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\n       * curveA and curveB keep unchanged.\n       * @param curve - the curve to continue from this curve\n       * @returns the newly constructed curve\n       */\n      continue(curve) {\n          const lastPoint = this._points[this._points.length - 1];\n          const continuedPoints = this._points.slice();\n          const curvePoints = curve.getPoints();\n          for (let i = 1; i < curvePoints.length; i++) {\n              continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n          }\n          const continuedCurve = new Curve3(continuedPoints);\n          return continuedCurve;\n      }\n      _computeLength(path) {\n          let l = 0;\n          for (let i = 1; i < path.length; i++) {\n              l += path[i].subtract(path[i - 1]).length();\n          }\n          return l;\n      }\n  }\n  Curve3d.Curve3 = Curve3;\n\n  var Furstum = {};\n\n  var Plane$1 = {};\n\n  Object.defineProperty(Plane$1, \"__esModule\", { value: true });\n  Plane$1.Plane = void 0;\n  const Vector3_1$1 = Vector3$1;\n  const Matrix_1 = Matrix$1;\n  const preallocatedVariables_1 = preallocatedVariables;\n  /**\n   * Represens a plane by the equation ax + by + cz + d = 0\n   * @public\n   */\n  class Plane {\n      /**\n       * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\n       * @param a - a component of the plane\n       * @param b - b component of the plane\n       * @param c - c component of the plane\n       * @param d - d component of the plane\n       */\n      constructor(a, b, c, d) {\n          this.normal = new Vector3_1$1.Vector3(a, b, c);\n          this.d = d;\n      }\n      // Statics\n      /**\n       * Creates a plane from an  array\n       * @param array - the array to create a plane from\n       * @returns a new Plane from the given array.\n       */\n      static FromArray(array) {\n          return new Plane(array[0], array[1], array[2], array[3]);\n      }\n      /**\n       * Creates a plane from three points\n       * @param point1 - point used to create the plane\n       * @param point2 - point used to create the plane\n       * @param point3 - point used to create the plane\n       * @returns a new Plane defined by the three given points.\n       */\n      static FromPoints(point1, point2, point3) {\n          const result = new Plane(0.0, 0.0, 0.0, 0.0);\n          result.copyFromPoints(point1, point2, point3);\n          return result;\n      }\n      /**\n       * Creates a plane from an origin point and a normal\n       * @param origin - origin of the plane to be constructed\n       * @param normal - normal of the plane to be constructed\n       * @returns a new Plane the normal vector to this plane at the given origin point.\n       * Note : the vector \"normal\" is updated because normalized.\n       */\n      static FromPositionAndNormal(origin, normal) {\n          const result = new Plane(0.0, 0.0, 0.0, 0.0);\n          normal.normalize();\n          result.normal = normal;\n          result.d = -(normal.x * origin.x +\n              normal.y * origin.y +\n              normal.z * origin.z);\n          return result;\n      }\n      /**\n       * Calculates the distance from a plane and a point\n       * @param origin - origin of the plane to be constructed\n       * @param normal - normal of the plane to be constructed\n       * @param point - point to calculate distance to\n       * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\n       */\n      static SignedDistanceToPlaneFromPositionAndNormal(origin, normal, point) {\n          const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n          return Vector3_1$1.Vector3.Dot(point, normal) + d;\n      }\n      /**\n       * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\n       */\n      asArray() {\n          return [this.normal.x, this.normal.y, this.normal.z, this.d];\n      }\n      // Methods\n      /**\n       * @returns a new plane copied from the current Plane.\n       */\n      clone() {\n          return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n      }\n      /**\n       * @returns the string \"Plane\".\n       */\n      getClassName() {\n          return 'Plane';\n      }\n      /**\n       * @returns the Plane hash code.\n       */\n      getHashCode() {\n          let hash = this.normal.getHashCode();\n          hash = (hash * 397) ^ (this.d || 0);\n          return hash;\n      }\n      /**\n       * Normalize the current Plane in place.\n       * @returns the updated Plane.\n       */\n      normalize() {\n          const norm = Math.sqrt(this.normal.x * this.normal.x +\n              this.normal.y * this.normal.y +\n              this.normal.z * this.normal.z);\n          let magnitude = 0.0;\n          if (norm !== 0) {\n              magnitude = 1.0 / norm;\n          }\n          this.normal.x *= magnitude;\n          this.normal.y *= magnitude;\n          this.normal.z *= magnitude;\n          this.d *= magnitude;\n          return this;\n      }\n      /**\n       * Applies a transformation the plane and returns the result\n       * @param transformation - the transformation matrix to be applied to the plane\n       * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\n       */\n      transform(transformation) {\n          const transposedMatrix = preallocatedVariables_1.MathTmp.Matrix[0];\n          Matrix_1.Matrix.TransposeToRef(transformation, transposedMatrix);\n          const m = transposedMatrix.m;\n          const x = this.normal.x;\n          const y = this.normal.y;\n          const z = this.normal.z;\n          const d = this.d;\n          const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\n          const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\n          const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\n          const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\n          return new Plane(normalX, normalY, normalZ, finalD);\n      }\n      /**\n       * Calcualtte the dot product between the point and the plane normal\n       * @param point - point to calculate the dot product with\n       * @returns the dot product (float) of the point coordinates and the plane normal.\n       */\n      dotCoordinate(point) {\n          return (this.normal.x * point.x +\n              this.normal.y * point.y +\n              this.normal.z * point.z +\n              this.d);\n      }\n      /**\n       * Updates the current Plane from the plane defined by the three given points.\n       * @param point1 - one of the points used to contruct the plane\n       * @param point2 - one of the points used to contruct the plane\n       * @param point3 - one of the points used to contruct the plane\n       * @returns the updated Plane.\n       */\n      copyFromPoints(point1, point2, point3) {\n          const x1 = point2.x - point1.x;\n          const y1 = point2.y - point1.y;\n          const z1 = point2.z - point1.z;\n          const x2 = point3.x - point1.x;\n          const y2 = point3.y - point1.y;\n          const z2 = point3.z - point1.z;\n          const yz = y1 * z2 - z1 * y2;\n          const xz = z1 * x2 - x1 * z2;\n          const xy = x1 * y2 - y1 * x2;\n          const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\n          let invPyth;\n          if (pyth !== 0) {\n              invPyth = 1.0 / pyth;\n          }\n          else {\n              invPyth = 0.0;\n          }\n          this.normal.x = yz * invPyth;\n          this.normal.y = xz * invPyth;\n          this.normal.z = xy * invPyth;\n          this.d = -(this.normal.x * point1.x +\n              this.normal.y * point1.y +\n              this.normal.z * point1.z);\n          return this;\n      }\n      /**\n       * Checks if the plane is facing a given direction\n       * @param direction - the direction to check if the plane is facing\n       * @param epsilon - value the dot product is compared against (returns true if dot &lt;= epsilon)\n       * @returns True is the vector \"direction\"  is the same side than the plane normal.\n       */\n      isFrontFacingTo(direction, epsilon) {\n          const dot = Vector3_1$1.Vector3.Dot(this.normal, direction);\n          return dot <= epsilon;\n      }\n      /**\n       * Calculates the distance to a point\n       * @param point - point to calculate distance to\n       * @returns the signed distance (float) from the given point to the Plane.\n       */\n      signedDistanceTo(point) {\n          return Vector3_1$1.Vector3.Dot(point, this.normal) + this.d;\n      }\n  }\n  Plane$1.Plane = Plane;\n\n  Object.defineProperty(Furstum, \"__esModule\", { value: true });\n  Furstum.Frustum = void 0;\n  const Plane_1 = Plane$1;\n  /**\n   * Reprasents a camera frustum\n   * @public\n   */\n  class Frustum {\n      /**\n       * Gets the planes representing the frustum\n       * @param transform - matrix to be applied to the returned planes\n       * @returns a new array of 6 Frustum planes computed by the given transformation matrix.\n       */\n      static GetPlanes(transform) {\n          const frustumPlanes = [];\n          for (let index = 0; index < 6; index++) {\n              frustumPlanes.push(new Plane_1.Plane(0.0, 0.0, 0.0, 0.0));\n          }\n          Frustum.GetPlanesToRef(transform, frustumPlanes);\n          return frustumPlanes;\n      }\n      /**\n       * Gets the near frustum plane transformed by the transform matrix\n       * @param transform - transformation matrix to be applied to the resulting frustum plane\n       * @param frustumPlane - the resuling frustum plane\n       */\n      static GetNearPlaneToRef(transform, frustumPlane) {\n          const m = transform.m;\n          frustumPlane.normal.x = m[3] + m[2];\n          frustumPlane.normal.y = m[7] + m[6];\n          frustumPlane.normal.z = m[11] + m[10];\n          frustumPlane.d = m[15] + m[14];\n          frustumPlane.normalize();\n      }\n      /**\n       * Gets the far frustum plane transformed by the transform matrix\n       * @param transform - transformation matrix to be applied to the resulting frustum plane\n       * @param frustumPlane - the resuling frustum plane\n       */\n      static GetFarPlaneToRef(transform, frustumPlane) {\n          const m = transform.m;\n          frustumPlane.normal.x = m[3] - m[2];\n          frustumPlane.normal.y = m[7] - m[6];\n          frustumPlane.normal.z = m[11] - m[10];\n          frustumPlane.d = m[15] - m[14];\n          frustumPlane.normalize();\n      }\n      /**\n       * Gets the left frustum plane transformed by the transform matrix\n       * @param transform - transformation matrix to be applied to the resulting frustum plane\n       * @param frustumPlane - the resuling frustum plane\n       */\n      static GetLeftPlaneToRef(transform, frustumPlane) {\n          const m = transform.m;\n          frustumPlane.normal.x = m[3] + m[0];\n          frustumPlane.normal.y = m[7] + m[4];\n          frustumPlane.normal.z = m[11] + m[8];\n          frustumPlane.d = m[15] + m[12];\n          frustumPlane.normalize();\n      }\n      /**\n       * Gets the right frustum plane transformed by the transform matrix\n       * @param transform - transformation matrix to be applied to the resulting frustum plane\n       * @param frustumPlane - the resuling frustum plane\n       */\n      static GetRightPlaneToRef(transform, frustumPlane) {\n          const m = transform.m;\n          frustumPlane.normal.x = m[3] - m[0];\n          frustumPlane.normal.y = m[7] - m[4];\n          frustumPlane.normal.z = m[11] - m[8];\n          frustumPlane.d = m[15] - m[12];\n          frustumPlane.normalize();\n      }\n      /**\n       * Gets the top frustum plane transformed by the transform matrix\n       * @param transform - transformation matrix to be applied to the resulting frustum plane\n       * @param frustumPlane - the resuling frustum plane\n       */\n      static GetTopPlaneToRef(transform, frustumPlane) {\n          const m = transform.m;\n          frustumPlane.normal.x = m[3] - m[1];\n          frustumPlane.normal.y = m[7] - m[5];\n          frustumPlane.normal.z = m[11] - m[9];\n          frustumPlane.d = m[15] - m[13];\n          frustumPlane.normalize();\n      }\n      /**\n       * Gets the bottom frustum plane transformed by the transform matrix\n       * @param transform - transformation matrix to be applied to the resulting frustum plane\n       * @param frustumPlane - the resuling frustum plane\n       */\n      static GetBottomPlaneToRef(transform, frustumPlane) {\n          const m = transform.m;\n          frustumPlane.normal.x = m[3] + m[1];\n          frustumPlane.normal.y = m[7] + m[5];\n          frustumPlane.normal.z = m[11] + m[9];\n          frustumPlane.d = m[15] + m[13];\n          frustumPlane.normalize();\n      }\n      /**\n       * Sets the given array \"frustumPlanes\" with the 6 Frustum planes computed by the given transformation matrix.\n       * @param transform - transformation matrix to be applied to the resulting frustum planes\n       * @param frustumPlanes - the resuling frustum planes\n       */\n      static GetPlanesToRef(transform, frustumPlanes) {\n          // Near\n          Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);\n          // Far\n          Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);\n          // Left\n          Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);\n          // Right\n          Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);\n          // Top\n          Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);\n          // Bottom\n          Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);\n      }\n  }\n  Furstum.Frustum = Frustum;\n\n  var Path2d = {};\n\n  Object.defineProperty(Path2d, \"__esModule\", { value: true });\n  Path2d.Path2 = void 0;\n  const Vector2_1 = Vector2$1;\n  const Arc2_1 = Arc2$1;\n  const types_1$1 = types;\n  /**\n   * Represents a 2D path made up of multiple 2D points\n   * @public\n   */\n  class Path2 {\n      /**\n       * Creates a Path2 object from the starting 2D coordinates x and y.\n       * @param x - the starting points x value\n       * @param y - the starting points y value\n       */\n      constructor(x, y) {\n          /**\n           * If the path start and end point are the same\n           */\n          this.closed = false;\n          this._points = new Array();\n          this._length = 0.0;\n          this._points.push(new Vector2_1.Vector2(x, y));\n      }\n      /**\n       * Creates a new path starting from an x and y position\n       * @param x - starting x value\n       * @param y - starting y value\n       * @returns a new Path2 starting at the coordinates (x, y).\n       */\n      static StartingAt(x, y) {\n          return new Path2(x, y);\n      }\n      /**\n       * Adds a new segment until the given coordinates (x, y) to the current Path2.\n       * @param x - the added points x value\n       * @param y - the added points y value\n       * @returns the updated Path2.\n       */\n      addLineTo(x, y) {\n          if (this.closed) {\n              return this;\n          }\n          const newPoint = new Vector2_1.Vector2(x, y);\n          const previousPoint = this._points[this._points.length - 1];\n          this._points.push(newPoint);\n          this._length += newPoint.subtract(previousPoint).length();\n          return this;\n      }\n      /**\n       * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\n       * @param midX - middle point x value\n       * @param midY - middle point y value\n       * @param endX - end point x value\n       * @param endY - end point y value\n       * @param numberOfSegments - (default: 36)\n       * @returns the updated Path2.\n       */\n      addArcTo(midX, midY, endX, endY, numberOfSegments = 36) {\n          if (this.closed) {\n              return this;\n          }\n          const startPoint = this._points[this._points.length - 1];\n          const midPoint = new Vector2_1.Vector2(midX, midY);\n          const endPoint = new Vector2_1.Vector2(endX, endY);\n          const arc = new Arc2_1.Arc2(startPoint, midPoint, endPoint);\n          let increment = arc.angle.radians() / numberOfSegments;\n          if (arc.orientation === types_1$1.Orientation.CW) {\n              increment *= -1;\n          }\n          let currentAngle = arc.startAngle.radians() + increment;\n          for (let i = 0; i < numberOfSegments; i++) {\n              const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n              const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n              this.addLineTo(x, y);\n              currentAngle += increment;\n          }\n          return this;\n      }\n      /**\n       * Closes the Path2.\n       * @returns the Path2.\n       */\n      close() {\n          this.closed = true;\n          return this;\n      }\n      /**\n       * Gets the sum of the distance between each sequential point in the path\n       * @returns the Path2 total length (float).\n       */\n      length() {\n          let result = this._length;\n          if (!this.closed) {\n              const lastPoint = this._points[this._points.length - 1];\n              const firstPoint = this._points[0];\n              result += firstPoint.subtract(lastPoint).length();\n          }\n          return result;\n      }\n      /**\n       * Gets the points which construct the path\n       * @returns the Path2 internal array of points.\n       */\n      getPoints() {\n          return this._points;\n      }\n      /**\n       * Retreives the point at the distance aways from the starting point\n       * @param normalizedLengthPosition - the length along the path to retreive the point from\n       * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\n       */\n      getPointAtLengthPosition(normalizedLengthPosition) {\n          if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n              return Vector2_1.Vector2.Zero();\n          }\n          const lengthPosition = normalizedLengthPosition * this.length();\n          let previousOffset = 0;\n          for (let i = 0; i < this._points.length; i++) {\n              const j = (i + 1) % this._points.length;\n              const a = this._points[i];\n              const b = this._points[j];\n              const bToA = b.subtract(a);\n              const nextOffset = bToA.length() + previousOffset;\n              if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n                  const dir = bToA.normalize();\n                  const localOffset = lengthPosition - previousOffset;\n                  return new Vector2_1.Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\n              }\n              previousOffset = nextOffset;\n          }\n          return Vector2_1.Vector2.Zero();\n      }\n  }\n  Path2d.Path2 = Path2;\n\n  var Path3d = {};\n\n  Object.defineProperty(Path3d, \"__esModule\", { value: true });\n  Path3d.Path3D = void 0;\n  const Vector3_1 = Vector3$1;\n  const types_1 = types;\n  const Scalar_1 = Scalar$1;\n  /**\n   * Represents a 3D path made up of multiple 3D points\n   * @public\n   */\n  class Path3D {\n      /**\n       * new Path3D(path, normal, raw)\n       * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\n       * please read the description in the tutorial :  http://doc.babylonjs.com/tutorials/How_to_use_Path3D\n       * @param path - an array of Vector3, the curve axis of the Path3D\n       * @param normal - (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\n       * @param raw - (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\n       */\n      constructor(\n      /**\n       * an array of Vector3, the curve axis of the Path3D\n       */\n      path, firstNormal = null, raw) {\n          this.path = path;\n          this._curve = new Array();\n          this._distances = new Array();\n          this._tangents = new Array();\n          this._normals = new Array();\n          this._binormals = new Array();\n          for (let p = 0; p < path.length; p++) {\n              this._curve[p] = path[p].clone(); // hard copy\n          }\n          this._raw = raw || false;\n          this._compute(firstNormal);\n      }\n      /**\n       * Returns the Path3D array of successive Vector3 designing its curve.\n       * @returns the Path3D array of successive Vector3 designing its curve.\n       */\n      getCurve() {\n          return this._curve;\n      }\n      /**\n       * Returns an array populated with tangent vectors on each Path3D curve point.\n       * @returns an array populated with tangent vectors on each Path3D curve point.\n       */\n      getTangents() {\n          return this._tangents;\n      }\n      /**\n       * Returns an array populated with normal vectors on each Path3D curve point.\n       * @returns an array populated with normal vectors on each Path3D curve point.\n       */\n      getNormals() {\n          return this._normals;\n      }\n      /**\n       * Returns an array populated with binormal vectors on each Path3D curve point.\n       * @returns an array populated with binormal vectors on each Path3D curve point.\n       */\n      getBinormals() {\n          return this._binormals;\n      }\n      /**\n       * Returns an array populated with distances (float) of the i-th point from the first curve point.\n       * @returns an array populated with distances (float) of the i-th point from the first curve point.\n       */\n      getDistances() {\n          return this._distances;\n      }\n      /**\n       * Forces the Path3D tangent, normal, binormal and distance recomputation.\n       * @param path - path which all values are copied into the curves points\n       * @param firstNormal - which should be projected onto the curve\n       * @returns the same object updated.\n       */\n      update(path, firstNormal = null) {\n          for (let p = 0; p < path.length; p++) {\n              this._curve[p].x = path[p].x;\n              this._curve[p].y = path[p].y;\n              this._curve[p].z = path[p].z;\n          }\n          this._compute(firstNormal);\n          return this;\n      }\n      // private function compute() : computes tangents, normals and binormals\n      _compute(firstNormal) {\n          const l = this._curve.length;\n          // first and last tangents\n          this._tangents[0] = this._getFirstNonNullVector(0);\n          if (!this._raw) {\n              this._tangents[0].normalize();\n          }\n          this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n          if (!this._raw) {\n              this._tangents[l - 1].normalize();\n          }\n          // normals and binormals at first point : arbitrary vector with _normalVector()\n          const tg0 = this._tangents[0];\n          const pp0 = this._normalVector(this._curve[0], tg0, firstNormal);\n          this._normals[0] = pp0;\n          if (!this._raw) {\n              this._normals[0].normalize();\n          }\n          this._binormals[0] = Vector3_1.Vector3.Cross(tg0, this._normals[0]);\n          if (!this._raw) {\n              this._binormals[0].normalize();\n          }\n          this._distances[0] = 0.0;\n          // normals and binormals : next points\n          let prev; // previous vector (segment)\n          let cur; // current vector (segment)\n          let curTang; // current tangent\n          // previous normal\n          let prevBinor; // previous binormal\n          for (let i = 1; i < l; i++) {\n              // tangents\n              prev = this._getLastNonNullVector(i);\n              if (i < l - 1) {\n                  cur = this._getFirstNonNullVector(i);\n                  this._tangents[i] = prev.add(cur);\n                  this._tangents[i].normalize();\n              }\n              this._distances[i] = this._distances[i - 1] + prev.length();\n              // normals and binormals\n              // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\n              curTang = this._tangents[i];\n              prevBinor = this._binormals[i - 1];\n              this._normals[i] = Vector3_1.Vector3.Cross(prevBinor, curTang);\n              if (!this._raw) {\n                  this._normals[i].normalize();\n              }\n              this._binormals[i] = Vector3_1.Vector3.Cross(curTang, this._normals[i]);\n              if (!this._raw) {\n                  this._binormals[i].normalize();\n              }\n          }\n      }\n      // returns the first non null vector from index : curve[index + N].subtract(curve[index])\n      _getFirstNonNullVector(index) {\n          let i = 1;\n          let nNVector = this._curve[index + i].subtract(this._curve[index]);\n          while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\n              i++;\n              nNVector = this._curve[index + i].subtract(this._curve[index]);\n          }\n          return nNVector;\n      }\n      // returns the last non null vector from index : curve[index].subtract(curve[index - N])\n      _getLastNonNullVector(index) {\n          let i = 1;\n          let nLVector = this._curve[index].subtract(this._curve[index - i]);\n          while (nLVector.length() === 0 && index > i + 1) {\n              i++;\n              nLVector = this._curve[index].subtract(this._curve[index - i]);\n          }\n          return nLVector;\n      }\n      // private function normalVector(v0, vt, va) :\n      // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n      // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\n      _normalVector(v0, vt, va) {\n          let normal0;\n          let tgl = vt.length();\n          if (tgl === 0.0) {\n              tgl = 1.0;\n          }\n          if (va === undefined || va === null) {\n              let point;\n              if (!Scalar_1.Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, types_1.Epsilon)) {\n                  // search for a point in the plane\n                  point = new Vector3_1.Vector3(0.0, -1.0, 0.0);\n              }\n              else if (!Scalar_1.Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, types_1.Epsilon)) {\n                  point = new Vector3_1.Vector3(1.0, 0.0, 0.0);\n              }\n              else if (!Scalar_1.Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, types_1.Epsilon)) {\n                  point = new Vector3_1.Vector3(0.0, 0.0, 1.0);\n              }\n              else {\n                  point = Vector3_1.Vector3.Zero();\n              }\n              normal0 = Vector3_1.Vector3.Cross(vt, point);\n          }\n          else {\n              normal0 = Vector3_1.Vector3.Cross(vt, va);\n              Vector3_1.Vector3.CrossToRef(normal0, vt, normal0);\n          }\n          normal0.normalize();\n          return normal0;\n      }\n  }\n  Path3d.Path3D = Path3D;\n\n  var Size$1 = {};\n\n  Object.defineProperty(Size$1, \"__esModule\", { value: true });\n  Size$1.Size = void 0;\n  /**\n   * Size containing widht and height\n   * @public\n   */\n  class Size {\n      /**\n       * Creates a Size object from the given width and height (floats).\n       * @param width - width of the new size\n       * @param height - height of the new size\n       */\n      constructor(width, height) {\n          this.width = width;\n          this.height = height;\n      }\n      /**\n       * The surface of the Size : width * height (float).\n       */\n      get surface() {\n          return this.width * this.height;\n      }\n      /**\n       * Create a new size of zero\n       * @returns a new Size set to (0.0, 0.0)\n       */\n      static Zero() {\n          return new Size(0.0, 0.0);\n      }\n      /**\n       * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n       * @param start - starting size to lerp between\n       * @param end - end size to lerp between\n       * @param amount - amount to lerp between the start and end values\n       * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n       */\n      static Lerp(start, end, amount) {\n          const w = start.width + (end.width - start.width) * amount;\n          const h = start.height + (end.height - start.height) * amount;\n          return new Size(w, h);\n      }\n      /**\n       * Returns a string with the Size width and height\n       * @returns a string with the Size width and height\n       */\n      toString() {\n          return `{W: ${this.width}, H: ${this.height}}`;\n      }\n      /**\n       * \"Size\"\n       * @returns the string \"Size\"\n       */\n      getClassName() {\n          return 'Size';\n      }\n      /**\n       * Returns the Size hash code.\n       * @returns a hash code for a unique width and height\n       */\n      getHashCode() {\n          let hash = this.width || 0;\n          hash = (hash * 397) ^ (this.height || 0);\n          return hash;\n      }\n      /**\n       * Updates the current size from the given one.\n       * @param src - the given size\n       */\n      copyFrom(src) {\n          this.width = src.width;\n          this.height = src.height;\n      }\n      /**\n       * Updates in place the current Size from the given floats.\n       * @param width - width of the new size\n       * @param height - height of the new size\n       * @returns the updated Size.\n       */\n      copyFromFloats(width, height) {\n          this.width = width;\n          this.height = height;\n          return this;\n      }\n      /**\n       * Updates in place the current Size from the given floats.\n       * @param width - width to set\n       * @param height - height to set\n       * @returns the updated Size.\n       */\n      set(width, height) {\n          return this.copyFromFloats(width, height);\n      }\n      /**\n       * Multiplies the width and height by numbers\n       * @param w - factor to multiple the width by\n       * @param h - factor to multiple the height by\n       * @returns a new Size set with the multiplication result of the current Size and the given floats.\n       */\n      multiplyByFloats(w, h) {\n          return new Size(this.width * w, this.height * h);\n      }\n      /**\n       * Clones the size\n       * @returns a new Size copied from the given one.\n       */\n      clone() {\n          return new Size(this.width, this.height);\n      }\n      /**\n       * True if the current Size and the given one width and height are strictly equal.\n       * @param other - the other size to compare against\n       * @returns True if the current Size and the given one width and height are strictly equal.\n       */\n      equals(other) {\n          if (!other) {\n              return false;\n          }\n          return this.width === other.width && this.height === other.height;\n      }\n      /**\n       * Sums the width and height of two sizes\n       * @param otherSize - size to add to this size\n       * @returns a new Size set as the addition result of the current Size and the given one.\n       */\n      add(otherSize) {\n          const r = new Size(this.width + otherSize.width, this.height + otherSize.height);\n          return r;\n      }\n      /**\n       * Subtracts the width and height of two\n       * @param otherSize - size to subtract to this size\n       * @returns a new Size set as the subtraction result of  the given one from the current Size.\n       */\n      subtract(otherSize) {\n          const r = new Size(this.width - otherSize.width, this.height - otherSize.height);\n          return r;\n      }\n  }\n  Size$1.Size = Size;\n\n  (function (exports) {\n  var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n      if (k2 === undefined) k2 = k;\n      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n  }) : (function(o, m, k, k2) {\n      if (k2 === undefined) k2 = k;\n      o[k2] = m[k];\n  }));\n  var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {\n      for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n  };\n  Object.defineProperty(exports, \"__esModule\", { value: true });\n  __exportStar(types, exports);\n  __exportStar(preallocatedVariables, exports);\n  __exportStar(Angle$1, exports);\n  __exportStar(Arc2$1, exports);\n  __exportStar(Axis$1, exports);\n  __exportStar(BezierCurve$1, exports);\n  __exportStar(Color3$1, exports);\n  __exportStar(Color4$1, exports);\n  __exportStar(Curve3d, exports);\n  __exportStar(Furstum, exports);\n  __exportStar(Matrix$1, exports);\n  __exportStar(Path2d, exports);\n  __exportStar(Path3d, exports);\n  __exportStar(Plane$1, exports);\n  __exportStar(Quaternion$1, exports);\n  __exportStar(Scalar$1, exports);\n  __exportStar(Size$1, exports);\n  __exportStar(Vector2$1, exports);\n  __exportStar(Vector3$1, exports);\n  __exportStar(Vector4$1, exports);\n  __exportStar(dist, exports);\n\n  }(dist));\n\n  var defaultParams = {\r\n      looping: true,\r\n      speed: 1.0,\r\n      weight: 1.0,\r\n      layer: 0\r\n  };\r\n  /**\r\n   * @public\r\n   */\r\n  var AnimationState = /** @class */ (function (_super) {\r\n      __extends(AnimationState, _super);\r\n      function AnimationState(clip, params) {\r\n          if (params === void 0) { params = defaultParams; }\r\n          var _this = _super.call(this) || this;\r\n          // @internal\r\n          _this.isAnimationClip = true;\r\n          /**\r\n           * Does the animation loop?, default: true\r\n           */\r\n          _this.looping = defaultParams.looping;\r\n          /**\r\n           * Weight of the animation, values from 0 to 1, used to blend several animations. default: 1\r\n           */\r\n          _this.weight = defaultParams.weight;\r\n          /**\r\n           * Is the animation playing? default: true\r\n           */\r\n          _this.playing = false;\r\n          /**\r\n           * Does any anyone asked to reset the animation? default: false\r\n           */\r\n          _this.shouldReset = false;\r\n          /**\r\n           * The animation speed\r\n           */\r\n          _this.speed = defaultParams.speed;\r\n          // @internal\r\n          _this.name = newId('AnimClip');\r\n          /**\r\n           * Layering allows you to have two or more levels of animation on an object's parameters at the same time\r\n           */\r\n          _this.layer = defaultParams.layer;\r\n          _this.clip = clip;\r\n          _this.setParams(__assign({}, params));\r\n          return _this;\r\n      }\r\n      /**\r\n       * Sets the clip parameters\r\n       */\r\n      AnimationState.prototype.setParams = function (params) {\r\n          this.looping = params.looping !== undefined ? params.looping : this.looping;\r\n          this.speed = params.speed || this.speed;\r\n          this.weight = params.weight || this.weight;\r\n          this.layer = params.layer || this.layer;\r\n          return this;\r\n      };\r\n      AnimationState.prototype.toJSON = function () {\r\n          var ret = JSON.parse(JSON.stringify(_super.prototype.toJSON.call(this)));\r\n          if (this.shouldReset) {\r\n              this.shouldReset = false;\r\n          }\r\n          return ret;\r\n      };\r\n      /**\r\n       * Starts the animation\r\n       */\r\n      AnimationState.prototype.play = function (reset) {\r\n          var _a;\r\n          if (reset === void 0) { reset = false; }\r\n          (_a = this.owner) === null || _a === void 0 ? void 0 : _a.play(this, reset);\r\n      };\r\n      /**\r\n       * Pauses the animation\r\n       */\r\n      AnimationState.prototype.pause = function () {\r\n          var _a;\r\n          (_a = this.owner) === null || _a === void 0 ? void 0 : _a.pause(this);\r\n      };\r\n      /**\r\n       * Resets the animation state to the frame 0\r\n       */\r\n      AnimationState.prototype.reset = function () {\r\n          this.shouldReset = true;\r\n      };\r\n      /**\r\n       * Resets and pauses the animation\r\n       */\r\n      AnimationState.prototype.stop = function () {\r\n          var _a;\r\n          (_a = this.owner) === null || _a === void 0 ? void 0 : _a.stop(this);\r\n      };\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], AnimationState.prototype, \"clip\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AnimationState.prototype, \"looping\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], AnimationState.prototype, \"weight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AnimationState.prototype, \"playing\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AnimationState.prototype, \"shouldReset\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], AnimationState.prototype, \"speed\", void 0);\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], AnimationState.prototype, \"name\", void 0);\r\n      return AnimationState;\r\n  }(ObservableComponent));\n\n  /** @public */\r\n  exports.InputEventType = void 0;\r\n  (function (InputEventType) {\r\n      InputEventType[InputEventType[\"DOWN\"] = 0] = \"DOWN\";\r\n      InputEventType[InputEventType[\"UP\"] = 1] = \"UP\";\r\n  })(exports.InputEventType || (exports.InputEventType = {}));\r\n  /** @public */\r\n  exports.CameraMode = void 0;\r\n  (function (CameraMode) {\r\n      CameraMode[CameraMode[\"FirstPerson\"] = 0] = \"FirstPerson\";\r\n      CameraMode[CameraMode[\"ThirdPerson\"] = 1] = \"ThirdPerson\";\r\n      // @internal\r\n      CameraMode[CameraMode[\"BuildingToolGodMode\"] = 2] = \"BuildingToolGodMode\";\r\n  })(exports.CameraMode || (exports.CameraMode = {}));\r\n  // @internal\r\n  var AVATAR_OBSERVABLE = 'AVATAR_OBSERVABLE';\r\n  /** @public */\r\n  exports.LandRole = void 0;\r\n  (function (LandRole) {\r\n      LandRole[\"OWNER\"] = \"owner\";\r\n      LandRole[\"OPERATOR\"] = \"operator\";\r\n  })(exports.LandRole || (exports.LandRole = {}));\n\n  /**\r\n   * @public\r\n   */\r\n  exports.ActionButton = void 0;\r\n  (function (ActionButton) {\r\n      ActionButton[\"POINTER\"] = \"POINTER\";\r\n      ActionButton[\"PRIMARY\"] = \"PRIMARY\";\r\n      ActionButton[\"SECONDARY\"] = \"SECONDARY\";\r\n      ActionButton[\"ANY\"] = \"ANY\";\r\n      ActionButton[\"FORWARD\"] = \"FORWARD\";\r\n      ActionButton[\"BACKWARD\"] = \"BACKWARD\";\r\n      ActionButton[\"RIGHT\"] = \"RIGHT\";\r\n      ActionButton[\"LEFT\"] = \"LEFT\";\r\n      ActionButton[\"JUMP\"] = \"JUMP\";\r\n      ActionButton[\"WALK\"] = \"WALK\";\r\n      ActionButton[\"ACTION_3\"] = \"ACTION_3\";\r\n      ActionButton[\"ACTION_4\"] = \"ACTION_4\";\r\n      ActionButton[\"ACTION_5\"] = \"ACTION_5\";\r\n      ActionButton[\"ACTION_6\"] = \"ACTION_6\";\r\n  })(exports.ActionButton || (exports.ActionButton = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  var PointerEventComponent = /** @class */ (function () {\r\n      function PointerEventComponent(callback) {\r\n          this.callback = callback;\r\n          if (!callback || !('apply' in callback) || !('call' in callback)) {\r\n              throw new Error('Callback is not a function');\r\n          }\r\n          Input.ensureInstance();\r\n      }\r\n      return PointerEventComponent;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var GlobalPointerDown = /** @class */ (function (_super) {\r\n      __extends(GlobalPointerDown, _super);\r\n      function GlobalPointerDown() {\r\n          return _super !== null && _super.apply(this, arguments) || this;\r\n      }\r\n      GlobalPointerDown = __decorate([\r\n          Component('pointerDown')\r\n      ], GlobalPointerDown);\r\n      return GlobalPointerDown;\r\n  }(PointerEventComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var GlobalPointerUp = /** @class */ (function (_super) {\r\n      __extends(GlobalPointerUp, _super);\r\n      function GlobalPointerUp() {\r\n          return _super !== null && _super.apply(this, arguments) || this;\r\n      }\r\n      GlobalPointerUp = __decorate([\r\n          Component('pointerUp')\r\n      ], GlobalPointerUp);\r\n      return GlobalPointerUp;\r\n  }(PointerEventComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var Subscription = /** @class */ (function () {\r\n      function Subscription(fn, useRaycast) {\r\n          this.fn = fn;\r\n          this.useRaycast = useRaycast;\r\n      }\r\n      return Subscription;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var Input = /** @class */ (function () {\r\n      function Input() {\r\n          // @internal\r\n          this.buttonIdMapping = [\r\n              exports.ActionButton.POINTER,\r\n              exports.ActionButton.PRIMARY,\r\n              exports.ActionButton.SECONDARY,\r\n              exports.ActionButton.ANY,\r\n              exports.ActionButton.FORWARD,\r\n              exports.ActionButton.BACKWARD,\r\n              exports.ActionButton.RIGHT,\r\n              exports.ActionButton.LEFT,\r\n              exports.ActionButton.JUMP,\r\n              exports.ActionButton.WALK,\r\n              exports.ActionButton.ACTION_3,\r\n              exports.ActionButton.ACTION_4,\r\n              exports.ActionButton.ACTION_5,\r\n              exports.ActionButton.ACTION_6\r\n          ];\r\n          // @internal\r\n          this.subscriptions = this.buttonIdMapping.reduce(function (acc, k) {\r\n              var _a;\r\n              return (__assign(__assign({}, acc), (_a = {}, _a[k] = { BUTTON_DOWN: [], BUTTON_UP: [] }, _a)));\r\n          }, {});\r\n          this.internalState = this.buttonIdMapping.reduce(function (acc, k) {\r\n              var _a;\r\n              return (__assign(__assign({}, acc), (_a = {}, _a[k] = { BUTTON_DOWN: false }, _a)));\r\n          }, {});\r\n      }\r\n      Object.defineProperty(Input, \"instance\", {\r\n          get: function () {\r\n              Input.ensureInstance();\r\n              return Input._instance;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      Input.ensureInstance = function () {\r\n          if (!Input._instance) {\r\n              Input._instance = new Input();\r\n          }\r\n      };\r\n      /**\r\n       * Allows to know if a button is pressed\r\n       *\r\n       * Returns true if the button is pressed\r\n       * @param buttonId - The id of the button.\r\n       */\r\n      Input.prototype.isButtonPressed = function (buttonId) {\r\n          return this.internalState[buttonId];\r\n      };\r\n      /**\r\n       * Subscribes to an input event and triggers the provided callback.\r\n       *\r\n       * Returns a function that can be called to remove the subscription.\r\n       * @param eventName - The name of the event (see InputEventKind).\r\n       * @param buttonId - The id of the button.\r\n       * @param useRaycast - Enables getting raycast information.\r\n       * @param fn - A callback function to be called when the event is triggered.\r\n       */\r\n      Input.prototype.subscribe = function (eventName, buttonId, useRaycast, fn) {\r\n          var _this = this;\r\n          this.subscriptions[buttonId][eventName].push(new Subscription(fn, useRaycast));\r\n          return function () {\r\n              _this.unsubscribe(eventName, buttonId, fn);\r\n          };\r\n      };\r\n      /**\r\n       * Removes an existing input event subscription.\r\n       * @param eventName - The name of the event (see InputEventKind).\r\n       * @param buttonId - The id of the button.\r\n       * @param fn - The callback function used when subscribing to the event.\r\n       */\r\n      Input.prototype.unsubscribe = function (eventName, buttonId, fn) {\r\n          var index = this.getSubscriptionId(eventName, buttonId, fn);\r\n          if (index > -1) {\r\n              return this.subscriptions[buttonId][eventName].splice(index, 1);\r\n          }\r\n          return false;\r\n      };\r\n      Input.prototype.handlePointerEvent = function (data) {\r\n          var button = this.getPointerById(data.buttonId);\r\n          if (!button) {\r\n              return;\r\n          }\r\n          var eventResult = __assign(__assign({}, data), { button: button, direction: new dist.Vector3().copyFrom(data.direction), origin: new dist.Vector3().copyFrom(data.origin), hit: undefined });\r\n          var hit = data.hit\r\n              ? __assign(__assign({}, data.hit), { hitPoint: new dist.Vector3().copyFrom(data.hit.hitPoint), normal: new dist.Vector3().copyFrom(data.hit.normal), worldNormal: new dist.Vector3().copyFrom(data.hit.worldNormal) }) : undefined;\r\n          if (data.type === exports.InputEventType.DOWN) {\r\n              this.internalState[button].BUTTON_DOWN = true;\r\n              for (var i = 0; i < this.subscriptions[button]['BUTTON_DOWN'].length; i++) {\r\n                  var subscription = this.subscriptions[button]['BUTTON_DOWN'][i];\r\n                  // remove hit information when raycast is disabled\r\n                  if (subscription.useRaycast) {\r\n                      eventResult.hit = hit;\r\n                  }\r\n                  else {\r\n                      eventResult.hit = undefined;\r\n                  }\r\n                  subscription.fn(eventResult);\r\n              }\r\n              if (hit && hit.entityId && DisposableComponent.engine) {\r\n                  var entity = DisposableComponent.engine.entities[hit.entityId];\r\n                  var handler = entity && entity.getComponentOrNull(GlobalPointerDown);\r\n                  if (handler) {\r\n                      eventResult.hit = hit;\r\n                      handler.callback(eventResult);\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              this.internalState[button].BUTTON_DOWN = false;\r\n              for (var i = 0; i < this.subscriptions[button]['BUTTON_UP'].length; i++) {\r\n                  var subscription = this.subscriptions[button]['BUTTON_UP'][i];\r\n                  // remove hit information when raycast is disabled\r\n                  if (subscription.useRaycast) {\r\n                      eventResult.hit = hit;\r\n                  }\r\n                  else {\r\n                      eventResult.hit = undefined;\r\n                  }\r\n                  subscription.fn(eventResult);\r\n              }\r\n              if (hit && hit.entityId && DisposableComponent.engine) {\r\n                  var entity = DisposableComponent.engine.entities[hit.entityId];\r\n                  var handler = entity && entity.getComponentOrNull(GlobalPointerUp);\r\n                  if (handler) {\r\n                      eventResult.hit = hit;\r\n                      handler.callback(eventResult);\r\n                  }\r\n              }\r\n          }\r\n      };\r\n      Input.prototype.getSubscriptionId = function (eventName, buttonId, fn) {\r\n          for (var i = 0; i < this.subscriptions[buttonId][eventName].length; i++) {\r\n              if (this.subscriptions[buttonId][eventName][i].fn === fn) {\r\n                  return i;\r\n              }\r\n          }\r\n          return -1;\r\n      };\r\n      Input.prototype.getPointerById = function (id) {\r\n          if (id < 0 || id >= this.buttonIdMapping.length) {\r\n              return null;\r\n          }\r\n          var actionButton = this.buttonIdMapping[id];\r\n          if (actionButton === exports.ActionButton.ANY) {\r\n              return null;\r\n          }\r\n          return actionButton;\r\n      };\r\n      return Input;\r\n  }());\n\n  /**\r\n   * @public\r\n   */\r\n  exports.CLASS_ID = void 0;\r\n  (function (CLASS_ID) {\r\n      CLASS_ID[CLASS_ID[\"TRANSFORM\"] = 1] = \"TRANSFORM\";\r\n      CLASS_ID[CLASS_ID[\"UUID_CALLBACK\"] = 8] = \"UUID_CALLBACK\";\r\n      CLASS_ID[CLASS_ID[\"BOX_SHAPE\"] = 16] = \"BOX_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"SPHERE_SHAPE\"] = 17] = \"SPHERE_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"PLANE_SHAPE\"] = 18] = \"PLANE_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"CONE_SHAPE\"] = 19] = \"CONE_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"CYLINDER_SHAPE\"] = 20] = \"CYLINDER_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"TEXT_SHAPE\"] = 21] = \"TEXT_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"NFT_SHAPE\"] = 22] = \"NFT_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"UI_WORLD_SPACE_SHAPE\"] = 23] = \"UI_WORLD_SPACE_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"UI_SCREEN_SPACE_SHAPE\"] = 24] = \"UI_SCREEN_SPACE_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"UI_CONTAINER_RECT\"] = 25] = \"UI_CONTAINER_RECT\";\r\n      CLASS_ID[CLASS_ID[\"UI_CONTAINER_STACK\"] = 26] = \"UI_CONTAINER_STACK\";\r\n      CLASS_ID[CLASS_ID[\"UI_TEXT_SHAPE\"] = 27] = \"UI_TEXT_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"UI_INPUT_TEXT_SHAPE\"] = 28] = \"UI_INPUT_TEXT_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"UI_IMAGE_SHAPE\"] = 29] = \"UI_IMAGE_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"UI_SLIDER_SHAPE\"] = 30] = \"UI_SLIDER_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"CIRCLE_SHAPE\"] = 31] = \"CIRCLE_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"BILLBOARD\"] = 32] = \"BILLBOARD\";\r\n      CLASS_ID[CLASS_ID[\"ANIMATION\"] = 33] = \"ANIMATION\";\r\n      CLASS_ID[CLASS_ID[\"FONT\"] = 34] = \"FONT\";\r\n      CLASS_ID[CLASS_ID[\"UI_FULLSCREEN_SHAPE\"] = 40] = \"UI_FULLSCREEN_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"UI_BUTTON_SHAPE\"] = 41] = \"UI_BUTTON_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"GLTF_SHAPE\"] = 54] = \"GLTF_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"OBJ_SHAPE\"] = 55] = \"OBJ_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"AVATAR_SHAPE\"] = 56] = \"AVATAR_SHAPE\";\r\n      CLASS_ID[CLASS_ID[\"BASIC_MATERIAL\"] = 64] = \"BASIC_MATERIAL\";\r\n      CLASS_ID[CLASS_ID[\"PBR_MATERIAL\"] = 65] = \"PBR_MATERIAL\";\r\n      CLASS_ID[CLASS_ID[\"HIGHLIGHT_ENTITY\"] = 66] = \"HIGHLIGHT_ENTITY\";\r\n      /** @deprecated Sound has been deprecataed */\r\n      CLASS_ID[CLASS_ID[\"SOUND\"] = 67] = \"SOUND\";\r\n      CLASS_ID[CLASS_ID[\"TEXTURE\"] = 68] = \"TEXTURE\";\r\n      CLASS_ID[CLASS_ID[\"VIDEO_CLIP\"] = 70] = \"VIDEO_CLIP\";\r\n      CLASS_ID[CLASS_ID[\"VIDEO_TEXTURE\"] = 71] = \"VIDEO_TEXTURE\";\r\n      CLASS_ID[CLASS_ID[\"AVATAR_TEXTURE\"] = 72] = \"AVATAR_TEXTURE\";\r\n      CLASS_ID[CLASS_ID[\"AUDIO_CLIP\"] = 200] = \"AUDIO_CLIP\";\r\n      CLASS_ID[CLASS_ID[\"AUDIO_SOURCE\"] = 201] = \"AUDIO_SOURCE\";\r\n      CLASS_ID[CLASS_ID[\"AUDIO_STREAM\"] = 202] = \"AUDIO_STREAM\";\r\n      CLASS_ID[CLASS_ID[\"GIZMOS\"] = 203] = \"GIZMOS\";\r\n      CLASS_ID[CLASS_ID[\"SMART_ITEM\"] = 204] = \"SMART_ITEM\";\r\n      CLASS_ID[CLASS_ID[\"AVATAR_MODIFIER_AREA\"] = 205] = \"AVATAR_MODIFIER_AREA\";\r\n      CLASS_ID[CLASS_ID[\"AVATAR_ATTACH\"] = 206] = \"AVATAR_ATTACH\";\r\n      CLASS_ID[CLASS_ID[\"CAMERA_MODE_AREA\"] = 207] = \"CAMERA_MODE_AREA\";\r\n      // For state sync only\r\n      CLASS_ID[CLASS_ID[\"NAME\"] = 300] = \"NAME\";\r\n      CLASS_ID[CLASS_ID[\"LOCKED_ON_EDIT\"] = 301] = \"LOCKED_ON_EDIT\";\r\n      CLASS_ID[CLASS_ID[\"VISIBLE_ON_EDIT\"] = 302] = \"VISIBLE_ON_EDIT\";\r\n  })(exports.CLASS_ID || (exports.CLASS_ID = {}));\r\n  /** @public */\r\n  exports.AvatarModifiers = void 0;\r\n  (function (AvatarModifiers) {\r\n      AvatarModifiers[\"HIDE_AVATARS\"] = \"HIDE_AVATARS\";\r\n      AvatarModifiers[\"DISABLE_PASSPORTS\"] = \"DISABLE_PASSPORTS\";\r\n  })(exports.AvatarModifiers || (exports.AvatarModifiers = {}));\r\n  /**\r\n   * Define an area where avatars can be modified in some way\r\n   * @public\r\n   */\r\n  var AvatarModifierArea = /** @class */ (function (_super) {\r\n      __extends(AvatarModifierArea, _super);\r\n      function AvatarModifierArea(args) {\r\n          var _this = _super.call(this) || this;\r\n          _this.area = args.area;\r\n          _this.modifiers = args.modifiers;\r\n          _this.excludeIds = args.excludeIds;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Object)\r\n      ], AvatarModifierArea.prototype, \"area\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Array)\r\n      ], AvatarModifierArea.prototype, \"modifiers\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Array)\r\n      ], AvatarModifierArea.prototype, \"excludeIds\", void 0);\r\n      AvatarModifierArea = __decorate([\r\n          Component('engine.avatarModifierArea', exports.CLASS_ID.AVATAR_MODIFIER_AREA),\r\n          __metadata(\"design:paramtypes\", [Object])\r\n      ], AvatarModifierArea);\r\n      return AvatarModifierArea;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var Transform = /** @class */ (function (_super) {\r\n      __extends(Transform, _super);\r\n      function Transform(args) {\r\n          if (args === void 0) { args = {}; }\r\n          var _this = _super.call(this) || this;\r\n          _this.position = args.position || dist.Vector3.Zero();\r\n          _this.rotation = args.rotation || dist.Quaternion.Identity;\r\n          _this.scale = args.scale || new dist.Vector3(1, 1, 1);\r\n          return _this;\r\n      }\r\n      Object.defineProperty(Transform.prototype, \"eulerAngles\", {\r\n          /**\r\n           * @public\r\n           * The rotation as Euler angles in degrees.\r\n           */\r\n          get: function () {\r\n              return this.rotation.eulerAngles;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      /**\r\n       * @public\r\n       * Rotates the transform so the forward vector points at target's current position.\r\n       */\r\n      Transform.prototype.lookAt = function (target, worldUp) {\r\n          if (worldUp === void 0) { worldUp = dist.MathTmp.staticUp; }\r\n          var result = new dist.Matrix();\r\n          dist.Matrix.LookAtLHToRef(this.position, target, worldUp, result);\r\n          result.invert();\r\n          dist.Quaternion.FromRotationMatrixToRef(result, this.rotation);\r\n          return this;\r\n      };\r\n      /**\r\n       * @public\r\n       * Applies a rotation of euler angles around the x, y and z axis.\r\n       */\r\n      Transform.prototype.rotate = function (axis, angle) {\r\n          this.rotation.multiplyInPlace(this.rotation.angleAxis(angle, axis));\r\n          return this;\r\n      };\r\n      /**\r\n       * @public\r\n       * Moves the transform in the direction and distance of translation.\r\n       */\r\n      Transform.prototype.translate = function (vec) {\r\n          this.position.addInPlace(vec);\r\n          return this;\r\n      };\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Vector3)\r\n      ], Transform.prototype, \"position\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Quaternion)\r\n      ], Transform.prototype, \"rotation\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Vector3)\r\n      ], Transform.prototype, \"scale\", void 0);\r\n      Transform = __decorate([\r\n          Component('engine.transform', exports.CLASS_ID.TRANSFORM),\r\n          __metadata(\"design:paramtypes\", [Object])\r\n      ], Transform);\r\n      return Transform;\r\n  }(ObservableComponent));\r\n  /** @public */\r\n  exports.AttachToAvatarAnchorPointId = void 0;\r\n  (function (AttachToAvatarAnchorPointId) {\r\n      AttachToAvatarAnchorPointId[AttachToAvatarAnchorPointId[\"Position\"] = 0] = \"Position\";\r\n      AttachToAvatarAnchorPointId[AttachToAvatarAnchorPointId[\"NameTag\"] = 1] = \"NameTag\";\r\n      /** @internal */\r\n      AttachToAvatarAnchorPointId[AttachToAvatarAnchorPointId[\"LeftHand\"] = 2] = \"LeftHand\";\r\n      /** @internal */\r\n      AttachToAvatarAnchorPointId[AttachToAvatarAnchorPointId[\"RightHand\"] = 3] = \"RightHand\";\r\n  })(exports.AttachToAvatarAnchorPointId || (exports.AttachToAvatarAnchorPointId = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  var AttachToAvatar = /** @class */ (function (_super) {\r\n      __extends(AttachToAvatar, _super);\r\n      function AttachToAvatar(args) {\r\n          if (args === void 0) { args = {}; }\r\n          var _this = _super.call(this) || this;\r\n          _this.avatarId = args.avatarId || '';\r\n          _this.anchorPointId =\r\n              args.anchorPointId || exports.AttachToAvatarAnchorPointId.Position;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], AttachToAvatar.prototype, \"avatarId\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], AttachToAvatar.prototype, \"anchorPointId\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], AttachToAvatar.prototype, \"avatarSceneId\", void 0);\r\n      AttachToAvatar = __decorate([\r\n          Component('engine.transform', exports.CLASS_ID.AVATAR_ATTACH),\r\n          __metadata(\"design:paramtypes\", [Object])\r\n      ], AttachToAvatar);\r\n      return AttachToAvatar;\r\n  }(ObservableComponent));\r\n  /**\r\n   * Billboard defines a behavior that makes the entity face the camera in any moment.\r\n   * @public\r\n   */\r\n  var Billboard = /** @class */ (function (_super) {\r\n      __extends(Billboard, _super);\r\n      function Billboard(x, y, z) {\r\n          if (x === void 0) { x = true; }\r\n          if (y === void 0) { y = true; }\r\n          if (z === void 0) { z = true; }\r\n          var _this = _super.call(this) || this;\r\n          _this.x = true;\r\n          _this.y = true;\r\n          _this.z = true;\r\n          _this.x = x;\r\n          _this.y = y;\r\n          _this.z = z;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Billboard.prototype, \"x\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Billboard.prototype, \"y\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Billboard.prototype, \"z\", void 0);\r\n      Billboard = __decorate([\r\n          Component('engine.billboard', exports.CLASS_ID.BILLBOARD),\r\n          __metadata(\"design:paramtypes\", [Boolean, Boolean, Boolean])\r\n      ], Billboard);\r\n      return Billboard;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var Shape = /** @class */ (function (_super) {\r\n      __extends(Shape, _super);\r\n      function Shape() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          /**\r\n           * Set to true to turn on the collider for the entity.\r\n           */\r\n          _this.withCollisions = true;\r\n          /**\r\n           * Set to true to turn on the PointerEvents blocking for the entity.\r\n           */\r\n          _this.isPointerBlocker = true;\r\n          /**\r\n           * Defines if the entity and its children should be rendered\r\n           */\r\n          _this.visible = true;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Shape.prototype, \"withCollisions\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Shape.prototype, \"isPointerBlocker\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Shape.prototype, \"visible\", void 0);\r\n      return Shape;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var BoxShape = /** @class */ (function (_super) {\r\n      __extends(BoxShape, _super);\r\n      function BoxShape() {\r\n          return _super !== null && _super.apply(this, arguments) || this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Array)\r\n      ], BoxShape.prototype, \"uvs\", void 0);\r\n      BoxShape = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.BOX_SHAPE)\r\n      ], BoxShape);\r\n      return BoxShape;\r\n  }(Shape));\r\n  /**\r\n   * @public\r\n   */\r\n  var SphereShape = /** @class */ (function (_super) {\r\n      __extends(SphereShape, _super);\r\n      function SphereShape() {\r\n          return _super !== null && _super.apply(this, arguments) || this;\r\n      }\r\n      SphereShape = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.SPHERE_SHAPE)\r\n      ], SphereShape);\r\n      return SphereShape;\r\n  }(Shape));\r\n  /**\r\n   * @public\r\n   */\r\n  var CircleShape = /** @class */ (function (_super) {\r\n      __extends(CircleShape, _super);\r\n      function CircleShape() {\r\n          return _super !== null && _super.apply(this, arguments) || this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], CircleShape.prototype, \"segments\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], CircleShape.prototype, \"arc\", void 0);\r\n      CircleShape = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.CIRCLE_SHAPE)\r\n      ], CircleShape);\r\n      return CircleShape;\r\n  }(Shape));\r\n  /**\r\n   * @public\r\n   */\r\n  var PlaneShape = /** @class */ (function (_super) {\r\n      __extends(PlaneShape, _super);\r\n      function PlaneShape() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          /**\r\n           * Sets the horizontal length of the plane. Defaults to 1.\r\n           */\r\n          _this.width = 1;\r\n          /**\r\n           * Sets the vertical length of the plane. Defaults to 1.\r\n           */\r\n          _this.height = 1;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], PlaneShape.prototype, \"width\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], PlaneShape.prototype, \"height\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Array)\r\n      ], PlaneShape.prototype, \"uvs\", void 0);\r\n      PlaneShape = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.PLANE_SHAPE)\r\n      ], PlaneShape);\r\n      return PlaneShape;\r\n  }(Shape));\r\n  /**\r\n   * @public\r\n   */\r\n  var ConeShape = /** @class */ (function (_super) {\r\n      __extends(ConeShape, _super);\r\n      function ConeShape() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          /**\r\n           * The radius of the top of a truncated cone. Defaults to 0.\r\n           */\r\n          _this.radiusTop = 0;\r\n          /**\r\n           * The radius of the base of the cone. Defaults to 1.\r\n           */\r\n          _this.radiusBottom = 1;\r\n          /**\r\n           * Sets the number of rings along the cone height (positive integer). Defaults to 1.\r\n           */\r\n          _this.segmentsHeight = 1;\r\n          /**\r\n           * Sets the number of cone sides (positive integer). Defaults to 36.\r\n           */\r\n          _this.segmentsRadial = 36;\r\n          /**\r\n           * Adds two extra faces per subdivision to enclose the cone around its height axis.\r\n           * Defaults to false.\r\n           */\r\n          _this.openEnded = false;\r\n          /**\r\n           * Sets the radius of the top and bottom caps at once.\r\n           *\r\n           * Properties `radiusTop` and `radiusBottom` are prioritized over this one.\r\n           */\r\n          _this.radius = null;\r\n          /**\r\n           * Sets the ratio (max 1) to apply to the circumference to slice the cone. Defaults to 360.\r\n           */\r\n          _this.arc = 360;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], ConeShape.prototype, \"radiusTop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], ConeShape.prototype, \"radiusBottom\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], ConeShape.prototype, \"segmentsHeight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], ConeShape.prototype, \"segmentsRadial\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], ConeShape.prototype, \"openEnded\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Object)\r\n      ], ConeShape.prototype, \"radius\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], ConeShape.prototype, \"arc\", void 0);\r\n      ConeShape = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.CONE_SHAPE)\r\n      ], ConeShape);\r\n      return ConeShape;\r\n  }(Shape));\r\n  /**\r\n   * @public\r\n   */\r\n  var CylinderShape = /** @class */ (function (_super) {\r\n      __extends(CylinderShape, _super);\r\n      function CylinderShape() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          /**\r\n           * The radius of the top of the cylinder. Defaults to 0.\r\n           */\r\n          _this.radiusTop = 1;\r\n          /**\r\n           * The radius of the base of the cylinder. Defaults to 1.\r\n           */\r\n          _this.radiusBottom = 1;\r\n          /**\r\n           * Sets the number of rings along the cylinder height (positive integer). Defaults to 1.\r\n           */\r\n          _this.segmentsHeight = 1;\r\n          /**\r\n           * Sets the number of cylinder sides (positive integer). Defaults to 36.\r\n           */\r\n          _this.segmentsRadial = 36;\r\n          /**\r\n           * Adds two extra faces per subdivision to enclose the cylinder around its height axis.\r\n           * Defaults to false.\r\n           */\r\n          _this.openEnded = false;\r\n          /**\r\n           * Sets the radius of the top and bottom caps at once.\r\n           *\r\n           * Properties `radiusTop` and `radiusBottom` are prioritized over this one.\r\n           */\r\n          _this.radius = null;\r\n          /**\r\n           * Sets the ratio (max 1) to apply to the circumference to slice the cylinder. Defaults to 360.\r\n           */\r\n          _this.arc = 360;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], CylinderShape.prototype, \"radiusTop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], CylinderShape.prototype, \"radiusBottom\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], CylinderShape.prototype, \"segmentsHeight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], CylinderShape.prototype, \"segmentsRadial\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], CylinderShape.prototype, \"openEnded\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Object)\r\n      ], CylinderShape.prototype, \"radius\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], CylinderShape.prototype, \"arc\", void 0);\r\n      CylinderShape = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.CYLINDER_SHAPE)\r\n      ], CylinderShape);\r\n      return CylinderShape;\r\n  }(Shape));\r\n  /**\r\n   * @public\r\n   */\r\n  var GLTFShape = /** @class */ (function (_super) {\r\n      __extends(GLTFShape, _super);\r\n      function GLTFShape(src) {\r\n          var _this = _super.call(this) || this;\r\n          _this.src = src;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          Shape.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], GLTFShape.prototype, \"src\", void 0);\r\n      GLTFShape = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.GLTF_SHAPE),\r\n          __metadata(\"design:paramtypes\", [String])\r\n      ], GLTFShape);\r\n      return GLTFShape;\r\n  }(Shape));\r\n  /** @public */\r\n  exports.PictureFrameStyle = void 0;\r\n  (function (PictureFrameStyle) {\r\n      PictureFrameStyle[PictureFrameStyle[\"Classic\"] = 0] = \"Classic\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Baroque_Ornament\"] = 1] = \"Baroque_Ornament\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Diamond_Ornament\"] = 2] = \"Diamond_Ornament\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Minimal_Wide\"] = 3] = \"Minimal_Wide\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Minimal_Grey\"] = 4] = \"Minimal_Grey\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Blocky\"] = 5] = \"Blocky\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Gold_Edges\"] = 6] = \"Gold_Edges\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Gold_Carved\"] = 7] = \"Gold_Carved\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Gold_Wide\"] = 8] = \"Gold_Wide\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Gold_Rounded\"] = 9] = \"Gold_Rounded\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Metal_Medium\"] = 10] = \"Metal_Medium\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Metal_Wide\"] = 11] = \"Metal_Wide\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Metal_Slim\"] = 12] = \"Metal_Slim\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Metal_Rounded\"] = 13] = \"Metal_Rounded\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Pins\"] = 14] = \"Pins\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Minimal_Black\"] = 15] = \"Minimal_Black\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Minimal_White\"] = 16] = \"Minimal_White\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Tape\"] = 17] = \"Tape\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Wood_Slim\"] = 18] = \"Wood_Slim\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Wood_Wide\"] = 19] = \"Wood_Wide\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Wood_Twigs\"] = 20] = \"Wood_Twigs\";\r\n      PictureFrameStyle[PictureFrameStyle[\"Canvas\"] = 21] = \"Canvas\";\r\n      PictureFrameStyle[PictureFrameStyle[\"None\"] = 22] = \"None\";\r\n  })(exports.PictureFrameStyle || (exports.PictureFrameStyle = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  var NFTShape = /** @class */ (function (_super) {\r\n      __extends(NFTShape, _super);\r\n      function NFTShape(src, args) {\r\n          if (args === void 0) { args = {}; }\r\n          var _this = _super.call(this) || this;\r\n          _this.src = src;\r\n          var color = new dist.Color3(0.6404918, 0.611472, 0.8584906);\r\n          var style = exports.PictureFrameStyle.Classic;\r\n          // check if args is color (backwards compatibility)\r\n          if ('r' in args) {\r\n              color = args;\r\n          }\r\n          else if (args !== null) {\r\n              if (args.color)\r\n                  color = args.color;\r\n              if (args.style)\r\n                  style = args.style;\r\n          }\r\n          _this.color = color;\r\n          _this.style = style;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          Shape.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], NFTShape.prototype, \"src\", void 0);\r\n      __decorate([\r\n          Shape.readonly,\r\n          __metadata(\"design:type\", Number)\r\n      ], NFTShape.prototype, \"style\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color3)\r\n      ], NFTShape.prototype, \"color\", void 0);\r\n      NFTShape = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.NFT_SHAPE),\r\n          __metadata(\"design:paramtypes\", [String, Object])\r\n      ], NFTShape);\r\n      return NFTShape;\r\n  }(Shape));\r\n  /**\r\n   * @public\r\n   */\r\n  var Texture = /** @class */ (function (_super) {\r\n      __extends(Texture, _super);\r\n      function Texture(src, opts) {\r\n          var _this = _super.call(this) || this;\r\n          var base64Test = new RegExp('data:[a-z-]+/[a-z-]+;base64');\r\n          if (src.length > 2048 || base64Test.test(src)) {\r\n              log('âš ï¸ðŸš¨ Base64 textures will be deprecated in version 7 of decentraland-ecs');\r\n          }\r\n          _this.src = src;\r\n          if (opts) {\r\n              for (var i in opts) {\r\n                  var that = _this;\r\n                  that[i] = opts[i];\r\n              }\r\n          }\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], Texture.prototype, \"src\", void 0);\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", Number)\r\n      ], Texture.prototype, \"samplingMode\", void 0);\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", Number)\r\n      ], Texture.prototype, \"wrap\", void 0);\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Texture.prototype, \"hasAlpha\", void 0);\r\n      Texture = __decorate([\r\n          DisposableComponent('engine.texture', exports.CLASS_ID.TEXTURE),\r\n          __metadata(\"design:paramtypes\", [String, Object])\r\n      ], Texture);\r\n      return Texture;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var Animator = /** @class */ (function (_super) {\r\n      __extends(Animator, _super);\r\n      function Animator() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.states = [];\r\n          return _this;\r\n      }\r\n      /**\r\n       * Adds an AnimationState to the animation lists.\r\n       */\r\n      Animator.prototype.addClip = function (clip) {\r\n          var _this = this;\r\n          this.states.push(clip);\r\n          clip.onChange(function () {\r\n              _this.dirty = true;\r\n          });\r\n          clip.owner = this;\r\n          return this;\r\n      };\r\n      /**\r\n       * Gets the animation clip instance for the specified clip name.\r\n       * If the clip doesn't exist a new one will be created.\r\n       */\r\n      Animator.prototype.getClip = function (clipName) {\r\n          for (var i = 0; i < this.states.length; i++) {\r\n              var clip = this.states[i];\r\n              if (clip.clip === clipName) {\r\n                  return clip;\r\n              }\r\n          }\r\n          var newClip = new AnimationState(clipName);\r\n          this.addClip(newClip);\r\n          return newClip;\r\n      };\r\n      /**\r\n       * Resets and pauses the animation state, if the clip is null it will stop all animations on this animator\r\n       */\r\n      Animator.prototype.stop = function (clip) {\r\n          if (clip) {\r\n              clip.playing = false;\r\n              clip.shouldReset = true;\r\n          }\r\n          else {\r\n              for (var i = 0; i < this.states.length; i++) {\r\n                  var animationState = this.states[i];\r\n                  this.stop(animationState);\r\n              }\r\n          }\r\n      };\r\n      /**\r\n       * Starts the animation\r\n       */\r\n      Animator.prototype.play = function (clip, reset) {\r\n          if (reset === void 0) { reset = false; }\r\n          for (var i = 0; i < this.states.length; i++) {\r\n              var animationState = this.states[i];\r\n              if (animationState.layer === clip.layer && clip !== animationState) {\r\n                  this.pause(animationState);\r\n              }\r\n          }\r\n          if (reset)\r\n              clip.shouldReset = true;\r\n          clip.playing = true;\r\n          clip.dirty = true;\r\n          clip.data.nonce = Math.random();\r\n      };\r\n      /**\r\n       * Pauses the animation state, if the clip is null it will pause all animations on this animator\r\n       */\r\n      Animator.prototype.pause = function (clip) {\r\n          if (clip) {\r\n              clip.playing = false;\r\n          }\r\n          else {\r\n              for (var i = 0; i < this.states.length; i++) {\r\n                  var animationState = this.states[i];\r\n                  this.pause(animationState);\r\n              }\r\n          }\r\n      };\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", Array)\r\n      ], Animator.prototype, \"states\", void 0);\r\n      Animator = __decorate([\r\n          Component('engine.animator', exports.CLASS_ID.ANIMATION)\r\n      ], Animator);\r\n      return Animator;\r\n  }(Shape));\r\n  /**\r\n   * @public\r\n   */\r\n  var OBJShape = /** @class */ (function (_super) {\r\n      __extends(OBJShape, _super);\r\n      function OBJShape(src) {\r\n          var _this = _super.call(this) || this;\r\n          _this.src = src;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OBJShape.prototype, \"src\", void 0);\r\n      OBJShape = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.OBJ_SHAPE),\r\n          __metadata(\"design:paramtypes\", [String])\r\n      ], OBJShape);\r\n      return OBJShape;\r\n  }(Shape));\r\n  /**\r\n   * @public\r\n   */\r\n  var Font = /** @class */ (function (_super) {\r\n      __extends(Font, _super);\r\n      function Font(src) {\r\n          if (src === void 0) { src = ''; }\r\n          var _this = _super.call(this) || this;\r\n          _this.src = src;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], Font.prototype, \"src\", void 0);\r\n      Font = __decorate([\r\n          DisposableComponent('engine.font', exports.CLASS_ID.FONT),\r\n          __metadata(\"design:paramtypes\", [String])\r\n      ], Font);\r\n      return Font;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  exports.Fonts = void 0;\r\n  (function (Fonts) {\r\n      /** @deprecated SanFrancisco has been deprecated. Use SansSerif instead.*/\r\n      Fonts[\"SanFrancisco\"] = \"builtin:SF-UI-Text-Regular SDF\";\r\n      /** @deprecated SanFrancisco_Heavy has been deprecated. Use SansSerif_Heavy instead.*/\r\n      Fonts[\"SanFrancisco_Heavy\"] = \"builtin:SF-UI-Text-Heavy SDF\";\r\n      /** @deprecated SanFrancisco_Semibold has been deprecated. Use SansSerif_SemiBold instead.*/\r\n      Fonts[\"SanFrancisco_Semibold\"] = \"builtin:SF-UI-Text-Semibold SDF\";\r\n      Fonts[\"LiberationSans\"] = \"builtin:LiberationSans SDF\";\r\n      Fonts[\"SansSerif\"] = \"SansSerif\";\r\n      Fonts[\"SansSerif_Heavy\"] = \"SansSerif_Heavy\";\r\n      Fonts[\"SansSerif_Bold\"] = \"SansSerif_Bold\";\r\n      Fonts[\"SansSerif_SemiBold\"] = \"SansSerif_SemiBold\";\r\n  })(exports.Fonts || (exports.Fonts = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  var TextShape = /** @class */ (function (_super) {\r\n      __extends(TextShape, _super);\r\n      function TextShape(value) {\r\n          var _this = _super.call(this) || this;\r\n          _this.outlineWidth = 0;\r\n          _this.outlineColor = new dist.Color3(1, 1, 1);\r\n          _this.color = new dist.Color3(1, 1, 1);\r\n          _this.fontSize = 10;\r\n          _this.opacity = 1.0;\r\n          _this.value = '';\r\n          _this.lineSpacing = '0px';\r\n          _this.lineCount = 0;\r\n          _this.textWrapping = false;\r\n          _this.shadowBlur = 0;\r\n          _this.shadowOffsetX = 0;\r\n          _this.shadowOffsetY = 0;\r\n          _this.shadowColor = new dist.Color3(1, 1, 1);\r\n          _this.hTextAlign = 'center';\r\n          _this.vTextAlign = 'center';\r\n          _this.width = 1;\r\n          _this.height = 1;\r\n          _this.paddingTop = 0;\r\n          _this.paddingRight = 0;\r\n          _this.paddingBottom = 0;\r\n          _this.paddingLeft = 0;\r\n          _this.billboard = false;\r\n          _this.visible = true;\r\n          if (value) {\r\n              _this.value = value;\r\n          }\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"outlineWidth\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color3)\r\n      ], TextShape.prototype, \"outlineColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color3)\r\n      ], TextShape.prototype, \"color\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"fontSize\", void 0);\r\n      __decorate([\r\n          ObservableComponent.component,\r\n          __metadata(\"design:type\", Font)\r\n      ], TextShape.prototype, \"font\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"opacity\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], TextShape.prototype, \"value\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], TextShape.prototype, \"lineSpacing\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"lineCount\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], TextShape.prototype, \"textWrapping\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"shadowBlur\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"shadowOffsetX\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"shadowOffsetY\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color3)\r\n      ], TextShape.prototype, \"shadowColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], TextShape.prototype, \"hTextAlign\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], TextShape.prototype, \"vTextAlign\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"width\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"height\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"paddingTop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"paddingRight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"paddingBottom\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], TextShape.prototype, \"paddingLeft\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], TextShape.prototype, \"billboard\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], TextShape.prototype, \"visible\", void 0);\r\n      TextShape = __decorate([\r\n          Component('engine.text', exports.CLASS_ID.TEXT_SHAPE),\r\n          __metadata(\"design:paramtypes\", [String])\r\n      ], TextShape);\r\n      return TextShape;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  exports.TransparencyMode = void 0;\r\n  (function (TransparencyMode) {\r\n      TransparencyMode[TransparencyMode[\"OPAQUE\"] = 0] = \"OPAQUE\";\r\n      TransparencyMode[TransparencyMode[\"ALPHA_TEST\"] = 1] = \"ALPHA_TEST\";\r\n      TransparencyMode[TransparencyMode[\"ALPHA_BLEND\"] = 2] = \"ALPHA_BLEND\";\r\n      TransparencyMode[TransparencyMode[\"ALPHA_TEST_AND_BLEND\"] = 3] = \"ALPHA_TEST_AND_BLEND\";\r\n      TransparencyMode[TransparencyMode[\"AUTO\"] = 4] = \"AUTO\";\r\n  })(exports.TransparencyMode || (exports.TransparencyMode = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  var Material = /** @class */ (function (_super) {\r\n      __extends(Material, _super);\r\n      function Material() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          /**\r\n           * Cutoff level for ALPHATEST mode. Range is between 0 and 1.\r\n           * Defaults to 0.5\r\n           */\r\n          _this.alphaTest = 0.5;\r\n          /**\r\n           * Allow the material to cast shadows over other objects\r\n           */\r\n          _this.castShadows = true;\r\n          /**\r\n           * Sets the transparency mode of the material.\r\n           * Defaults to -1.\r\n           *\r\n           * | Value | Type                                           |\r\n           * | ----- | ---------------------------------------------- |\r\n           * | 0     | OPAQUE  (default)                              |\r\n           * | 1     | ALPHATEST                                      |\r\n           * | 2     | ALPHABLEND                                     |\r\n           * | 3     | ALPHATESTANDBLEND                              |\r\n           * | 4     | AUTO (ALPHABLEND if alpha OPAQUE otherwise     |\r\n           */\r\n          _this.transparencyMode = exports.TransparencyMode.AUTO;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], Material.prototype, \"alphaTest\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Object)\r\n      ], Material.prototype, \"albedoColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color3\r\n          /**\r\n           * Specifies the metallic scalar of the metallic/roughness workflow.\r\n           * Can also be used to scale the metalness values of the metallic texture.\r\n           * Defaults to  0.5.\r\n           */\r\n          )\r\n      ], Material.prototype, \"emissiveColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], Material.prototype, \"metallic\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], Material.prototype, \"roughness\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color3\r\n          /**\r\n           * Intensity of the direct lights e.g. the four lights available in scene.\r\n           * This impacts both the direct diffuse and specular highlights.\r\n           * Defaults to 1.\r\n           */\r\n          )\r\n      ], Material.prototype, \"reflectivityColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], Material.prototype, \"directIntensity\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], Material.prototype, \"microSurface\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], Material.prototype, \"emissiveIntensity\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], Material.prototype, \"specularIntensity\", void 0);\r\n      __decorate([\r\n          ObservableComponent.component,\r\n          __metadata(\"design:type\", Object)\r\n      ], Material.prototype, \"albedoTexture\", void 0);\r\n      __decorate([\r\n          ObservableComponent.component,\r\n          __metadata(\"design:type\", Object)\r\n      ], Material.prototype, \"alphaTexture\", void 0);\r\n      __decorate([\r\n          ObservableComponent.component,\r\n          __metadata(\"design:type\", Object)\r\n      ], Material.prototype, \"emissiveTexture\", void 0);\r\n      __decorate([\r\n          ObservableComponent.component,\r\n          __metadata(\"design:type\", Object)\r\n      ], Material.prototype, \"bumpTexture\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Material.prototype, \"castShadows\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], Material.prototype, \"transparencyMode\", void 0);\r\n      Material = __decorate([\r\n          DisposableComponent('engine.material', exports.CLASS_ID.PBR_MATERIAL)\r\n      ], Material);\r\n      return Material;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var BasicMaterial = /** @class */ (function (_super) {\r\n      __extends(BasicMaterial, _super);\r\n      function BasicMaterial() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          /**\r\n           * A number between 0 and 1.\r\n           * Any pixel with an alpha lower than this value will be shown as transparent.\r\n           */\r\n          _this.alphaTest = 0.5;\r\n          /**\r\n           * Allow the material to cast shadows over other objects\r\n           */\r\n          _this.castShadows = true;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.component,\r\n          __metadata(\"design:type\", Object)\r\n      ], BasicMaterial.prototype, \"texture\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], BasicMaterial.prototype, \"alphaTest\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], BasicMaterial.prototype, \"castShadows\", void 0);\r\n      BasicMaterial = __decorate([\r\n          DisposableComponent('engine.material', exports.CLASS_ID.BASIC_MATERIAL)\r\n      ], BasicMaterial);\r\n      return BasicMaterial;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnUUIDEvent = /** @class */ (function (_super) {\r\n      __extends(OnUUIDEvent, _super);\r\n      function OnUUIDEvent(callback) {\r\n          var _this = _super.call(this) || this;\r\n          // @internal\r\n          _this.uuid = newId('UUID');\r\n          if (!callback || !('apply' in callback) || !('call' in callback)) {\r\n              throw new Error('Callback is not a function');\r\n          }\r\n          _this.callback = callback;\r\n          return _this;\r\n      }\r\n      OnUUIDEvent.uuidEvent = function (target, propertyKey) {\r\n          if (delete target[propertyKey]) {\r\n              var componentSymbol_1 = propertyKey + '_' + Math.random();\r\n              target[componentSymbol_1] = undefined;\r\n              Object.defineProperty(target, componentSymbol_1, __assign(__assign({}, Object.getOwnPropertyDescriptor(target, componentSymbol_1)), { enumerable: false }));\r\n              Object.defineProperty(target, propertyKey.toString(), {\r\n                  get: function () {\r\n                      return this[componentSymbol_1];\r\n                  },\r\n                  set: function (value) {\r\n                      var oldValue = this[componentSymbol_1];\r\n                      if (value) {\r\n                          if (value instanceof OnUUIDEvent) {\r\n                              this.data[propertyKey] = value.uuid;\r\n                          }\r\n                          else {\r\n                              throw new Error('value is not an OnUUIDEvent');\r\n                          }\r\n                      }\r\n                      else {\r\n                          this.data[propertyKey] = null;\r\n                      }\r\n                      this[componentSymbol_1] = value;\r\n                      if (value !== oldValue) {\r\n                          this.dirty = true;\r\n                          for (var i = 0; i < this.subscriptions.length; i++) {\r\n                              this.subscriptions[i](propertyKey, value, oldValue);\r\n                          }\r\n                      }\r\n                  },\r\n                  enumerable: true\r\n              });\r\n          }\r\n      };\r\n      OnUUIDEvent.prototype.toJSON = function () {\r\n          return { uuid: this.uuid, type: this.type };\r\n      };\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Function)\r\n      ], OnUUIDEvent.prototype, \"callback\", void 0);\r\n      return OnUUIDEvent;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnPointerUUIDEvent = /** @class */ (function (_super) {\r\n      __extends(OnPointerUUIDEvent, _super);\r\n      function OnPointerUUIDEvent() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.button = exports.ActionButton.ANY;\r\n          _this.hoverText = 'Interact';\r\n          _this.distance = 10;\r\n          _this.showFeedback = true;\r\n          return _this;\r\n      }\r\n      OnPointerUUIDEvent.prototype.toJSON = function () {\r\n          return {\r\n              uuid: this.uuid,\r\n              type: this.type,\r\n              button: this.button,\r\n              hoverText: this.hoverText,\r\n              distance: this.distance,\r\n              showFeedback: this.showFeedback\r\n          };\r\n      };\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], OnPointerUUIDEvent.prototype, \"button\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], OnPointerUUIDEvent.prototype, \"hoverText\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], OnPointerUUIDEvent.prototype, \"distance\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], OnPointerUUIDEvent.prototype, \"showFeedback\", void 0);\r\n      return OnPointerUUIDEvent;\r\n  }(OnUUIDEvent));\r\n  /**\r\n   * @internal\r\n   */\r\n  var OnPointerLock = /** @class */ (function (_super) {\r\n      __extends(OnPointerLock, _super);\r\n      function OnPointerLock() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.type = 'onPointerLock';\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnPointerLock.prototype, \"type\", void 0);\r\n      OnPointerLock = __decorate([\r\n          Component('engine.onPointerLock', exports.CLASS_ID.UUID_CALLBACK)\r\n      ], OnPointerLock);\r\n      return OnPointerLock;\r\n  }(OnUUIDEvent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnAnimationEnd = /** @class */ (function (_super) {\r\n      __extends(OnAnimationEnd, _super);\r\n      function OnAnimationEnd() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.type = 'onAnimationEnd';\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnAnimationEnd.prototype, \"type\", void 0);\r\n      OnAnimationEnd = __decorate([\r\n          Component('engine.onAnimationEnd', exports.CLASS_ID.UUID_CALLBACK)\r\n      ], OnAnimationEnd);\r\n      return OnAnimationEnd;\r\n  }(OnUUIDEvent));\r\n  /**\r\n   * @internal\r\n   */\r\n  var SmartItem = /** @class */ (function (_super) {\r\n      __extends(SmartItem, _super);\r\n      function SmartItem() {\r\n          return _super !== null && _super.apply(this, arguments) || this;\r\n      }\r\n      SmartItem = __decorate([\r\n          Component('engine.smartItem', exports.CLASS_ID.SMART_ITEM)\r\n      ], SmartItem);\r\n      return SmartItem;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var VideoClip = /** @class */ (function (_super) {\r\n      __extends(VideoClip, _super);\r\n      function VideoClip(url) {\r\n          var _this = _super.call(this) || this;\r\n          _this.url = url;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], VideoClip.prototype, \"url\", void 0);\r\n      VideoClip = __decorate([\r\n          DisposableComponent('engine.VideoClip', exports.CLASS_ID.VIDEO_CLIP),\r\n          __metadata(\"design:paramtypes\", [String])\r\n      ], VideoClip);\r\n      return VideoClip;\r\n  }(ObservableComponent));\r\n  /** @public */\r\n  exports.VideoStatus = void 0;\r\n  (function (VideoStatus) {\r\n      VideoStatus[VideoStatus[\"NONE\"] = 0] = \"NONE\";\r\n      VideoStatus[VideoStatus[\"ERROR\"] = 1] = \"ERROR\";\r\n      VideoStatus[VideoStatus[\"LOADING\"] = 2] = \"LOADING\";\r\n      VideoStatus[VideoStatus[\"READY\"] = 3] = \"READY\";\r\n      VideoStatus[VideoStatus[\"PLAYING\"] = 4] = \"PLAYING\";\r\n      VideoStatus[VideoStatus[\"BUFFERING\"] = 5] = \"BUFFERING\";\r\n  })(exports.VideoStatus || (exports.VideoStatus = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  var VideoTexture = /** @class */ (function (_super) {\r\n      __extends(VideoTexture, _super);\r\n      function VideoTexture(videoClip, opts) {\r\n          var _this = _super.call(this) || this;\r\n          _this.volume = 1;\r\n          _this.playbackRate = 1;\r\n          _this.loop = false;\r\n          _this.seek = -1;\r\n          _this._position = -1;\r\n          _this._videoLength = -1;\r\n          _this._status = exports.VideoStatus.NONE;\r\n          /**\r\n           * Is this VideoTexture playing?\r\n           */\r\n          _this.playing = false;\r\n          if (!(videoClip instanceof VideoClip)) {\r\n              throw new Error(\"Trying to create VideoTexture(VideoClip) with an invalid VideoClip\");\r\n          }\r\n          _this.videoClipId = getComponentId(videoClip);\r\n          if (opts) {\r\n              for (var i in opts) {\r\n                  var that = _this;\r\n                  that[i] = opts[i];\r\n              }\r\n          }\r\n          return _this;\r\n      }\r\n      VideoTexture.prototype.play = function () {\r\n          this.playing = true;\r\n      };\r\n      VideoTexture.prototype.pause = function () {\r\n          this.playing = false;\r\n      };\r\n      VideoTexture.prototype.reset = function () {\r\n          this.seekTime(0);\r\n          this.pause();\r\n      };\r\n      VideoTexture.prototype.seekTime = function (seconds) {\r\n          this.seek = seconds;\r\n          this.dirty = true;\r\n          this.data.nonce = Math.random();\r\n      };\r\n      VideoTexture.prototype.toJSON = function () {\r\n          if (this.seek >= 0) {\r\n              // the seek value was changed/used\r\n              var ret = JSON.parse(JSON.stringify(_super.prototype.toJSON.call(this)));\r\n              this.seek = -1;\r\n              return ret;\r\n          }\r\n          return _super.prototype.toJSON.call(this);\r\n      };\r\n      VideoTexture.prototype.update = function (videoEvent) {\r\n          if (videoEvent.videoClipId === this.videoClipId) {\r\n              this._status = videoEvent.videoStatus || exports.VideoStatus.NONE;\r\n              this._videoLength = videoEvent.totalVideoLength;\r\n              this._position = videoEvent.currentOffset;\r\n          }\r\n      };\r\n      Object.defineProperty(VideoTexture.prototype, \"position\", {\r\n          get: function () {\r\n              return this._position;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      Object.defineProperty(VideoTexture.prototype, \"videoLength\", {\r\n          get: function () {\r\n              return this._videoLength;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      Object.defineProperty(VideoTexture.prototype, \"status\", {\r\n          get: function () {\r\n              return this._status;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], VideoTexture.prototype, \"videoClipId\", void 0);\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", Number)\r\n      ], VideoTexture.prototype, \"samplingMode\", void 0);\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", Number)\r\n      ], VideoTexture.prototype, \"wrap\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], VideoTexture.prototype, \"volume\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], VideoTexture.prototype, \"playbackRate\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], VideoTexture.prototype, \"loop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], VideoTexture.prototype, \"seek\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], VideoTexture.prototype, \"playing\", void 0);\r\n      VideoTexture = __decorate([\r\n          DisposableComponent('engine.VideoTexture', exports.CLASS_ID.VIDEO_TEXTURE),\r\n          __metadata(\"design:paramtypes\", [VideoClip, Object])\r\n      ], VideoTexture);\r\n      return VideoTexture;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var CameraModeArea = /** @class */ (function (_super) {\r\n      __extends(CameraModeArea, _super);\r\n      function CameraModeArea(args) {\r\n          var _this = _super.call(this) || this;\r\n          _this.area = args.area;\r\n          _this.cameraMode = args.cameraMode;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Object)\r\n      ], CameraModeArea.prototype, \"area\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], CameraModeArea.prototype, \"cameraMode\", void 0);\r\n      CameraModeArea = __decorate([\r\n          Component('engine.cameraModeArea', exports.CLASS_ID.CAMERA_MODE_AREA),\r\n          __metadata(\"design:paramtypes\", [Object])\r\n      ], CameraModeArea);\r\n      return CameraModeArea;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var AvatarTexture = /** @class */ (function (_super) {\r\n      __extends(AvatarTexture, _super);\r\n      function AvatarTexture(userId, opts) {\r\n          var _this = _super.call(this) || this;\r\n          _this.userId = userId;\r\n          if (opts) {\r\n              for (var i in opts) {\r\n                  var that = _this;\r\n                  that[i] = opts[i];\r\n              }\r\n          }\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], AvatarTexture.prototype, \"userId\", void 0);\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", Number)\r\n      ], AvatarTexture.prototype, \"samplingMode\", void 0);\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", Number)\r\n      ], AvatarTexture.prototype, \"wrap\", void 0);\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AvatarTexture.prototype, \"hasAlpha\", void 0);\r\n      AvatarTexture = __decorate([\r\n          DisposableComponent('engine.texture', exports.CLASS_ID.AVATAR_TEXTURE),\r\n          __metadata(\"design:paramtypes\", [String, Object])\r\n      ], AvatarTexture);\r\n      return AvatarTexture;\r\n  }(ObservableComponent));\n\n  /**\r\n   * @public\r\n   */\r\n  var Camera = /** @class */ (function () {\r\n      function Camera() {\r\n          var _this = this;\r\n          /** Camera position, relative to the parcel. */\r\n          this.position = new dist.Vector3();\r\n          /** Camera rotation */\r\n          this.rotation = new dist.Quaternion();\r\n          /** Feet position, relative to the parcel.  */\r\n          this.feetPosition = new dist.Vector3();\r\n          /** Camera position, absolute. */\r\n          this.worldPosition = new dist.Vector3();\r\n          // @internal\r\n          this.lastEventPosition = { x: 0, y: 0, z: 0 };\r\n          // @internal\r\n          this.lastEventWorldPosition = { x: 0, y: 0, z: 0 };\r\n          // @internal\r\n          this.lastEventRotation = { x: 0, y: 0, z: 0, w: 1.0 };\r\n          // @internal\r\n          this._playerHeight = 1.6;\r\n          // @internal\r\n          this._cameraMode = exports.CameraMode.ThirdPerson;\r\n          if (typeof dcl !== 'undefined') {\r\n              dcl.subscribe('positionChanged');\r\n              dcl.subscribe('rotationChanged');\r\n              dcl.subscribe('cameraModeChanged');\r\n              dcl.onEvent(function (event) {\r\n                  switch (event.type) {\r\n                      case 'positionChanged':\r\n                          _this.positionChanged(event.data);\r\n                          break;\r\n                      case 'rotationChanged':\r\n                          _this.rotationChanged(event.data);\r\n                          break;\r\n                      case 'cameraModeChanged':\r\n                          _this.cameraModeChanged(event.data);\r\n                          break;\r\n                  }\r\n              });\r\n          }\r\n          Object.defineProperty(this.position, 'x', {\r\n              get: function () { return _this.lastEventPosition.x; }\r\n          });\r\n          Object.defineProperty(this.position, 'y', {\r\n              get: function () { return _this.lastEventPosition.y; }\r\n          });\r\n          Object.defineProperty(this.position, 'z', {\r\n              get: function () { return _this.lastEventPosition.z; }\r\n          });\r\n          Object.defineProperty(this.worldPosition, 'x', {\r\n              get: function () { return _this.lastEventWorldPosition.x; }\r\n          });\r\n          Object.defineProperty(this.worldPosition, 'y', {\r\n              get: function () { return _this.lastEventWorldPosition.y; }\r\n          });\r\n          Object.defineProperty(this.worldPosition, 'z', {\r\n              get: function () { return _this.lastEventWorldPosition.z; }\r\n          });\r\n          Object.defineProperty(this.feetPosition, 'x', {\r\n              get: function () { return _this.lastEventPosition.x; }\r\n          });\r\n          Object.defineProperty(this.feetPosition, 'y', {\r\n              get: function () { return _this.lastEventPosition.y - _this.playerHeight; }\r\n          });\r\n          Object.defineProperty(this.feetPosition, 'z', {\r\n              get: function () { return _this.lastEventPosition.z; }\r\n          });\r\n          Object.defineProperty(this.rotation, 'x', {\r\n              get: function () { return _this.lastEventRotation.x; }\r\n          });\r\n          Object.defineProperty(this.rotation, 'y', {\r\n              get: function () { return _this.lastEventRotation.y; }\r\n          });\r\n          Object.defineProperty(this.rotation, 'z', {\r\n              get: function () { return _this.lastEventRotation.z; }\r\n          });\r\n          Object.defineProperty(this.rotation, 'w', {\r\n              get: function () { return _this.lastEventRotation.w; }\r\n          });\r\n      }\r\n      Object.defineProperty(Camera, \"instance\", {\r\n          get: function () {\r\n              if (!Camera._instance) {\r\n                  Camera._instance = new Camera();\r\n              }\r\n              return Camera._instance;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      Object.defineProperty(Camera.prototype, \"playerHeight\", {\r\n          /** Player height. */\r\n          get: function () {\r\n              return this._playerHeight;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      Object.defineProperty(Camera.prototype, \"cameraMode\", {\r\n          /** @deprecated Use onCameraModeChangedObservable Observable instead. */\r\n          get: function () {\r\n              return this._cameraMode;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      // @internal\r\n      Camera.prototype.positionChanged = function (e) {\r\n          this.lastEventPosition = e.position;\r\n          this.lastEventWorldPosition = e.cameraPosition;\r\n          this._playerHeight = e.playerHeight;\r\n      };\r\n      // @internal\r\n      Camera.prototype.rotationChanged = function (e) {\r\n          this.lastEventRotation = e.quaternion;\r\n      };\r\n      // @internal\r\n      Camera.prototype.cameraModeChanged = function (e) {\r\n          this._cameraMode = e.cameraMode;\r\n      };\r\n      return Camera;\r\n  }());\n\n  /**\r\n   * @internal\r\n   */\r\n  var QueryPrefix;\r\n  (function (QueryPrefix) {\r\n      QueryPrefix[\"HitFirst\"] = \"rqhf\";\r\n      QueryPrefix[\"HitAll\"] = \"rqha\";\r\n  })(QueryPrefix || (QueryPrefix = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  var PhysicsCast = /** @class */ (function () {\r\n      function PhysicsCast() {\r\n          this.queries = {};\r\n      }\r\n      Object.defineProperty(PhysicsCast, \"instance\", {\r\n          get: function () {\r\n              PhysicsCast.ensureInstance();\r\n              return PhysicsCast._instance;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      PhysicsCast.ensureInstance = function () {\r\n          if (!PhysicsCast._instance) {\r\n              PhysicsCast._instance = new PhysicsCast();\r\n          }\r\n      };\r\n      PhysicsCast.prototype.getRayFromCamera = function (distance) {\r\n          var rotation = Camera.instance.rotation;\r\n          var rotationMat = dist.Matrix.Identity();\r\n          rotation.toRotationMatrix(rotationMat);\r\n          var direction = dist.Vector3.TransformCoordinates(dist.Vector3.Forward(), rotationMat);\r\n          var ray = {\r\n              origin: Camera.instance.position,\r\n              direction: direction,\r\n              distance: distance\r\n          };\r\n          return ray;\r\n      };\r\n      PhysicsCast.prototype.getRayFromPositions = function (from, to) {\r\n          var direction = to.subtract(from);\r\n          var length = direction.length();\r\n          var ray = {\r\n              origin: from,\r\n              direction: direction.normalize(),\r\n              distance: length\r\n          };\r\n          return ray;\r\n      };\r\n      PhysicsCast.prototype.hitFirst = function (ray, hitCallback, id) {\r\n          var queryId = typeof id === 'number' ? QueryPrefix.HitFirst + id : uuid();\r\n          this.queries[queryId] = hitCallback;\r\n          if (typeof dcl !== 'undefined') {\r\n              dcl.query('raycast', { queryId: queryId, queryType: 'HitFirst', ray: ray });\r\n          }\r\n      };\r\n      PhysicsCast.prototype.hitAll = function (ray, hitCallback, id) {\r\n          var queryId = typeof id === 'number' ? QueryPrefix.HitAll + id : uuid();\r\n          this.queries[queryId] = hitCallback;\r\n          if (typeof dcl !== 'undefined') {\r\n              dcl.query('raycast', { queryId: queryId, queryType: 'HitAll', ray: ray });\r\n          }\r\n      };\r\n      PhysicsCast.prototype.hitFirstAvatar = function (_ray, _hitCallback) {\r\n          log('not implemented yet');\r\n      };\r\n      PhysicsCast.prototype.hitAllAvatars = function (_ray, _hitCallback) {\r\n          log('not implemented yet');\r\n      };\r\n      PhysicsCast.prototype.handleRaycastHitFirstResponse = function (response) {\r\n          this.queries[response.payload.queryId](response.payload.payload);\r\n          delete this.queries[response.payload.queryId];\r\n      };\r\n      PhysicsCast.prototype.handleRaycastHitAllResponse = function (response) {\r\n          this.queries[response.payload.queryId](response.payload.payload);\r\n          delete this.queries[response.payload.queryId];\r\n      };\r\n      return PhysicsCast;\r\n  }());\n\n  /**\r\n   * @public\r\n   */\r\n  var RaycastEventSystem = /** @class */ (function () {\r\n      function RaycastEventSystem() {\r\n      }\r\n      RaycastEventSystem.prototype.activate = function (engine) {\r\n          engine.eventManager.addListener(RaycastResponse, this, function (event) {\r\n              if (event.payload.queryType === 'HitFirst') {\r\n                  PhysicsCast.instance.handleRaycastHitFirstResponse(event);\r\n              }\r\n              else if (event.payload.queryType === 'HitAll') {\r\n                  PhysicsCast.instance.handleRaycastHitAllResponse(event);\r\n              }\r\n          });\r\n          if (typeof dcl !== 'undefined') {\r\n              dcl.subscribe('raycastResponse');\r\n          }\r\n      };\r\n      RaycastEventSystem.prototype.deactivate = function () {\r\n          if (typeof dcl !== 'undefined') {\r\n              dcl.unsubscribe('raycastResponse');\r\n          }\r\n      };\r\n      return RaycastEventSystem;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var PointerEventSystem = /** @class */ (function () {\r\n      function PointerEventSystem() {\r\n      }\r\n      PointerEventSystem.prototype.activate = function (engine) {\r\n          engine.eventManager.addListener(PointerEvent, this, function (event) {\r\n              Input.instance.handlePointerEvent(event.payload);\r\n          });\r\n          if (typeof dcl !== 'undefined') {\r\n              dcl.subscribe('pointerUp');\r\n              dcl.subscribe('pointerDown');\r\n              dcl.subscribe('actionButtonEvent');\r\n          }\r\n      };\r\n      PointerEventSystem.prototype.deactivate = function () {\r\n          if (typeof dcl !== 'undefined') {\r\n              dcl.unsubscribe('pointerUp');\r\n              dcl.unsubscribe('pointerDown');\r\n              dcl.unsubscribe('actionButtonEvent');\r\n          }\r\n      };\r\n      return PointerEventSystem;\r\n  }());\r\n  /**\r\n   * @public\r\n   */\r\n  var UUIDEventSystem = /** @class */ (function () {\r\n      function UUIDEventSystem() {\r\n          this.handlerMap = {};\r\n      }\r\n      UUIDEventSystem.prototype.activate = function (engine) {\r\n          engine.eventManager.addListener(UUIDEvent, this, this.handleEvent);\r\n          engine.eventManager.addListener(ComponentAdded, this, this.componentAdded);\r\n          engine.eventManager.addListener(ComponentRemoved, this, this.componentRemoved);\r\n          if (typeof dcl !== 'undefined') {\r\n              dcl.subscribe('uuidEvent');\r\n          }\r\n      };\r\n      UUIDEventSystem.prototype.deactivate = function () {\r\n          if (typeof dcl !== 'undefined') {\r\n              dcl.unsubscribe('uuidEvent');\r\n          }\r\n      };\r\n      UUIDEventSystem.prototype.onAddEntity = function (entity) {\r\n          for (var componentName in entity.components) {\r\n              var component = entity.components[componentName];\r\n              if (component instanceof OnUUIDEvent) {\r\n                  this.handlerMap[component.uuid] = component;\r\n              }\r\n          }\r\n      };\r\n      UUIDEventSystem.prototype.onRemoveEntity = function (entity) {\r\n          for (var componentName in entity.components) {\r\n              var component = entity.components[componentName];\r\n              if (component instanceof OnUUIDEvent) {\r\n                  delete this.handlerMap[component.uuid];\r\n              }\r\n          }\r\n      };\r\n      UUIDEventSystem.prototype.componentAdded = function (event) {\r\n          if (event.entity.isAddedToEngine()) {\r\n              var component = event.entity.components[event.componentName];\r\n              if (component instanceof OnUUIDEvent) {\r\n                  this.handlerMap[component.uuid] = component;\r\n              }\r\n          }\r\n      };\r\n      UUIDEventSystem.prototype.componentRemoved = function (event) {\r\n          if (event.entity.isAddedToEngine()) {\r\n              if (event.component instanceof OnUUIDEvent) {\r\n                  delete this.handlerMap[event.component.uuid];\r\n              }\r\n          }\r\n      };\r\n      UUIDEventSystem.prototype.handleEvent = function (event) {\r\n          if (event.uuid in this.handlerMap) {\r\n              var handler = this.handlerMap[event.uuid];\r\n              if (handler) {\r\n                  if (handler.callback && 'call' in handler.callback) {\r\n                      handler.callback(event.payload);\r\n                  }\r\n              }\r\n          }\r\n      };\r\n      return UUIDEventSystem;\r\n  }());\r\n  /** @internal */\r\n  var raycastEventSystem = new RaycastEventSystem();\r\n  /** @internal */\r\n  var pointerEventSystem = new PointerEventSystem();\r\n  /** @internal */\r\n  var uuidEventSystem = new UUIDEventSystem();\n\n  /**\r\n   * @public\r\n   */\r\n  var AudioClip = /** @class */ (function (_super) {\r\n      __extends(AudioClip, _super);\r\n      function AudioClip(url) {\r\n          var _this = _super.call(this) || this;\r\n          /**\r\n           * Is this clip looping by default?\r\n           */\r\n          _this.loop = false;\r\n          /**\r\n           * Clip's master volume. This volume affects all the AudioSources.\r\n           * Valid ranges from 0 to 1\r\n           */\r\n          _this.volume = 1;\r\n          _this.url = url;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], AudioClip.prototype, \"url\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AudioClip.prototype, \"loop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], AudioClip.prototype, \"loadingCompleteEventId\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], AudioClip.prototype, \"volume\", void 0);\r\n      AudioClip = __decorate([\r\n          DisposableComponent('engine.AudioClip', exports.CLASS_ID.AUDIO_CLIP),\r\n          __metadata(\"design:paramtypes\", [String])\r\n      ], AudioClip);\r\n      return AudioClip;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var AudioSource = /** @class */ (function (_super) {\r\n      __extends(AudioSource, _super);\r\n      function AudioSource(audioClip) {\r\n          var _this = _super.call(this) || this;\r\n          _this.audioClip = audioClip;\r\n          /**\r\n           * Is this clip looping by default?\r\n           */\r\n          _this.loop = false;\r\n          /**\r\n           * Clip's master volume. This volume affects all the AudioSources.\r\n           * Valid ranges from 0 to 1\r\n           */\r\n          _this.volume = 1;\r\n          /**\r\n           * Is this AudioSource playing?\r\n           */\r\n          _this.playing = false;\r\n          /**\r\n           * Pitch, default: 1.0, range from 0.0 to MaxFloat\r\n           */\r\n          _this.pitch = 1.0;\r\n          /**\r\n           * Timestamp of when the playOnce was executed to see if we need to start over the audio\r\n           */\r\n          _this.playedAtTimestamp = Date.now();\r\n          if (!(audioClip instanceof AudioClip)) {\r\n              throw new Error(\"Trying to create AudioSource(AudioClip) with an invalid AudioClip\");\r\n          }\r\n          _this.audioClipId = getComponentId(audioClip);\r\n          return _this;\r\n      }\r\n      /**\r\n       * Disables the looping and plays the current source once.\r\n       * If the sound was playing, it stops and starts over.\r\n       */\r\n      AudioSource.prototype.playOnce = function () {\r\n          this.playing = true;\r\n          this.dirty = true;\r\n          this.playedAtTimestamp = Date.now();\r\n          this.data.nonce = Math.random();\r\n          return this;\r\n      };\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], AudioSource.prototype, \"audioClipId\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AudioSource.prototype, \"loop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], AudioSource.prototype, \"volume\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AudioSource.prototype, \"playing\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], AudioSource.prototype, \"pitch\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], AudioSource.prototype, \"playedAtTimestamp\", void 0);\r\n      AudioSource = __decorate([\r\n          Component('engine.AudioSource', exports.CLASS_ID.AUDIO_SOURCE),\r\n          __metadata(\"design:paramtypes\", [AudioClip])\r\n      ], AudioSource);\r\n      return AudioSource;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @public\r\n   */\r\n  var AudioStream = /** @class */ (function (_super) {\r\n      __extends(AudioStream, _super);\r\n      function AudioStream(url) {\r\n          var _this = _super.call(this) || this;\r\n          _this.playing = false;\r\n          _this.volume = 1;\r\n          _this.url = url;\r\n          _this.playing = true;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], AudioStream.prototype, \"url\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AudioStream.prototype, \"playing\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], AudioStream.prototype, \"volume\", void 0);\r\n      AudioStream = __decorate([\r\n          Component('engine.AudioStream', exports.CLASS_ID.AUDIO_STREAM),\r\n          __metadata(\"design:paramtypes\", [String])\r\n      ], AudioStream);\r\n      return AudioStream;\r\n  }(ObservableComponent));\n\n  /**\r\n   * Gizmo identifiers\r\n   * @public\r\n   */\r\n  exports.Gizmo = void 0;\r\n  (function (Gizmo) {\r\n      Gizmo[\"MOVE\"] = \"MOVE\";\r\n      Gizmo[\"ROTATE\"] = \"ROTATE\";\r\n      Gizmo[\"SCALE\"] = \"SCALE\";\r\n      Gizmo[\"NONE\"] = \"NONE\";\r\n  })(exports.Gizmo || (exports.Gizmo = {}));\r\n  /**\r\n   * This event is triggered after the user finalizes dragging a gizmo.\r\n   * @public\r\n   */\r\n  var OnGizmoEvent = /** @class */ (function (_super) {\r\n      __extends(OnGizmoEvent, _super);\r\n      function OnGizmoEvent() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.type = 'gizmoEvent';\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnGizmoEvent.prototype, \"type\", void 0);\r\n      OnGizmoEvent = __decorate([\r\n          Component('engine.gizmoEvent', exports.CLASS_ID.UUID_CALLBACK)\r\n      ], OnGizmoEvent);\r\n      return OnGizmoEvent;\r\n  }(OnUUIDEvent));\r\n  /**\r\n   * Enables gizmos in the entity. Gizmos only work in EDITOR, PREVIEW or DEBUG modes.\r\n   * @public\r\n   */\r\n  var Gizmos = /** @class */ (function (_super) {\r\n      __extends(Gizmos, _super);\r\n      function Gizmos() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          /**\r\n           * Enable position gizmo\r\n           */\r\n          _this.position = true;\r\n          /**\r\n           * Enable rotation gizmo\r\n           */\r\n          _this.rotation = true;\r\n          /**\r\n           * Enable scale gizmo\r\n           */\r\n          _this.scale = true;\r\n          /**\r\n           * Cycle through gizmos using click.\r\n           */\r\n          _this.cycle = true;\r\n          /**\r\n           * Align the gizmos to match the local reference system\r\n           */\r\n          _this.localReference = false;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Gizmos.prototype, \"position\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Gizmos.prototype, \"rotation\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Gizmos.prototype, \"scale\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Gizmos.prototype, \"cycle\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], Gizmos.prototype, \"selectedGizmo\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], Gizmos.prototype, \"localReference\", void 0);\r\n      Gizmos = __decorate([\r\n          Component('engine.gizmos', exports.CLASS_ID.GIZMOS)\r\n      ], Gizmos);\r\n      return Gizmos;\r\n  }(ObservableComponent));\n\n  /**\r\n   * @public\r\n   */\r\n  var OnFocus = /** @class */ (function (_super) {\r\n      __extends(OnFocus, _super);\r\n      function OnFocus(callback) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'onFocus';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnFocus.prototype, \"type\", void 0);\r\n      OnFocus = __decorate([\r\n          Component('engine.onFocus', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function])\r\n      ], OnFocus);\r\n      return OnFocus;\r\n  }(OnUUIDEvent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnTextSubmit = /** @class */ (function (_super) {\r\n      __extends(OnTextSubmit, _super);\r\n      function OnTextSubmit(callback) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'onTextSubmit';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnTextSubmit.prototype, \"type\", void 0);\r\n      OnTextSubmit = __decorate([\r\n          Component('engine.onTextSubmit', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function])\r\n      ], OnTextSubmit);\r\n      return OnTextSubmit;\r\n  }(OnUUIDEvent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnBlur = /** @class */ (function (_super) {\r\n      __extends(OnBlur, _super);\r\n      function OnBlur(callback) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'onBlur';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnBlur.prototype, \"type\", void 0);\r\n      OnBlur = __decorate([\r\n          Component('engine.onBlur', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function])\r\n      ], OnBlur);\r\n      return OnBlur;\r\n  }(OnUUIDEvent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnEnter = /** @class */ (function (_super) {\r\n      __extends(OnEnter, _super);\r\n      function OnEnter(callback) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'onEnter';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnEnter.prototype, \"type\", void 0);\r\n      OnEnter = __decorate([\r\n          Component('engine.onEnter', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function])\r\n      ], OnEnter);\r\n      return OnEnter;\r\n  }(OnUUIDEvent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnChanged = /** @class */ (function (_super) {\r\n      __extends(OnChanged, _super);\r\n      function OnChanged(callback) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'onChange';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnChanged.prototype, \"type\", void 0);\r\n      OnChanged = __decorate([\r\n          Component('engine.onChange', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function])\r\n      ], OnChanged);\r\n      return OnChanged;\r\n  }(OnUUIDEvent));\r\n  /**\r\n   * @public @deprecated use `OnPointerDown` instead\r\n   */\r\n  var OnClick = /** @class */ (function (_super) {\r\n      __extends(OnClick, _super);\r\n      function OnClick(callback, options) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'onClick';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          if (options) {\r\n              _this.showFeedback = !(options.showFeedback === false);\r\n              if (options.button) {\r\n                  _this.button = options.button;\r\n              }\r\n              if (options.hoverText) {\r\n                  _this.hoverText = options.hoverText;\r\n              }\r\n              if (options.distance) {\r\n                  _this.distance = options.distance;\r\n              }\r\n          }\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnClick.prototype, \"type\", void 0);\r\n      OnClick = __decorate([\r\n          Component('engine.onClick', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function, Object])\r\n      ], OnClick);\r\n      return OnClick;\r\n  }(OnPointerUUIDEvent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnPointerDown = /** @class */ (function (_super) {\r\n      __extends(OnPointerDown, _super);\r\n      function OnPointerDown(callback, options) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'pointerDown';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          if (options) {\r\n              _this.showFeedback = !(options.showFeedback === false);\r\n              if (options.button) {\r\n                  _this.button = options.button;\r\n              }\r\n              if (options.hoverText) {\r\n                  _this.hoverText = options.hoverText;\r\n              }\r\n              if (options.distance) {\r\n                  _this.distance = options.distance;\r\n              }\r\n          }\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnPointerDown.prototype, \"type\", void 0);\r\n      OnPointerDown = __decorate([\r\n          Component('engine.pointerDown', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function, Object])\r\n      ], OnPointerDown);\r\n      return OnPointerDown;\r\n  }(OnPointerUUIDEvent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnPointerUp = /** @class */ (function (_super) {\r\n      __extends(OnPointerUp, _super);\r\n      function OnPointerUp(callback, options) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'pointerUp';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          if (options) {\r\n              _this.showFeedback = !(options.showFeedback === false);\r\n              if (options.button) {\r\n                  _this.button = options.button;\r\n              }\r\n              if (options.hoverText) {\r\n                  _this.hoverText = options.hoverText;\r\n              }\r\n              if (options.distance) {\r\n                  _this.distance = options.distance;\r\n              }\r\n          }\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnPointerUp.prototype, \"type\", void 0);\r\n      OnPointerUp = __decorate([\r\n          Component('engine.pointerUp', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function, Object])\r\n      ], OnPointerUp);\r\n      return OnPointerUp;\r\n  }(OnPointerUUIDEvent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnPointerHoverEnter = /** @class */ (function (_super) {\r\n      __extends(OnPointerHoverEnter, _super);\r\n      function OnPointerHoverEnter(callback, options) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'pointerHoverEnter';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          if (options) {\r\n              if (options.distance) {\r\n                  _this.distance = options.distance;\r\n              }\r\n          }\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnPointerHoverEnter.prototype, \"type\", void 0);\r\n      OnPointerHoverEnter = __decorate([\r\n          Component('engine.pointerHoverEnter', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function, Object])\r\n      ], OnPointerHoverEnter);\r\n      return OnPointerHoverEnter;\r\n  }(OnPointerUUIDEvent));\r\n  /**\r\n   * @public\r\n   */\r\n  var OnPointerHoverExit = /** @class */ (function (_super) {\r\n      __extends(OnPointerHoverExit, _super);\r\n      function OnPointerHoverExit(callback) {\r\n          var _this = _super.call(this, callback) || this;\r\n          _this.type = 'pointerHoverExit';\r\n          // This injection is necessary ONLY in events that are ALWAYS turned on and are\r\n          // not assignable to entities. Like events for the UI elements\r\n          // TODO(Brian): This will be removed when UI gets back to the entity parenting.\r\n          uuidEventSystem.handlerMap[_this.uuid] = _this;\r\n          // Changed default distance value for this component because in most cases we probably\r\n          // don't want for the hover exit event to be limited by a distance, and it default value was too small.\r\n          _this.distance = 160;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.readonly,\r\n          __metadata(\"design:type\", String)\r\n      ], OnPointerHoverExit.prototype, \"type\", void 0);\r\n      OnPointerHoverExit = __decorate([\r\n          Component('engine.pointerHoverExit', exports.CLASS_ID.UUID_CALLBACK),\r\n          __metadata(\"design:paramtypes\", [Function])\r\n      ], OnPointerHoverExit);\r\n      return OnPointerHoverExit;\r\n  }(OnPointerUUIDEvent));\n\n  /**\r\n   * @public\r\n   */\r\n  var UIShape = /** @class */ (function (_super) {\r\n      __extends(UIShape, _super);\r\n      function UIShape(parent) {\r\n          var _this = _super.call(this) || this;\r\n          /**\r\n           * Defines if the entity and its children should be rendered\r\n           */\r\n          _this.name = null;\r\n          _this.visible = true;\r\n          _this.opacity = 1;\r\n          _this.hAlign = 'center';\r\n          _this.vAlign = 'center';\r\n          _this.width = '100px';\r\n          _this.height = '50px';\r\n          _this.positionX = '0px';\r\n          _this.positionY = '0px';\r\n          _this.isPointerBlocker = true;\r\n          if (parent) {\r\n              _this._parent = parent;\r\n              _this.data.parentComponent = getComponentId(parent);\r\n          }\r\n          return _this;\r\n      }\r\n      Object.defineProperty(UIShape.prototype, \"parent\", {\r\n          get: function () {\r\n              return this._parent;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      Object.defineProperty(UIShape.prototype, \"parentComponent\", {\r\n          // @internal\r\n          get: function () {\r\n              return this.data.parentComponent;\r\n          },\r\n          enumerable: false,\r\n          configurable: true\r\n      });\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIShape.prototype, \"name\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIShape.prototype, \"visible\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIShape.prototype, \"opacity\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIShape.prototype, \"hAlign\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIShape.prototype, \"vAlign\", void 0);\r\n      __decorate([\r\n          ObservableComponent.uiValue,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIShape.prototype, \"width\", void 0);\r\n      __decorate([\r\n          ObservableComponent.uiValue,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIShape.prototype, \"height\", void 0);\r\n      __decorate([\r\n          ObservableComponent.uiValue,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIShape.prototype, \"positionX\", void 0);\r\n      __decorate([\r\n          ObservableComponent.uiValue,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIShape.prototype, \"positionY\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIShape.prototype, \"isPointerBlocker\", void 0);\r\n      return UIShape;\r\n  }(ObservableComponent));\r\n  /**\r\n   * @internal\r\n   * NOTE(Brian): this should be deprecated\r\n   */\r\n  var UIFullScreen = /** @class */ (function (_super) {\r\n      __extends(UIFullScreen, _super);\r\n      function UIFullScreen() {\r\n          return _super.call(this, null) || this;\r\n      }\r\n      UIFullScreen = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_FULLSCREEN_SHAPE),\r\n          __metadata(\"design:paramtypes\", [])\r\n      ], UIFullScreen);\r\n      return UIFullScreen;\r\n  }(UIShape));\r\n  /**\r\n   * @internal\r\n   * NOTE(Brian): this should be deprecated\r\n   */\r\n  var UIWorldSpace = /** @class */ (function (_super) {\r\n      __extends(UIWorldSpace, _super);\r\n      function UIWorldSpace() {\r\n          return _super.call(this, null) || this;\r\n      }\r\n      UIWorldSpace = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_WORLD_SPACE_SHAPE),\r\n          __metadata(\"design:paramtypes\", [])\r\n      ], UIWorldSpace);\r\n      return UIWorldSpace;\r\n  }(UIShape));\r\n  /**\r\n   * @public\r\n   */\r\n  var UICanvas = /** @class */ (function (_super) {\r\n      __extends(UICanvas, _super);\r\n      function UICanvas() {\r\n          return _super.call(this, null) || this;\r\n      }\r\n      UICanvas = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_SCREEN_SPACE_SHAPE),\r\n          __metadata(\"design:paramtypes\", [])\r\n      ], UICanvas);\r\n      return UICanvas;\r\n  }(UIShape));\r\n  /**\r\n   * @public\r\n   */\r\n  var UIContainerRect = /** @class */ (function (_super) {\r\n      __extends(UIContainerRect, _super);\r\n      function UIContainerRect() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.thickness = 0;\r\n          _this.color = dist.Color4.Clear();\r\n          _this.alignmentUsesSize = true;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIContainerRect.prototype, \"thickness\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIContainerRect.prototype, \"color\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIContainerRect.prototype, \"alignmentUsesSize\", void 0);\r\n      UIContainerRect = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_CONTAINER_RECT)\r\n      ], UIContainerRect);\r\n      return UIContainerRect;\r\n  }(UIShape));\r\n  /**\r\n   * @public\r\n   */\r\n  exports.UIStackOrientation = void 0;\r\n  (function (UIStackOrientation) {\r\n      UIStackOrientation[UIStackOrientation[\"VERTICAL\"] = 0] = \"VERTICAL\";\r\n      UIStackOrientation[UIStackOrientation[\"HORIZONTAL\"] = 1] = \"HORIZONTAL\";\r\n  })(exports.UIStackOrientation || (exports.UIStackOrientation = {}));\r\n  /**\r\n   * @public\r\n   */\r\n  var UIContainerStack = /** @class */ (function (_super) {\r\n      __extends(UIContainerStack, _super);\r\n      function UIContainerStack() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.adaptWidth = true;\r\n          _this.adaptHeight = true;\r\n          _this.color = dist.Color4.Clear();\r\n          _this.stackOrientation = exports.UIStackOrientation.VERTICAL;\r\n          _this.spacing = 0;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIContainerStack.prototype, \"adaptWidth\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIContainerStack.prototype, \"adaptHeight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIContainerStack.prototype, \"color\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIContainerStack.prototype, \"stackOrientation\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIContainerStack.prototype, \"spacing\", void 0);\r\n      UIContainerStack = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_CONTAINER_STACK)\r\n      ], UIContainerStack);\r\n      return UIContainerStack;\r\n  }(UIShape));\r\n  /**\r\n   * @public\r\n   */\r\n  var UIButton = /** @class */ (function (_super) {\r\n      __extends(UIButton, _super);\r\n      function UIButton() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.fontSize = 10;\r\n          _this.fontWeight = 'normal';\r\n          _this.thickness = 0;\r\n          _this.cornerRadius = 0;\r\n          _this.color = dist.Color4.White();\r\n          _this.background = dist.Color4.White();\r\n          _this.paddingTop = 0;\r\n          _this.paddingRight = 0;\r\n          _this.paddingBottom = 0;\r\n          _this.paddingLeft = 0;\r\n          _this.shadowBlur = 0;\r\n          _this.shadowOffsetX = 0;\r\n          _this.shadowOffsetY = 0;\r\n          _this.shadowColor = dist.Color4.Black();\r\n          _this.text = 'button';\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"fontSize\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIButton.prototype, \"fontWeight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"thickness\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"cornerRadius\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIButton.prototype, \"color\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIButton.prototype, \"background\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"paddingTop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"paddingRight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"paddingBottom\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"paddingLeft\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"shadowBlur\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"shadowOffsetX\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIButton.prototype, \"shadowOffsetY\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIButton.prototype, \"shadowColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIButton.prototype, \"text\", void 0);\r\n      UIButton = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_BUTTON_SHAPE)\r\n      ], UIButton);\r\n      return UIButton;\r\n  }(UIShape));\r\n  /**\r\n   * @public\r\n   */\r\n  var UIText = /** @class */ (function (_super) {\r\n      __extends(UIText, _super);\r\n      function UIText() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.outlineWidth = 0;\r\n          _this.outlineColor = dist.Color4.White();\r\n          _this.color = dist.Color4.White();\r\n          _this.fontSize = 10;\r\n          _this.fontAutoSize = false;\r\n          _this.value = '';\r\n          _this.lineSpacing = 0;\r\n          _this.lineCount = 0;\r\n          _this.adaptWidth = false;\r\n          _this.adaptHeight = false;\r\n          _this.textWrapping = false;\r\n          _this.shadowBlur = 0;\r\n          _this.shadowOffsetX = 0;\r\n          _this.shadowOffsetY = 0;\r\n          _this.shadowColor = dist.Color4.Black();\r\n          _this.hTextAlign = 'left';\r\n          _this.vTextAlign = 'bottom';\r\n          _this.paddingTop = 0;\r\n          _this.paddingRight = 0;\r\n          _this.paddingBottom = 0;\r\n          _this.paddingLeft = 0;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"outlineWidth\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIText.prototype, \"outlineColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIText.prototype, \"color\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"fontSize\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIText.prototype, \"fontAutoSize\", void 0);\r\n      __decorate([\r\n          ObservableComponent.component,\r\n          __metadata(\"design:type\", Font)\r\n      ], UIText.prototype, \"font\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIText.prototype, \"value\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"lineSpacing\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"lineCount\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIText.prototype, \"adaptWidth\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIText.prototype, \"adaptHeight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIText.prototype, \"textWrapping\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"shadowBlur\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"shadowOffsetX\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"shadowOffsetY\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIText.prototype, \"shadowColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIText.prototype, \"hTextAlign\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIText.prototype, \"vTextAlign\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"paddingTop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"paddingRight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"paddingBottom\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIText.prototype, \"paddingLeft\", void 0);\r\n      UIText = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_TEXT_SHAPE)\r\n      ], UIText);\r\n      return UIText;\r\n  }(UIShape));\r\n  /**\r\n   * @public\r\n   */\r\n  var UIInputText = /** @class */ (function (_super) {\r\n      __extends(UIInputText, _super);\r\n      function UIInputText(parent) {\r\n          var _this = _super.call(this, parent) || this;\r\n          _this.outlineWidth = 0;\r\n          _this.outlineColor = dist.Color4.Black();\r\n          _this.color = dist.Color4.Clear();\r\n          _this.fontSize = 10;\r\n          _this.value = '';\r\n          _this.placeholder = '';\r\n          _this.margin = 10;\r\n          _this.hTextAlign = 'left';\r\n          _this.vTextAlign = 'bottom';\r\n          _this.focusedBackground = dist.Color4.Black();\r\n          _this.textWrapping = false;\r\n          _this.shadowBlur = 0;\r\n          _this.shadowOffsetX = 0;\r\n          _this.shadowOffsetY = 0;\r\n          _this.shadowColor = dist.Color4.White();\r\n          _this.paddingTop = 0;\r\n          _this.paddingRight = 0;\r\n          _this.paddingBottom = 0;\r\n          _this.paddingLeft = 0;\r\n          _this.onTextSubmit = null;\r\n          _this.onChanged = null;\r\n          _this.onFocus = null;\r\n          _this.onBlur = null;\r\n          _this.onTextChanged = new OnChanged(function (e) {\r\n              var _a = e.value, value = _a.value, isSubmit = _a.isSubmit;\r\n              // NOTE: here we want to keep the same `dirty` state as before changing `this.value`\r\n              // because changing `this.value` will set the component as `dirty` and send a message to the renderer with it value\r\n              // and that message is unnecesary (if the only thing that have changed is `this.value`) since that new value has come from the renderer itself\r\n              var isDirty = _this.dirty;\r\n              _this.value = value;\r\n              _this.dirty = isDirty;\r\n              if (isSubmit && _this.onTextSubmit) {\r\n                  var onSubmitValue = { text: value };\r\n                  _this.onTextSubmit.callback(onSubmitValue);\r\n              }\r\n              else if (!isSubmit && _this.onChanged) {\r\n                  var onChangeValue = {\r\n                      value: value,\r\n                      pointerId: e.pointerId\r\n                  };\r\n                  _this.onChanged.callback(onChangeValue);\r\n              }\r\n          });\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"outlineWidth\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIInputText.prototype, \"outlineColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIInputText.prototype, \"color\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"fontSize\", void 0);\r\n      __decorate([\r\n          ObservableComponent.component,\r\n          __metadata(\"design:type\", Font)\r\n      ], UIInputText.prototype, \"font\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIInputText.prototype, \"value\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIInputText.prototype, \"placeholder\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"margin\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIInputText.prototype, \"hTextAlign\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], UIInputText.prototype, \"vTextAlign\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIInputText.prototype, \"focusedBackground\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIInputText.prototype, \"textWrapping\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"shadowBlur\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"shadowOffsetX\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"shadowOffsetY\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIInputText.prototype, \"shadowColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"paddingTop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"paddingRight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"paddingBottom\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIInputText.prototype, \"paddingLeft\", void 0);\r\n      __decorate([\r\n          OnUUIDEvent.uuidEvent,\r\n          __metadata(\"design:type\", OnChanged)\r\n      ], UIInputText.prototype, \"onTextChanged\", void 0);\r\n      __decorate([\r\n          OnUUIDEvent.uuidEvent,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIInputText.prototype, \"onFocus\", void 0);\r\n      __decorate([\r\n          OnUUIDEvent.uuidEvent,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIInputText.prototype, \"onBlur\", void 0);\r\n      UIInputText = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_INPUT_TEXT_SHAPE),\r\n          __metadata(\"design:paramtypes\", [Object])\r\n      ], UIInputText);\r\n      return UIInputText;\r\n  }(UIShape));\r\n  /**\r\n   * @public\r\n   */\r\n  var UIImage = /** @class */ (function (_super) {\r\n      __extends(UIImage, _super);\r\n      function UIImage(parent, source) {\r\n          var _this = _super.call(this, parent) || this;\r\n          _this.sourceLeft = 0;\r\n          _this.sourceTop = 0;\r\n          _this.sourceWidth = 1;\r\n          _this.sourceHeight = 1;\r\n          _this.paddingTop = 0;\r\n          _this.paddingRight = 0;\r\n          _this.paddingBottom = 0;\r\n          _this.paddingLeft = 0;\r\n          _this.sizeInPixels = true;\r\n          _this.onClick = null;\r\n          _this.source = source;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIImage.prototype, \"sourceLeft\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIImage.prototype, \"sourceTop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIImage.prototype, \"sourceWidth\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIImage.prototype, \"sourceHeight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.component,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIImage.prototype, \"source\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIImage.prototype, \"paddingTop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIImage.prototype, \"paddingRight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIImage.prototype, \"paddingBottom\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIImage.prototype, \"paddingLeft\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIImage.prototype, \"sizeInPixels\", void 0);\r\n      __decorate([\r\n          OnUUIDEvent.uuidEvent,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIImage.prototype, \"onClick\", void 0);\r\n      UIImage = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_IMAGE_SHAPE),\r\n          __metadata(\"design:paramtypes\", [UIShape, Object])\r\n      ], UIImage);\r\n      return UIImage;\r\n  }(UIShape));\r\n  /**\r\n   * @public\r\n   */\r\n  var UIScrollRect = /** @class */ (function (_super) {\r\n      __extends(UIScrollRect, _super);\r\n      function UIScrollRect() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.valueX = 0;\r\n          _this.valueY = 0;\r\n          _this.backgroundColor = dist.Color4.Clear();\r\n          _this.isHorizontal = false;\r\n          _this.isVertical = false;\r\n          _this.paddingTop = 0;\r\n          _this.paddingRight = 0;\r\n          _this.paddingBottom = 0;\r\n          _this.paddingLeft = 0;\r\n          _this.onChanged = null;\r\n          return _this;\r\n      }\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIScrollRect.prototype, \"valueX\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIScrollRect.prototype, \"valueY\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", dist.Color4)\r\n      ], UIScrollRect.prototype, \"backgroundColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIScrollRect.prototype, \"isHorizontal\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], UIScrollRect.prototype, \"isVertical\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIScrollRect.prototype, \"paddingTop\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIScrollRect.prototype, \"paddingRight\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIScrollRect.prototype, \"paddingBottom\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], UIScrollRect.prototype, \"paddingLeft\", void 0);\r\n      __decorate([\r\n          OnUUIDEvent.uuidEvent,\r\n          __metadata(\"design:type\", Object)\r\n      ], UIScrollRect.prototype, \"onChanged\", void 0);\r\n      UIScrollRect = __decorate([\r\n          DisposableComponent('engine.shape', exports.CLASS_ID.UI_SLIDER_SHAPE)\r\n      ], UIScrollRect);\r\n      return UIScrollRect;\r\n  }(UIShape));\n\n  /**\r\n   * @public\r\n   */\r\n  var AvatarShape = /** @class */ (function (_super) {\r\n      __extends(AvatarShape, _super);\r\n      function AvatarShape() {\r\n          var _this = _super !== null && _super.apply(this, arguments) || this;\r\n          _this.useDummyModel = false;\r\n          _this.talking = false;\r\n          return _this;\r\n      }\r\n      AvatarShape_1 = AvatarShape;\r\n      AvatarShape.Dummy = function () {\r\n          var avatarShape = new AvatarShape_1();\r\n          avatarShape.useDummyModel = true;\r\n          return avatarShape;\r\n      };\r\n      var AvatarShape_1;\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], AvatarShape.prototype, \"id\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], AvatarShape.prototype, \"name\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], AvatarShape.prototype, \"expressionTriggerId\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Number)\r\n      ], AvatarShape.prototype, \"expressionTriggerTimestamp\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", String)\r\n      ], AvatarShape.prototype, \"bodyShape\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Array)\r\n      ], AvatarShape.prototype, \"wearables\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Object)\r\n      ], AvatarShape.prototype, \"skinColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Object)\r\n      ], AvatarShape.prototype, \"hairColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Object)\r\n      ], AvatarShape.prototype, \"eyeColor\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AvatarShape.prototype, \"useDummyModel\", void 0);\r\n      __decorate([\r\n          ObservableComponent.field,\r\n          __metadata(\"design:type\", Boolean)\r\n      ], AvatarShape.prototype, \"talking\", void 0);\r\n      AvatarShape = AvatarShape_1 = __decorate([\r\n          Component('engine.avatarShape', exports.CLASS_ID.AVATAR_SHAPE)\r\n      ], AvatarShape);\r\n      return AvatarShape;\r\n  }(ObservableComponent));\n\n  var communicationsController = null;\r\n  var communicationsControllerPromise = null;\r\n  var _messageObserver = null;\r\n  /**\r\n   * @internal\r\n   */\r\n  function getMessageObserver() {\r\n      if (!_messageObserver) {\r\n          _messageObserver = new Observable();\r\n      }\r\n      return _messageObserver;\r\n  }\r\n  function ensureCommunicationsController() {\r\n      if (!communicationsControllerPromise) {\r\n          communicationsControllerPromise = dcl.loadModule('@decentraland/CommunicationsController', {});\r\n          void communicationsControllerPromise.then(function ($) {\r\n              communicationsController = $;\r\n          });\r\n          var observer_1 = getMessageObserver();\r\n          dcl.subscribe('comms');\r\n          dcl.onEvent(function (event) {\r\n              if (event.type === 'comms') {\r\n                  observer_1.notifyObservers(event.data);\r\n              }\r\n          });\r\n      }\r\n      return communicationsControllerPromise;\r\n  }\r\n  /**\r\n   * @public\r\n   */\r\n  var MessageBus = /** @class */ (function () {\r\n      function MessageBus() {\r\n          var _this = this;\r\n          this.messageQueue = [];\r\n          this.connected = false;\r\n          this.flushing = false;\r\n          void ensureCommunicationsController().then(function () {\r\n              _this.connected = true;\r\n              _this.flush();\r\n          });\r\n      }\r\n      MessageBus.prototype.on = function (message, callback) {\r\n          return getMessageObserver().add(function (e) {\r\n              try {\r\n                  var m = JSON.parse(e.message);\r\n                  if (m.message === message) {\r\n                      callback(m.payload, e.sender);\r\n                  }\r\n              }\r\n              catch (e) {\r\n                  dcl.error('Error parsing comms message ' + (e.message || ''), e);\r\n              }\r\n          });\r\n      };\r\n      // @internal\r\n      MessageBus.prototype.sendRaw = function (message) {\r\n          this.messageQueue.push(message);\r\n          if (this.connected) {\r\n              this.flush();\r\n          }\r\n      };\r\n      MessageBus.prototype.emit = function (message, payload) {\r\n          var messageToSend = JSON.stringify({ message: message, payload: payload });\r\n          this.sendRaw(messageToSend);\r\n          getMessageObserver().notifyObservers({\r\n              message: messageToSend,\r\n              sender: 'self'\r\n          });\r\n      };\r\n      MessageBus.prototype.flush = function () {\r\n          var _this = this;\r\n          if (this.messageQueue.length === 0)\r\n              return;\r\n          if (!this.connected)\r\n              return;\r\n          if (!communicationsController)\r\n              return;\r\n          if (this.flushing)\r\n              return;\r\n          var message = this.messageQueue.shift();\r\n          this.flushing = true;\r\n          dcl.callRpc(communicationsController.rpcHandle, 'send', [message]).then(function (_) {\r\n              _this.flushing = false;\r\n              _this.flush();\r\n          }, function (e) {\r\n              _this.flushing = false;\r\n              error('Error flushing MessageBus', e);\r\n          });\r\n      };\r\n      return MessageBus;\r\n  }());\n\n  // CORE DEPENDENCIES\r\n  var entity = new Entity('scene');\r\n  entity.uuid = '0';\r\n  // Initialize engine\r\n  /** @public */\r\n  var engine = new Engine(entity);\r\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n  // @ts-ignore\r\n  DisposableComponent.engine = engine;\r\n  // Initialize Decentraland interface\r\n  if (typeof dcl !== 'undefined') {\r\n      engine.addSystem(new DecentralandSynchronizationSystem(dcl), Infinity);\r\n      _initEventObservables(dcl);\r\n  }\r\n  // Initialize UUID Events system\r\n  engine.addSystem(uuidEventSystem);\r\n  // Initialize Pointer Events System\r\n  engine.addSystem(pointerEventSystem);\r\n  // Initialize Raycast Events System\r\n  engine.addSystem(raycastEventSystem);\n\n  exports.AVATAR_OBSERVABLE = AVATAR_OBSERVABLE;\n  exports.Angle = dist.Angle;\n  exports.AnimationState = AnimationState;\n  exports.Animator = Animator;\n  exports.Arc2 = dist.Arc2;\n  exports.AttachToAvatar = AttachToAvatar;\n  exports.Attachable = Attachable;\n  exports.AudioClip = AudioClip;\n  exports.AudioSource = AudioSource;\n  exports.AudioStream = AudioStream;\n  exports.AvatarModifierArea = AvatarModifierArea;\n  exports.AvatarShape = AvatarShape;\n  exports.AvatarTexture = AvatarTexture;\n  exports.Axis = dist.Axis;\n  exports.BasicMaterial = BasicMaterial;\n  exports.BezierCurve = dist.BezierCurve;\n  exports.Billboard = Billboard;\n  exports.BoxShape = BoxShape;\n  exports.Camera = Camera;\n  exports.CameraModeArea = CameraModeArea;\n  exports.CircleShape = CircleShape;\n  exports.Color3 = dist.Color3;\n  exports.Color4 = dist.Color4;\n  exports.Component = Component;\n  exports.ComponentAdded = ComponentAdded;\n  exports.ComponentGroup = ComponentGroup;\n  exports.ComponentRemoved = ComponentRemoved;\n  exports.ConeShape = ConeShape;\n  exports.Curve3 = dist.Curve3;\n  exports.CylinderShape = CylinderShape;\n  exports.DEG2RAD = dist.DEG2RAD;\n  exports.DisposableComponent = DisposableComponent;\n  exports.DisposableComponentCreated = DisposableComponentCreated;\n  exports.DisposableComponentRemoved = DisposableComponentRemoved;\n  exports.DisposableComponentUpdated = DisposableComponentUpdated;\n  exports.Engine = Engine;\n  exports.Entity = Entity;\n  exports.Epsilon = dist.Epsilon;\n  exports.EventConstructor = EventConstructor;\n  exports.EventManager = EventManager;\n  exports.Font = Font;\n  exports.Frustum = dist.Frustum;\n  exports.GLTFShape = GLTFShape;\n  exports.Gizmos = Gizmos;\n  exports.GlobalPointerDown = GlobalPointerDown;\n  exports.GlobalPointerUp = GlobalPointerUp;\n  exports.Input = Input;\n  exports.Material = Material;\n  exports.Matrix = dist.Matrix;\n  exports.MessageBus = MessageBus;\n  exports.MultiObserver = MultiObserver;\n  exports.NFTShape = NFTShape;\n  exports.OBJShape = OBJShape;\n  exports.Observable = Observable;\n  exports.ObservableComponent = ObservableComponent;\n  exports.Observer = Observer;\n  exports.ObserverEventState = ObserverEventState;\n  exports.OnAnimationEnd = OnAnimationEnd;\n  exports.OnBlur = OnBlur;\n  exports.OnChanged = OnChanged;\n  exports.OnClick = OnClick;\n  exports.OnEnter = OnEnter;\n  exports.OnFocus = OnFocus;\n  exports.OnGizmoEvent = OnGizmoEvent;\n  exports.OnPointerDown = OnPointerDown;\n  exports.OnPointerHoverEnter = OnPointerHoverEnter;\n  exports.OnPointerHoverExit = OnPointerHoverExit;\n  exports.OnPointerLock = OnPointerLock;\n  exports.OnPointerUUIDEvent = OnPointerUUIDEvent;\n  exports.OnPointerUp = OnPointerUp;\n  exports.OnTextSubmit = OnTextSubmit;\n  exports.OnUUIDEvent = OnUUIDEvent;\n  exports.Orientation = dist.Orientation;\n  exports.ParentChanged = ParentChanged;\n  exports.Path2 = dist.Path2;\n  exports.Path3D = dist.Path3D;\n  exports.PhysicsCast = PhysicsCast;\n  exports.Plane = dist.Plane;\n  exports.PlaneShape = PlaneShape;\n  exports.PointerEvent = PointerEvent;\n  exports.PointerEventComponent = PointerEventComponent;\n  exports.PointerEventSystem = PointerEventSystem;\n  exports.Quaternion = dist.Quaternion;\n  exports.RAD2DEG = dist.RAD2DEG;\n  exports.RaycastEventSystem = RaycastEventSystem;\n  exports.RaycastResponse = RaycastResponse;\n  exports.Scalar = dist.Scalar;\n  exports.Shape = Shape;\n  exports.Size = dist.Size;\n  exports.SmartItem = SmartItem;\n  exports.Space = dist.Space;\n  exports.SphereShape = SphereShape;\n  exports.Subscription = Subscription;\n  exports.TextShape = TextShape;\n  exports.Texture = Texture;\n  exports.ToGammaSpace = dist.ToGammaSpace;\n  exports.ToLinearSpace = dist.ToLinearSpace;\n  exports.Transform = Transform;\n  exports.UIButton = UIButton;\n  exports.UICanvas = UICanvas;\n  exports.UIContainerRect = UIContainerRect;\n  exports.UIContainerStack = UIContainerStack;\n  exports.UIFullScreen = UIFullScreen;\n  exports.UIImage = UIImage;\n  exports.UIInputText = UIInputText;\n  exports.UIScrollRect = UIScrollRect;\n  exports.UIShape = UIShape;\n  exports.UIText = UIText;\n  exports.UIValue = UIValue;\n  exports.UIWorldSpace = UIWorldSpace;\n  exports.UUIDEvent = UUIDEvent;\n  exports.UUIDEventSystem = UUIDEventSystem;\n  exports.Vector2 = dist.Vector2;\n  exports.Vector3 = dist.Vector3;\n  exports.Vector4 = dist.Vector4;\n  exports.VideoClip = VideoClip;\n  exports.VideoTexture = VideoTexture;\n  exports._initEventObservables = _initEventObservables;\n  exports.buildArray = buildArray$1;\n  exports.engine = engine;\n  exports.error = error;\n  exports.executeTask = executeTask;\n  exports.getComponentClassId = getComponentClassId;\n  exports.getComponentId = getComponentId;\n  exports.getComponentName = getComponentName;\n  exports.getMessageObserver = getMessageObserver;\n  exports.isDisposableComponent = isDisposableComponent;\n  exports.log = log;\n  exports.newId = newId;\n  exports.onCameraModeChangedObservable = onCameraModeChangedObservable;\n  exports.onEnterScene = onEnterScene;\n  exports.onEnterSceneObservable = onEnterSceneObservable;\n  exports.onIdleStateChangedObservable = onIdleStateChangedObservable;\n  exports.onLeaveScene = onLeaveScene;\n  exports.onLeaveSceneObservable = onLeaveSceneObservable;\n  exports.onPlayerClickedObservable = onPlayerClickedObservable;\n  exports.onPlayerConnectedObservable = onPlayerConnectedObservable;\n  exports.onPlayerDisconnectedObservable = onPlayerDisconnectedObservable;\n  exports.onPlayerExpressionObservable = onPlayerExpressionObservable;\n  exports.onPointerLockedStateChange = onPointerLockedStateChange;\n  exports.onProfileChanged = onProfileChanged;\n  exports.onRealmChangedObservable = onRealmChangedObservable;\n  exports.onSceneReadyObservable = onSceneReadyObservable;\n  exports.onVideoEvent = onVideoEvent;\n  exports.openExternalURL = openExternalURL;\n  exports.openNFTDialog = openNFTDialog;\n  exports.pointerEventSystem = pointerEventSystem;\n  exports.raycastEventSystem = raycastEventSystem;\n  exports.teleportTo = teleportTo;\n  exports.uuid = uuid;\n  exports.uuidEventSystem = uuidEventSystem;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}(this.self = this.self || {}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbIi4uL3NyYy9lY3MvQXR0YWNoYWJsZS50cyIsIi4uL3NyYy9lY3MvaGVscGVycy50cyIsIi4uL3NyYy9lY3MvRXZlbnRNYW5hZ2VyLnRzIiwiLi4vc3JjL2Vjcy9JRW50aXR5LnRzIiwiLi4vc3JjL2Vjcy9VSVZhbHVlLnRzIiwiLi4vc3JjL2Vjcy9Db21wb25lbnQudHMiLCIuLi9zcmMvZWNzL0NvbXBvbmVudEdyb3VwLnRzIiwiLi4vc3JjL2Vjcy9FbnRpdHkudHMiLCIuLi9zcmMvZWNzL0VuZ2luZS50cyIsIi4uL3NyYy9lY3MvVGFzay50cyIsIi4uL3NyYy9lY3MvT2JzZXJ2YWJsZS50cyIsIi4uL3NyYy9lY3MvVXNlckFjdGlvbnMudHMiLCIuLi9zcmMvZGVjZW50cmFsYW5kL0V2ZW50cy50cyIsIi4uL3NyYy9kZWNlbnRyYWxhbmQvSW1wbGVtZW50YXRpb24udHMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L3R5cGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BkY2wvZWNzLW1hdGgvZGlzdC91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AZGNsL2Vjcy1tYXRoL2Rpc3QvU2NhbGFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BkY2wvZWNzLW1hdGgvZGlzdC9WZWN0b3I0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BkY2wvZWNzLW1hdGgvZGlzdC9NYXRyaXguanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L1F1YXRlcm5pb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L1ZlY3RvcjMuanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L3ByZWFsbG9jYXRlZFZhcmlhYmxlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AZGNsL2Vjcy1tYXRoL2Rpc3QvQW5nbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L1ZlY3RvcjIuanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L0FyYzIuanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L0F4aXMuanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L0JlemllckN1cnZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BkY2wvZWNzLW1hdGgvZGlzdC9Db2xvcjQuanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L0NvbG9yMy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AZGNsL2Vjcy1tYXRoL2Rpc3QvQ3VydmUzZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AZGNsL2Vjcy1tYXRoL2Rpc3QvUGxhbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L0Z1cnN0dW0uanMiLCIuLi9ub2RlX21vZHVsZXMvQGRjbC9lY3MtbWF0aC9kaXN0L1BhdGgyZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AZGNsL2Vjcy1tYXRoL2Rpc3QvUGF0aDNkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BkY2wvZWNzLW1hdGgvZGlzdC9TaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BkY2wvZWNzLW1hdGgvZGlzdC9pbmRleC5qcyIsIi4uL3NyYy9kZWNlbnRyYWxhbmQvQW5pbWF0aW9uU3RhdGUudHMiLCIuLi9zcmMvZGVjZW50cmFsYW5kL1R5cGVzLnRzIiwiLi4vc3JjL2RlY2VudHJhbGFuZC9JbnB1dC50cyIsIi4uL3NyYy9kZWNlbnRyYWxhbmQvQ29tcG9uZW50cy50cyIsIi4uL3NyYy9kZWNlbnRyYWxhbmQvQ2FtZXJhLnRzIiwiLi4vc3JjL2RlY2VudHJhbGFuZC9QaHlzaWNzQ2FzdC50cyIsIi4uL3NyYy9kZWNlbnRyYWxhbmQvU3lzdGVtcy50cyIsIi4uL3NyYy9kZWNlbnRyYWxhbmQvQXVkaW8udHMiLCIuLi9zcmMvZGVjZW50cmFsYW5kL0dpem1vcy50cyIsIi4uL3NyYy9kZWNlbnRyYWxhbmQvVUlFdmVudHMudHMiLCIuLi9zcmMvZGVjZW50cmFsYW5kL1VJU2hhcGVzLnRzIiwiLi4vc3JjL2RlY2VudHJhbGFuZC9BdmF0YXJTaGFwZS50cyIsIi4uL3NyYy9kZWNlbnRyYWxhbmQvTWVzc2FnZUJ1cy50cyIsIi4uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJRW50aXR5LCBJRW5naW5lIH0gZnJvbSAnLi9JRW50aXR5J1xuXG4vKipcbiAqIEVudGl0aWVzIGNhbiBiZSBhdHRhY2hlZCB0byBlYWNoIG90aGVyIGJ5IHVzaW5nIHRoZSBgc2V0UGFyZW50YCBtZXRob2QuIEhvd2V2ZXIsIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB3ZSBtaWdodCB3YW50IHRvIGF0dGFjaCBlbnRpdGllc1xuICogdG8gb3RoZXIgb2JqZWN0cyB0aGF0IGFyZSBub3QgZW50aXRpZXMgY3JlYXRlZCBieSB0aGUgc2FtZSBzY2VuZSAoZm9yIGV4YW1wbGUsIHRoZSBwbGF5ZXIncyBhdmF0YXIpLiBGb3IgdGhvc2UgY2FzZXMsIHdlIGhhdmUgdGhpcyBjbGFzcy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEF0dGFjaGFibGUge1xuICAvKiogVXNlZCB0byBhdHRhY2ggZW50aXRpZXMgdG8gdGhlIGF2YXRhci4gRW50aXRpZXMgd2lsbCBmb2xsb3cgdGhlIGF2YXRhciB3aGVuIGl0IG1vdmVzICovXG4gIHN0YXRpYyByZWFkb25seSBBVkFUQVI6IEF0dGFjaGFibGUgPSB7XG4gICAgZ2V0RW50aXR5UmVwcmVzZW50YXRpb246IChlbmdpbmU6IElFbmdpbmUpID0+IGVuZ2luZS5hdmF0YXJFbnRpdHlcbiAgfSBhcyBjb25zdFxuICAvKiogVXNlZCB0byBhdHRhY2ggZW50aXRpZXMgdG8gdGhlIGNhbWVyYS4gV2hlbiBpbiBmaXJzdCBwZXJzb24gbW9kZSwgdGhlIGF0dGFjaGVkIGVudGl0aWVzIHdpbGwgYWxzbyByb3RhdGUgd2l0aCB0aGUgY2FtZXJhICovXG4gIHN0YXRpYyByZWFkb25seSBGSVJTVF9QRVJTT05fQ0FNRVJBOiBBdHRhY2hhYmxlID0ge1xuICAgIGdldEVudGl0eVJlcHJlc2VudGF0aW9uOiAoZW5naW5lOiBJRW5naW5lKSA9PiBlbmdpbmUuZmlyc3RQZXJzb25DYW1lcmFFbnRpdHlcbiAgfSBhcyBjb25zdFxuXG4gIC8vIEBpbnRlcm5hbFxuICAvKiogRW50aXRpZXMgbXVzdCBiZSBhdHRhY2hlZCB0byBlbnRpdGllcywgc28gaW4gdGhpcyBjYXNlLCBlYWNoIGF0dGFjaGFibGUgb2JqZWN0IG11c3QgcmV0dXJuIHRoZSBlbnRpdHkgdXNlZCB0byBwcmVzZW50IGl0ICovXG4gIGFic3RyYWN0IGdldEVudGl0eVJlcHJlc2VudGF0aW9uKGVuZ2luZTogSUVuZ2luZSk6IElFbnRpdHlcbn1cbiIsImxldCBsYXN0R2VuZXJhdGVkSWQgPSAwXG5cbmRlY2xhcmUgbGV0IGNvbnNvbGU6IGFueVxuXG4vKipcbiAqIExvZyBmdW5jdGlvbi4gT25seSB3b3JrcyBpbiBkZWJ1ZyBtb2RlLCBvdGhlcndpc2UgaXQgZG9lcyBub3RoaW5nLlxuICogQHBhcmFtIGFyZ3MgLSBhbnkgbG9nZ2FibGUgcGFyYW1ldGVyXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2coLi4uYXJnczogYW55W10pIHtcbiAgaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGNsLmxvZyguLi5hcmdzKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCdERUJVRzonLCAuLi5hcmdzKVxuICB9XG59XG5cbi8qKlxuICogRXJyb3IgZnVuY3Rpb24uIFByaW50cyBhIGNvbnNvbGUgZXJyb3IuIE9ubHkgd29ya3MgaW4gZGVidWcgbW9kZSwgb3RoZXJ3aXNlIGl0IGRvZXMgbm90aGluZy5cbiAqIEBwYXJhbSBlcnJvciAtIHN0cmluZyBvciBFcnJvciBvYmplY3QuXG4gKiBAcGFyYW0gZGF0YSAtIGFueSBkZWJ1ZyBpbmZvcm1hdGlvbi5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGVycm9yOiBzdHJpbmcgfCBFcnJvciwgZGF0YT86IGFueSkge1xuICBpZiAodHlwZW9mIGRjbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkY2wuZXJyb3IoZXJyb3IgYXMgYW55LCBkYXRhKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0VSUk9SOicsIGVycm9yLCBkYXRhKVxuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbmV3IHByZWZpeGVkIGlkXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZXdJZCh0eXBlOiBzdHJpbmcpIHtcbiAgbGFzdEdlbmVyYXRlZElkKytcbiAgaWYgKHR5cGUubGVuZ3RoID09PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignbmV3SWQodHlwZTogc3RyaW5nKTogdHlwZSBjYW5ub3QgYmUgZW1wdHknKVxuICByZXR1cm4gdHlwZSArIGxhc3RHZW5lcmF0ZWRJZC50b1N0cmluZygzNilcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMFxuICAgIGNvbnN0IHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXG4gIH0pXG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZ2l2ZW4gc2l6ZSBmaWxsZWQgd2l0aCBlbGVtZW50IGJ1aWx0IGZyb20gdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGFuZCB0aGUgcGFyYW10ZXJzXG4gKiBAcGFyYW0gc2l6ZSAtIHRoZSBudW1iZXIgb2YgZWxlbWVudCB0byBjb25zdHJ1Y3QgYW5kIHB1dCBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSBpdGVtQnVpbGRlciAtIGEgY2FsbGJhY2sgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZSBvZiBpdGVtLiBDYWxsZWQgb25jZSBwZXIgYXJyYXkgZW50cnkuXG4gKiBAcmV0dXJucyBhIG5ldyBhcnJheSBmaWxsZWQgd2l0aCBuZXcgb2JqZWN0c1xuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEFycmF5PFQ+KHNpemU6IG51bWJlciwgaXRlbUJ1aWxkZXI6ICgpID0+IFQpOiBBcnJheTxUPiB7XG4gIGNvbnN0IGE6IFRbXSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgYS5wdXNoKGl0ZW1CdWlsZGVyKCkpXG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcGVuRXh0ZXJuYWxVUkwodXJsOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGNsLm9wZW5FeHRlcm5hbFVybCh1cmwpXG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0VSUk9SOiBvcGVuRXh0ZXJuYWxVUkwgZGNsIGlzIHVuZGVmaW5lZCcpXG4gIH1cbn1cblxuLyoqXG4gKiBQb3B1cCBORlQgaW5mbyBkaWFsb2dcbiAqIEBwYXJhbSBzY3IgLSAnZXRoZXJldW06Ly9jb250cmFjdEFkZHJlc3MvdG9rZW5JRCdcbiAqIEBwYXJhbSBjb21tZW50IC0gb3B0aW9uYWwuIGFkZCBhIGNvbW1lbnQuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcGVuTkZURGlhbG9nKHNjcjogc3RyaW5nLCBjb21tZW50OiBzdHJpbmcgfCBudWxsID0gbnVsbCkge1xuICBpZiAodHlwZW9mIGRjbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCByZWdleCA9IC9ldGhlcmV1bTpcXC9cXC8oLispXFwvKC4rKS9cbiAgICBjb25zdCBtYXRjaGVzID0gc2NyLm1hdGNoKHJlZ2V4KVxuXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZGNsLm9wZW5ORlREaWFsb2cobWF0Y2hlc1sxXSwgbWF0Y2hlc1syXSwgY29tbWVudClcbiAgfSBlbHNlIHtcbiAgICBlcnJvcignRVJST1I6IG9wZW5ORlREaWFsb2cgZGNsIGlzIHVuZGVmaW5lZCcpXG4gIH1cbn1cbiIsImltcG9ydCB7IGVycm9yLCBuZXdJZCB9IGZyb20gJy4vaGVscGVycydcblxuY29uc3QgZXZlbnROYW1lU3ltYm9sID0gJ19fZXZlbnRfbmFtZV9fJ1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRXZlbnRDb25zdHJ1Y3RvcjxUPiB7XG4gIC8vIEBpbnRlcm5hbFxuICBbZXZlbnROYW1lU3ltYm9sXT86IHN0cmluZ1xuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVFxufVxuXG5jb25zdCB0YWtlbkV2ZW50TmFtZXM6IHN0cmluZ1tdID0gW11cblxuZnVuY3Rpb24gZ2V0RXZlbnROYW1lRnJvbUNvbnN0cnVjdG9yPFQ+KGN0b3I6IElFdmVudENvbnN0cnVjdG9yPFQ+KTogc3RyaW5nIHtcbiAgaWYgKCEoZXZlbnROYW1lU3ltYm9sIGluIGN0b3IpIHx8IHR5cGVvZiBjdG9yW2V2ZW50TmFtZVN5bWJvbF0gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgRXZlbnRDb25zdHJ1Y3RvciBpcyBub3QgcmVnaXN0ZXJlZCcpXG4gIH1cbiAgcmV0dXJuIGN0b3JbZXZlbnROYW1lU3ltYm9sXSBhcyBhbnkgYXMgc3RyaW5nXG59XG5cbnR5cGUgRXZlbnRMaXN0ZW5lcjxYPiA9IHtcbiAgbGlzdGVuZXI6IFhcbiAgZm46ICh0aGlzOiBYLCBldmVudDogYW55KSA9PiB2b2lkXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgRXZlbnRNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBsaXN0ZW5lcnM6IFJlY29yZDxzdHJpbmcsIEFycmF5PEV2ZW50TGlzdGVuZXI8YW55Pj4+ID0ge31cblxuICBhZGRMaXN0ZW5lcjxULCBYPihcbiAgICBldmVudENsYXNzOiBJRXZlbnRDb25zdHJ1Y3RvcjxUPixcbiAgICBsaXN0ZW5lcjogWCxcbiAgICBsaXN0ZW5lckZ1bmN0aW9uOiAodGhpczogWCwgZXZlbnQ6IFQpID0+IHZvaWRcbiAgKSB7XG4gICAgaWYgKCFldmVudENsYXNzIHx8IHR5cGVvZiAoZXZlbnRDbGFzcyBhcyBhbnkpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRXZlbnRDb25zdHJ1Y3RvcicpXG4gICAgfVxuICAgIGNvbnN0IGV2ZW50TmFtZSA9IGdldEV2ZW50TmFtZUZyb21Db25zdHJ1Y3RvcihldmVudENsYXNzKVxuXG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV1cblxuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdID0gW11cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGxpc3RlbmVyc1tpXVxuICAgICAgaWYgKHgubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIGxpc3RlbmVyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLnB1c2goe1xuICAgICAgbGlzdGVuZXIsXG4gICAgICBmbjogbGlzdGVuZXJGdW5jdGlvblxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVtb3ZlTGlzdGVuZXI8WD4obGlzdGVuZXI6IFgsIGV2ZW50Q2xhc3M6IElFdmVudENvbnN0cnVjdG9yPGFueT4pOiBib29sZWFuIHtcbiAgICBpZiAoIWV2ZW50Q2xhc3MgfHwgdHlwZW9mIChldmVudENsYXNzIGFzIGFueSkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBFdmVudENvbnN0cnVjdG9yJylcbiAgICB9XG5cbiAgICBjb25zdCBldmVudE5hbWUgPSBnZXRFdmVudE5hbWVGcm9tQ29uc3RydWN0b3IoZXZlbnRDbGFzcylcblxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV1cblxuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGxpc3RlbmVyc1tpXVxuICAgICAgaWYgKHgubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSlcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZpcmVFdmVudDxUIGV4dGVuZHMgb2JqZWN0PihldmVudDogVCkge1xuICAgIGNvbnN0IGV2ZW50TmFtZSA9IGdldEV2ZW50TmFtZUZyb21Db25zdHJ1Y3RvcigoZXZlbnQgYXMgYW55KS5jb25zdHJ1Y3RvcilcblxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV1cblxuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbCA9IGxpc3RlbmVyc1tpXVxuICAgICAgICAgIGwuZm4uY2FsbChsLmxpc3RlbmVyLCBldmVudClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFRPRE86IGUgbWF5IG5vdCBiZSBhbiBpbnN0YW5jZSBvZiBFcnJvclxuICAgICAgICAgIGVycm9yKGUgYXMgYW55KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEV2ZW50Q29uc3RydWN0b3IoKTogQ2xhc3NEZWNvcmF0b3Ige1xuICBjb25zdCBldmVudE5hbWUgPSBuZXdJZCgnRVYnKVxuXG4gIGlmICh0YWtlbkV2ZW50TmFtZXMuaW5kZXhPZihldmVudE5hbWUpICE9PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGV2ZW50IG5hbWUgJHtldmVudE5hbWV9IGlzIGFscmVhZHkgdGFrZW5gKVxuICB9XG5cbiAgdGFrZW5FdmVudE5hbWVzLnB1c2goZXZlbnROYW1lKVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gIHJldHVybiA8VEZ1bmN0aW9uIGV4dGVuZHMgRnVuY3Rpb24+KHRhcmdldDogVEZ1bmN0aW9uKTogVEZ1bmN0aW9uIHwgdm9pZCA9PiB7XG4gICAgOyh0YXJnZXQgYXMgYW55KVtldmVudE5hbWVTeW1ib2xdID0gZXZlbnROYW1lXG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnRMaWtlLCBDb21wb25lbnRDb25zdHJ1Y3RvciB9IGZyb20gJy4vQ29tcG9uZW50J1xuaW1wb3J0IHsgRXZlbnRDb25zdHJ1Y3RvciwgRXZlbnRNYW5hZ2VyIH0gZnJvbSAnLi9FdmVudE1hbmFnZXInXG5pbXBvcnQgeyBBdHRhY2hhYmxlIH0gZnJvbSAnLi9BdHRhY2hhYmxlJ1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJU3lzdGVtIHtcbiAgYWN0aXZlPzogYm9vbGVhblxuXG4gIGFjdGl2YXRlPyhlbmdpbmU6IElFbmdpbmUpOiB2b2lkXG4gIGRlYWN0aXZhdGU/KCk6IHZvaWRcblxuICB1cGRhdGU/KGR0OiBudW1iZXIpOiB2b2lkXG5cbiAgb25BZGRFbnRpdHk/KGVudGl0eTogSUVudGl0eSk6IHZvaWRcbiAgb25SZW1vdmVFbnRpdHk/KGVudGl0eTogSUVudGl0eSk6IHZvaWRcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUVuZ2luZSB7XG4gIHJvb3RFbnRpdHk6IElFbnRpdHlcbiAgcmVhZG9ubHkgZmlyc3RQZXJzb25DYW1lcmFFbnRpdHk6IElFbnRpdHlcbiAgcmVhZG9ubHkgYXZhdGFyRW50aXR5OiBJRW50aXR5XG4gIHJlYWRvbmx5IGVudGl0aWVzOiBSZWFkb25seTxSZWNvcmQ8c3RyaW5nLCBJRW50aXR5Pj5cblxuICBhZGRFbnRpdHkoZW50aXR5OiBJRW50aXR5KTogdm9pZFxuICByZW1vdmVFbnRpdHkoZW50aXR5OiBJRW50aXR5KTogdm9pZFxuICBhZGRTeXN0ZW0oc3lzdGVtOiBJU3lzdGVtLCBwcmlvcml0eTogbnVtYmVyKTogdm9pZFxuICByZW1vdmVTeXN0ZW0oc3lzdGVtOiBJU3lzdGVtKTogdm9pZFxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRW50aXR5IHtcbiAgY2hpbGRyZW46IFJlY29yZDxzdHJpbmcsIElFbnRpdHk+XG4gIGV2ZW50TWFuYWdlcjogRXZlbnRNYW5hZ2VyIHwgbnVsbFxuICBhbGl2ZTogYm9vbGVhblxuICByZWFkb25seSB1dWlkOiBzdHJpbmdcbiAgcmVhZG9ubHkgY29tcG9uZW50czogUmVjb3JkPHN0cmluZywgYW55PlxuXG4gIGlzQWRkZWRUb0VuZ2luZSgpOiBib29sZWFuXG4gIGdldFBhcmVudCgpOiBJRW50aXR5IHwgbnVsbFxuICBzZXRQYXJlbnQoZTogSUVudGl0eSB8IEF0dGFjaGFibGUgfCBudWxsKTogdm9pZFxuXG4gIGdldENvbXBvbmVudDxUID0gYW55Pihjb21wb25lbnQ6IHN0cmluZyk6IFRcbiAgZ2V0Q29tcG9uZW50PFQ+KGNvbXBvbmVudDogQ29tcG9uZW50Q29uc3RydWN0b3I8VD4pOiBUXG4gIGdldENvbXBvbmVudDxUPihjb21wb25lbnQ6IENvbXBvbmVudENvbnN0cnVjdG9yPFQ+IHwgc3RyaW5nKTogVFxuXG4gIC8qKlxuICAgKiBHZXRzIGEgY29tcG9uZW50LCBpZiBpdCBkb2Vzbid0IGV4aXN0LCBpdCByZXR1cm5zIG51bGwuXG4gICAqIEBwYXJhbSBjb21wb25lbnQgLSBjb21wb25lbnQgY2xhc3Mgb3IgbmFtZVxuICAgKi9cbiAgZ2V0Q29tcG9uZW50T3JOdWxsPFQgPSBhbnk+KGNvbXBvbmVudDogc3RyaW5nKTogVCB8IG51bGxcbiAgZ2V0Q29tcG9uZW50T3JOdWxsPFQ+KGNvbXBvbmVudDogQ29tcG9uZW50Q29uc3RydWN0b3I8VD4pOiBUIHwgbnVsbFxuICBnZXRDb21wb25lbnRPck51bGw8VD4oY29tcG9uZW50OiBDb21wb25lbnRDb25zdHJ1Y3RvcjxUPiB8IHN0cmluZyk6IFQgfCBudWxsXG5cbiAgZ2V0Q29tcG9uZW50T3JDcmVhdGU8VD4oY29tcG9uZW50OiBDb21wb25lbnRDb25zdHJ1Y3RvcjxUPiAmIHsgbmV3ICgpOiBUIH0pOiBUXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQuIElmIHRoZSBjb21wb25lbnQgYWxyZWFkeSBleGlzdCwgaXQgdGhyb3dzIGFuIEVycm9yLlxuICAgKiBAcGFyYW0gY29tcG9uZW50IC0gY29tcG9uZW50IGluc3RhbmNlLlxuICAgKi9cbiAgYWRkQ29tcG9uZW50PFQgZXh0ZW5kcyBvYmplY3Q+KGNvbXBvbmVudDogVCk6IHZvaWRcblxuICBhZGRDb21wb25lbnRPclJlcGxhY2U8VCBleHRlbmRzIG9iamVjdD4oY29tcG9uZW50OiBUKTogdm9pZFxuXG4gIHJlbW92ZUNvbXBvbmVudChjb21wb25lbnQ6IHN0cmluZywgdHJpZ2dlclJlbW92ZWRFdmVudD86IGJvb2xlYW4pOiB2b2lkXG4gIHJlbW92ZUNvbXBvbmVudDxUIGV4dGVuZHMgb2JqZWN0PihcbiAgICBjb21wb25lbnQ6IFQsXG4gICAgdHJpZ2dlclJlbW92ZWRFdmVudD86IGJvb2xlYW5cbiAgKTogdm9pZFxuICByZW1vdmVDb21wb25lbnQoXG4gICAgY29tcG9uZW50OiBDb21wb25lbnRDb25zdHJ1Y3Rvcjxhbnk+LFxuICAgIHRyaWdnZXJSZW1vdmVkRXZlbnQ/OiBib29sZWFuXG4gICk6IHZvaWRcbiAgcmVtb3ZlQ29tcG9uZW50KFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgY29tcG9uZW50OiBvYmplY3QgfCBzdHJpbmcgfCBGdW5jdGlvbixcbiAgICB0cmlnZ2VyUmVtb3ZlZEV2ZW50OiBhbnlcbiAgKTogdm9pZFxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgaGFzQ29tcG9uZW50PFQgPSBhbnk+KGNvbXBvbmVudDogc3RyaW5nKTogYm9vbGVhblxuICBoYXNDb21wb25lbnQ8VD4oY29tcG9uZW50OiBDb21wb25lbnRDb25zdHJ1Y3RvcjxUPik6IGJvb2xlYW5cbiAgaGFzQ29tcG9uZW50PFQgZXh0ZW5kcyBvYmplY3Q+KGNvbXBvbmVudDogVCk6IGJvb2xlYW5cbiAgaGFzQ29tcG9uZW50PFQ+KGNvbXBvbmVudDogQ29tcG9uZW50Q29uc3RydWN0b3I8VD4gfCBzdHJpbmcpOiBib29sZWFuXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARXZlbnRDb25zdHJ1Y3RvcigpXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50UmVtb3ZlZCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBlbnRpdHk6IElFbnRpdHksXG4gICAgcHVibGljIGNvbXBvbmVudE5hbWU6IHN0cmluZyxcbiAgICBwdWJsaWMgY29tcG9uZW50OiBDb21wb25lbnRMaWtlXG4gICkge1xuICAgIC8vIHN0dWJcbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQEV2ZW50Q29uc3RydWN0b3IoKVxuZXhwb3J0IGNsYXNzIENvbXBvbmVudEFkZGVkIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGVudGl0eTogSUVudGl0eSxcbiAgICBwdWJsaWMgY29tcG9uZW50TmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyBjbGFzc0lkOiBudW1iZXIgfCBudWxsXG4gICkge1xuICAgIC8vIHN0dWJcbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQEV2ZW50Q29uc3RydWN0b3IoKVxuZXhwb3J0IGNsYXNzIFBhcmVudENoYW5nZWQge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgZW50aXR5OiBJRW50aXR5LCBwdWJsaWMgcGFyZW50OiBJRW50aXR5IHwgbnVsbCkge1xuICAgIC8vIHN0dWJcbiAgfVxufVxuIiwiLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBlbnVtIFVJVmFsdWVUeXBlIHtcbiAgUEVSQ0VOVCA9IDAsXG4gIFBJWEVMUyA9IDFcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBVSVZhbHVlIHtcbiAgdmFsdWU6IG51bWJlclxuICB0eXBlOiBVSVZhbHVlVHlwZVxuXG4gIGNvbnN0cnVjdG9yKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICB0aGlzLnR5cGUgPSBVSVZhbHVlVHlwZS5QSVhFTFNcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB2YWx1ZUFzU3RyaW5nOiBzdHJpbmcgPSB2YWx1ZVxuICAgICAgaWYgKHZhbHVlQXNTdHJpbmcuaW5kZXhPZigncHgnKSA+IC0xKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFVJVmFsdWVUeXBlLlBJWEVMU1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZUFzU3RyaW5nLmluZGV4T2YoJyUnKSA+IC0xKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFVJVmFsdWVUeXBlLlBFUkNFTlRcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWVBc1N0cmluZylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBsZXQgcmVzdWx0OiBzdHJpbmcgPSB0aGlzLnZhbHVlLnRvU3RyaW5nKClcblxuICAgIGlmICh0aGlzLnR5cGUgPT09IFVJVmFsdWVUeXBlLlBFUkNFTlQpIHtcbiAgICAgIHJlc3VsdCArPSAnJSdcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9ICdweCdcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cbiIsImltcG9ydCB7IG5ld0lkIH0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHsgRXZlbnRDb25zdHJ1Y3RvciB9IGZyb20gJy4vRXZlbnRNYW5hZ2VyJ1xuaW1wb3J0IHsgVUlWYWx1ZSB9IGZyb20gJy4vVUlWYWx1ZSdcblxuY29uc3QgY29tcG9uZW50U3ltYm9sID0gJ19fbmFtZV9fc3ltYm9sXydcbmNvbnN0IGNvbXBvbmVudENsYXNzSWRTeW1ib2wgPSAnX19jbGFzc0lkX19zeW1ib2xfJ1xuY29uc3QgY29tcG9uZW50SWRTeW1ib2wgPSAnX19jb21wb25lbnRfX2lkXydcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50TGlrZSB7XG4gIC8vIEBpbnRlcm5hbFxuICBbY29tcG9uZW50U3ltYm9sXT86IHN0cmluZ1xuICAvLyBAaW50ZXJuYWxcbiAgW2NvbXBvbmVudENsYXNzSWRTeW1ib2xdPzogbnVtYmVyXG5cbiAgLy8gQGludGVybmFsXG4gIGFkZGVkVG9FbnRpdHk/KGVudGl0eTogYW55KTogdm9pZFxuICAvLyBAaW50ZXJuYWxcbiAgcmVtb3ZlZEZyb21FbnRpdHk/KGVudGl0eTogYW55KTogdm9pZFxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEaXNwb3NhYmxlQ29tcG9uZW50TGlrZSBleHRlbmRzIENvbXBvbmVudExpa2Uge1xuICAvLyBAaW50ZXJuYWxcbiAgW2NvbXBvbmVudElkU3ltYm9sXT86IHN0cmluZ1xuICBvbkRpc3Bvc2U/KCk6IHZvaWRcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcG9uZW50Q29uc3RydWN0b3I8VCBleHRlbmRzIENvbXBvbmVudExpa2U+IHtcbiAgLy8gQGludGVybmFsXG4gIFtjb21wb25lbnRTeW1ib2xdPzogc3RyaW5nXG4gIC8vIEBpbnRlcm5hbFxuICBbY29tcG9uZW50Q2xhc3NJZFN5bWJvbF0/OiBudW1iZXJcbiAgaXNDb21wb25lbnQ/OiBib29sZWFuXG4gIG9yaWdpbmFsQ2xhc3NOYW1lPzogc3RyaW5nXG4gIG5ldyAoLi4uYXJnczogYW55W10pOiBUXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIERpc3Bvc2FibGVDb21wb25lbnRDb25zdHJ1Y3RvcjxcbiAgVCBleHRlbmRzIERpc3Bvc2FibGVDb21wb25lbnRMaWtlXG4+IHtcbiAgLy8gQGludGVybmFsXG4gIFtjb21wb25lbnRTeW1ib2xdPzogc3RyaW5nXG4gIC8vIEBpbnRlcm5hbFxuICBbY29tcG9uZW50Q2xhc3NJZFN5bWJvbF0/OiBudW1iZXJcbiAgaXNDb21wb25lbnQ/OiBib29sZWFuXG4gIGlzRGlzcG9zYWJsZUNvbXBvbmVudD86IHRydWVcbiAgb3JpZ2luYWxDbGFzc05hbWU/OiBzdHJpbmdcbiAgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFRcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBFdmVudENvbnN0cnVjdG9yKClcbmV4cG9ydCBjbGFzcyBEaXNwb3NhYmxlQ29tcG9uZW50Q3JlYXRlZCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjb21wb25lbnRJZDogc3RyaW5nLFxuICAgIHB1YmxpYyBjb21wb25lbnROYW1lOiBzdHJpbmcsXG4gICAgcHVibGljIGNsYXNzSWQ6IG51bWJlclxuICApIHtcbiAgICAvLyBzdHViXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBFdmVudENvbnN0cnVjdG9yKClcbmV4cG9ydCBjbGFzcyBEaXNwb3NhYmxlQ29tcG9uZW50UmVtb3ZlZCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBjb21wb25lbnRJZDogc3RyaW5nKSB7XG4gICAgLy8gc3R1YlxuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARXZlbnRDb25zdHJ1Y3RvcigpXG5leHBvcnQgY2xhc3MgRGlzcG9zYWJsZUNvbXBvbmVudFVwZGF0ZWQge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgY29tcG9uZW50SWQ6IHN0cmluZyxcbiAgICBwdWJsaWMgY29tcG9uZW50OiBEaXNwb3NhYmxlQ29tcG9uZW50TGlrZVxuICApIHtcbiAgICAvLyBzdHViXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnQoY29tcG9uZW50TmFtZTogc3RyaW5nLCBjbGFzc0lkPzogbnVtYmVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiA8VEZ1bmN0aW9uIGV4dGVuZHMgQ29tcG9uZW50Q29uc3RydWN0b3I8YW55Pj4oXG4gICAgdGFyZ2V0OiBURnVuY3Rpb25cbiAgKTogVEZ1bmN0aW9uIHwgdm9pZCB7XG4gICAgaWYgKHRhcmdldC5pc0NvbXBvbmVudCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYFlvdSBjYW5ub3QgZXh0ZW5kIGEgY29tcG9uZW50LiBUcnlpbmcgdG8gZXh0ZW5kICR7dGFyZ2V0Lm9yaWdpbmFsQ2xhc3NOYW1lfSB3aXRoOiAke2NvbXBvbmVudE5hbWV9YFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGV4dGVuZGVkQ2xhc3MgPSB0YXJnZXQgYXMgYW55XG5cbiAgICBjb25zdCBSZWdpc3RlcmVkQ29tcG9uZW50OiBhbnkgPSBmdW5jdGlvbiBSZWdpc3RlcmVkQ29tcG9uZW50KCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgIGNvbnN0IHJldCA9IG5ldyBleHRlbmRlZENsYXNzKC4uLmFyZ3MpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGNvbXBvbmVudFN5bWJvbCwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogY29tcG9uZW50TmFtZVxuICAgICAgfSlcblxuICAgICAgaWYgKGNsYXNzSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBjb21wb25lbnRDbGFzc0lkU3ltYm9sLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IGNsYXNzSWRcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cblxuICAgIGlmIChjbGFzc0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFJlZ2lzdGVyZWRDb21wb25lbnRbY29tcG9uZW50Q2xhc3NJZFN5bWJvbF0gPSBjbGFzc0lkXG4gICAgfVxuXG4gICAgUmVnaXN0ZXJlZENvbXBvbmVudFtjb21wb25lbnRTeW1ib2xdID0gY29tcG9uZW50TmFtZVxuICAgIFJlZ2lzdGVyZWRDb21wb25lbnQuaXNDb21wb25lbnQgPSB0cnVlXG4gICAgUmVnaXN0ZXJlZENvbXBvbmVudC5vcmlnaW5hbENsYXNzTmFtZSA9IGNvbXBvbmVudE5hbWVcblxuICAgIFJlZ2lzdGVyZWRDb21wb25lbnQucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZVxuICAgIFJlZ2lzdGVyZWRDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdGFyZ2V0XG5cbiAgICByZXR1cm4gUmVnaXN0ZXJlZENvbXBvbmVudCBhcyBURnVuY3Rpb25cbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gRGlzcG9zYWJsZUNvbXBvbmVudChjb21wb25lbnROYW1lOiBzdHJpbmcsIGNsYXNzSWQ6IG51bWJlcikge1xuICByZXR1cm4gZnVuY3Rpb24gPFRGdW5jdGlvbiBleHRlbmRzIERpc3Bvc2FibGVDb21wb25lbnRDb25zdHJ1Y3Rvcjxhbnk+PihcbiAgICB0YXJnZXQ6IFRGdW5jdGlvblxuICApOiBURnVuY3Rpb24gfCB2b2lkIHtcbiAgICBpZiAodGFyZ2V0LmlzQ29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCBleHRlbmQgYSBjb21wb25lbnQuIFRyeWluZyB0byBleHRlbmQgJHt0YXJnZXQub3JpZ2luYWxDbGFzc05hbWV9IHdpdGg6ICR7Y29tcG9uZW50TmFtZX1gXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiAoY2xhc3NJZCBhcyBhbnkpICE9PSAnbnVtYmVyJyB8fCBpc05hTihjbGFzc0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjbGFzc0lkOiAke2NsYXNzSWR9IGlzIGFuIGludmFsaWQgaW50ZWdlcmApXG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW5kZWRDbGFzcyA9IHRhcmdldFxuXG4gICAgY29uc3QgUmVnaXN0ZXJlZENvbXBvbmVudDogYW55ID0gZnVuY3Rpb24gUmVnaXN0ZXJlZENvbXBvbmVudCgpIHtcbiAgICAgIGlmICghRGlzcG9zYWJsZUNvbXBvbmVudC5lbmdpbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdZb3UgbmVlZCB0byBzZXQgYSBEaXNwb3NhYmxlQ29tcG9uZW50LmVuZ2luZSBiZWZvcmUgY3JlYXRpbmcgZGlzcG9zYWJsZSBjb21wb25lbnRzJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICBjb25zdCByZXQgPSBuZXcgZXh0ZW5kZWRDbGFzcyguLi4oYXJncyBhcyBhbnkpKVxuICAgICAgY29uc3QgaWQgPSBuZXdJZCgnQycpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGNvbXBvbmVudFN5bWJvbCwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogY29tcG9uZW50TmFtZVxuICAgICAgfSlcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJldCwgY29tcG9uZW50SWRTeW1ib2wsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGlkXG4gICAgICB9KVxuXG4gICAgICBpZiAoKGNsYXNzSWQgYXMgYW55KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGNvbXBvbmVudENsYXNzSWRTeW1ib2wsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogY2xhc3NJZFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoRGlzcG9zYWJsZUNvbXBvbmVudC5lbmdpbmUpIHtcbiAgICAgICAgRGlzcG9zYWJsZUNvbXBvbmVudC5lbmdpbmUucmVnaXN0ZXJDb21wb25lbnQocmV0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgaWYgKChjbGFzc0lkIGFzIGFueSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgUmVnaXN0ZXJlZENvbXBvbmVudFtjb21wb25lbnRDbGFzc0lkU3ltYm9sXSA9IGNsYXNzSWRcbiAgICB9XG5cbiAgICBSZWdpc3RlcmVkQ29tcG9uZW50W2NvbXBvbmVudFN5bWJvbF0gPSBjb21wb25lbnROYW1lXG4gICAgUmVnaXN0ZXJlZENvbXBvbmVudC5pc0NvbXBvbmVudCA9IHRydWVcbiAgICBSZWdpc3RlcmVkQ29tcG9uZW50LmlzRGlzcG9zYWJsZUNvbXBvbmVudCA9IHRydWVcbiAgICBSZWdpc3RlcmVkQ29tcG9uZW50Lm9yaWdpbmFsQ2xhc3NOYW1lID0gY29tcG9uZW50TmFtZVxuXG4gICAgUmVnaXN0ZXJlZENvbXBvbmVudC5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlXG4gICAgUmVnaXN0ZXJlZENvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSB0YXJnZXRcblxuICAgIHJldHVybiBSZWdpc3RlcmVkQ29tcG9uZW50IGFzIFRGdW5jdGlvblxuICB9XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBuYW1lc3BhY2UgRGlzcG9zYWJsZUNvbXBvbmVudCB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBleHBvcnQgbGV0IGVuZ2luZTogYW55ID0gbnVsbFxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWU8VCBleHRlbmRzIFJlY29yZDxhbnksIGFueT4gPSBhbnk+KFxuICBjb21wb25lbnQ6IFQgfCBDb21wb25lbnRDb25zdHJ1Y3RvcjxUPlxuKTogc3RyaW5nIHtcbiAgaWYgKCFjb21wb25lbnQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvbXBvbmVudCArICcgaXMgbm90IGEgY29tcG9uZW50LicpXG4gIH1cbiAgaWYgKGNvbXBvbmVudFtjb21wb25lbnRTeW1ib2xdKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudFtjb21wb25lbnRTeW1ib2xdIGFzIHN0cmluZ1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoY29tcG9uZW50ICsgJyBpcyBub3QgYSByZWdpc3RlcmVkIGNvbXBvbmVudC4nKVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBvbmVudENsYXNzSWQ8VCBleHRlbmRzIFJlY29yZDxhbnksIGFueT4gPSBhbnk+KFxuICBjb21wb25lbnQ6IFQgfCBDb21wb25lbnRDb25zdHJ1Y3RvcjxUPlxuKTogbnVtYmVyIHwgbnVsbCB7XG4gIGlmICghY29tcG9uZW50KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb21wb25lbnQgKyAnIGlzIG5vdCBhIGNvbXBvbmVudC4nKVxuICB9XG4gIGlmIChjb21wb25lbnRbY29tcG9uZW50Q2xhc3NJZFN5bWJvbF0pIHtcbiAgICByZXR1cm4gY29tcG9uZW50W2NvbXBvbmVudENsYXNzSWRTeW1ib2xdIGFzIG51bWJlclxuICB9XG4gIGlmICghY29tcG9uZW50W2NvbXBvbmVudFN5bWJvbF0pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvbXBvbmVudCArICcgaXMgbm90IGEgcmVnaXN0ZXJlZCBjb21wb25lbnQuJylcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcG9uZW50SWQ8VCBleHRlbmRzIERpc3Bvc2FibGVDb21wb25lbnRMaWtlPihcbiAgY29tcG9uZW50OiBUXG4pOiBzdHJpbmcge1xuICBpZiAoIWNvbXBvbmVudCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29tcG9uZW50ICsgJyBpcyBub3QgYSBjb21wb25lbnQuJylcbiAgfVxuICBpZiAoY29tcG9uZW50W2NvbXBvbmVudElkU3ltYm9sXSkge1xuICAgIHJldHVybiBjb21wb25lbnRbY29tcG9uZW50SWRTeW1ib2xdIGFzIGFueSBhcyBzdHJpbmdcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvbXBvbmVudCArICcgaXMgbm90IGEgcmVnaXN0ZXJlZCBkaXNwb3NhYmxlIGNvbXBvbmVudC4nKVxufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgT2JzZXJ2YWJsZUNvbXBvbmVudFN1YnNjcmlwdGlvbiA9IChcbiAga2V5OiBzdHJpbmcsXG4gIG5ld1ZhbDogYW55LFxuICBvbGRWYWw6IGFueVxuKSA9PiB2b2lkXG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZUNvbXBvbmVudCB7XG4gIC8vIEBpbnRlcm5hbFxuICBkaXJ0eTogYm9vbGVhbiA9IGZhbHNlXG4gIC8vIEBpbnRlcm5hbFxuICBkYXRhOiBhbnkgPSB7fVxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IEFycmF5PE9ic2VydmFibGVDb21wb25lbnRTdWJzY3JpcHRpb24+ID0gW11cblxuICBzdGF0aWMgY29tcG9uZW50KHRhcmdldDogT2JzZXJ2YWJsZUNvbXBvbmVudCwgcHJvcGVydHlLZXk6IHN0cmluZykge1xuICAgIGlmIChkZWxldGUgKHRhcmdldCBhcyBhbnkpW3Byb3BlcnR5S2V5XSkge1xuICAgICAgY29uc3QgY29tcG9uZW50U3ltYm9sID0gcHJvcGVydHlLZXkgKyAnXycgKyBNYXRoLnJhbmRvbSgpXG4gICAgICA7KHRhcmdldCBhcyBhbnkpW2NvbXBvbmVudFN5bWJvbF0gPSB1bmRlZmluZWRcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50U3ltYm9sLCB7XG4gICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb21wb25lbnRTeW1ib2wpLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSlcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkudG9TdHJpbmcoKSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1tjb21wb25lbnRTeW1ib2xdXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW2NvbXBvbmVudFN5bWJvbF1cblxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW3Byb3BlcnR5S2V5XSA9IGdldENvbXBvbmVudElkKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcHJvcGVydHlLZXldID0gbnVsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXNbY29tcG9uZW50U3ltYm9sXSA9IHZhbHVlXG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaV0ocHJvcGVydHlLZXksIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZpZWxkKHRhcmdldDogT2JzZXJ2YWJsZUNvbXBvbmVudCwgcHJvcGVydHlLZXk6IHN0cmluZykge1xuICAgIGlmIChkZWxldGUgKHRhcmdldCBhcyBhbnkpW3Byb3BlcnR5S2V5XSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkudG9TdHJpbmcoKSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0aGlzOiBPYnNlcnZhYmxlQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtwcm9wZXJ0eUtleV1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhpczogT2JzZXJ2YWJsZUNvbXBvbmVudCwgdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuZGF0YVtwcm9wZXJ0eUtleV1cbiAgICAgICAgICB0aGlzLmRhdGFbcHJvcGVydHlLZXldID0gdmFsdWVcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlXG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpXShwcm9wZXJ0eUtleSwgdmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdWlWYWx1ZSh0YXJnZXQ6IE9ic2VydmFibGVDb21wb25lbnQsIHByb3BlcnR5S2V5OiBzdHJpbmcpIHtcbiAgICBpZiAoZGVsZXRlICh0YXJnZXQgYXMgYW55KVtwcm9wZXJ0eUtleV0pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LnRvU3RyaW5nKCksIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAodGhpczogT2JzZXJ2YWJsZUNvbXBvbmVudCk6IHN0cmluZyB8IG51bWJlciB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtwcm9wZXJ0eUtleV0udG9TdHJpbmcoKVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aGlzOiBPYnNlcnZhYmxlQ29tcG9uZW50LCB2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKSB7XG4gICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLmRhdGFbcHJvcGVydHlLZXldXG5cbiAgICAgICAgICBjb25zdCBmaW5hbFZhbHVlID0gbmV3IFVJVmFsdWUodmFsdWUpXG5cbiAgICAgICAgICB0aGlzLmRhdGFbcHJvcGVydHlLZXldID0gZmluYWxWYWx1ZVxuXG4gICAgICAgICAgaWYgKGZpbmFsVmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaV0ocHJvcGVydHlLZXksIGZpbmFsVmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcmVhZG9ubHkodGFyZ2V0OiBPYnNlcnZhYmxlQ29tcG9uZW50LCBwcm9wZXJ0eUtleTogc3RyaW5nKSB7XG4gICAgaWYgKGRlbGV0ZSAodGFyZ2V0IGFzIGFueSlbcHJvcGVydHlLZXldKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleS50b1N0cmluZygpLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKHRoaXM6IE9ic2VydmFibGVDb21wb25lbnQpIHtcbiAgICAgICAgICBpZiAocHJvcGVydHlLZXkgaW4gdGhpcy5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmllbGQgJHtwcm9wZXJ0eUtleX0gaXMgdW5pbml0aWFsaXplZGApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbcHJvcGVydHlLZXldXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHRoaXM6IE9ic2VydmFibGVDb21wb25lbnQsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5S2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmllbGQgJHtwcm9wZXJ0eUtleX0gaXMgcmVhZG9ubHlgKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRhdGFbcHJvcGVydHlLZXldID0gdmFsdWVcbiAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIG9uQ2hhbmdlKGZuOiBPYnNlcnZhYmxlQ29tcG9uZW50U3Vic2NyaXB0aW9uKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goZm4pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Rpc3Bvc2FibGVDb21wb25lbnQoY29tcG9uZW50OiBDb21wb25lbnRMaWtlKSB7XG4gIHJldHVybiBjb21wb25lbnRJZFN5bWJvbCBpbiBjb21wb25lbnRcbn1cbiIsImltcG9ydCB7IGdldENvbXBvbmVudE5hbWUsIENvbXBvbmVudENvbnN0cnVjdG9yIH0gZnJvbSAnLi9Db21wb25lbnQnXG5pbXBvcnQgeyBJRW50aXR5IH0gZnJvbSAnLi9JRW50aXR5J1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvbmVudEdyb3VwIHtcbiAgcmVhZG9ubHkgZW50aXRpZXM6IFJlYWRvbmx5QXJyYXk8SUVudGl0eT4gPSBbXVxuICByZWFkb25seSByZXF1aXJlcyE6IFJlYWRvbmx5QXJyYXk8Q29tcG9uZW50Q29uc3RydWN0b3I8YW55Pj5cbiAgcmVhZG9ubHkgcmVxdWlyZXNOYW1lcyE6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPlxuXG4gIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlXG5cbiAgcHJpdmF0ZSBfcmVxdWlyZXNOYW1lczogc3RyaW5nW10gPSBbXVxuXG4gIGNvbnN0cnVjdG9yKC4uLnJlcXVpcmVzOiBDb21wb25lbnRDb25zdHJ1Y3Rvcjxhbnk+W10pIHtcbiAgICAvLyB2YWxpZGF0ZSByZXF1aXJlcyBsaXN0XG4gICAgaWYgKCFyZXF1aXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnRHcm91cDogQ291bGQgbm90IGxvYWQgdGhlIHJlcXVpcmVzIGxpc3QnKVxuICAgIH1cbiAgICBpZiAoIShyZXF1aXJlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnRHcm91cDogcmVxdWlyZXMgbGlzdCBpcyBub3QgYW4gQXJyYXknKVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVxdWlyZXMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmVzLnNsaWNlKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXF1aXJlc05hbWVzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1aXJlc05hbWVzLnNsaWNlKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IHJlcXVpcmVzLmxlbmd0aDsgaXgrKykge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gcmVxdWlyZXNbaXhdXG4gICAgICBsZXQgbmFtZTogc3RyaW5nIHwgbnVsbCA9IG51bGxcblxuICAgICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDb21wb25lbnRHcm91cDogdGhlIHJlcXVpcmVkIGNvbXBvbmVudCBhdCBsb2NhdGlvbiAke2l4fSBpcyBpbnZhbGlkYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDb21wb25lbnRHcm91cDogdGhlIHJlcXVpcmVkIGNvbXBvbmVudCBhdCBsb2NhdGlvbiAke2l4fSBpcyBub3QgcmVnaXN0ZXJlZCBhcyBhIEBDb21wb25lbnQuIFJlbWVtYmVyIHRvIHByb3ZpZGUgdGhlIGNsYXNzIG9mIHRoZSBjb21wb25lbnQsIG5vdCB0aGUgbmFtZWBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVxdWlyZXNOYW1lcy5zb21lKCgkKSA9PiAkID09PSBuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENvbXBvbmVudEdyb3VwOiB0aGUgcmVxdWlyZWQgY29tcG9uZW50IGxpc3QgaGFzIGEgcmVwZWF0ZWQgbmFtZSAke25hbWV9YFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcXVpcmVzTmFtZXMucHVzaChuYW1lKVxuICAgIH1cbiAgfVxuXG4gIGhhc0VudGl0eShlbnRpdHk6IElFbnRpdHkpOiBib29sZWFuIHtcbiAgICBpZiAoIWVudGl0eS5pc0FkZGVkVG9FbmdpbmUoKSkgcmV0dXJuIGZhbHNlXG5cbiAgICByZXR1cm4gdGhpcy5lbnRpdGllcy5pbmRleE9mKGVudGl0eSkgIT09IC0xXG4gIH1cblxuICAvLyBAaW50ZXJuYWxcbiAgYWRkRW50aXR5KGVudGl0eTogSUVudGl0eSkge1xuICAgIGlmICghZW50aXR5LmlzQWRkZWRUb0VuZ2luZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ29tcG9uZW50R3JvdXA6IENhbm5vdCBhZGQgYSBlbnRpdHkgdGhhdCBpcyBub3QgYWRkZWQgdG8gdGhlIGVuZ2luZSdcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbnRpdGllcy5pbmRleE9mKGVudGl0eSkgPT09IC0xKSB7XG4gICAgICA7KHRoaXMuZW50aXRpZXMgYXMgSUVudGl0eVtdKS5wdXNoKGVudGl0eSlcbiAgICB9XG4gIH1cblxuICAvLyBAaW50ZXJuYWxcbiAgcmVtb3ZlRW50aXR5KGVudGl0eTogSUVudGl0eSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5lbnRpdGllcy5pbmRleE9mKGVudGl0eSlcblxuICAgIGlmIChpZCAhPT0gLTEpIHtcbiAgICAgIDsodGhpcy5lbnRpdGllcyBhcyBJRW50aXR5W10pLnNwbGljZShpZCwgMSlcbiAgICB9XG4gIH1cblxuICAvLyBAaW50ZXJuYWxcbiAgY29tcG9uZW50UmVtb3ZlZChlbnRpdHk6IElFbnRpdHksIGNvbXBvbmVudDogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVpcmVzTmFtZXMuaW5kZXhPZihjb21wb25lbnQpICE9PSAtMSkge1xuICAgICAgdGhpcy5yZW1vdmVFbnRpdHkoZW50aXR5KVxuICAgIH1cbiAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICBtZWV0c1JlcXVpcmVtZW50cyhlbnRpdHk6IElFbnRpdHkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3JlcXVpcmVzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB0aGlzLl9yZXF1aXJlc05hbWVzW2ldXG4gICAgICBpZiAoIShjb21wb25lbnROYW1lIGluIGVudGl0eS5jb21wb25lbnRzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgZ2V0Q29tcG9uZW50TmFtZSxcbiAgQ29tcG9uZW50Q29uc3RydWN0b3IsXG4gIGdldENvbXBvbmVudENsYXNzSWQsXG4gIENvbXBvbmVudExpa2Vcbn0gZnJvbSAnLi9Db21wb25lbnQnXG5pbXBvcnQge1xuICBJRW5naW5lLFxuICBJRW50aXR5LFxuICBDb21wb25lbnRBZGRlZCxcbiAgQ29tcG9uZW50UmVtb3ZlZCxcbiAgUGFyZW50Q2hhbmdlZFxufSBmcm9tICcuL0lFbnRpdHknXG5pbXBvcnQgeyBFdmVudE1hbmFnZXIgfSBmcm9tICcuL0V2ZW50TWFuYWdlcidcbmltcG9ydCB7IG5ld0lkLCBsb2cgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBBdHRhY2hhYmxlIH0gZnJvbSAnLi9BdHRhY2hhYmxlJ1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEVudGl0eSBpbXBsZW1lbnRzIElFbnRpdHkge1xuICBwdWJsaWMgY2hpbGRyZW46IFJlY29yZDxzdHJpbmcsIElFbnRpdHk+ID0ge31cbiAgcHVibGljIGV2ZW50TWFuYWdlcjogRXZlbnRNYW5hZ2VyIHwgbnVsbCA9IG51bGxcbiAgcHVibGljIGFsaXZlOiBib29sZWFuID0gZmFsc2VcblxuICBwdWJsaWMgcmVhZG9ubHkgdXVpZDogc3RyaW5nID0gbmV3SWQoJ0UnKVxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50czogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG5cbiAgLy8gQGludGVybmFsXG4gIHB1YmxpYyBlbmdpbmU6IElFbmdpbmUgfCBudWxsID0gbnVsbFxuXG4gIC8vIEBpbnRlcm5hbFxuICBwcml2YXRlIF9wYXJlbnQ6IElFbnRpdHkgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lPzogc3RyaW5nKSB7XG4gICAgLy8gc3R1YlxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb3IgcmVwbGFjZXMgYSBjb21wb25lbnQgaW4gdGhlIGVudGl0eS5cbiAgICogQHBhcmFtIGNvbXBvbmVudCAtIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICovXG4gIGFkZENvbXBvbmVudE9yUmVwbGFjZTxUIGV4dGVuZHMgb2JqZWN0Pihjb21wb25lbnQ6IFQpOiBUIHtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWW91IHBhc3NlZCBhIGZ1bmN0aW9uIG9yIGNsYXNzIGFzIGEgY29tcG9uZW50LCBhbiBpbnN0YW5jZSBvZiBjb21wb25lbnQgaXMgZXhwZWN0ZWQnXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgcGFzc2VkIGEgJHt0eXBlb2YgY29tcG9uZW50fSwgYW4gaW5zdGFuY2Ugb2YgY29tcG9uZW50IGlzIGV4cGVjdGVkYFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudClcblxuICAgIGlmICh0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV0gPT09IGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZUNvbXBvbmVudCh0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV0sIGZhbHNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIGNvbXBvbmVudCBpcyBwcmVzZW50IGluIHRoZSBlbnRpdHkuXG4gICAqIEBwYXJhbSBjb21wb25lbnQgLSBjb21wb25lbnQgY2xhc3MsIGluc3RhbmNlIG9yIG5hbWVcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgaGFzQ29tcG9uZW50PFQgPSBhbnk+KGNvbXBvbmVudDogc3RyaW5nKTogYm9vbGVhblxuICBoYXNDb21wb25lbnQ8VD4oY29tcG9uZW50OiBDb21wb25lbnRDb25zdHJ1Y3RvcjxUPik6IGJvb2xlYW5cbiAgaGFzQ29tcG9uZW50PFQgZXh0ZW5kcyBvYmplY3Q+KGNvbXBvbmVudDogVCk6IGJvb2xlYW5cbiAgaGFzQ29tcG9uZW50PFQ+KGNvbXBvbmVudDogQ29tcG9uZW50Q29uc3RydWN0b3I8VD4gfCBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB0eXBlT2ZDb21wb25lbnQgPSB0eXBlb2YgY29tcG9uZW50XG5cbiAgICBpZiAoXG4gICAgICB0eXBlT2ZDb21wb25lbnQgIT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlT2ZDb21wb25lbnQgIT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlT2ZDb21wb25lbnQgIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0VudGl0eSNoYXMoY29tcG9uZW50KTogY29tcG9uZW50IGlzIG5vdCBhIGNsYXNzLCBuYW1lIG9yIGluc3RhbmNlJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGlmICgoY29tcG9uZW50IGFzIGFueSkgPT09IG51bGwpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9XG4gICAgICB0eXBlT2ZDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gKGNvbXBvbmVudCBhcyBzdHJpbmcpXG4gICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnQgYXMgYW55KVxuXG4gICAgY29uc3Qgc3RvcmVkQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdXG5cbiAgICBpZiAoIXN0b3JlZENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVPZkNvbXBvbmVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBzdG9yZWRDb21wb25lbnQgPT09IGNvbXBvbmVudFxuICAgIH1cblxuICAgIGlmICh0eXBlT2ZDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzdG9yZWRDb21wb25lbnQgaW5zdGFuY2VvZiAoY29tcG9uZW50IGFzIENvbXBvbmVudENvbnN0cnVjdG9yPFQ+KVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGNvbXBvbmVudCwgaWYgaXQgZG9lc24ndCBleGlzdCwgaXQgdGhyb3dzIGFuIEVycm9yLlxuICAgKiBAcGFyYW0gY29tcG9uZW50IC0gY29tcG9uZW50IGNsYXNzIG9yIG5hbWVcbiAgICovXG4gIGdldENvbXBvbmVudDxUID0gYW55Pihjb21wb25lbnQ6IHN0cmluZyk6IFRcbiAgZ2V0Q29tcG9uZW50PFQ+KGNvbXBvbmVudDogQ29tcG9uZW50Q29uc3RydWN0b3I8VD4pOiBUXG4gIGdldENvbXBvbmVudDxUPihjb21wb25lbnQ6IENvbXBvbmVudENvbnN0cnVjdG9yPFQ+IHwgc3RyaW5nKTogVCB7XG4gICAgY29uc3QgdHlwZU9mQ29tcG9uZW50ID0gdHlwZW9mIGNvbXBvbmVudFxuXG4gICAgaWYgKHR5cGVPZkNvbXBvbmVudCAhPT0gJ3N0cmluZycgJiYgdHlwZU9mQ29tcG9uZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudGl0eSNnZXQoY29tcG9uZW50KTogY29tcG9uZW50IGlzIG5vdCBhIGNsYXNzIG9yIG5hbWUnKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPVxuICAgICAgdHlwZU9mQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICA/IChjb21wb25lbnQgYXMgc3RyaW5nKVxuICAgICAgICA6IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50IGFzIGFueSlcblxuICAgIGNvbnN0IHN0b3JlZENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXVxuXG4gICAgaWYgKCFzdG9yZWRDb21wb25lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbiBub3QgZ2V0IGNvbXBvbmVudCBcIiR7Y29tcG9uZW50TmFtZX1cIiBmcm9tIGVudGl0eSBcIiR7dGhpcy5pZGVudGlmaWVyfVwiYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0eXBlT2ZDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChzdG9yZWRDb21wb25lbnQgaW5zdGFuY2VvZiAoY29tcG9uZW50IGFzIENvbXBvbmVudENvbnN0cnVjdG9yPFQ+KSkge1xuICAgICAgICByZXR1cm4gc3RvcmVkQ29tcG9uZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbiBub3QgZ2V0IGNvbXBvbmVudCBcIiR7Y29tcG9uZW50TmFtZX1cIiBmcm9tIGVudGl0eSBcIiR7dGhpcy5pZGVudGlmaWVyfVwiIChieSBpbnN0YW5jZSlgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RvcmVkQ29tcG9uZW50XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGNvbXBvbmVudCwgaWYgaXQgZG9lc24ndCBleGlzdCwgaXQgcmV0dXJucyBudWxsLlxuICAgKiBAcGFyYW0gY29tcG9uZW50IC0gY29tcG9uZW50IGNsYXNzIG9yIG5hbWVcbiAgICovXG4gIGdldENvbXBvbmVudE9yTnVsbDxUID0gYW55Pihjb21wb25lbnQ6IHN0cmluZyk6IFQgfCBudWxsXG4gIGdldENvbXBvbmVudE9yTnVsbDxUPihjb21wb25lbnQ6IENvbXBvbmVudENvbnN0cnVjdG9yPFQ+KTogVCB8IG51bGxcbiAgZ2V0Q29tcG9uZW50T3JOdWxsPFQ+KGNvbXBvbmVudDogQ29tcG9uZW50Q29uc3RydWN0b3I8VD4gfCBzdHJpbmcpOiBUIHwgbnVsbCB7XG4gICAgY29uc3QgdHlwZU9mQ29tcG9uZW50ID0gdHlwZW9mIGNvbXBvbmVudFxuXG4gICAgaWYgKHR5cGVPZkNvbXBvbmVudCAhPT0gJ3N0cmluZycgJiYgdHlwZU9mQ29tcG9uZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFbnRpdHkjZ2V0T3JOdWxsKGNvbXBvbmVudCk6IGNvbXBvbmVudCBpcyBub3QgYSBjbGFzcyBvciBuYW1lJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPVxuICAgICAgdHlwZU9mQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICA/IChjb21wb25lbnQgYXMgc3RyaW5nKVxuICAgICAgICA6IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50IGFzIGFueSlcblxuICAgIGNvbnN0IHN0b3JlZENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXVxuXG4gICAgaWYgKCFzdG9yZWRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKHR5cGVPZkNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHN0b3JlZENvbXBvbmVudCBpbnN0YW5jZW9mIChjb21wb25lbnQgYXMgQ29tcG9uZW50Q29uc3RydWN0b3I8VD4pKSB7XG4gICAgICAgIHJldHVybiBzdG9yZWRDb21wb25lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3JlZENvbXBvbmVudFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBjb21wb25lbnQsIGlmIGl0IGRvZXNuJ3QgZXhpc3QsIGl0IGNyZWF0ZXMgdGhlIGNvbXBvbmVudCBhbmQgcmV0dXJucyBpdC5cbiAgICogQHBhcmFtIGNvbXBvbmVudCAtIGNvbXBvbmVudCBjbGFzc1xuICAgKi9cbiAgZ2V0Q29tcG9uZW50T3JDcmVhdGU8VD4oXG4gICAgY29tcG9uZW50OiBDb21wb25lbnRDb25zdHJ1Y3RvcjxUPiAmIHsgbmV3ICgpOiBUIH1cbiAgKTogVCB7XG4gICAgaWYgKHR5cGVvZiAoY29tcG9uZW50IGFzIGFueSkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW50aXR5I2dldE9yQ3JlYXRlKGNvbXBvbmVudCk6IGNvbXBvbmVudCBpcyBub3QgYSBjbGFzcycpXG4gICAgfVxuXG4gICAgbGV0IHJldCA9IHRoaXMuZ2V0Q29tcG9uZW50T3JOdWxsKGNvbXBvbmVudClcblxuICAgIGlmICghcmV0KSB7XG4gICAgICByZXQgPSBuZXcgY29tcG9uZW50KClcbiAgICAgIC8vIFNhZmUtZ3VhcmQgdG8gb25seSBhZGQgcmVnaXN0ZXJlZCBjb21wb25lbnRzIHRvIGVudGl0aWVzXG4gICAgICBnZXRDb21wb25lbnROYW1lKHJldClcbiAgICAgIHRoaXMuYWRkQ29tcG9uZW50T3JSZXBsYWNlKHJldCBhcyBhbnkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQuIElmIHRoZSBjb21wb25lbnQgYWxyZWFkeSBleGlzdCwgaXQgdGhyb3dzIGFuIEVycm9yLlxuICAgKiBAcGFyYW0gY29tcG9uZW50IC0gY29tcG9uZW50IGluc3RhbmNlLlxuICAgKi9cbiAgYWRkQ29tcG9uZW50PFQgZXh0ZW5kcyBvYmplY3Q+KGNvbXBvbmVudDogVCk6IFQge1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRW50aXR5I2FkZChjb21wb25lbnQpOiBZb3UgcGFzc2VkIGEgZnVuY3Rpb24gb3IgY2xhc3MgYXMgYSBjb21wb25lbnQsIGFuIGluc3RhbmNlIG9mIGNvbXBvbmVudCBpcyBleHBlY3RlZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnQpXG4gICAgY29uc3QgY2xhc3NJZCA9IGdldENvbXBvbmVudENsYXNzSWQoY29tcG9uZW50KVxuXG4gICAgaWYgKHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQSBjb21wb25lbnQgb2YgdHlwZSBcIiR7Y29tcG9uZW50TmFtZX1cIiBpcyBhbHJlYWR5IHByZXNlbnQgaW4gZW50aXR5IFwiJHt0aGlzLmlkZW50aWZpZXJ9XCJgXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdID0gY29tcG9uZW50XG5cbiAgICBpZiAodGhpcy5ldmVudE1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmVFdmVudChcbiAgICAgICAgbmV3IENvbXBvbmVudEFkZGVkKHRoaXMsIGNvbXBvbmVudE5hbWUsIGNsYXNzSWQpXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmVkQ29tcG9uZW50ID0gY29tcG9uZW50IGFzIENvbXBvbmVudExpa2VcblxuICAgIGlmICh0eXBlb2Ygc3RvcmVkQ29tcG9uZW50LmFkZGVkVG9FbnRpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0b3JlZENvbXBvbmVudC5hZGRlZFRvRW50aXR5KHRoaXMpXG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGluc3RhbmNlIGZyb20gdGhlIGVudGl0eS5cbiAgICogQHBhcmFtIGNvbXBvbmVudCAtIGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHRyaWdnZXJSZW1vdmVkRXZlbnQgLSBzaG91bGQgdGhpcyBhY3Rpb24gdHJpZ2dlciBhbiBldmVudD9cbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudChjb21wb25lbnQ6IHN0cmluZywgdHJpZ2dlclJlbW92ZWRFdmVudD86IGJvb2xlYW4pOiB2b2lkXG4gIHJlbW92ZUNvbXBvbmVudDxUIGV4dGVuZHMgb2JqZWN0PihcbiAgICBjb21wb25lbnQ6IFQsXG4gICAgdHJpZ2dlclJlbW92ZWRFdmVudD86IGJvb2xlYW5cbiAgKTogdm9pZFxuICByZW1vdmVDb21wb25lbnQoXG4gICAgY29tcG9uZW50OiBDb21wb25lbnRDb25zdHJ1Y3Rvcjxhbnk+LFxuICAgIHRyaWdnZXJSZW1vdmVkRXZlbnQ/OiBib29sZWFuXG4gICk6IHZvaWRcbiAgcmVtb3ZlQ29tcG9uZW50KFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgY29tcG9uZW50OiBvYmplY3QgfCBzdHJpbmcgfCBGdW5jdGlvbixcbiAgICB0cmlnZ2VyUmVtb3ZlZEV2ZW50ID0gdHJ1ZVxuICApOiB2b2lkIHtcbiAgICBjb25zdCB0eXBlT2ZDb21wb25lbnQgPSB0eXBlb2YgY29tcG9uZW50XG5cbiAgICBpZiAoXG4gICAgICB0eXBlT2ZDb21wb25lbnQgIT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlT2ZDb21wb25lbnQgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVPZkNvbXBvbmVudCAhPT0gJ29iamVjdCdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0VudGl0eSNyZW1vdmUoY29tcG9uZW50KTogY29tcG9uZW50IGlzIG5vdCBhIGNsYXNzLCBjbGFzcyBvciBuYW1lJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPVxuICAgICAgdHlwZU9mQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgICAgICA/IChjb21wb25lbnQgYXMgc3RyaW5nKVxuICAgICAgICA6IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50IGFzIGFueSlcblxuICAgIGNvbnN0IHN0b3JlZENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tcbiAgICAgIGNvbXBvbmVudE5hbWVcbiAgICBdIGFzIENvbXBvbmVudExpa2UgfCB2b2lkXG5cbiAgICBpZiAoIXN0b3JlZENvbXBvbmVudCkge1xuICAgICAgbG9nKFxuICAgICAgICBgRW50aXR5IFdhcm5pbmc6IFRyeWluZyB0byByZW1vdmUgaW5leGlzdGluZyBjb21wb25lbnQgXCIke2NvbXBvbmVudE5hbWV9XCIgZnJvbSBlbnRpdHkgXCIke3RoaXMuaWRlbnRpZmllcn1cImBcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlT2ZDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChzdG9yZWRDb21wb25lbnQgaW5zdGFuY2VvZiAoY29tcG9uZW50IGFzIENvbXBvbmVudENvbnN0cnVjdG9yPGFueT4pKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV1cblxuICAgICAgICBpZiAoc3RvcmVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgaWYgKHRyaWdnZXJSZW1vdmVkRXZlbnQgJiYgdGhpcy5ldmVudE1hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmVFdmVudChcbiAgICAgICAgICAgICAgbmV3IENvbXBvbmVudFJlbW92ZWQodGhpcywgY29tcG9uZW50TmFtZSwgc3RvcmVkQ29tcG9uZW50KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkQ29tcG9uZW50LnJlbW92ZWRGcm9tRW50aXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdG9yZWRDb21wb25lbnQucmVtb3ZlZEZyb21FbnRpdHkodGhpcylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2coXG4gICAgICAgICAgYEVudGl0eSBXYXJuaW5nOiBUcnlpbmcgdG8gcmVtb3ZlIHdyb25nIChieSBjb25zdHJ1Y3RvcikgY29tcG9uZW50IFwiJHtjb21wb25lbnROYW1lfVwiIGZyb20gZW50aXR5IFwiJHt0aGlzLmlkZW50aWZpZXJ9XCJgXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuY29tcG9uZW50c1tjb21wb25lbnROYW1lXVxuXG4gICAgaWYgKHN0b3JlZENvbXBvbmVudCkge1xuICAgICAgaWYgKHRyaWdnZXJSZW1vdmVkRXZlbnQgJiYgdGhpcy5ldmVudE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZUV2ZW50KFxuICAgICAgICAgIG5ldyBDb21wb25lbnRSZW1vdmVkKHRoaXMsIGNvbXBvbmVudE5hbWUsIHN0b3JlZENvbXBvbmVudClcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN0b3JlZENvbXBvbmVudC5yZW1vdmVkRnJvbUVudGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdG9yZWRDb21wb25lbnQucmVtb3ZlZEZyb21FbnRpdHkodGhpcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVudGl0eSBpcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBlbmdpbmUuXG4gICAqIFJldHVybnMgZmFsc2UgaWYgbm8gZW5naW5lIHdhcyBkZWZpbmVkLlxuICAgKi9cbiAgaXNBZGRlZFRvRW5naW5lKCk6IGJvb2xlYW4ge1xuICAgIGlmIChcbiAgICAgIHRoaXMuZW5naW5lICYmXG4gICAgICAodGhpcy51dWlkIGluIHRoaXMuZW5naW5lLmVudGl0aWVzIHx8IHRoaXMuZW5naW5lLnJvb3RFbnRpdHkgPT09IHRoaXMpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhcmVudCBlbnRpdHlcbiAgICovXG4gIHNldFBhcmVudChfcGFyZW50OiBJRW50aXR5IHwgQXR0YWNoYWJsZSB8IG51bGwpOiBJRW50aXR5IHtcbiAgICBsZXQgbmV3UGFyZW50OiBJRW50aXR5IHwgbnVsbFxuXG4gICAgLy8gQ2hlY2sgaWYgcGFyZW50IGlzIG9mIHR5cGUgQXR0YWNoYWJsZVxuICAgIGlmIChfcGFyZW50ICYmICdnZXRFbnRpdHlSZXByZXNlbnRhdGlvbicgaW4gX3BhcmVudCkge1xuICAgICAgaWYgKCF0aGlzLmVuZ2luZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEluIG9yZGVyIHRvIHNldCBhbiBhdHRhY2hhYmxlIGFzIHBhcmVudCwgeW91IGZpcnN0IG5lZWQgdG8gYWRkIHRoZSBlbnRpdHkgdG8gdGhlIGVuZ2luZS5gXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIG5ld1BhcmVudCA9IF9wYXJlbnQuZ2V0RW50aXR5UmVwcmVzZW50YXRpb24odGhpcy5lbmdpbmUpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BhcmVudCA9ICFfcGFyZW50ICYmIHRoaXMuZW5naW5lID8gdGhpcy5lbmdpbmUucm9vdEVudGl0eSA6IF9wYXJlbnRcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcblxuICAgIGlmIChuZXdQYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBzZXQgcGFyZW50IGZvciBlbnRpdHkgXCIke3RoaXMuaWRlbnRpZmllcn1cIjogQW4gZW50aXR5IGNhbid0IHNldCBpdHNlbGYgYXMgYSBpdHMgb3duIHBhcmVudGBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAobmV3UGFyZW50ID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGNvbnN0IGNpcmN1bGFyQW5jZXN0b3IgPSB0aGlzLmdldENpcmN1bGFyQW5jZXN0b3IobmV3UGFyZW50KVxuXG4gICAgaWYgKGNpcmN1bGFyQW5jZXN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBzZXQgcGFyZW50IGZvciBlbnRpdHkgXCIke3RoaXMuaWRlbnRpZmllcn1cIjogQ2lyY3VsYXIgcGFyZW50IHJlZmVyZW5jZXMgYXJlIG5vdCBhbGxvd2VkIChTZWUgZW50aXR5IFwiJHtjaXJjdWxhckFuY2VzdG9yfVwiKWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgZGVsZXRlIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW5bdGhpcy51dWlkXVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwYXJlbnQgYW5kIGNoaWxkIGFyZSBib3RoIG9uIHRoZSBlbmdpbmUsIG9yIG9mZiB0aGUgZW5naW5lLCB0b2dldGhlclxuICAgIGlmIChuZXdQYXJlbnQgIT09IG51bGwgJiYgbmV3UGFyZW50LnV1aWQgIT09ICcwJykge1xuICAgICAgaWYgKCFuZXdQYXJlbnQuaXNBZGRlZFRvRW5naW5lKCkgJiYgdGhpcy5pc0FkZGVkVG9FbmdpbmUoKSkge1xuICAgICAgICB0aGlzLmVuZ2luZSEucmVtb3ZlRW50aXR5KHRoaXMpXG4gICAgICB9XG4gICAgICBpZiAobmV3UGFyZW50LmlzQWRkZWRUb0VuZ2luZSgpICYmICF0aGlzLmlzQWRkZWRUb0VuZ2luZSgpKSB7XG4gICAgICAgIDsobmV3UGFyZW50IGFzIEVudGl0eSkuZW5naW5lIS5hZGRFbnRpdHkodGhpcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wYXJlbnQgPSBuZXdQYXJlbnQgfHwgbnVsbFxuICAgIHRoaXMucmVnaXN0ZXJBc0NoaWxkKClcblxuICAgIGlmICh0aGlzLmV2ZW50TWFuYWdlciAmJiB0aGlzLmVuZ2luZSkge1xuICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZUV2ZW50KG5ldyBQYXJlbnRDaGFuZ2VkKHRoaXMsIG5ld1BhcmVudCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJlbnQgZW50aXR5XG4gICAqL1xuICBnZXRQYXJlbnQoKTogSUVudGl0eSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZSB8fCB0aGlzLnV1aWRcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q2lyY3VsYXJBbmNlc3RvcihlbnQ6IElFbnRpdHkgfCBudWxsKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuZW5naW5lID8gdGhpcy5lbmdpbmUucm9vdEVudGl0eSA6IG51bGxcbiAgICBsZXQgZTogSUVudGl0eSB8IG51bGwgPSBlbnRcblxuICAgIHdoaWxlIChlICYmIGUgIT09IHJvb3QpIHtcbiAgICAgIGNvbnN0IHBhcmVudDogSUVudGl0eSB8IG51bGwgPSBlLmdldFBhcmVudCgpXG4gICAgICBpZiAocGFyZW50ID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiBlLnV1aWRcbiAgICAgIH1cbiAgICAgIGUgPSBwYXJlbnRcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckFzQ2hpbGQoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuXG4gICAgaWYgKHRoaXMudXVpZCAmJiBwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5jaGlsZHJlblt0aGlzLnV1aWRdID0gdGhpc1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgSUVuZ2luZSxcbiAgSVN5c3RlbSxcbiAgSUVudGl0eSxcbiAgQ29tcG9uZW50QWRkZWQsXG4gIENvbXBvbmVudFJlbW92ZWRcbn0gZnJvbSAnLi9JRW50aXR5J1xuXG5pbXBvcnQge1xuICBnZXRDb21wb25lbnROYW1lLFxuICBnZXRDb21wb25lbnRJZCxcbiAgRGlzcG9zYWJsZUNvbXBvbmVudFVwZGF0ZWQsXG4gIERpc3Bvc2FibGVDb21wb25lbnRMaWtlLFxuICBDb21wb25lbnRDb25zdHJ1Y3RvcixcbiAgRGlzcG9zYWJsZUNvbXBvbmVudENyZWF0ZWQsXG4gIERpc3Bvc2FibGVDb21wb25lbnRSZW1vdmVkLFxuICBnZXRDb21wb25lbnRDbGFzc0lkXG59IGZyb20gJy4vQ29tcG9uZW50J1xuaW1wb3J0IHsgRXZlbnRNYW5hZ2VyIH0gZnJvbSAnLi9FdmVudE1hbmFnZXInXG5pbXBvcnQgeyBDb21wb25lbnRHcm91cCB9IGZyb20gJy4vQ29tcG9uZW50R3JvdXAnXG5cbmltcG9ydCB7IGxvZywgZXJyb3IgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICcuL0VudGl0eSdcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudHlwZSBTeXN0ZW1FbnRyeSA9IHsgc3lzdGVtOiBJU3lzdGVtOyBwcmlvcml0eTogbnVtYmVyIH1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmdpbmUgaW1wbGVtZW50cyBJRW5naW5lIHtcbiAgcmVhZG9ubHkgZXZlbnRNYW5hZ2VyOiBFdmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKClcbiAgcmVhZG9ubHkgcm9vdEVudGl0eTogSUVudGl0eVxuICByZWFkb25seSBmaXJzdFBlcnNvbkNhbWVyYUVudGl0eTogSUVudGl0eVxuICByZWFkb25seSBhdmF0YXJFbnRpdHk6IElFbnRpdHlcblxuICAvLyBAaW50ZXJuYWxcbiAgcmVhZG9ubHkgc3lzdGVtczogU3lzdGVtRW50cnlbXSA9IFtdXG5cbiAgLy8gQGludGVybmFsXG4gIHJlYWRvbmx5IGVudGl0eUxpc3RzOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBJRW50aXR5Pj4gPSB7fVxuXG4gIC8vIEBpbnRlcm5hbFxuICByZWFkb25seSBhZGRlZFN5c3RlbXM6IElTeXN0ZW1bXSA9IFtdXG5cbiAgcHJpdmF0ZSByZWFkb25seSBfZW50aXRpZXM6IFJlY29yZDxzdHJpbmcsIElFbnRpdHk+ID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBfZGlzcG9zYWJsZUNvbXBvbmVudHM6IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAgRGlzcG9zYWJsZUNvbXBvbmVudExpa2VcbiAgPiA9IHt9XG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbXBvbmVudEdyb3VwczogUmVjb3JkPHN0cmluZywgQ29tcG9uZW50R3JvdXBbXT4gPSB7fVxuXG4gIC8vIHN5c3RlbXMgdGhhdCBkb2Vzbid0IHJlcXVpcmUgYW55IGNvbXBvbmVudCBvciBoYW5kbGUgdGhlaXIgb3duIGxvZ2ljXG4gIHByaXZhdGUgcmVhZG9ubHkgc2ltcGxlU3lzdGVtczogSVN5c3RlbVtdID0gW11cblxuICBnZXQgZW50aXRpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGl0aWVzIGFzIFJlYWRvbmx5PFJlY29yZDxzdHJpbmcsIElFbnRpdHk+PlxuICB9XG5cbiAgZ2V0IGRpc3Bvc2FibGVDb21wb25lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNwb3NhYmxlQ29tcG9uZW50cyBhcyBSZWFkb25seTxcbiAgICAgIFJlY29yZDxzdHJpbmcsIERpc3Bvc2FibGVDb21wb25lbnRMaWtlPlxuICAgID5cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHJvb3RFbnRpdHk6IElFbnRpdHkpIHtcbiAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRMaXN0ZW5lcihcbiAgICAgIENvbXBvbmVudEFkZGVkLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuY29tcG9uZW50QWRkZWRIYW5kbGVyXG4gICAgKVxuICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgQ29tcG9uZW50UmVtb3ZlZCxcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLmNvbXBvbmVudFJlbW92ZWRIYW5kbGVyXG4gICAgKVxuICAgIHRoaXMucm9vdEVudGl0eSA9IHJvb3RFbnRpdHlcbiAgICB0aGlzLmZpcnN0UGVyc29uQ2FtZXJhRW50aXR5ID0gbmV3IEVudGl0eSgpXG4gICAgOyh0aGlzLmZpcnN0UGVyc29uQ2FtZXJhRW50aXR5IGFzIGFueSkudXVpZCA9XG4gICAgICAnRmlyc3RQZXJzb25DYW1lcmFFbnRpdHlSZWZlcmVuY2UnXG4gICAgdGhpcy5hZGRFbnRpdHkodGhpcy5maXJzdFBlcnNvbkNhbWVyYUVudGl0eSlcbiAgICB0aGlzLmF2YXRhckVudGl0eSA9IG5ldyBFbnRpdHkoKVxuICAgIDsodGhpcy5hdmF0YXJFbnRpdHkgYXMgYW55KS51dWlkID0gJ0F2YXRhckVudGl0eVJlZmVyZW5jZSdcbiAgICB0aGlzLmFkZEVudGl0eSh0aGlzLmF2YXRhckVudGl0eSlcbiAgfVxuXG4gIGFkZEVudGl0eShlbnRpdHk6IElFbnRpdHkpOiBJRW50aXR5IHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbnRpdHkuZ2V0UGFyZW50KClcblxuICAgIGlmIChlbnRpdHkuaXNBZGRlZFRvRW5naW5lKCkpIHtcbiAgICAgIHJldHVybiBlbnRpdHlcbiAgICB9XG5cbiAgICBlbnRpdHkuZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXJcbiAgICA7KGVudGl0eSBhcyBFbnRpdHkpLmVuZ2luZSA9IHRoaXNcblxuICAgIHRoaXMuX2VudGl0aWVzW2VudGl0eS51dWlkXSA9IGVudGl0eVxuXG4gICAgdGhpcy5jaGVja1JlcXVpcmVtZW50c0FuZEFkZChlbnRpdHkpXG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgZW50aXR5LnNldFBhcmVudCh0aGlzLnJvb3RFbnRpdHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcGFyZW50LmlzQWRkZWRUb0VuZ2luZSgpICYmIHBhcmVudCAhPT0gdGhpcy5yb290RW50aXR5KSB7XG4gICAgICAgIGxvZyhcbiAgICAgICAgICAnRW5naW5lOiB3YXJuaW5nLCBhZGRlZCBhbiBlbnRpdHkgd2l0aCBhIHBhcmVudCBub3QgcHJlc2VudCBpbiB0aGUgZW5naW5lLiBQYXJlbnQgaWQ6ICcgK1xuICAgICAgICAgICAgcGFyZW50LnV1aWRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGVudGl0eS5hbGl2ZSA9IHRydWVcblxuICAgIGZvciAoY29uc3QgaSBpbiBlbnRpdHkuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZW50aXR5LmNoaWxkcmVuW2ldXG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKCFjaGlsZC5pc0FkZGVkVG9FbmdpbmUoKSkge1xuICAgICAgICAgIHRoaXMuYWRkRW50aXR5KGNoaWxkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudGl0eVxuICB9XG5cbiAgcmVtb3ZlRW50aXR5KGVudGl0eTogSUVudGl0eSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlkID0gZW50aXR5LnV1aWRcblxuICAgIGlmIChlbnRpdHkuaXNBZGRlZFRvRW5naW5lKCkpIHtcbiAgICAgIGZvciAoY29uc3QgY29tcG9uZW50TmFtZSBpbiBlbnRpdHkuY29tcG9uZW50cykge1xuICAgICAgICBjb25zdCBjb21wb25lbnRHcm91cHMgPSB0aGlzLl9jb21wb25lbnRHcm91cHNbY29tcG9uZW50TmFtZV1cblxuICAgICAgICBpZiAoY29tcG9uZW50R3JvdXBzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBncm91cEluZGV4IGluIGNvbXBvbmVudEdyb3Vwcykge1xuICAgICAgICAgICAgY29tcG9uZW50R3JvdXBzW2dyb3VwSW5kZXhdLnJlbW92ZUVudGl0eShlbnRpdHkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuZW50aXR5TGlzdHNbY29tcG9uZW50TmFtZV1baWRdXG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaW1wbGVTeXN0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN5c3RlbSA9IHRoaXMuc2ltcGxlU3lzdGVtc1tpXVxuXG4gICAgICAgIGlmIChzeXN0ZW0ub25SZW1vdmVFbnRpdHkpIHtcbiAgICAgICAgICBzeXN0ZW0ub25SZW1vdmVFbnRpdHkoZW50aXR5KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgaSBpbiBlbnRpdHkuY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBlbnRpdHkuY2hpbGRyZW5baV1cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFbnRpdHkoY2hpbGQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZW50aXR5LmFsaXZlID0gZmFsc2VcbiAgICAgIGVudGl0eS5ldmVudE1hbmFnZXIgPSBudWxsXG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9lbnRpdGllc1tpZF1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nKCdFbmdpbmU6IFRyeWluZyB0byByZW1vdmUgbm9uIGV4aXN0ZW50IGVudGl0eSBmcm9tIGVuZ2luZS4nKVxuICAgICAgaWYgKCFlbnRpdHkuaXNBZGRlZFRvRW5naW5lKCkpIHtcbiAgICAgICAgbG9nKFxuICAgICAgICAgIGBFbmdpbmU6IEVudGl0eSBcIiR7ZW50aXR5LnV1aWR9XCIgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIGFueSBlbmdpbmUgeWV0LmBcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKCdFbmdpbmU6IEVudGl0eSBpZDogJyArIGlkKVxuICAgICAgfVxuICAgICAgbG9nKFwiRW5naW5lOiBFbnRpdHkncyBjb21wb25lbnRzOlwiKVxuICAgICAgZm9yIChjb25zdCBjb21wb25lbnROYW1lIGluIGVudGl0eS5jb21wb25lbnRzKSB7XG4gICAgICAgIGxvZyhjb21wb25lbnROYW1lKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgYWRkU3lzdGVtKHN5c3RlbTogSVN5c3RlbSwgcHJpb3JpdHk6IG51bWJlciA9IDApIHtcbiAgICBpZiAodGhpcy5hZGRlZFN5c3RlbXMuaW5kZXhPZihzeXN0ZW0pICE9PSAtMSkge1xuICAgICAgbG9nKCdFbmdpbmU6IFRyeWluZyB0byBhZGQgYSBzeXN0ZW0gdGhhdCBpcyBhbHJlYWR5IGFkZGVkLiBBYm9ydGluZycpXG4gICAgICByZXR1cm4gc3lzdGVtXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3lzdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3lzdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuc3lzdGVtc1tpXVxuICAgICAgICBjb25zdCBpc0xhc3QgPSBpID09PSB0aGlzLnN5c3RlbXMubGVuZ3RoIC0gMVxuXG4gICAgICAgIGlmIChlbnRyeS5wcmlvcml0eSA+IHByaW9yaXR5KSB7XG4gICAgICAgICAgdGhpcy5hZGRlZFN5c3RlbXMucHVzaChzeXN0ZW0pXG4gICAgICAgICAgdGhpcy5zeXN0ZW1zLnNwbGljZShpLCAwLCB7IHN5c3RlbSwgcHJpb3JpdHkgfSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICAgIHRoaXMuYWRkZWRTeXN0ZW1zLnB1c2goc3lzdGVtKVxuICAgICAgICAgIHRoaXMuc3lzdGVtcy5zcGxpY2UoaSArIDEsIDAsIHsgc3lzdGVtLCBwcmlvcml0eSB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRlZFN5c3RlbXMucHVzaChzeXN0ZW0pXG4gICAgICB0aGlzLnN5c3RlbXMuc3BsaWNlKDEsIDAsIHsgc3lzdGVtLCBwcmlvcml0eSB9KVxuICAgIH1cblxuICAgIHRoaXMucmVnaXN0ZXJTeXN0ZW0oc3lzdGVtKVxuXG4gICAgcmV0dXJuIHN5c3RlbVxuICB9XG5cbiAgcmVtb3ZlU3lzdGVtKHN5c3RlbTogSVN5c3RlbSkge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuYWRkZWRTeXN0ZW1zLmluZGV4T2Yoc3lzdGVtKVxuXG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgIHN5c3RlbS5hY3RpdmUgPSBmYWxzZVxuXG4gICAgICBpZiAoc3lzdGVtLmRlYWN0aXZhdGUpIHtcbiAgICAgICAgc3lzdGVtLmRlYWN0aXZhdGUoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZGVkU3lzdGVtcy5zcGxpY2UoaWR4LCAxKVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3lzdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzeXMgPSB0aGlzLnN5c3RlbXNbaV0uc3lzdGVtXG4gICAgICAgIGlmIChzeXMgPT09IHN5c3RlbSkge1xuICAgICAgICAgIHRoaXMuc3lzdGVtcy5zcGxpY2UoaSwgMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnN5c3RlbXMpIHtcbiAgICAgIGNvbnN0IHN5c3RlbSA9IHRoaXMuc3lzdGVtc1tpXS5zeXN0ZW1cbiAgICAgIGlmIChzeXN0ZW0uYWN0aXZlICYmIHN5c3RlbS51cGRhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzeXN0ZW0udXBkYXRlKGR0KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gVE9ETzogZSBtYXkgbm90IGJlIGFuIEVycm9yXG4gICAgICAgICAgZXJyb3IoZSBhcyBhbnkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldEVudGl0aWVzV2l0aENvbXBvbmVudChjb21wb25lbnQ6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgZ2V0RW50aXRpZXNXaXRoQ29tcG9uZW50KFxuICAgIGNvbXBvbmVudDogQ29tcG9uZW50Q29uc3RydWN0b3I8YW55PlxuICApOiBSZWNvcmQ8c3RyaW5nLCBJRW50aXR5PlxuICBnZXRFbnRpdGllc1dpdGhDb21wb25lbnQoXG4gICAgY29tcG9uZW50OiBDb21wb25lbnRDb25zdHJ1Y3Rvcjxhbnk+IHwgc3RyaW5nXG4gICk6IFJlY29yZDxzdHJpbmcsIElFbnRpdHk+IHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID1cbiAgICAgIHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnID8gY29tcG9uZW50IDogZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnQpXG5cbiAgICBpZiAoY29tcG9uZW50TmFtZSBpbiB0aGlzLmVudGl0eUxpc3RzKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRpdHlMaXN0c1tjb21wb25lbnROYW1lXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKHRoaXMuZW50aXR5TGlzdHNbY29tcG9uZW50TmFtZV0gPSB7fSlcbiAgICB9XG4gIH1cblxuICByZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQ6IERpc3Bvc2FibGVDb21wb25lbnRMaWtlKSB7XG4gICAgY29uc3QgaWQgPSBnZXRDb21wb25lbnRJZChjb21wb25lbnQpXG4gICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50KVxuICAgIGNvbnN0IGNsYXNzSWQgPSBnZXRDb21wb25lbnRDbGFzc0lkKGNvbXBvbmVudClcbiAgICB0aGlzLl9kaXNwb3NhYmxlQ29tcG9uZW50c1tpZF0gPSBjb21wb25lbnRcbiAgICBpZiAoY2xhc3NJZCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZUV2ZW50KFxuICAgICAgICBuZXcgRGlzcG9zYWJsZUNvbXBvbmVudENyZWF0ZWQoaWQsIG5hbWUsIGNsYXNzSWQpXG4gICAgICApXG4gICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlRXZlbnQobmV3IERpc3Bvc2FibGVDb21wb25lbnRVcGRhdGVkKGlkLCBjb21wb25lbnQpKVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2VDb21wb25lbnQoY29tcG9uZW50OiBEaXNwb3NhYmxlQ29tcG9uZW50TGlrZSkge1xuICAgIGNvbnN0IGlkID0gZ2V0Q29tcG9uZW50SWQoY29tcG9uZW50KVxuXG4gICAgaWYgKGRlbGV0ZSB0aGlzLl9kaXNwb3NhYmxlQ29tcG9uZW50c1tpZF0pIHtcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmVFdmVudChuZXcgRGlzcG9zYWJsZUNvbXBvbmVudFJlbW92ZWQoaWQpKVxuXG4gICAgICBpZiAoY29tcG9uZW50Lm9uRGlzcG9zZSkge1xuICAgICAgICBjb21wb25lbnQub25EaXNwb3NlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdXBkYXRlQ29tcG9uZW50KGNvbXBvbmVudDogRGlzcG9zYWJsZUNvbXBvbmVudExpa2UpIHtcbiAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlRXZlbnQoXG4gICAgICBuZXcgRGlzcG9zYWJsZUNvbXBvbmVudFVwZGF0ZWQoZ2V0Q29tcG9uZW50SWQoY29tcG9uZW50KSwgY29tcG9uZW50KVxuICAgIClcbiAgfVxuXG4gIGdldENvbXBvbmVudEdyb3VwKC4uLnJlcXVpcmVzOiBDb21wb25lbnRDb25zdHJ1Y3Rvcjxhbnk+W10pIHtcbiAgICBsZXQgY29tcG9uZW50R3JvdXAgPSB1bmRlZmluZWRcblxuICAgIC8vIFJldHVybiBhbiBhbHJlYWR5IGNyZWF0ZWQgY29tcG9uZW50LWdyb3VwIGlmIGl0IGFscmVhZHkgZXhpc3RzXG4gICAgaWYgKHJlcXVpcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIDEuIGdldCBjb21wb25lbnQgZ3JvdXBzIGZvciBmaXJzdCByZXF1aXJlXG4gICAgICBjb25zdCBjb21wb25lbnRHcm91cHMgPVxuICAgICAgICB0aGlzLl9jb21wb25lbnRHcm91cHNbZ2V0Q29tcG9uZW50TmFtZShyZXF1aXJlc1swXSldXG5cbiAgICAgIGlmIChjb21wb25lbnRHcm91cHMpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHJlcXVpcmVzLnNsaWNlKClcblxuICAgICAgICAvLyAyLiBzZWFyY2ggZm9yIGEgY29tcG9uZW50IGdyb3VwIHRoYXQgaGFzIGFsbCB0aGUgc2FtZSByZXF1aXJlbWVudHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wb25lbnRHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB0cmF2ZXJzZWRDb21wb25lbnRHcm91cCA9IGNvbXBvbmVudEdyb3Vwc1tpXVxuXG4gICAgICAgICAgaWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSB0cmF2ZXJzZWRDb21wb25lbnRHcm91cC5yZXF1aXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29tcG9uZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VkQ29tcG9uZW50R3JvdXAucmVxdWlyZXMuaW5kZXhPZihjb21wb25lbnRzW2pdKSA9PT0gLTFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgaWYgKGogPT09IGNvbXBvbmVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudEdyb3VwID0gdHJhdmVyc2VkQ29tcG9uZW50R3JvdXBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50R3JvdXApIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudEdyb3VwKSB7XG4gICAgICAvLyAzLiBGb3VuZCBhbiBleGlzdGVudCBjb21wb25lbnQgZ3JvdXAgd2l0aCB0aGUgZXhhY3Qgc2FtZSByZXF1aXJlbWVudHNcbiAgICAgIHJldHVybiBjb21wb25lbnRHcm91cFxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYW5kIHN0b3JlIGl0XG4gICAgY29tcG9uZW50R3JvdXAgPSBuZXcgQ29tcG9uZW50R3JvdXAoLi4ucmVxdWlyZXMpXG5cbiAgICBjb21wb25lbnRHcm91cC5hY3RpdmUgPSB0cnVlXG5cbiAgICBjb25zdCByZXF1aXJlc05hbWVzID0gY29tcG9uZW50R3JvdXAucmVxdWlyZXNOYW1lc1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1aXJlc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb21wb25lbnROYW1lID0gcmVxdWlyZXNOYW1lc1tpXVxuXG4gICAgICBsZXQgY29tcG9uZW50R3JvdXBzID0gdGhpcy5fY29tcG9uZW50R3JvdXBzW2NvbXBvbmVudE5hbWVdXG5cbiAgICAgIGlmICghY29tcG9uZW50R3JvdXBzKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudEdyb3Vwc1tjb21wb25lbnROYW1lXSA9IGNvbXBvbmVudEdyb3VwcyA9IFtdXG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnRHcm91cHMuaW5kZXhPZihjb21wb25lbnRHcm91cCkgPT09IC0xKSB7XG4gICAgICAgIGNvbXBvbmVudEdyb3Vwcy5wdXNoKGNvbXBvbmVudEdyb3VwKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgZW50aXR5SWQgaW4gdGhpcy5fZW50aXRpZXMpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXF1aXJlbWVudHModGhpcy5fZW50aXRpZXNbZW50aXR5SWRdLCBjb21wb25lbnRHcm91cClcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50R3JvdXBcbiAgfVxuXG4gIHJlbW92ZUNvbXBvbmVudEdyb3VwKGNvbXBvbmVudEdyb3VwOiBDb21wb25lbnRHcm91cCkge1xuICAgIGlmIChjb21wb25lbnRHcm91cC5hY3RpdmUpIHtcbiAgICAgIGNvbXBvbmVudEdyb3VwLmFjdGl2ZSA9IGZhbHNlXG4gICAgICBjb25zdCByZXF1aXJlc05hbWVzID0gY29tcG9uZW50R3JvdXAucmVxdWlyZXNOYW1lc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1aXJlc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSByZXF1aXJlc05hbWVzW2ldXG5cbiAgICAgICAgY29uc3QgY29tcG9uZW50R3JvdXBzID0gdGhpcy5fY29tcG9uZW50R3JvdXBzW2NvbXBvbmVudE5hbWVdXG5cbiAgICAgICAgaWYgKGNvbXBvbmVudEdyb3Vwcykge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IGNvbXBvbmVudEdyb3Vwcy5pbmRleE9mKGNvbXBvbmVudEdyb3VwKVxuICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICBjb21wb25lbnRHcm91cHMuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlclN5c3RlbShzeXN0ZW06IElTeXN0ZW0pIHtcbiAgICBzeXN0ZW0uYWN0aXZlID0gdHJ1ZVxuXG4gICAgaWYgKHN5c3RlbS5hY3RpdmF0ZSkge1xuICAgICAgc3lzdGVtLmFjdGl2YXRlKHRoaXMpXG4gICAgfVxuXG4gICAgdGhpcy5zaW1wbGVTeXN0ZW1zLnB1c2goc3lzdGVtKVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja1JlcXVpcmVtZW50c0FuZEFkZChlbnRpdHk6IElFbnRpdHkpIHtcbiAgICBpZiAoIWVudGl0eS5pc0FkZGVkVG9FbmdpbmUoKSkgcmV0dXJuXG5cbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudE5hbWUgaW4gZW50aXR5LmNvbXBvbmVudHMpIHtcbiAgICAgIGlmICghKGNvbXBvbmVudE5hbWUgaW4gdGhpcy5lbnRpdHlMaXN0cykpIHtcbiAgICAgICAgdGhpcy5lbnRpdHlMaXN0c1tjb21wb25lbnROYW1lXSA9IHt9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW50aXR5TGlzdHNbY29tcG9uZW50TmFtZV1bZW50aXR5LnV1aWRdID0gZW50aXR5XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudEdyb3VwcyA9IHRoaXMuX2NvbXBvbmVudEdyb3Vwc1tjb21wb25lbnROYW1lXVxuXG4gICAgICBpZiAoY29tcG9uZW50R3JvdXBzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3lzdGVtSW5kZXggaW4gY29tcG9uZW50R3JvdXBzKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVtZW50cyhlbnRpdHksIGNvbXBvbmVudEdyb3Vwc1tzeXN0ZW1JbmRleF0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2ltcGxlU3lzdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3lzdGVtID0gdGhpcy5zaW1wbGVTeXN0ZW1zW2ldXG5cbiAgICAgIGlmIChzeXN0ZW0ub25BZGRFbnRpdHkpIHtcbiAgICAgICAgc3lzdGVtLm9uQWRkRW50aXR5KGVudGl0eSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrUmVxdWlyZW1lbnRzKGVudGl0eTogSUVudGl0eSwgc3lzdGVtOiBDb21wb25lbnRHcm91cCkge1xuICAgIGlmIChzeXN0ZW0ubWVldHNSZXF1aXJlbWVudHMoZW50aXR5KSkge1xuICAgICAgaWYgKCFzeXN0ZW0uaGFzRW50aXR5KGVudGl0eSkpIHtcbiAgICAgICAgc3lzdGVtLmFkZEVudGl0eShlbnRpdHkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzeXN0ZW0uaGFzRW50aXR5KGVudGl0eSkpIHtcbiAgICAgICAgc3lzdGVtLnJlbW92ZUVudGl0eShlbnRpdHkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb21wb25lbnRBZGRlZEhhbmRsZXIoZXZlbnQ6IENvbXBvbmVudEFkZGVkKSB7XG4gICAgY29uc3QgeyBlbnRpdHksIGNvbXBvbmVudE5hbWUgfSA9IGV2ZW50XG5cbiAgICBpZiAoIWVudGl0eS5pc0FkZGVkVG9FbmdpbmUoKSkgcmV0dXJuXG5cbiAgICBpZiAoIXRoaXMuZW50aXR5TGlzdHNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHRoaXMuZW50aXR5TGlzdHNbY29tcG9uZW50TmFtZV0gPSB7IFtlbnRpdHkudXVpZF06IGVudGl0eSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW50aXR5TGlzdHNbY29tcG9uZW50TmFtZV1bZW50aXR5LnV1aWRdID0gZW50aXR5XG4gICAgfVxuXG4gICAgY29uc3QgY29tcG9uZW50R3JvdXBzID0gdGhpcy5fY29tcG9uZW50R3JvdXBzW2NvbXBvbmVudE5hbWVdXG5cbiAgICBpZiAoY29tcG9uZW50R3JvdXBzKSB7XG4gICAgICBmb3IgKGNvbnN0IGkgaW4gY29tcG9uZW50R3JvdXBzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlbWVudHMoZW50aXR5LCBjb21wb25lbnRHcm91cHNbaV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb21wb25lbnRSZW1vdmVkSGFuZGxlcihldmVudDogQ29tcG9uZW50UmVtb3ZlZCkge1xuICAgIC8vIEluIGNhc2UgYSBzaW5nbGUgY29tcG9uZW50IGdldHMgcmVtb3ZlZCBmcm9tIGFuIGVudGl0eSwgd2UgaW5mb3JtXG4gICAgLy8gYWxsIHN5c3RlbXMgdGhhdCB0aGlzIGVudGl0eSBsb3N0IHRoaXMgc3BlY2lmaWMgY29tcG9uZW50LlxuICAgIGNvbnN0IHsgZW50aXR5LCBjb21wb25lbnROYW1lIH0gPSBldmVudFxuXG4gICAgaWYgKCFlbnRpdHkuaXNBZGRlZFRvRW5naW5lKCkpIHJldHVyblxuXG4gICAgZGVsZXRlIHRoaXMuZW50aXR5TGlzdHNbY29tcG9uZW50TmFtZV1bZW50aXR5LnV1aWRdXG5cbiAgICBjb25zdCBjb21wb25lbnRHcm91cHMgPSB0aGlzLl9jb21wb25lbnRHcm91cHNbY29tcG9uZW50TmFtZV1cblxuICAgIGlmIChjb21wb25lbnRHcm91cHMpIHtcbiAgICAgIGZvciAoY29uc3QgaSBpbiBjb21wb25lbnRHcm91cHMpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVtZW50cyhlbnRpdHksIGNvbXBvbmVudEdyb3Vwc1tpXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGVycm9yIH0gZnJvbSAnLi9oZWxwZXJzJ1xuXG5kZWNsYXJlIGxldCBQcm9taXNlOiBhbnlcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIFRhc2tSZXN1bHQ8VD4gPSBQcm9taXNlPFQ+ICYge1xuICBpc0NvbXBsZXRlOiBib29sZWFuXG4gIGRpZEZhaWw/OiBib29sZWFuXG4gIGVycm9yPzogRXJyb3JcbiAgcmVzdWx0PzogVFxufVxuXG5jb25zdCBfZGVmZXIgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpXG5cbi8qKlxuICogRXhlY3V0ZXMgYW4gYXN5bmNocm9ub3VzIHRhc2tcbiAqIEBwYXJhbSB0YXNrIC0gdGhlIHRhc2sgdG8gZXhlY3V0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZVRhc2s8VD4odGFzazogKCkgPT4gUHJvbWlzZTxUPik6IFRhc2tSZXN1bHQ8VD4ge1xuICBjb25zdCByZXN1bHQ6IFRhc2tSZXN1bHQ8VD4gPSBfZGVmZXIodGFzaylcblxuICByZXN1bHQuaXNDb21wbGV0ZSA9IGZhbHNlXG5cbiAgcmVzdWx0XG4gICAgLnRoZW4oKCQpID0+IHtcbiAgICAgIHJlc3VsdC5pc0NvbXBsZXRlID0gdHJ1ZVxuICAgICAgcmVzdWx0LnJlc3VsdCA9ICRcbiAgICAgIHJlc3VsdC5kaWRGYWlsID0gZmFsc2VcbiAgICB9KVxuICAgIC5jYXRjaCgoJCkgPT4ge1xuICAgICAgcmVzdWx0LmlzQ29tcGxldGUgPSB0cnVlXG4gICAgICByZXN1bHQuZXJyb3IgPSAkXG4gICAgICByZXN1bHQuZGlkRmFpbCA9IHRydWVcbiAgICAgIGVycm9yKCdleGVjdXRlVGFzazogRkFJTEVEICcgKyAkLnRvU3RyaW5nKCksICQpXG4gICAgfSlcblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJpbXBvcnQgeyBleGVjdXRlVGFzayB9IGZyb20gJy4vVGFzaydcblxuZGVjbGFyZSBsZXQgUHJvbWlzZTogYW55XG5cbi8qKlxuICogQSBjbGFzcyBzZXJ2ZXMgYXMgYSBtZWRpdW0gYmV0d2VlbiB0aGUgb2JzZXJ2YWJsZSBhbmQgaXRzIG9ic2VydmVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2ZXJFdmVudFN0YXRlIHtcbiAgLyoqXG4gICAqIEFuIE9ic2VydmVyIGNhbiBzZXQgdGhpcyBwcm9wZXJ0eSB0byB0cnVlIHRvIHByZXZlbnQgc3Vic2VxdWVudCBvYnNlcnZlcnMgb2YgYmVpbmcgbm90aWZpZWRcbiAgICovXG4gIHB1YmxpYyBza2lwTmV4dE9ic2VydmVycyE6IGJvb2xlYW5cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXNrIHZhbHVlIHRoYXQgd2VyZSB1c2VkIHRvIHRyaWdnZXIgdGhlIGV2ZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBFdmVudFN0YXRlIG9iamVjdFxuICAgKi9cbiAgcHVibGljIG1hc2shOiBudW1iZXJcblxuICAvKipcbiAgICogVGhlIG9iamVjdCB0aGF0IG9yaWdpbmFsbHkgbm90aWZpZWQgdGhlIGV2ZW50XG4gICAqL1xuICBwdWJsaWMgdGFyZ2V0PzogYW55XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IG9iamVjdCBpbiB0aGUgYnViYmxpbmcgcGhhc2VcbiAgICovXG4gIHB1YmxpYyBjdXJyZW50VGFyZ2V0PzogYW55XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBsYXN0IGZ1bmN0aW9uIHRoYXQgd2FzIGV4ZWN1dGVkLlxuICAgKiBJZiBpdCBpcyB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gdGhlIGNhbGxiYWNrIGNoYWluIGl0IHdpbGwgYmUgdGhlIGV2ZW50IGRhdGEuXG4gICAqL1xuICBwdWJsaWMgbGFzdFJldHVyblZhbHVlPzogYW55XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBFdmVudFN0YXRlXG4gICAqIEBwYXJhbSBtYXNrIC0gZGVmaW5lcyB0aGUgbWFzayBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0ZVxuICAgKiBAcGFyYW0gc2tpcE5leHRPYnNlcnZlcnMgLSBkZWZpbmVzIGEgZmxhZyB3aGljaCB3aWxsIGluc3RydWN0IHRoZSBvYnNlcnZhYmxlIHRvIHNraXAgZm9sbG93aW5nIG9ic2VydmVycyB3aGVuIHNldCB0byB0cnVlXG4gICAqIEBwYXJhbSB0YXJnZXQgLSBkZWZpbmVzIHRoZSBvcmlnaW5hbCB0YXJnZXQgb2YgdGhlIHN0YXRlXG4gICAqIEBwYXJhbSBjdXJyZW50VGFyZ2V0IC0gZGVmaW5lcyB0aGUgY3VycmVudCB0YXJnZXQgb2YgdGhlIHN0YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBtYXNrOiBudW1iZXIsXG4gICAgc2tpcE5leHRPYnNlcnZlcnMgPSBmYWxzZSxcbiAgICB0YXJnZXQ/OiBhbnksXG4gICAgY3VycmVudFRhcmdldD86IGFueVxuICApIHtcbiAgICB0aGlzLmluaXRhbGl6ZShtYXNrLCBza2lwTmV4dE9ic2VydmVycywgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGN1cnJlbnQgZXZlbnQgc3RhdGVcbiAgICogQHBhcmFtIG1hc2sgLSBkZWZpbmVzIHRoZSBtYXNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0YXRlXG4gICAqIEBwYXJhbSBza2lwTmV4dE9ic2VydmVycyAtIGRlZmluZXMgYSBmbGFnIHdoaWNoIHdpbGwgaW5zdHJ1Y3QgdGhlIG9ic2VydmFibGUgdG8gc2tpcCBmb2xsb3dpbmcgb2JzZXJ2ZXJzIHdoZW4gc2V0IHRvIHRydWVcbiAgICogQHBhcmFtIHRhcmdldCAtIGRlZmluZXMgdGhlIG9yaWdpbmFsIHRhcmdldCBvZiB0aGUgc3RhdGVcbiAgICogQHBhcmFtIGN1cnJlbnRUYXJnZXQgLSBkZWZpbmVzIHRoZSBjdXJyZW50IHRhcmdldCBvZiB0aGUgc3RhdGVcbiAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgZXZlbnQgc3RhdGVcbiAgICovXG4gIHB1YmxpYyBpbml0YWxpemUoXG4gICAgbWFzazogbnVtYmVyLFxuICAgIHNraXBOZXh0T2JzZXJ2ZXJzID0gZmFsc2UsXG4gICAgdGFyZ2V0PzogYW55LFxuICAgIGN1cnJlbnRUYXJnZXQ/OiBhbnlcbiAgKTogT2JzZXJ2ZXJFdmVudFN0YXRlIHtcbiAgICB0aGlzLm1hc2sgPSBtYXNrXG4gICAgdGhpcy5za2lwTmV4dE9ic2VydmVycyA9IHNraXBOZXh0T2JzZXJ2ZXJzXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXRcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhbiBPYnNlcnZlciByZWdpc3RlcmVkIHRvIGEgZ2l2ZW4gT2JzZXJ2YWJsZSBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBPYnNlcnZlcjxUPiB7XG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgYSBwcm9wZXJ0eSBkZWZpbmluZyB0aGF0IHRoZSBvYnNlcnZlciBhcyB0byBiZSB1bnJlZ2lzdGVyZWQgYWZ0ZXIgdGhlIG5leHQgbm90aWZpY2F0aW9uXG4gICAqL1xuICBwdWJsaWMgdW5yZWdpc3Rlck9uTmV4dENhbGwgPSBmYWxzZVxuXG4gIC8qKiBGb3IgaW50ZXJuYWwgdXNhZ2UgKi9cbiAgcHVibGljIF93aWxsQmVVbnJlZ2lzdGVyZWQgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9ic2VydmVyXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIGRlZmluZXMgdGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiB0aGUgb2JzZXJ2ZXIgaXMgbm90aWZpZWRcbiAgICogQHBhcmFtIG1hc2sgLSBkZWZpbmVzIHRoZSBtYXNrIG9mIHRoZSBvYnNlcnZlciAodXNlZCB0byBmaWx0ZXIgbm90aWZpY2F0aW9ucylcbiAgICogQHBhcmFtIHNjb3BlIC0gZGVmaW5lcyB0aGUgY3VycmVudCBzY29wZSB1c2VkIHRvIHJlc3RvcmUgdGhlIEpTIGNvbnRleHRcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbiB0aGUgb2JzZXJ2ZXIgaXMgbm90aWZpZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgY2FsbGJhY2s6IChldmVudERhdGE6IFQsIGV2ZW50U3RhdGU6IE9ic2VydmVyRXZlbnRTdGF0ZSkgPT4gdm9pZCxcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBtYXNrIG9mIHRoZSBvYnNlcnZlciAodXNlZCB0byBmaWx0ZXIgbm90aWZpY2F0aW9ucylcbiAgICAgKi9cbiAgICBwdWJsaWMgbWFzazogbnVtYmVyLFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGN1cnJlbnQgc2NvcGUgdXNlZCB0byByZXN0b3JlIHRoZSBKUyBjb250ZXh0XG4gICAgICovXG4gICAgcHVibGljIHNjb3BlOiBhbnkgPSBudWxsXG4gICkge31cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBsaXN0IG9mIG9ic2VydmVycyByZWdpc3RlcmVkIHRvIG11bHRpcGxlIE9ic2VydmFibGVzIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpT2JzZXJ2ZXI8VD4ge1xuICBwcml2YXRlIF9vYnNlcnZlcnM6IE9ic2VydmVyPFQ+W10gfCBudWxsID0gbnVsbFxuICBwcml2YXRlIF9vYnNlcnZhYmxlczogT2JzZXJ2YWJsZTxUPltdIHwgbnVsbCA9IG51bGxcblxuICAvKipcbiAgICogUmFpc2UgYSBjYWxsYmFjayB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2YWJsZSB3aWxsIG5vdGlmeVxuICAgKiBAcGFyYW0gb2JzZXJ2YWJsZXMgLSBkZWZpbmVzIGEgbGlzdCBvZiBvYnNlcnZhYmxlcyB0byB3YXRjaFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBkZWZpbmVzIHRoZSBjYWxsYmFjayB0byBjYWxsIG9uIG5vdGlmaWNhdGlvblxuICAgKiBAcGFyYW0gbWFzayAtIGRlZmluZXMgdGhlIG1hc2sgdXNlZCB0byBmaWx0ZXIgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gc2NvcGUgLSBkZWZpbmVzIHRoZSBjdXJyZW50IHNjb3BlIHVzZWQgdG8gcmVzdG9yZSB0aGUgSlMgY29udGV4dFxuICAgKiBAcmV0dXJucyB0aGUgbmV3IE11bHRpT2JzZXJ2ZXJcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgV2F0Y2g8VD4oXG4gICAgb2JzZXJ2YWJsZXM6IE9ic2VydmFibGU8VD5bXSxcbiAgICBjYWxsYmFjazogKGV2ZW50RGF0YTogVCwgZXZlbnRTdGF0ZTogT2JzZXJ2ZXJFdmVudFN0YXRlKSA9PiB2b2lkLFxuICAgIG1hc2s6IG51bWJlciA9IC0xLFxuICAgIHNjb3BlOiBhbnkgPSBudWxsXG4gICk6IE11bHRpT2JzZXJ2ZXI8VD4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNdWx0aU9ic2VydmVyPFQ+KClcblxuICAgIHJlc3VsdC5fb2JzZXJ2ZXJzID0gbmV3IEFycmF5PE9ic2VydmVyPFQ+PigpXG4gICAgcmVzdWx0Ll9vYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzXG5cbiAgICBmb3IgKGNvbnN0IG9ic2VydmFibGUgb2Ygb2JzZXJ2YWJsZXMpIHtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gb2JzZXJ2YWJsZS5hZGQoY2FsbGJhY2ssIG1hc2ssIGZhbHNlLCBzY29wZSlcbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICByZXN1bHQuX29ic2VydmVycy5wdXNoKG9ic2VydmVyKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIGFzc29jaWF0ZWQgcmVzb3VyY2VzXG4gICAqL1xuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fb2JzZXJ2ZXJzICYmIHRoaXMuX29ic2VydmFibGVzKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fb2JzZXJ2ZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlc1tpbmRleF0ucmVtb3ZlKHRoaXMuX29ic2VydmVyc1tpbmRleF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gbnVsbFxuICAgIHRoaXMuX29ic2VydmFibGVzID0gbnVsbFxuICB9XG59XG5cbi8qKlxuICogVGhlIE9ic2VydmFibGUgY2xhc3MgaXMgYSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIE9ic2VydmFibGUgcGF0dGVybi5cbiAqXG4gKiBUaGVyZSdzIG9uZSBzbGlnaHQgcGFydGljdWxhcml0eSB0aG91Z2g6IGEgZ2l2ZW4gT2JzZXJ2YWJsZSBjYW4gbm90aWZ5IGl0cyBvYnNlcnZlciB1c2luZyBhIHBhcnRpY3VsYXIgbWFzayB2YWx1ZSwgb25seSB0aGUgT2JzZXJ2ZXJzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIG1hc2sgdmFsdWUgd2lsbCBiZSBub3RpZmllZC5cbiAqIFRoaXMgZW5hYmxlIGEgbW9yZSBmaW5lIGdyYWluZWQgZXhlY3V0aW9uIHdpdGhvdXQgaGF2aW5nIHRvIHJlbHkgb24gbXVsdGlwbGUgZGlmZmVyZW50IE9ic2VydmFibGUgb2JqZWN0cy5cbiAqIEZvciBpbnN0YW5jZSB5b3UgbWF5IGhhdmUgYSBnaXZlbiBPYnNlcnZhYmxlIHRoYXQgaGF2ZSBmb3VyIGRpZmZlcmVudCB0eXBlcyBvZiBub3RpZmljYXRpb25zOiBNb3ZlIChtYXNrID0gMHgwMSksIFN0b3AgKG1hc2sgPSAweDAyKSwgVHVybiBSaWdodCAobWFzayA9IDBYMDQpLCBUdXJuIExlZnQgKG1hc2sgPSAwWDA4KS5cbiAqIEEgZ2l2ZW4gb2JzZXJ2ZXIgY2FuIHJlZ2lzdGVyIGl0c2VsZiB3aXRoIG9ubHkgTW92ZSBhbmQgU3RvcCAobWFzayA9IDB4MDMpLCB0aGVuIGl0IHdpbGwgb25seSBiZSBub3RpZmllZCB3aGVuIG9uZSBvZiB0aGVzZSB0d28gb2NjdXJzIGFuZCB3aWxsIG5ldmVyIGJlIGZvciBUdXJuIExlZnQvUmlnaHQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZTxUPiB7XG4gIHByaXZhdGUgX29ic2VydmVycyA9IG5ldyBBcnJheTxPYnNlcnZlcjxUPj4oKVxuXG4gIHByaXZhdGUgX2V2ZW50U3RhdGU6IE9ic2VydmVyRXZlbnRTdGF0ZVxuXG4gIHByaXZhdGUgX29uT2JzZXJ2ZXJBZGRlZDogbnVsbCB8ICgob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB2b2lkKSA9IG51bGxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvYnNlcnZhYmxlXG4gICAqIEBwYXJhbSBvbk9ic2VydmVyQWRkZWQgLSBkZWZpbmVzIGEgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIGEgbmV3IG9ic2VydmVyIGlzIGFkZGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihvbk9ic2VydmVyQWRkZWQ/OiAob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB2b2lkKSB7XG4gICAgdGhpcy5fZXZlbnRTdGF0ZSA9IG5ldyBPYnNlcnZlckV2ZW50U3RhdGUoMClcblxuICAgIGlmIChvbk9ic2VydmVyQWRkZWQpIHtcbiAgICAgIHRoaXMuX29uT2JzZXJ2ZXJBZGRlZCA9IG9uT2JzZXJ2ZXJBZGRlZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgT2JzZXJ2ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIHRoYXQgT2JzZXJ2ZXJcbiAgICogQHBhcmFtIG1hc2sgLSB0aGUgbWFzayB1c2VkIHRvIGZpbHRlciBvYnNlcnZlcnNcbiAgICogQHBhcmFtIGluc2VydEZpcnN0IC0gaWYgdHJ1ZSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBpbnNlcnRlZCBhdCB0aGUgZmlyc3QgcG9zaXRpb24sIGhlbmNlIGV4ZWN1dGVkIGJlZm9yZSB0aGUgb3RoZXJzIG9uZXMuIElmIGZhbHNlIChkZWZhdWx0IGJlaGF2aW9yKSB0aGUgY2FsbGJhY2sgd2lsbCBiZSBpbnNlcnRlZCBhdCB0aGUgbGFzdCBwb3NpdGlvbiwgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBvdGhlcnMgYWxyZWFkeSBwcmVzZW50LlxuICAgKiBAcGFyYW0gc2NvcGUgLSBvcHRpb25hbCBzY29wZSBmb3IgdGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBmcm9tXG4gICAqIEBwYXJhbSB1bnJlZ2lzdGVyT25GaXJzdENhbGwgLSBkZWZpbmVzIGlmIHRoZSBvYnNlcnZlciBhcyB0byBiZSB1bnJlZ2lzdGVyZWQgYWZ0ZXIgdGhlIG5leHQgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgY3JlYXRlZCBmb3IgdGhlIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgYWRkKFxuICAgIGNhbGxiYWNrOiAoZXZlbnREYXRhOiBULCBldmVudFN0YXRlOiBPYnNlcnZlckV2ZW50U3RhdGUpID0+IHZvaWQsXG4gICAgbWFzazogbnVtYmVyID0gLTEsXG4gICAgaW5zZXJ0Rmlyc3QgPSBmYWxzZSxcbiAgICBzY29wZTogYW55ID0gbnVsbCxcbiAgICB1bnJlZ2lzdGVyT25GaXJzdENhbGwgPSBmYWxzZVxuICApOiBudWxsIHwgT2JzZXJ2ZXI8VD4ge1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIoY2FsbGJhY2ssIG1hc2ssIHNjb3BlKVxuICAgIG9ic2VydmVyLnVucmVnaXN0ZXJPbk5leHRDYWxsID0gdW5yZWdpc3Rlck9uRmlyc3RDYWxsXG5cbiAgICBpZiAoaW5zZXJ0Rmlyc3QpIHtcbiAgICAgIHRoaXMuX29ic2VydmVycy51bnNoaWZ0KG9ic2VydmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vYnNlcnZlcnMucHVzaChvYnNlcnZlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb25PYnNlcnZlckFkZGVkKSB7XG4gICAgICB0aGlzLl9vbk9ic2VydmVyQWRkZWQob2JzZXJ2ZXIpXG4gICAgfVxuXG4gICAgcmV0dXJuIG9ic2VydmVyXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IE9ic2VydmVyIHdpdGggdGhlIHNwZWNpZmllZCBjYWxsYmFjayBhbmQgdW5yZWdpc3RlcnMgYWZ0ZXIgdGhlIG5leHQgbm90aWZpY2F0aW9uXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIHRoYXQgT2JzZXJ2ZXJcbiAgICogQHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBjcmVhdGVkIGZvciB0aGUgY2FsbGJhY2tcbiAgICovXG4gIHB1YmxpYyBhZGRPbmNlKFxuICAgIGNhbGxiYWNrOiAoZXZlbnREYXRhOiBULCBldmVudFN0YXRlOiBPYnNlcnZlckV2ZW50U3RhdGUpID0+IHZvaWRcbiAgKTogbnVsbCB8IE9ic2VydmVyPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5hZGQoY2FsbGJhY2ssIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIE9ic2VydmVyIGZyb20gdGhlIE9ic2VydmFibGUgb2JqZWN0XG4gICAqIEBwYXJhbSBvYnNlcnZlciAtIHRoZSBpbnN0YW5jZSBvZiB0aGUgT2JzZXJ2ZXIgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm5zIGZhbHNlIGlmIGl0IGRvZXNuJ3QgYmVsb25nIHRvIHRoaXMgT2JzZXJ2YWJsZVxuICAgKi9cbiAgcHVibGljIHJlbW92ZShvYnNlcnZlcjogbnVsbCB8IE9ic2VydmVyPFQ+KTogYm9vbGVhbiB7XG4gICAgaWYgKCFvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9vYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcilcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2RlZmVyVW5yZWdpc3RlcihvYnNlcnZlcilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgT2JzZXJ2YWJsZSBvYmplY3RcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gdGhlIGNhbGxiYWNrIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0gc2NvcGUgLSBvcHRpb25hbCBzY29wZS4gSWYgdXNlZCBvbmx5IHRoZSBjYWxsYmFja3Mgd2l0aCB0aGlzIHNjb3BlIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBAcmV0dXJucyBmYWxzZSBpZiBpdCBkb2Vzbid0IGJlbG9uZyB0byB0aGlzIE9ic2VydmFibGVcbiAgICovXG4gIHB1YmxpYyByZW1vdmVDYWxsYmFjayhcbiAgICBjYWxsYmFjazogKGV2ZW50RGF0YTogVCwgZXZlbnRTdGF0ZTogT2JzZXJ2ZXJFdmVudFN0YXRlKSA9PiB2b2lkLFxuICAgIHNjb3BlPzogYW55XG4gICk6IGJvb2xlYW4ge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9vYnNlcnZlcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX29ic2VydmVyc1tpbmRleF0uY2FsbGJhY2sgPT09IGNhbGxiYWNrICYmXG4gICAgICAgICghc2NvcGUgfHwgc2NvcGUgPT09IHRoaXMuX29ic2VydmVyc1tpbmRleF0uc2NvcGUpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fZGVmZXJVbnJlZ2lzdGVyKHRoaXMuX29ic2VydmVyc1tpbmRleF0pXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IGFsbCBPYnNlcnZlcnMgYnkgY2FsbGluZyB0aGVpciByZXNwZWN0aXZlIGNhbGxiYWNrIHdpdGggdGhlIGdpdmVuIGRhdGFcbiAgICogV2lsbCByZXR1cm4gdHJ1ZSBpZiBhbGwgb2JzZXJ2ZXJzIHdlcmUgZXhlY3V0ZWQsIGZhbHNlIGlmIGFuIG9ic2VydmVyIHNldCBza2lwTmV4dE9ic2VydmVycyB0byB0cnVlLCB0aGVuIHByZXZlbnQgdGhlIHN1YnNlcXVlbnQgb25lcyB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBldmVudERhdGEgLSBkZWZpbmVzIHRoZSBkYXRhIHRvIHNlbmQgdG8gYWxsIG9ic2VydmVyc1xuICAgKiBAcGFyYW0gbWFzayAtIGRlZmluZXMgdGhlIG1hc2sgb2YgdGhlIGN1cnJlbnQgbm90aWZpY2F0aW9uIChvYnNlcnZlcnMgd2l0aCBpbmNvbXBhdGlibGUgbWFzayAoaWUgbWFzayAmIG9ic2VydmVyLm1hc2sgPT09IDApIHdpbGwgbm90IGJlIG5vdGlmaWVkKVxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gZGVmaW5lcyB0aGUgb3JpZ2luYWwgdGFyZ2V0IG9mIHRoZSBzdGF0ZVxuICAgKiBAcGFyYW0gY3VycmVudFRhcmdldCAtIGRlZmluZXMgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIHRoZSBzdGF0ZVxuICAgKiBAcmV0dXJucyBmYWxzZSBpZiB0aGUgY29tcGxldGUgb2JzZXJ2ZXIgY2hhaW4gd2FzIG5vdCBwcm9jZXNzZWQgKGJlY2F1c2Ugb25lIG9ic2VydmVyIHNldCB0aGUgc2tpcE5leHRPYnNlcnZlcnMgdG8gdHJ1ZSlcbiAgICovXG4gIHB1YmxpYyBub3RpZnlPYnNlcnZlcnMoXG4gICAgZXZlbnREYXRhOiBULFxuICAgIG1hc2s6IG51bWJlciA9IC0xLFxuICAgIHRhcmdldD86IGFueSxcbiAgICBjdXJyZW50VGFyZ2V0PzogYW55XG4gICk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5fb2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2V2ZW50U3RhdGVcbiAgICBzdGF0ZS5tYXNrID0gbWFza1xuICAgIHN0YXRlLnRhcmdldCA9IHRhcmdldFxuICAgIHN0YXRlLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0XG4gICAgc3RhdGUuc2tpcE5leHRPYnNlcnZlcnMgPSBmYWxzZVxuICAgIHN0YXRlLmxhc3RSZXR1cm5WYWx1ZSA9IGV2ZW50RGF0YVxuXG4gICAgZm9yIChjb25zdCBvYnMgb2YgdGhpcy5fb2JzZXJ2ZXJzKSB7XG4gICAgICBpZiAob2JzLl93aWxsQmVVbnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKG9icy5tYXNrICYgbWFzaykge1xuICAgICAgICBpZiAob2JzLnNjb3BlKSB7XG4gICAgICAgICAgc3RhdGUubGFzdFJldHVyblZhbHVlID0gb2JzLmNhbGxiYWNrLmFwcGx5KG9icy5zY29wZSwgW1xuICAgICAgICAgICAgZXZlbnREYXRhLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICBdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmxhc3RSZXR1cm5WYWx1ZSA9IG9icy5jYWxsYmFjayhldmVudERhdGEsIHN0YXRlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9icy51bnJlZ2lzdGVyT25OZXh0Q2FsbCkge1xuICAgICAgICAgIHRoaXMuX2RlZmVyVW5yZWdpc3RlcihvYnMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5za2lwTmV4dE9ic2VydmVycykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsaW5nIHRoaXMgd2lsbCBleGVjdXRlIGVhY2ggY2FsbGJhY2ssIGV4cGVjdGluZyBpdCB0byBiZSBhIHByb21pc2Ugb3IgcmV0dXJuIGEgdmFsdWUuXG4gICAqIElmIGF0IGFueSBwb2ludCBpbiB0aGUgY2hhaW4gb25lIGZ1bmN0aW9uIGZhaWxzLCB0aGUgcHJvbWlzZSB3aWxsIGZhaWwgYW5kIHRoZSBleGVjdXRpb24gd2lsbCBub3QgY29udGludWUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjaGFpbiBvZiBldmVudHMgKHNvbWV0aW1lcyBhc3luYyBldmVudHMpIGlzIG5lZWRlZCB0byBpbml0aWFsaXplIGEgY2VydGFpbiBvYmplY3RcbiAgICogYW5kIGl0IGlzIGNydWNpYWwgdGhhdCBhbGwgY2FsbGJhY2tzIHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAqIFRoZSBvcmRlciBvZiB0aGUgY2FsbGJhY2tzIGlzIGtlcHQsIGNhbGxiYWNrcyBhcmUgbm90IGV4ZWN1dGVkIHBhcmFsbGVsLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnREYXRhIC0gVGhlIGRhdGEgdG8gYmUgc2VudCB0byBlYWNoIGNhbGxiYWNrXG4gICAqIEBwYXJhbSBtYXNrIC0gaXMgdXNlZCB0byBmaWx0ZXIgb2JzZXJ2ZXJzIGRlZmF1bHRzIHRvIC0xXG4gICAqIEBwYXJhbSB0YXJnZXQgLSBkZWZpbmVzIHRoZSBjYWxsYmFjayB0YXJnZXQgKHNlZSBFdmVudFN0YXRlKVxuICAgKiBAcGFyYW0gY3VycmVudFRhcmdldCAtIGRlZmluZXMgaGUgY3VycmVudCBvYmplY3QgaW4gdGhlIGJ1YmJsaW5nIHBoYXNlXG4gICAqIEByZXR1cm5zIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSB0aGFuIHJlc29sdmVzIHdoZW4gYWxsIGNhbGxiYWNrcyBleGVjdXRlZCBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBwdWJsaWMgbm90aWZ5T2JzZXJ2ZXJzV2l0aFByb21pc2UoXG4gICAgZXZlbnREYXRhOiBULFxuICAgIG1hc2s6IG51bWJlciA9IC0xLFxuICAgIHRhcmdldD86IGFueSxcbiAgICBjdXJyZW50VGFyZ2V0PzogYW55XG4gICk6IFByb21pc2U8VD4ge1xuICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBwcm9taXNlXG4gICAgbGV0IHA6IFByb21pc2U8YW55PiA9IFByb21pc2UucmVzb2x2ZShldmVudERhdGEpXG5cbiAgICAvLyBubyBvYnNlcnZlcnM/IHJldHVybiB0aGlzIHByb21pc2UuXG4gICAgaWYgKCF0aGlzLl9vYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcFxuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fZXZlbnRTdGF0ZVxuICAgIHN0YXRlLm1hc2sgPSBtYXNrXG4gICAgc3RhdGUudGFyZ2V0ID0gdGFyZ2V0XG4gICAgc3RhdGUuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXRcbiAgICBzdGF0ZS5za2lwTmV4dE9ic2VydmVycyA9IGZhbHNlXG5cbiAgICAvLyBleGVjdXRlIG9uZSBjYWxsYmFjayBhZnRlciBhbm90aGVyIChub3QgdXNpbmcgUHJvbWlzZS5hbGwsIHRoZSBvcmRlciBpcyBpbXBvcnRhbnQpXG4gICAgdGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goKG9icykgPT4ge1xuICAgICAgaWYgKHN0YXRlLnNraXBOZXh0T2JzZXJ2ZXJzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKG9icy5fd2lsbEJlVW5yZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKG9icy5tYXNrICYgbWFzaykge1xuICAgICAgICBpZiAob2JzLnNjb3BlKSB7XG4gICAgICAgICAgcCA9IHAudGhlbigobGFzdFJldHVybmVkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RSZXR1cm5WYWx1ZSA9IGxhc3RSZXR1cm5lZFZhbHVlXG4gICAgICAgICAgICByZXR1cm4gb2JzLmNhbGxiYWNrLmFwcGx5KG9icy5zY29wZSwgW2V2ZW50RGF0YSwgc3RhdGVdKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCA9IHAudGhlbigobGFzdFJldHVybmVkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RSZXR1cm5WYWx1ZSA9IGxhc3RSZXR1cm5lZFZhbHVlXG4gICAgICAgICAgICByZXR1cm4gb2JzLmNhbGxiYWNrKGV2ZW50RGF0YSwgc3RhdGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzLnVucmVnaXN0ZXJPbk5leHRDYWxsKSB7XG4gICAgICAgICAgdGhpcy5fZGVmZXJVbnJlZ2lzdGVyKG9icylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyByZXR1cm4gdGhlIGV2ZW50RGF0YVxuICAgIHJldHVybiBwLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIGV2ZW50RGF0YVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogTm90aWZ5IGEgc3BlY2lmaWMgb2JzZXJ2ZXJcbiAgICogQHBhcmFtIG9ic2VydmVyIC0gZGVmaW5lcyB0aGUgb2JzZXJ2ZXIgdG8gbm90aWZ5XG4gICAqIEBwYXJhbSBldmVudERhdGEgLSBkZWZpbmVzIHRoZSBkYXRhIHRvIGJlIHNlbnQgdG8gZWFjaCBjYWxsYmFja1xuICAgKiBAcGFyYW0gbWFzayAtIGlzIHVzZWQgdG8gZmlsdGVyIG9ic2VydmVycyBkZWZhdWx0cyB0byAtMVxuICAgKi9cbiAgcHVibGljIG5vdGlmeU9ic2VydmVyKFxuICAgIG9ic2VydmVyOiBPYnNlcnZlcjxUPixcbiAgICBldmVudERhdGE6IFQsXG4gICAgbWFzazogbnVtYmVyID0gLTFcbiAgKTogdm9pZCB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9ldmVudFN0YXRlXG4gICAgc3RhdGUubWFzayA9IG1hc2tcbiAgICBzdGF0ZS5za2lwTmV4dE9ic2VydmVycyA9IGZhbHNlXG5cbiAgICBvYnNlcnZlci5jYWxsYmFjayhldmVudERhdGEsIHN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIG9ic2VydmFibGUgaGFzIGF0IGxlYXN0IG9uZSBvYnNlcnZlclxuICAgKiBAcmV0dXJucyB0cnVlIGlzIHRoZSBPYnNlcnZhYmxlIGhhcyBhdCBsZWFzdCBvbmUgT2JzZXJ2ZXIgcmVnaXN0ZXJlZFxuICAgKi9cbiAgcHVibGljIGhhc09ic2VydmVycygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fb2JzZXJ2ZXJzLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgbGlzdCBvZiBvYnNlcnZlcnNcbiAgICovXG4gIHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBuZXcgQXJyYXk8T2JzZXJ2ZXI8VD4+KClcbiAgICB0aGlzLl9vbk9ic2VydmVyQWRkZWQgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgdGhlIGN1cnJlbnQgb2JzZXJ2YWJsZVxuICAgKiBAcmV0dXJucyBhIG5ldyBvYnNlcnZhYmxlXG4gICAqL1xuICBwdWJsaWMgY2xvbmUoKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE9ic2VydmFibGU8VD4oKVxuXG4gICAgcmVzdWx0Ll9vYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuc2xpY2UoMClcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBEb2VzIHRoaXMgb2JzZXJ2YWJsZSBoYW5kbGVzIG9ic2VydmVyIHJlZ2lzdGVyZWQgd2l0aCBhIGdpdmVuIG1hc2tcbiAgICogQHBhcmFtIG1hc2sgLSBkZWZpbmVzIHRoZSBtYXNrIHRvIGJlIHRlc3RlZFxuICAgKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBvbmUgb2JzZXJ2ZXIgcmVnaXN0ZXJlZCB3aXRoIHRoZSBnaXZlbiBtYXNrIGlzIGhhbmRlbGVkXG4gICAqL1xuICBwdWJsaWMgaGFzU3BlY2lmaWNNYXNrKG1hc2s6IG51bWJlciA9IC0xKTogYm9vbGVhbiB7XG4gICAgZm9yIChjb25zdCBvYnMgb2YgdGhpcy5fb2JzZXJ2ZXJzKSB7XG4gICAgICBpZiAob2JzLm1hc2sgJiBtYXNrIHx8IG9icy5tYXNrID09PSBtYXNrKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJpdmF0ZSBfZGVmZXJVbnJlZ2lzdGVyKG9ic2VydmVyOiBPYnNlcnZlcjxUPik6IHZvaWQge1xuICAgIG9ic2VydmVyLnVucmVnaXN0ZXJPbk5leHRDYWxsID0gZmFsc2VcbiAgICBvYnNlcnZlci5fd2lsbEJlVW5yZWdpc3RlcmVkID0gdHJ1ZVxuICAgIHZvaWQgZXhlY3V0ZVRhc2soYXN5bmMgKCkgPT4gdGhpcy5fcmVtb3ZlKG9ic2VydmVyKSlcbiAgfVxuXG4gIC8vIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gbm90IGl0ZXJhdGluZyBvdmVyIF9vYnNlcnZlcnMgdG8gYXZvaWQgY2FsbGJhY2sgc2tpcHBpbmcuXG4gIC8vIFJlbW92ZXMgYW4gb2JzZXJ2ZXIgZnJvbSB0aGUgX29ic2VydmVyIEFycmF5LlxuICBwcml2YXRlIF9yZW1vdmUob2JzZXJ2ZXI6IG51bGwgfCBPYnNlcnZlcjxUPik6IGJvb2xlYW4ge1xuICAgIGlmICghb2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpXG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwibGV0IG1vZHVsZVByb21pc2U6IGFueVxuXG4vKipcbiAqIHRlbGVwb3J0IHBsYXllciB0byBhIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gZGVzdGluYXRpb24gLSBcImNvb3JkWCxjb29yZFlcIiwgXCJtYWdpY1wiLCBcImNyb3dkXCJcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbGVwb3J0VG8oZGVzdGluYXRpb246IHN0cmluZykge1xuICAvLyBlcnJvcihgdGVsZXBvcnRUbyhkZXN0aW5hdGlvbikgd2FzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2U6XG5cbiAgLy8gaW1wb3J0IHtyZXF1ZXN0VGVsZXBvcnR9IGZyb20gJ0BkZWNlbnRyYWxhbmQvVXNlckFjdGlvbk1vZHVsZSdcbiAgLy8gZXhlY3V0ZVRhc2soYXN5bmMgKCkgPT4ge1xuICAvLyAgIGF3YWl0IHJlcXVlc3RUZWxlcG9ydChkZXN0aW5hdGlvbilcbiAgLy8gfSlgKVxuICBjYWxsTW9kdWxlUnBjKCdyZXF1ZXN0VGVsZXBvcnQnLCBbZGVzdGluYXRpb25dKVxufVxuXG5mdW5jdGlvbiBlbnN1cmVNb2R1bGUoKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgbW9kdWxlUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRjbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGVQcm9taXNlID0gZGNsLmxvYWRNb2R1bGUoJ0BkZWNlbnRyYWxhbmQvVXNlckFjdGlvbk1vZHVsZScsIHt9KVxuICB9XG4gIHJldHVybiB0eXBlb2YgbW9kdWxlUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRjbCAhPT0gJ3VuZGVmaW5lZCdcbn1cblxuZnVuY3Rpb24gY2FsbE1vZHVsZVJwYyhtZXRob2ROYW1lOiBzdHJpbmcsIGFyZ3M6IGFueVtdKTogdm9pZCB7XG4gIGlmIChlbnN1cmVNb2R1bGUoKSkge1xuICAgIG1vZHVsZVByb21pc2UudGhlbigoJDogYW55KSA9PiB7XG4gICAgICB2b2lkIGRjbC5jYWxsUnBjKCQucnBjSGFuZGxlLCBtZXRob2ROYW1lLCBhcmdzKVxuICAgIH0pXG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50Q29uc3RydWN0b3IgfSBmcm9tICcuLi9lY3MvRXZlbnRNYW5hZ2VyJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL2Vjcy9PYnNlcnZhYmxlJ1xuaW1wb3J0IHsgVmlkZW9UZXh0dXJlIH0gZnJvbSAnLi9Db21wb25lbnRzJ1xuaW1wb3J0IHsgRGlzcG9zYWJsZUNvbXBvbmVudCB9IGZyb20gJy4uL2Vjcy9Db21wb25lbnQnXG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARXZlbnRDb25zdHJ1Y3RvcigpXG5leHBvcnQgY2xhc3MgVVVJREV2ZW50PFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHV1aWQ6IHN0cmluZywgcHVibGljIHJlYWRvbmx5IHBheWxvYWQ6IFQpIHt9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARXZlbnRDb25zdHJ1Y3RvcigpXG5leHBvcnQgY2xhc3MgUmF5Y2FzdFJlc3BvbnNlPFQ+IHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHBheWxvYWQ6IFJheWNhc3RSZXNwb25zZVBheWxvYWQ8VD4pIHt9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARXZlbnRDb25zdHJ1Y3RvcigpXG5leHBvcnQgY2xhc3MgUG9pbnRlckV2ZW50PEdsb2JhbElucHV0RXZlbnRSZXN1bHQ+IHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHBheWxvYWQ6IEdsb2JhbElucHV0RXZlbnRSZXN1bHQpIHt9XG59XG5cbmxldCBpbnRlcm5hbERjbDogRGVjZW50cmFsYW5kSW50ZXJmYWNlIHwgdm9pZFxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgYSBjYWxsYmFjayB0aGF0IGlzIHBhc3NlZCB0byB0aGUgT2JzZXJ2YWJsZVxuICogY29uc3RydWN0b3IgdG8gc3Vic2NyaWJlIHRvIHRoZSBldmVudHMgb2YgdGhlIERlY2VudHJhbGFuZEludGVyZmFjZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmVyKGV2ZW50TmFtZToga2V5b2YgSUV2ZW50cykge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChpbnRlcm5hbERjbCkge1xuICAgICAgaW50ZXJuYWxEY2wuc3Vic2NyaWJlKGV2ZW50TmFtZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHlvdSBjaGFuZ2UgeW91ciBjYW1lcmEgYmV0d2VlbiAxc3QgYW5kIDNyZCBwZXJzb25cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG9uQ2FtZXJhTW9kZUNoYW5nZWRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGU8XG4gIElFdmVudHNbJ2NhbWVyYU1vZGVDaGFuZ2VkJ11cbj4oY3JlYXRlU3Vic2NyaWJlcignY2FtZXJhTW9kZUNoYW5nZWQnKSlcblxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHlvdSBjaGFuZ2UgeW91ciBjYW1lcmEgYmV0d2VlbiAxc3QgYW5kIDNyZCBwZXJzb25cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG9uSWRsZVN0YXRlQ2hhbmdlZE9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxcbiAgSUV2ZW50c1snaWRsZVN0YXRlQ2hhbmdlZCddXG4+KGNyZWF0ZVN1YnNjcmliZXIoJ2lkbGVTdGF0ZUNoYW5nZWQnKSlcblxuLyoqXG4gKiBUaGVzZSBldmVudHMgYXJlIHRyaWdnZXJlZCBhZnRlciB5b3VyIGNoYXJhY3RlciBlbnRlcnMgdGhlIHNjZW5lLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgb25FbnRlclNjZW5lT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPElFdmVudHNbJ29uRW50ZXJTY2VuZSddPihcbiAgY3JlYXRlU3Vic2NyaWJlcignb25FbnRlclNjZW5lJylcbilcblxuLyoqIEBwdWJsaWMgQGRlcHJlY2F0ZWQgVXNlIG9uRW50ZXJTY2VuZU9ic2VydmFibGUgaW5zdGVhZC4gKi9cbmV4cG9ydCBjb25zdCBvbkVudGVyU2NlbmUgPSBvbkVudGVyU2NlbmVPYnNlcnZhYmxlXG5cbi8qKlxuICogVGhlc2UgZXZlbnRzIGFyZSB0cmlnZ2VyZWQgYWZ0ZXIgeW91ciBjaGFyYWN0ZXIgbGVhdmVzIHRoZSBzY2VuZS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG9uTGVhdmVTY2VuZU9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxJRXZlbnRzWydvbkxlYXZlU2NlbmUnXT4oXG4gIGNyZWF0ZVN1YnNjcmliZXIoJ29uTGVhdmVTY2VuZScpXG4pXG5cbi8qKiBAcHVibGljIEBkZXByZWNhdGVkIFVzZSBvbkxlYXZlU2NlbmVPYnNlcnZhYmxlIGluc3RlYWQuICovXG5leHBvcnQgY29uc3Qgb25MZWF2ZVNjZW5lID0gb25MZWF2ZVNjZW5lT2JzZXJ2YWJsZVxuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIGFsbCB0aGUgcmVzb3VyY2VzIG9mIHRoZSBzY2VuZSB3ZXJlIGxvYWRlZCAobW9kZWxzLCB0ZXh0dXJlcywgZXRjLi4uKVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgb25TY2VuZVJlYWR5T2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPElFdmVudHNbJ3NjZW5lU3RhcnQnXT4oXG4gIGNyZWF0ZVN1YnNjcmliZXIoJ3NjZW5lU3RhcnQnKVxuKVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG9uUGxheWVyRXhwcmVzc2lvbk9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxcbiAgSUV2ZW50c1sncGxheWVyRXhwcmVzc2lvbiddXG4+KGNyZWF0ZVN1YnNjcmliZXIoJ3BsYXllckV4cHJlc3Npb24nKSlcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBvblBvaW50ZXJMb2NrZWRTdGF0ZUNoYW5nZSA9IG5ldyBPYnNlcnZhYmxlPFxuICBJRXZlbnRzWydvblBvaW50ZXJMb2NrJ11cbj4oY3JlYXRlU3Vic2NyaWJlcignb25Qb2ludGVyTG9jaycpKVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG9uVmlkZW9FdmVudCA9IG5ldyBPYnNlcnZhYmxlPElFdmVudHNbJ3ZpZGVvRXZlbnQnXT4oXG4gIGNyZWF0ZVN1YnNjcmliZXIoJ3ZpZGVvRXZlbnQnKVxuKVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG9uUHJvZmlsZUNoYW5nZWQgPSBuZXcgT2JzZXJ2YWJsZTxJRXZlbnRzWydwcm9maWxlQ2hhbmdlZCddPihcbiAgY3JlYXRlU3Vic2NyaWJlcigncHJvZmlsZUNoYW5nZWQnKVxuKVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG9uUGxheWVyQ29ubmVjdGVkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPFxuICBJRXZlbnRzWydwbGF5ZXJDb25uZWN0ZWQnXVxuPihjcmVhdGVTdWJzY3JpYmVyKCdwbGF5ZXJDb25uZWN0ZWQnKSlcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBvblBsYXllckRpc2Nvbm5lY3RlZE9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxcbiAgSUV2ZW50c1sncGxheWVyRGlzY29ubmVjdGVkJ11cbj4oY3JlYXRlU3Vic2NyaWJlcigncGxheWVyRGlzY29ubmVjdGVkJykpXG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgb25SZWFsbUNoYW5nZWRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGU8XG4gIElFdmVudHNbJ29uUmVhbG1DaGFuZ2VkJ11cbj4oY3JlYXRlU3Vic2NyaWJlcignb25SZWFsbUNoYW5nZWQnKSlcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBvblBsYXllckNsaWNrZWRPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGU8XG4gIElFdmVudHNbJ3BsYXllckNsaWNrZWQnXVxuPihjcmVhdGVTdWJzY3JpYmVyKCdwbGF5ZXJDbGlja2VkJykpXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBUaGlzIGZ1bmN0aW9uIGFkZHMgX29uZV8gbGlzdGVuZXIgdG8gdGhlIG9uRXZlbnQgZXZlbnQgb2YgZGNsIGludGVyZmFjZS5cbiAqIExldmVyYWdpbmcgYSBzd2l0Y2ggdG8gcm91dGUgZXZlbnRzIHRvIHRoZSBPYnNlcnZhYmxlIGhhbmRsZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX2luaXRFdmVudE9ic2VydmFibGVzKGRjbDogRGVjZW50cmFsYW5kSW50ZXJmYWNlKSB7XG4gIC8vIHN0b3JlIGludGVybmFsIHJlZmVyZW5jZSB0byBkY2wsIGl0IGlzIGdvaW5nIHRvIGJlIHVzZWQgdG8gc3Vic2NyaWJlIHRvIHRoZSBldmVudHNcbiAgaW50ZXJuYWxEY2wgPSBkY2xcblxuICBpZiAoaW50ZXJuYWxEY2wpIHtcbiAgICBpbnRlcm5hbERjbC5vbkV2ZW50KChldmVudCkgPT4ge1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ29uRW50ZXJTY2VuZSc6IHtcbiAgICAgICAgICBvbkVudGVyU2NlbmVPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgYXMgSUV2ZW50c1snb25FbnRlclNjZW5lJ11cbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnb25MZWF2ZVNjZW5lJzoge1xuICAgICAgICAgIG9uTGVhdmVTY2VuZU9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKFxuICAgICAgICAgICAgZXZlbnQuZGF0YSBhcyBJRXZlbnRzWydvbkxlYXZlU2NlbmUnXVxuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjYW1lcmFNb2RlQ2hhbmdlZCc6IHtcbiAgICAgICAgICBvbkNhbWVyYU1vZGVDaGFuZ2VkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoXG4gICAgICAgICAgICBldmVudC5kYXRhIGFzIElFdmVudHNbJ2NhbWVyYU1vZGVDaGFuZ2VkJ11cbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaWRsZVN0YXRlQ2hhbmdlZCc6IHtcbiAgICAgICAgICBvbklkbGVTdGF0ZUNoYW5nZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgYXMgSUV2ZW50c1snaWRsZVN0YXRlQ2hhbmdlZCddXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NjZW5lU3RhcnQnOiB7XG4gICAgICAgICAgb25TY2VuZVJlYWR5T2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoXG4gICAgICAgICAgICBldmVudC5kYXRhIGFzIElFdmVudHNbJ3NjZW5lU3RhcnQnXVxuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwbGF5ZXJFeHByZXNzaW9uJzoge1xuICAgICAgICAgIG9uUGxheWVyRXhwcmVzc2lvbk9ic2VydmFibGUubm90aWZ5T2JzZXJ2ZXJzKFxuICAgICAgICAgICAgZXZlbnQuZGF0YSBhcyBJRXZlbnRzWydwbGF5ZXJFeHByZXNzaW9uJ11cbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndmlkZW9FdmVudCc6IHtcbiAgICAgICAgICBjb25zdCB2aWRlb0RhdGEgPSBldmVudC5kYXRhIGFzIElFdmVudHNbJ3ZpZGVvRXZlbnQnXVxuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IERpc3Bvc2FibGVDb21wb25lbnQuZW5naW5lLmRpc3Bvc2FibGVDb21wb25lbnRzW1xuICAgICAgICAgICAgdmlkZW9EYXRhLmNvbXBvbmVudElkXG4gICAgICAgICAgXSBhcyBWaWRlb1RleHR1cmVcbiAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQudXBkYXRlKHZpZGVvRGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgICAgb25WaWRlb0V2ZW50Lm5vdGlmeU9ic2VydmVycyh2aWRlb0RhdGEpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncHJvZmlsZUNoYW5nZWQnOiB7XG4gICAgICAgICAgb25Qcm9maWxlQ2hhbmdlZC5ub3RpZnlPYnNlcnZlcnMoXG4gICAgICAgICAgICBldmVudC5kYXRhIGFzIElFdmVudHNbJ3Byb2ZpbGVDaGFuZ2VkJ11cbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnb25Qb2ludGVyTG9jayc6IHtcbiAgICAgICAgICBvblBvaW50ZXJMb2NrZWRTdGF0ZUNoYW5nZS5ub3RpZnlPYnNlcnZlcnMoXG4gICAgICAgICAgICBldmVudC5kYXRhIGFzIElFdmVudHNbJ29uUG9pbnRlckxvY2snXVxuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwbGF5ZXJDb25uZWN0ZWQnOiB7XG4gICAgICAgICAgb25QbGF5ZXJDb25uZWN0ZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgYXMgSUV2ZW50c1sncGxheWVyQ29ubmVjdGVkJ11cbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncGxheWVyRGlzY29ubmVjdGVkJzoge1xuICAgICAgICAgIG9uUGxheWVyRGlzY29ubmVjdGVkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoXG4gICAgICAgICAgICBldmVudC5kYXRhIGFzIElFdmVudHNbJ3BsYXllckRpc2Nvbm5lY3RlZCddXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ29uUmVhbG1DaGFuZ2VkJzoge1xuICAgICAgICAgIG9uUmVhbG1DaGFuZ2VkT2JzZXJ2YWJsZS5ub3RpZnlPYnNlcnZlcnMoXG4gICAgICAgICAgICBldmVudC5kYXRhIGFzIElFdmVudHNbJ29uUmVhbG1DaGFuZ2VkJ11cbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncGxheWVyQ2xpY2tlZCc6IHtcbiAgICAgICAgICBvblBsYXllckNsaWNrZWRPYnNlcnZhYmxlLm5vdGlmeU9ic2VydmVycyhcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgYXMgSUV2ZW50c1sncGxheWVyQ2xpY2tlZCddXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgRGlzcG9zYWJsZUNvbXBvbmVudENyZWF0ZWQsXG4gIERpc3Bvc2FibGVDb21wb25lbnRSZW1vdmVkLFxuICBEaXNwb3NhYmxlQ29tcG9uZW50VXBkYXRlZCxcbiAgZ2V0Q29tcG9uZW50Q2xhc3NJZCxcbiAgZ2V0Q29tcG9uZW50SWQsXG4gIGlzRGlzcG9zYWJsZUNvbXBvbmVudCxcbiAgT2JzZXJ2YWJsZUNvbXBvbmVudFxufSBmcm9tICcuLi9lY3MvQ29tcG9uZW50J1xuaW1wb3J0IHsgRW5naW5lIH0gZnJvbSAnLi4vZWNzL0VuZ2luZSdcbmltcG9ydCB7XG4gIENvbXBvbmVudEFkZGVkLFxuICBDb21wb25lbnRSZW1vdmVkLFxuICBJRW50aXR5LFxuICBJU3lzdGVtLFxuICBQYXJlbnRDaGFuZ2VkXG59IGZyb20gJy4uL2Vjcy9JRW50aXR5J1xuaW1wb3J0IHsgVVVJREV2ZW50LCBQb2ludGVyRXZlbnQsIFJheWNhc3RSZXNwb25zZSB9IGZyb20gJy4vRXZlbnRzJ1xuaW1wb3J0IHsgUmF5Y2FzdEhpdEVudGl0aWVzLCBSYXljYXN0SGl0RW50aXR5IH0gZnJvbSAnLi9QaHlzaWNzQ2FzdCdcblxuLy8gVGhpcyBudW1iZXIgaXMgZGVmaW5lZCBpbiB0aGUgcHJvdG9jb2wgRUNTLlNldEVudGl0eVBhcmVudC4zXG5jb25zdCBST09UX0VOVElUWV9JRCA9ICcwJ1xuXG5leHBvcnQgY2xhc3MgRGVjZW50cmFsYW5kU3luY2hyb25pemF0aW9uU3lzdGVtIGltcGxlbWVudHMgSVN5c3RlbSB7XG4gIGNhY2hlZENvbXBvbmVudHM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHN0cmluZz4+ID0ge31cbiAgZW5naW5lITogRW5naW5lXG5cbiAgY29uc3RydWN0b3IocHVibGljIGRjbDogRGVjZW50cmFsYW5kSW50ZXJmYWNlKSB7fVxuXG4gIGFjdGl2YXRlKGVuZ2luZTogRW5naW5lKSB7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmVcbiAgICBlbmdpbmUuZXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKENvbXBvbmVudEFkZGVkLCB0aGlzLCB0aGlzLmNvbXBvbmVudEFkZGVkKVxuICAgIGVuZ2luZS5ldmVudE1hbmFnZXIuYWRkTGlzdGVuZXIoXG4gICAgICBDb21wb25lbnRSZW1vdmVkLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuY29tcG9uZW50UmVtb3ZlZFxuICAgIClcbiAgICBlbmdpbmUuZXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgRGlzcG9zYWJsZUNvbXBvbmVudENyZWF0ZWQsXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5kaXNwb3NhYmxlQ29tcG9uZW50Q3JlYXRlZFxuICAgIClcbiAgICBlbmdpbmUuZXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgRGlzcG9zYWJsZUNvbXBvbmVudFJlbW92ZWQsXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5kaXNwb3NhYmxlQ29tcG9uZW50UmVtb3ZlZFxuICAgIClcbiAgICBlbmdpbmUuZXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgRGlzcG9zYWJsZUNvbXBvbmVudFVwZGF0ZWQsXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5kaXNwb3NhYmxlQ29tcG9uZW50VXBkYXRlZFxuICAgIClcbiAgICBlbmdpbmUuZXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFBhcmVudENoYW5nZWQsIHRoaXMsIHRoaXMucGFyZW50Q2hhbmdlZClcblxuICAgIGNvbnN0IHJvb3RJZCA9IGVuZ2luZS5yb290RW50aXR5LnV1aWRcblxuICAgIHRoaXMuZGNsLmFkZEVudGl0eShyb290SWQpXG5cbiAgICAvLyBUT0RPKGFndXMpOiBzZW5kIGRpc3Bvc2FibGVDb21wb25lbnRzIGlmIGV4aXN0XG5cbiAgICB0aGlzLmRjbC5vblVwZGF0ZSgoZHQpID0+IHtcbiAgICAgIGVuZ2luZS51cGRhdGUoZHQpXG4gICAgICB0aGlzLnByZXNlbnRFbnRpdGllcygpXG4gICAgfSlcblxuICAgIHRoaXMuZGNsLm9uRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YSBhcyBhbnlcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlICd1dWlkRXZlbnQnOlxuICAgICAgICAgIGVuZ2luZS5ldmVudE1hbmFnZXIuZmlyZUV2ZW50KG5ldyBVVUlERXZlbnQoZGF0YS51dWlkLCBkYXRhLnBheWxvYWQpKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3JheWNhc3RSZXNwb25zZSc6XG4gICAgICAgICAgaWYgKGRhdGEucXVlcnlUeXBlID09PSAnSGl0Rmlyc3QnKSB7XG4gICAgICAgICAgICBlbmdpbmUuZXZlbnRNYW5hZ2VyLmZpcmVFdmVudChcbiAgICAgICAgICAgICAgbmV3IFJheWNhc3RSZXNwb25zZTxSYXljYXN0SGl0RW50aXR5PihkYXRhKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5xdWVyeVR5cGUgPT09ICdIaXRBbGwnKSB7XG4gICAgICAgICAgICBlbmdpbmUuZXZlbnRNYW5hZ2VyLmZpcmVFdmVudChcbiAgICAgICAgICAgICAgbmV3IFJheWNhc3RSZXNwb25zZTxSYXljYXN0SGl0RW50aXRpZXM+KGRhdGEpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2FjdGlvbkJ1dHRvbkV2ZW50JzpcbiAgICAgICAgICBlbmdpbmUuZXZlbnRNYW5hZ2VyLmZpcmVFdmVudChuZXcgUG9pbnRlckV2ZW50KGRhdGEucGF5bG9hZCkpXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIHN5c3RlbS5vbkFkZEVudGl0eSBpcyBjYWxsZWQgYnkgdGhlIGVuZ2luZSB3aGVuIGEgZW50aXR5IGlzIGFkZGVkIHRvIHRoZVxuICAgKiBlbmdpbmUuXG4gICAqL1xuICBvbkFkZEVudGl0eShlbnRpdHk6IElFbnRpdHkpIHtcbiAgICBpZiAoZW50aXR5ICYmIGVudGl0eS5pc0FkZGVkVG9FbmdpbmUoKSkge1xuICAgICAgY29uc3QgZW50aXR5SWQgPSBlbnRpdHkudXVpZFxuICAgICAgY29uc3QgcGFyZW50ID0gZW50aXR5LmdldFBhcmVudCgpXG5cbiAgICAgIHRoaXMuZGNsLmFkZEVudGl0eShlbnRpdHlJZClcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB0aGUgZW50aXR5IGhhcyBhIHBhcmVudCwgd2Ugc2VuZCB0aGUgdGhlIGVucGFyZW50aW5nIHNpZ25hbFxuICAgICAgICAvLyBvdGhlcndpc2UgdGhlIGVuZ2luZSB3aWxsIGtub3cgdGhlIGVudGl0eSBpcyBzZXQgYXMgYSBjaGlsZCBvZlxuICAgICAgICAvLyBlbmdpbmUucm9vdEVudGl0eSBieSBkZWZhdWx0XG4gICAgICAgIHRoaXMuZGNsLnNldFBhcmVudChlbnRpdHlJZCwgcGFyZW50LnV1aWQpXG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIGNhY2hlIGRpY3Rpb25hcnkgdG8gYXZvaWQgc2VuZCByZWR1bmRhbnQgaW5mb3JtYXRpb24gdG9cbiAgICAgIC8vIHRoZSBlbmdpbmUgaW4gb3JkZXIgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd29yayBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gICAgICB0aGlzLmNhY2hlZENvbXBvbmVudHNbZW50aXR5SWRdID0ge31cblxuICAgICAgLy8gdGhpcyBpdGVyYXRvciBzZW5kcyB0aGUgY3VycmVudCBjb21wb25lbnRzIG9mIHRlIGVuZ2luZSBhdCB0aGUgbW9tZW50XG4gICAgICAvLyBvZiBhZGRpdGlvblxuICAgICAgZm9yIChjb25zdCBjb21wb25lbnROYW1lIGluIGVudGl0eS5jb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGVudGl0eS5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdXG4gICAgICAgIGNvbnN0IGNsYXNzSWQgPSBnZXRDb21wb25lbnRDbGFzc0lkKGNvbXBvbmVudClcblxuICAgICAgICBpZiAoY2xhc3NJZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpc0Rpc3Bvc2FibGVDb21wb25lbnQoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgYXR0YWNoIGNvbXBvbmVudCBzaWduYWxcbiAgICAgICAgICAgIHRoaXMuZGNsLmF0dGFjaEVudGl0eUNvbXBvbmVudChcbiAgICAgICAgICAgICAgZW50aXR5LnV1aWQsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudElkKGNvbXBvbmVudClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50SnNvbjogc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoY29tcG9uZW50KVxuXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSB1cGRhdGVkIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5kY2wudXBkYXRlRW50aXR5Q29tcG9uZW50KFxuICAgICAgICAgICAgICBlbnRpdHlJZCxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgY2xhc3NJZCxcbiAgICAgICAgICAgICAgY29tcG9uZW50SnNvblxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBzZW50IGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5jYWNoZWRDb21wb25lbnRzW2VudGl0eUlkXVtjb21wb25lbnROYW1lXSA9IGNvbXBvbmVudEpzb25cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogc3lzdGVtLm9uUmVtb3ZlRW50aXR5IGlzIGNhbGxlZCBieSB0aGUgZW5naW5lIHdoZW4gYSBlbnRpdHkgZ2V0cyByZW1vdmVkXG4gICAqIGZyb20gdGhlIGVuZ2luZS5cbiAgICovXG4gIG9uUmVtb3ZlRW50aXR5KGVudGl0eTogSUVudGl0eSkge1xuICAgIGlmIChlbnRpdHkuaXNBZGRlZFRvRW5naW5lKCkpIHtcbiAgICAgIGNvbnN0IGVudGl0eUlkID0gZW50aXR5LnV1aWRcblxuICAgICAgLy8gU2VuZCB0aGUgcmVtb3ZlRW50aXR5IHNpZ25hbFxuICAgICAgdGhpcy5kY2wucmVtb3ZlRW50aXR5KGVudGl0eUlkKVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIGNhY2hlcyBmcm9tIGxvY2FsIG1lbW9yeVxuICAgICAgZGVsZXRlIHRoaXMuY2FjaGVkQ29tcG9uZW50c1tlbnRpdHlJZF1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdXBkYXRlIGN5Y2xlLlxuICAgKiBJdCBmaW5kcyBhbmQgc2VuZHMgdXBkYXRlcyBpbiBjb21wb25lbnRzIG9mIHRoZSBlbmdpbmUgZW50aXRpZXMuXG4gICAqL1xuICBwcml2YXRlIHByZXNlbnRFbnRpdGllcygpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5lbmdpbmUuZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW5naW5lLmVudGl0aWVzW2ldXG5cbiAgICAgIGZvciAoY29uc3QgY29tcG9uZW50TmFtZSBpbiBlbnRpdHkuY29tcG9uZW50cykge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBlbnRpdHkuY29tcG9uZW50c1tjb21wb25lbnROYW1lXVxuICAgICAgICBjb25zdCBjbGFzc0lkID0gZ2V0Q29tcG9uZW50Q2xhc3NJZChjb21wb25lbnQpXG5cbiAgICAgICAgaWYgKGNsYXNzSWQgIT09IG51bGwgJiYgIWlzRGlzcG9zYWJsZUNvbXBvbmVudChjb21wb25lbnQpKSB7XG4gICAgICAgICAgY29uc3QganNvblJlcHJlc2VudGF0aW9uID0gdGhpcy5nZXRKc29uSWZEaXJ0eShcbiAgICAgICAgICAgIGVudGl0eS51dWlkLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoanNvblJlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSB1cGRhdGVkIGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5kY2wudXBkYXRlRW50aXR5Q29tcG9uZW50KFxuICAgICAgICAgICAgICBlbnRpdHkudXVpZCxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgICAgY2xhc3NJZCxcbiAgICAgICAgICAgICAganNvblJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICApXG4gICAgICAgICAgICB0aGlzLmNsZWFyRGlydHkoXG4gICAgICAgICAgICAgIGVudGl0eS51dWlkLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICAgIGpzb25SZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5lbmdpbmUuZGlzcG9zYWJsZUNvbXBvbmVudHMpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuZW5naW5lLmRpc3Bvc2FibGVDb21wb25lbnRzW2lkXVxuICAgICAgaWYgKGNvbXBvbmVudCBpbnN0YW5jZW9mIE9ic2VydmFibGVDb21wb25lbnQgJiYgY29tcG9uZW50LmRpcnR5KSB7XG4gICAgICAgIHRoaXMuZGNsLmNvbXBvbmVudFVwZGF0ZWQoaWQsIEpTT04uc3RyaW5naWZ5KGNvbXBvbmVudCkpXG4gICAgICAgIGNvbXBvbmVudC5kaXJ0eSA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCBpcyBhZGRlZCB0byBhbiBlbnRpdHkuIFRoZSBldmVudFxuICAgKiAocGFyYW0gMSkgY29udGFpbnMgdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBub3RpZnkgdGhlIGVuZ2luZSBhYm91dCB0aGVcbiAgICogY29tcG9uZW50IHRoYXQgd2FzIGFkZGVkIGFuZCB0aGUgZW50aXR5LlxuICAgKi9cbiAgcHJpdmF0ZSBjb21wb25lbnRBZGRlZChldmVudDogQ29tcG9uZW50QWRkZWQpIHtcbiAgICBpZiAoZXZlbnQuZW50aXR5LmlzQWRkZWRUb0VuZ2luZSgpKSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBldmVudC5lbnRpdHkuY29tcG9uZW50c1tldmVudC5jb21wb25lbnROYW1lXVxuXG4gICAgICBpZiAoaXNEaXNwb3NhYmxlQ29tcG9uZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5kY2wuYXR0YWNoRW50aXR5Q29tcG9uZW50KFxuICAgICAgICAgIGV2ZW50LmVudGl0eS51dWlkLFxuICAgICAgICAgIGV2ZW50LmNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgZ2V0Q29tcG9uZW50SWQoY29tcG9uZW50KVxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmNsYXNzSWQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50SnNvbjogc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoY29tcG9uZW50KVxuXG4gICAgICAgIC8vIFNlbmQgdGhlIHVwZGF0ZWQgY29tcG9uZW50XG4gICAgICAgIHRoaXMuZGNsLnVwZGF0ZUVudGl0eUNvbXBvbmVudChcbiAgICAgICAgICBldmVudC5lbnRpdHkudXVpZCxcbiAgICAgICAgICBldmVudC5jb21wb25lbnROYW1lLFxuICAgICAgICAgIGV2ZW50LmNsYXNzSWQsXG4gICAgICAgICAgY29tcG9uZW50SnNvblxuICAgICAgICApXG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjYWNoZWQgY29weSBvZiB0aGUgc2VudCBjb21wb25lbnRcbiAgICAgICAgdGhpcy5jYWNoZWRDb21wb25lbnRzW2V2ZW50LmVudGl0eS51dWlkXVtldmVudC5jb21wb25lbnROYW1lXSA9XG4gICAgICAgICAgY29tcG9uZW50SnNvblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZW1vdmVkIGZyb20gYW4gZW50aXR5LlxuICAgKi9cbiAgcHJpdmF0ZSBjb21wb25lbnRSZW1vdmVkKGV2ZW50OiBDb21wb25lbnRSZW1vdmVkKSB7XG4gICAgaWYgKGV2ZW50LmVudGl0eS5pc0FkZGVkVG9FbmdpbmUoKSkge1xuICAgICAgdGhpcy5kY2wucmVtb3ZlRW50aXR5Q29tcG9uZW50KGV2ZW50LmVudGl0eS51dWlkLCBldmVudC5jb21wb25lbnROYW1lKVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIGNhY2hlZCBjb21wb25lbnQgc28gd2UgY2FuIHNlbmQgaXQgYWdhaW4gd2hlbiByZS1hZGRpbmdcbiAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlZENvbXBvbmVudHNbZXZlbnQuZW50aXR5LnV1aWRdW2V2ZW50LmNvbXBvbmVudE5hbWVdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBhZnRlciBhIGRpc3Bvc2FibGVDb21wb25lbnQgaXMgY3JlYXRlZC5cbiAgICogSXQgaW5zdGFudGlhdGVzIHRoZSBjb21wb25lbnQgaW4gdGhlIGVuZ2luZSwgdGhlIGV2ZW50IHRoYXQgdXBkYXRlcyB0aGVcbiAgICogY3JlYXRlZCBjb21wb25lbnQgaXMgZmlyZWQgaW1tZWRpYXRseSBhZnRlci5cbiAgICovXG4gIHByaXZhdGUgZGlzcG9zYWJsZUNvbXBvbmVudENyZWF0ZWQoZXZlbnQ6IERpc3Bvc2FibGVDb21wb25lbnRDcmVhdGVkKSB7XG4gICAgdGhpcy5kY2wuY29tcG9uZW50Q3JlYXRlZChcbiAgICAgIGV2ZW50LmNvbXBvbmVudElkLFxuICAgICAgZXZlbnQuY29tcG9uZW50TmFtZSxcbiAgICAgIGV2ZW50LmNsYXNzSWRcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGFmdGVyIGEgZGlzcG9zYWJsZUNvbXBvbmVudCBpcyB1cGRhdGVkLCBvbmNlIHBlclxuICAgKiB1cGRhdGUgY3ljbGUgYW5kIG9uY2UgYWZ0ZXIgY3JlYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGRpc3Bvc2FibGVDb21wb25lbnRSZW1vdmVkKGV2ZW50OiBEaXNwb3NhYmxlQ29tcG9uZW50UmVtb3ZlZCkge1xuICAgIHRoaXMuZGNsLmNvbXBvbmVudERpc3Bvc2VkKGV2ZW50LmNvbXBvbmVudElkKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCByaWdodCBhZnRlciBhIGRpcG9zYWJsZUNvbXBvbmVudCBnZXRzIGRpc3Bvc2VkLiBUaGF0XG4gICAqIHByb2Nlc3MgaXMgbWFudWFsLlxuICAgKlxuICAgKiBUT0RPKG1lbmR1eixkYW5pKTogV2hhdCBoYXBwZW5zIGlmIGEgZGlzcG9zYWJsZUNvbXBvbmVudCBnZXRzIGRpc3Bvc2VkIGFuZFxuICAgKiBpdCByZW1haW5zIGF0dGFjaGVkIHRvIHNvbWUgZW50aXRpZXM/XG4gICAqL1xuICBwcml2YXRlIGRpc3Bvc2FibGVDb21wb25lbnRVcGRhdGVkKGV2ZW50OiBEaXNwb3NhYmxlQ29tcG9uZW50VXBkYXRlZCkge1xuICAgIHRoaXMuZGNsLmNvbXBvbmVudFVwZGF0ZWQoXG4gICAgICBldmVudC5jb21wb25lbnRJZCxcbiAgICAgIEpTT04uc3RyaW5naWZ5KGV2ZW50LmNvbXBvbmVudClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gYSBwYXJlbnQgY2hhbmdlcyBpbiBhbiBlbnRpdHkuXG4gICAqL1xuICBwcml2YXRlIHBhcmVudENoYW5nZWQoZXZlbnQ6IFBhcmVudENoYW5nZWQpIHtcbiAgICB0aGlzLmRjbC5zZXRQYXJlbnQoXG4gICAgICBldmVudC5lbnRpdHkudXVpZCxcbiAgICAgIGV2ZW50LnBhcmVudCA/IGV2ZW50LnBhcmVudC51dWlkIDogUk9PVF9FTlRJVFlfSURcbiAgICApXG4gIH1cblxuICBwcml2YXRlIGdldEpzb25JZkRpcnR5KFxuICAgIGVudGl0eUlkOiBzdHJpbmcsXG4gICAgY29tcG9uZW50TmFtZTogc3RyaW5nLFxuICAgIGNvbXBvbmVudDogYW55XG4gICk6IGZhbHNlIHwgc3RyaW5nIHtcbiAgICBjb25zdCBqc29uUmVwcmVzZW50YXRpb24gPSBKU09OLnN0cmluZ2lmeShjb21wb25lbnQpXG4gICAgcmV0dXJuIChcbiAgICAgIGpzb25SZXByZXNlbnRhdGlvbiAhPT0gdGhpcy5jYWNoZWRDb21wb25lbnRzW2VudGl0eUlkXVtjb21wb25lbnROYW1lXSAmJlxuICAgICAganNvblJlcHJlc2VudGF0aW9uXG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSBjbGVhckRpcnR5KFxuICAgIGVudGl0eUlkOiBzdHJpbmcsXG4gICAgY29tcG9uZW50TmFtZTogc3RyaW5nLFxuICAgIGNvbXBvbmVudDogYW55LFxuICAgIGpzb25SZXByZXNlbnRhdGlvbjogc3RyaW5nXG4gICkge1xuICAgIHRoaXMuY2FjaGVkQ29tcG9uZW50c1tlbnRpdHlJZF1bY29tcG9uZW50TmFtZV0gPSBqc29uUmVwcmVzZW50YXRpb25cbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJBRDJERUcgPSBleHBvcnRzLkRFRzJSQUQgPSBleHBvcnRzLkVwc2lsb24gPSBleHBvcnRzLlRvTGluZWFyU3BhY2UgPSBleHBvcnRzLlRvR2FtbWFTcGFjZSA9IGV4cG9ydHMuU3BhY2UgPSBleHBvcnRzLk9yaWVudGF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBEZWZpbmVzIHBvdGVudGlhbCBvcmllbnRhdGlvbiBmb3IgYmFjayBmYWNlIGN1bGxpbmdcbiAqIEBwdWJsaWNcbiAqL1xudmFyIE9yaWVudGF0aW9uO1xuKGZ1bmN0aW9uIChPcmllbnRhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENsb2Nrd2lzZVxuICAgICAqL1xuICAgIE9yaWVudGF0aW9uW09yaWVudGF0aW9uW1wiQ1dcIl0gPSAwXSA9IFwiQ1dcIjtcbiAgICAvKiogQ291bnRlciBjbG9ja3dpc2UgKi9cbiAgICBPcmllbnRhdGlvbltPcmllbnRhdGlvbltcIkNDV1wiXSA9IDFdID0gXCJDQ1dcIjtcbn0pKE9yaWVudGF0aW9uID0gZXhwb3J0cy5PcmllbnRhdGlvbiB8fCAoZXhwb3J0cy5PcmllbnRhdGlvbiA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgc3VwcG9ydGVkIHNwYWNlc1xuICogQHB1YmxpY1xuICovXG52YXIgU3BhY2U7XG4oZnVuY3Rpb24gKFNwYWNlKSB7XG4gICAgLyoqIExvY2FsIChvYmplY3QpIHNwYWNlICovXG4gICAgU3BhY2VbU3BhY2VbXCJMT0NBTFwiXSA9IDBdID0gXCJMT0NBTFwiO1xuICAgIC8qKiBXb3JsZCBzcGFjZSAqL1xuICAgIFNwYWNlW1NwYWNlW1wiV09STERcIl0gPSAxXSA9IFwiV09STERcIjtcbiAgICAvKiogQm9uZSBzcGFjZSAqL1xuICAgIFNwYWNlW1NwYWNlW1wiQk9ORVwiXSA9IDJdID0gXCJCT05FXCI7XG59KShTcGFjZSA9IGV4cG9ydHMuU3BhY2UgfHwgKGV4cG9ydHMuU3BhY2UgPSB7fSkpO1xuLyoqXG4gKiBDb25zdGFudCB1c2VkIHRvIGNvbnZlcnQgYSB2YWx1ZSB0byBnYW1tYSBzcGFjZVxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLlRvR2FtbWFTcGFjZSA9IDEgLyAyLjI7XG4vKipcbiAqIENvbnN0YW50IHVzZWQgdG8gY29udmVydCBhIHZhbHVlIHRvIGxpbmVhciBzcGFjZVxuICogQHB1YmxpY1xuICovXG5leHBvcnRzLlRvTGluZWFyU3BhY2UgPSAyLjI7XG4vKipcbiAqIENvbnN0YW50IHVzZWQgdG8gZGVmaW5lIHRoZSBtaW5pbWFsIG51bWJlciB2YWx1ZSBpbiBCYWJ5bG9uLmpzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMuRXBzaWxvbiA9IDAuMDAwMDAxO1xuLyoqXG4gKiBDb25zdGFudCB1c2VkIHRvIGNvbnZlcnQgZnJvbSBFdWxlciBkZWdyZWVzIHRvIHJhZGlhbnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5ERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcbi8qKlxuICogQ29uc3RhbnQgdXNlZCB0byBjb252ZXJ0IGZyb20gcmFkaWFucyB0byBFdWxlciBkZWdyZWVzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMuUkFEMkRFRyA9IDM2MCAvIChNYXRoLlBJICogMik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGRBcnJheSA9IHZvaWQgMDtcbi8qKlxuICogQGludGVybmFsXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBnaXZlbiBzaXplIGZpbGxlZCB3aXRoIGVsZW1lbnQgYnVpbHQgZnJvbSB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgYW5kIHRoZSBwYXJhbXRlcnNcbiAqIEBwYXJhbSBzaXplIC0gdGhlIG51bWJlciBvZiBlbGVtZW50IHRvIGNvbnN0cnVjdCBhbmQgcHV0IGluIHRoZSBhcnJheVxuICogQHBhcmFtIGl0ZW1CdWlsZGVyIC0gYSBjYWxsYmFjayByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mIGl0ZW0uIENhbGxlZCBvbmNlIHBlciBhcnJheSBlbnRyeS5cbiAqIEByZXR1cm5zIGEgbmV3IGFycmF5IGZpbGxlZCB3aXRoIG5ldyBvYmplY3RzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gYnVpbGRBcnJheShzaXplLCBpdGVtQnVpbGRlcikge1xuICAgIGNvbnN0IGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICBhLnB1c2goaXRlbUJ1aWxkZXIoKSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuZXhwb3J0cy5idWlsZEFycmF5ID0gYnVpbGRBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY2FsYXIgPSB2b2lkIDA7XG4vKipcbiAqIFNjYWxhciBjb21wdXRhdGlvbiBsaWJyYXJ5XG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFNjYWxhciB7XG4gICAgLyoqXG4gICAgICogQm9vbGVhbiA6IHRydWUgaWYgdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiBhIGFuZCBiIGlzIGxvd2VyIHRoYW4gZXBzaWxvbiAoZGVmYXVsdCA9IDEuNDAxMjk4RS00NSlcbiAgICAgKiBAcGFyYW0gYSAtIG51bWJlclxuICAgICAqIEBwYXJhbSBiIC0gbnVtYmVyXG4gICAgICogQHBhcmFtIGVwc2lsb24gLSAoZGVmYXVsdCA9IDEuNDAxMjk4RS00NSlcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBhbmQgYiBpcyBsb3dlciB0aGFuIGVwc2lsb24gKGRlZmF1bHQgPSAxLjQwMTI5OEUtNDUpXG4gICAgICovXG4gICAgc3RhdGljIFdpdGhpbkVwc2lsb24oYSwgYiwgZXBzaWxvbiA9IDEuNDAxMjk4ZS00NSkge1xuICAgICAgICBjb25zdCBudW0gPSBhIC0gYjtcbiAgICAgICAgcmV0dXJuIC1lcHNpbG9uIDw9IG51bSAmJiBudW0gPD0gZXBzaWxvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyA6IHRoZSB1cHBlciBjYXNlIHRyYW5zbGF0aW9uIG9mIHRoZSBudW1iZXIgaSB0byBoZXhhZGVjaW1hbC5cbiAgICAgKiBAcGFyYW0gaSAtIG51bWJlclxuICAgICAqIEByZXR1cm5zIHRoZSB1cHBlciBjYXNlIHRyYW5zbGF0aW9uIG9mIHRoZSBudW1iZXIgaSB0byBoZXhhZGVjaW1hbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgVG9IZXgoaSkge1xuICAgICAgICBjb25zdCBzdHIgPSBpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGkgPD0gMTUpIHtcbiAgICAgICAgICAgIHJldHVybiAoJzAnICsgc3RyKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyAtMSBpZiB2YWx1ZSBpcyBuZWdhdGl2ZSBhbmQgKzEgaXMgdmFsdWUgaXMgcG9zaXRpdmUuXG4gICAgICogQHBhcmFtIF92YWx1ZSAtIHRoZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBpdHNlbGYgaWYgaXQncyBlcXVhbCB0byB6ZXJvLlxuICAgICAqL1xuICAgIHN0YXRpYyBTaWduKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IF92YWx1ZSA9ICt2YWx1ZTsgLy8gY29udmVydCB0byBhIG51bWJlclxuICAgICAgICBpZiAoX3ZhbHVlID09PSAwIHx8IGlzTmFOKF92YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF92YWx1ZSA+IDAgPyAxIDogLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGl0c2VsZiBpZiBpdCdzIGJldHdlZW4gbWluIGFuZCBtYXguXG4gICAgICogUmV0dXJucyBtaW4gaWYgdGhlIHZhbHVlIGlzIGxvd2VyIHRoYW4gbWluLlxuICAgICAqIFJldHVybnMgbWF4IGlmIHRoZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gbWF4LlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBjbG1hcFxuICAgICAqIEBwYXJhbSBtaW4gLSB0aGUgbWluIHZhbHVlIHRvIGNsYW1wIHRvIChkZWZhdWx0OiAwKVxuICAgICAqIEBwYXJhbSBtYXggLSB0aGUgbWF4IHZhbHVlIHRvIGNsYW1wIHRvIChkZWZhdWx0OiAxKVxuICAgICAqIEByZXR1cm5zIHRoZSBjbGFtcGVkIHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIENsYW1wKHZhbHVlLCBtaW4gPSAwLCBtYXggPSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIGxvZzIgb2YgdmFsdWUuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIGNvbXB1dGUgbG9nMiBvZlxuICAgICAqIEByZXR1cm5zIHRoZSBsb2cyIG9mIHZhbHVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBMb2cyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh2YWx1ZSkgKiBNYXRoLkxPRzJFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29wcyB0aGUgdmFsdWUsIHNvIHRoYXQgaXQgaXMgbmV2ZXIgbGFyZ2VyIHRoYW4gbGVuZ3RoIGFuZCBuZXZlciBzbWFsbGVyIHRoYW4gMC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgbW9kdWxvIG9wZXJhdG9yIGJ1dCBpdCB3b3JrcyB3aXRoIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuXG4gICAgICogRm9yIGV4YW1wbGUsIHVzaW5nIDMuMCBmb3IgdCBhbmQgMi41IGZvciBsZW5ndGgsIHRoZSByZXN1bHQgd291bGQgYmUgMC41LlxuICAgICAqIFdpdGggdCA9IDUgYW5kIGxlbmd0aCA9IDIuNSwgdGhlIHJlc3VsdCB3b3VsZCBiZSAwLjAuXG4gICAgICogTm90ZSwgaG93ZXZlciwgdGhhdCB0aGUgYmVoYXZpb3VyIGlzIG5vdCBkZWZpbmVkIGZvciBuZWdhdGl2ZSBudW1iZXJzIGFzIGl0IGlzIGZvciB0aGUgbW9kdWxvIG9wZXJhdG9yXG4gICAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlXG4gICAgICogQHBhcmFtIGxlbmd0aCAtIHRoZSBsZW5ndGhcbiAgICAgKiBAcmV0dXJucyB0aGUgbG9vcGVkIHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIFJlcGVhdCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAtIE1hdGguZmxvb3IodmFsdWUgLyBsZW5ndGgpICogbGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdGhlIHZhbHVlIGJldHdlZW4gMC4wIGFuZCAxLjAgdXNpbmcgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gbm9ybWFsaXplXG4gICAgICogQHBhcmFtIG1pbiAtIG1heCB0byBub3JtYWxpemUgYmV0d2VlblxuICAgICAqIEBwYXJhbSBtYXggLSBtaW4gdG8gbm9ybWFsaXplIGJldHdlZW5cbiAgICAgKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBOb3JtYWxpemUodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbm9ybWFsaXplIHRoZSB2YWx1ZSBmcm9tIDAuMCBhbmQgMS4wIHVzaW5nIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgICAqIEBwYXJhbSBub3JtYWxpemVkIC0gdmFsdWUgdG8gZGVub3JtYWxpemVcbiAgICAgKiBAcGFyYW0gbWluIC0gbWF4IHRvIGRlbm9ybWFsaXplIGJldHdlZW5cbiAgICAgKiBAcGFyYW0gbWF4IC0gbWluIHRvIGRlbm9ybWFsaXplIGJldHdlZW5cbiAgICAgKiBAcmV0dXJucyB0aGUgZGVub3JtYWxpemVkIHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIERlbm9ybWFsaXplKG5vcm1hbGl6ZWQsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNob3J0ZXN0IGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gZ2l2ZW4gYW5nbGVzIGdpdmVuIGluIGRlZ3JlZXMuXG4gICAgICogQHBhcmFtIGN1cnJlbnQgLSBjdXJyZW50IGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gdGFyZ2V0IGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJucyB0aGUgZGVsdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgRGVsdGFBbmdsZShjdXJyZW50LCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG51bSA9IFNjYWxhci5SZXBlYXQodGFyZ2V0IC0gY3VycmVudCwgMzYwLjApO1xuICAgICAgICBpZiAobnVtID4gMTgwLjApIHtcbiAgICAgICAgICAgIG51bSAtPSAzNjAuMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaW5nUG9uZ3MgdGhlIHZhbHVlIHQsIHNvIHRoYXQgaXQgaXMgbmV2ZXIgbGFyZ2VyIHRoYW4gbGVuZ3RoIGFuZCBuZXZlciBzbWFsbGVyIHRoYW4gMC5cbiAgICAgKiBAcGFyYW0gdHggLSB2YWx1ZVxuICAgICAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGhcbiAgICAgKiBAcmV0dXJucyBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBtb3ZlIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gMCBhbmQgbGVuZ3RoXG4gICAgICovXG4gICAgc3RhdGljIFBpbmdQb25nKHR4LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdCA9IFNjYWxhci5SZXBlYXQodHgsIGxlbmd0aCAqIDIuMCk7XG4gICAgICAgIHJldHVybiBsZW5ndGggLSBNYXRoLmFicyh0IC0gbGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJwb2xhdGVzIGJldHdlZW4gbWluIGFuZCBtYXggd2l0aCBzbW9vdGhpbmcgYXQgdGhlIGxpbWl0cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaW50ZXJwb2xhdGVzIGJldHdlZW4gbWluIGFuZCBtYXggaW4gYSBzaW1pbGFyIHdheSB0byBMZXJwLiBIb3dldmVyLCB0aGUgaW50ZXJwb2xhdGlvbiB3aWxsIGdyYWR1YWxseSBzcGVlZCB1cFxuICAgICAqIGZyb20gdGhlIHN0YXJ0IGFuZCBzbG93IGRvd24gdG93YXJkIHRoZSBlbmQuIFRoaXMgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBuYXR1cmFsLWxvb2tpbmcgYW5pbWF0aW9uLCBmYWRpbmcgYW5kIG90aGVyIHRyYW5zaXRpb25zLlxuICAgICAqIEBwYXJhbSBmcm9tIC0gZnJvbVxuICAgICAqIEBwYXJhbSB0byAtIHRvXG4gICAgICogQHBhcmFtIHR4IC0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB0aGUgc21vb3RoIHN0ZXBwZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgU21vb3RoU3RlcChmcm9tLCB0bywgdHgpIHtcbiAgICAgICAgbGV0IHQgPSBTY2FsYXIuQ2xhbXAodHgpO1xuICAgICAgICB0ID0gLTIuMCAqIHQgKiB0ICogdCArIDMuMCAqIHQgKiB0O1xuICAgICAgICByZXR1cm4gdG8gKiB0ICsgZnJvbSAqICgxLjAgLSB0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgYSB2YWx1ZSBjdXJyZW50IHRvd2FyZHMgdGFyZ2V0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc2FtZSBhcyBNYXRoZi5MZXJwIGJ1dCBpbnN0ZWFkIHRoZSBmdW5jdGlvbiB3aWxsIGVuc3VyZSB0aGF0IHRoZSBzcGVlZCBuZXZlciBleGNlZWRzIG1heERlbHRhLlxuICAgICAqIE5lZ2F0aXZlIHZhbHVlcyBvZiBtYXhEZWx0YSBwdXNoZXMgdGhlIHZhbHVlIGF3YXkgZnJvbSB0YXJnZXQuXG4gICAgICogQHBhcmFtIGN1cnJlbnQgLSBjdXJyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHRhcmdldCAtIHRhcmdldCB2YWx1ZVxuICAgICAqIEBwYXJhbSBtYXhEZWx0YSAtIG1heCBkaXN0YW5jZSB0byBtb3ZlXG4gICAgICogQHJldHVybnMgcmVzdWx0aW5nIHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIE1vdmVUb3dhcmRzKGN1cnJlbnQsIHRhcmdldCwgbWF4RGVsdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGlmIChNYXRoLmFicyh0YXJnZXQgLSBjdXJyZW50KSA8PSBtYXhEZWx0YSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY3VycmVudCArIFNjYWxhci5TaWduKHRhcmdldCAtIGN1cnJlbnQpICogbWF4RGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBNb3ZlVG93YXJkcyBidXQgbWFrZXMgc3VyZSB0aGUgdmFsdWVzIGludGVycG9sYXRlIGNvcnJlY3RseSB3aGVuIHRoZXkgd3JhcCBhcm91bmQgMzYwIGRlZ3JlZXMuXG4gICAgICpcbiAgICAgKiBWYXJpYWJsZXMgY3VycmVudCBhbmQgdGFyZ2V0IGFyZSBhc3N1bWVkIHRvIGJlIGluIGRlZ3JlZXMuIEZvciBvcHRpbWl6YXRpb24gcmVhc29ucywgbmVnYXRpdmUgdmFsdWVzIG9mIG1heERlbHRhXG4gICAgICogIGFyZSBub3Qgc3VwcG9ydGVkIGFuZCBtYXkgY2F1c2Ugb3NjaWxsYXRpb24uIFRvIHB1c2ggY3VycmVudCBhd2F5IGZyb20gYSB0YXJnZXQgYW5nbGUsIGFkZCAxODAgdG8gdGhhdCBhbmdsZSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBjdXJyZW50IC0gY3VycmVudCB2YWx1ZVxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcGFyYW0gbWF4RGVsdGEgLSBtYXggZGlzdGFuY2UgdG8gbW92ZVxuICAgICAqIEByZXR1cm5zIHJlc3VsdGluZyBhbmdsZVxuICAgICAqL1xuICAgIHN0YXRpYyBNb3ZlVG93YXJkc0FuZ2xlKGN1cnJlbnQsIHRhcmdldCwgbWF4RGVsdGEpIHtcbiAgICAgICAgY29uc3QgbnVtID0gU2NhbGFyLkRlbHRhQW5nbGUoY3VycmVudCwgdGFyZ2V0KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGlmICgtbWF4RGVsdGEgPCBudW0gJiYgbnVtIDwgbWF4RGVsdGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFNjYWxhci5Nb3ZlVG93YXJkcyhjdXJyZW50LCBjdXJyZW50ICsgbnVtLCBtYXhEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzY2FsYXIgd2l0aCB2YWx1ZXMgbGluZWFybHkgaW50ZXJwb2xhdGVkIG9mIFwiYW1vdW50XCIgYmV0d2VlbiB0aGUgc3RhcnQgc2NhbGFyIGFuZCB0aGUgZW5kIHNjYWxhci5cbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBzdGFydCB2YWx1ZVxuICAgICAqIEBwYXJhbSBlbmQgLSB0YXJnZXQgdmFsdWVcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gYW1vdW50IHRvIGxlcnAgYmV0d2VlblxuICAgICAqIEByZXR1cm5zIHRoZSBsZXJwZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgTGVycChzdGFydCwgZW5kLCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGFtb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBMZXJwIGJ1dCBtYWtlcyBzdXJlIHRoZSB2YWx1ZXMgaW50ZXJwb2xhdGUgY29ycmVjdGx5IHdoZW4gdGhleSB3cmFwIGFyb3VuZCAzNjAgZGVncmVlcy5cbiAgICAgKiBUaGUgcGFyYW1ldGVyIHQgaXMgY2xhbXBlZCB0byB0aGUgcmFuZ2UgWzAsIDFdLiBWYXJpYWJsZXMgYSBhbmQgYiBhcmUgYXNzdW1lZCB0byBiZSBpbiBkZWdyZWVzLlxuICAgICAqIEBwYXJhbSBzdGFydCAtIHN0YXJ0IHZhbHVlXG4gICAgICogQHBhcmFtIGVuZCAtIHRhcmdldCB2YWx1ZVxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBhbW91bnQgdG8gbGVycCBiZXR3ZWVuXG4gICAgICogQHJldHVybnMgdGhlIGxlcnBlZCB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBMZXJwQW5nbGUoc3RhcnQsIGVuZCwgYW1vdW50KSB7XG4gICAgICAgIGxldCBudW0gPSBTY2FsYXIuUmVwZWF0KGVuZCAtIHN0YXJ0LCAzNjAuMCk7XG4gICAgICAgIGlmIChudW0gPiAxODAuMCkge1xuICAgICAgICAgICAgbnVtIC09IDM2MC4wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydCArIG51bSAqIFNjYWxhci5DbGFtcChhbW91bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBsaW5lYXIgcGFyYW1ldGVyIHQgdGhhdCBwcm9kdWNlcyB0aGUgaW50ZXJwb2xhbnQgdmFsdWUgd2l0aGluIHRoZSByYW5nZSBbYSwgYl0uXG4gICAgICogQHBhcmFtIGEgLSBzdGFydCB2YWx1ZVxuICAgICAqIEBwYXJhbSBiIC0gdGFyZ2V0IHZhbHVlXG4gICAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgYmV0d2VlbiBhIGFuZCBiXG4gICAgICogQHJldHVybnMgdGhlIGludmVyc2VMZXJwIHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIEludmVyc2VMZXJwKGEsIGIsIHZhbHVlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgICAgcmVzdWx0ID0gU2NhbGFyLkNsYW1wKCh2YWx1ZSAtIGEpIC8gKGIgLSBhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAwLjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzY2FsYXIgbG9jYXRlZCBmb3IgXCJhbW91bnRcIiAoZmxvYXQpIG9uIHRoZSBIZXJtaXRlIHNwbGluZSBkZWZpbmVkIGJ5IHRoZSBzY2FsYXJzIFwidmFsdWUxXCIsIFwidmFsdWUzXCIsIFwidGFuZ2VudDFcIiwgXCJ0YW5nZW50MlwiLlxuICAgICAqIHtAbGluayBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0hlcm1pdGVQb2x5bm9taWFsLmh0bWx9XG4gICAgICogQHBhcmFtIHZhbHVlMSAtIHNwbGluZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB0YW5nZW50MSAtIHNwbGluZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZTIgLSBzcGxpbmUgdmFsdWVcbiAgICAgKiBAcGFyYW0gdGFuZ2VudDIgLSBzcGxpbmUgdmFsdWVcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gaW5wdXQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBoZXJtaXRlIHJlc3VsdFxuICAgICAqL1xuICAgIHN0YXRpYyBIZXJtaXRlKHZhbHVlMSwgdGFuZ2VudDEsIHZhbHVlMiwgdGFuZ2VudDIsIGFtb3VudCkge1xuICAgICAgICBjb25zdCBzcXVhcmVkID0gYW1vdW50ICogYW1vdW50O1xuICAgICAgICBjb25zdCBjdWJlZCA9IGFtb3VudCAqIHNxdWFyZWQ7XG4gICAgICAgIGNvbnN0IHBhcnQxID0gMi4wICogY3ViZWQgLSAzLjAgKiBzcXVhcmVkICsgMS4wO1xuICAgICAgICBjb25zdCBwYXJ0MiA9IC0yLjAgKiBjdWJlZCArIDMuMCAqIHNxdWFyZWQ7XG4gICAgICAgIGNvbnN0IHBhcnQzID0gY3ViZWQgLSAyLjAgKiBzcXVhcmVkICsgYW1vdW50O1xuICAgICAgICBjb25zdCBwYXJ0NCA9IGN1YmVkIC0gc3F1YXJlZDtcbiAgICAgICAgcmV0dXJuIHZhbHVlMSAqIHBhcnQxICsgdmFsdWUyICogcGFydDIgKyB0YW5nZW50MSAqIHBhcnQzICsgdGFuZ2VudDIgKiBwYXJ0NDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBmbG9hdCBudW1iZXIgYmV0d2VlbiBhbmQgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZSBvZiByYW5kb21cbiAgICAgKiBAcGFyYW0gbWF4IC0gbWF4IHZhbHVlIG9mIHJhbmRvbVxuICAgICAqIEByZXR1cm5zIHJhbmRvbSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBSYW5kb21SYW5nZShtaW4sIG1heCkge1xuICAgICAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHBlcmNlbnRhZ2Ugb2YgYSBudW1iZXIgaW4gYSBnaXZlbiByYW5nZS5cbiAgICAgKlxuICAgICAqIFJhbmdlVG9QZXJjZW50KDQwLDIwLDYwKSB3aWxsIHJldHVybiAwLjUgKDUwJSlcbiAgICAgKiBSYW5nZVRvUGVyY2VudCgzNCwwLDEwMCkgd2lsbCByZXR1cm4gMC4zNCAoMzQlKVxuICAgICAqIEBwYXJhbSBudW0gLSB0byBjb252ZXJ0IHRvIHBlcmNlbnRhZ2VcbiAgICAgKiBAcGFyYW0gbWluIC0gbWluIHJhbmdlXG4gICAgICogQHBhcmFtIG1heCAtIG1heCByYW5nZVxuICAgICAqIEByZXR1cm5zIHRoZSBwZXJjZW50YWdlXG4gICAgICovXG4gICAgc3RhdGljIFJhbmdlVG9QZXJjZW50KG51bSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIChudW0gLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBudW1iZXIgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcGVyY2VudGFnZSBpbiBhIGdpdmVuIHJhbmdlLlxuICAgICAqXG4gICAgICogUGVyY2VudFRvUmFuZ2UoMC4zNCwwLDEwMCkgd2lsbCByZXR1cm4gMzQuXG4gICAgICogQHBhcmFtIHBlcmNlbnQgLSB0byBjb252ZXJ0IHRvIG51bWJlclxuICAgICAqIEBwYXJhbSBtaW4gLSBtaW4gcmFuZ2VcbiAgICAgKiBAcGFyYW0gbWF4IC0gbWF4IHJhbmdlXG4gICAgICogQHJldHVybnMgdGhlIG51bWJlclxuICAgICAqL1xuICAgIHN0YXRpYyBQZXJjZW50VG9SYW5nZShwZXJjZW50LCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gKG1heCAtIG1pbikgKiBwZXJjZW50ICsgbWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBjb252ZXJ0ZWQgdG8gZXF1aXZhbGVudCB2YWx1ZSBiZXR3ZWVuIC1NYXRoLlBJIGFuZCBNYXRoLlBJIHJhZGlhbnMuXG4gICAgICogQHBhcmFtIGFuZ2xlIC0gVGhlIGFuZ2xlIHRvIG5vcm1hbGl6ZSBpbiByYWRpYW4uXG4gICAgICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBhbmdsZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgTm9ybWFsaXplUmFkaWFucyhhbmdsZSkge1xuICAgICAgICAvLyBNb3JlIHByZWNpc2UgYnV0IHNsb3dlciB2ZXJzaW9uIGtlcHQgZm9yIHJlZmVyZW5jZS5cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGU6bm8tY29tbWVudGVkLW91dC1jb2RlXG4gICAgICAgIC8qXG4gICAgICAgICAgLy8gYW5nbGUgPSBhbmdsZSAlIFRvb2xzLlR3b1BpO1xuICAgICAgICAgIC8vIGFuZ2xlID0gKGFuZ2xlICsgVG9vbHMuVHdvUGkpICUgVG9vbHMuVHdvUGk7XG4gICAgXG4gICAgICAgICAgLy9pZiAoYW5nbGUgPiBNYXRoLlBJKSB7XG4gICAgICAgICAgLy9cdGFuZ2xlIC09IFRvb2xzLlR3b1BpO1xuICAgICAgICAgIC8vfVxuICAgICAgICAgICAqL1xuICAgICAgICByZXR1cm4gYW5nbGUgLSBTY2FsYXIuVHdvUGkgKiBNYXRoLmZsb29yKChhbmdsZSArIE1hdGguUEkpIC8gU2NhbGFyLlR3b1BpKTtcbiAgICB9XG59XG5leHBvcnRzLlNjYWxhciA9IFNjYWxhcjtcbi8qKlxuICogVHdvIHBpIGNvbnN0YW50cyBjb252ZW5pZW50IGZvciBjb21wdXRhdGlvbi5cbiAqL1xuU2NhbGFyLlR3b1BpID0gTWF0aC5QSSAqIDI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY2FsYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZlY3RvcjQgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBTY2FsYXJfMSA9IHJlcXVpcmUoXCIuL1NjYWxhclwiKTtcbmNvbnN0IFZlY3RvcjNfMSA9IHJlcXVpcmUoXCIuL1ZlY3RvcjNcIik7XG4vKipcbiAqIFZlY3RvcjQgY2xhc3MgY3JlYXRlZCBmb3IgRXVsZXJBbmdsZSBjbGFzcyBjb252ZXJzaW9uIHRvIFF1YXRlcm5pb25cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgVmVjdG9yNCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFZlY3RvcjQgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGZsb2F0cy5cbiAgICAgKiBAcGFyYW0geCAtIHggdmFsdWUgb2YgdGhlIHZlY3RvclxuICAgICAqIEBwYXJhbSB5IC0geSB2YWx1ZSBvZiB0aGUgdmVjdG9yXG4gICAgICogQHBhcmFtIHogLSB6IHZhbHVlIG9mIHRoZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdyAtIHcgdmFsdWUgb2YgdGhlIHZlY3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiB4IHZhbHVlIG9mIHRoZSB2ZWN0b3IgKi9cbiAgICB4LCBcbiAgICAvKiogeSB2YWx1ZSBvZiB0aGUgdmVjdG9yICovXG4gICAgeSwgXG4gICAgLyoqIHogdmFsdWUgb2YgdGhlIHZlY3RvciAqL1xuICAgIHosIFxuICAgIC8qKiB3IHZhbHVlIG9mIHRoZSB2ZWN0b3IgKi9cbiAgICB3KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgfVxuICAgIC8vIFN0YXRpY3NcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjQgYXMgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24gb2YgdGhlIHR3byBnaXZlbiB2ZWN0b3JzLlxuICAgICAqIEBwYXJhbSB2ZWN0b3IxIC0gdGhlIGZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB2ZWN0b3IyIC0gdGhlIHNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVzdWx0aW5nIHZlY3RvclxuICAgICAqL1xuICAgIHN0YXRpYyBBZGQodmVjdG9yMSwgdmVjdG9yMikge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjQodmVjdG9yMS54LCB2ZWN0b3IxLnksIHZlY3RvcjEueiwgdmVjdG9yMS53KS5hZGRJblBsYWNlKHZlY3RvcjIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjQgc2V0IGZyb20gdGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBnaXZlbiBhcnJheS5cbiAgICAgKiBAcGFyYW0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gcHVsbCB2YWx1ZXMgZnJvbVxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSB0aGUgb2Zmc2V0IGludG8gdGhlIGFycmF5IHRvIHN0YXJ0IGF0XG4gICAgICogQHJldHVybnMgdGhlIG5ldyB2ZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yNChhcnJheVtvZmZzZXRdLCBhcnJheVtvZmZzZXQgKyAxXSwgYXJyYXlbb2Zmc2V0ICsgMl0sIGFycmF5W29mZnNldCArIDNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgZnJvbSB0aGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGdpdmVuIGFycmF5LlxuICAgICAqIEBwYXJhbSBhcnJheSAtIHRoZSBhcnJheSB0byBwdWxsIHZhbHVlcyBmcm9tXG4gICAgICogQHBhcmFtIG9mZnNldCAtIHRoZSBvZmZzZXQgaW50byB0aGUgYXJyYXkgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gdGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gICAgICovXG4gICAgc3RhdGljIEZyb21BcnJheVRvUmVmKGFycmF5LCBvZmZzZXQsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCA9IGFycmF5W29mZnNldF07XG4gICAgICAgIHJlc3VsdC55ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG4gICAgICAgIHJlc3VsdC56ID0gYXJyYXlbb2Zmc2V0ICsgMl07XG4gICAgICAgIHJlc3VsdC53ID0gYXJyYXlbb2Zmc2V0ICsgM107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIHZlY3RvciBcInJlc3VsdFwiIGZyb20gdGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBnaXZlbiBGbG9hdEFycmF5LlxuICAgICAqIEBwYXJhbSBhcnJheSAtIHRoZSBhcnJheSB0byBwdWxsIHZhbHVlcyBmcm9tXG4gICAgICogQHBhcmFtIG9mZnNldCAtIHRoZSBvZmZzZXQgaW50byB0aGUgYXJyYXkgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gdGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gICAgICovXG4gICAgc3RhdGljIEZyb21GbG9hdEFycmF5VG9SZWYoYXJyYXksIG9mZnNldCwgcmVzdWx0KSB7XG4gICAgICAgIFZlY3RvcjQuRnJvbUFycmF5VG9SZWYoYXJyYXksIG9mZnNldCwgcmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgY29vcmRpbmF0ZXMgZnJvbSB0aGUgZ2l2ZW4gZmxvYXRzLlxuICAgICAqIEBwYXJhbSB4IC0gZmxvYXQgdG8gc2V0IGZyb21cbiAgICAgKiBAcGFyYW0geSAtIGZsb2F0IHRvIHNldCBmcm9tXG4gICAgICogQHBhcmFtIHogLSBmbG9hdCB0byBzZXQgZnJvbVxuICAgICAqIEBwYXJhbSB3IC0gZmxvYXQgdG8gc2V0IGZyb21cbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gdGhlIHZlY3RvciB0byB0aGUgZmxvYXRzIGluXG4gICAgICovXG4gICAgc3RhdGljIEZyb21GbG9hdHNUb1JlZih4LCB5LCB6LCB3LCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnggPSB4O1xuICAgICAgICByZXN1bHQueSA9IHk7XG4gICAgICAgIHJlc3VsdC56ID0gejtcbiAgICAgICAgcmVzdWx0LncgPSB3O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjQgc2V0IHRvICgwLjAsIDAuMCwgMC4wLCAwLjApXG4gICAgICogQHJldHVybnMgdGhlIG5ldyB2ZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgWmVybygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3I0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yNCBzZXQgdG8gKDEuMCwgMS4wLCAxLjAsIDEuMClcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IHZlY3RvclxuICAgICAqL1xuICAgIHN0YXRpYyBPbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IG5vcm1hbGl6ZWQgVmVjdG9yNCBmcm9tIHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHBhcmFtIHZlY3RvciAtIHRoZSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gICAgICogQHJldHVybnMgdGhlIHZlY3RvclxuICAgICAqL1xuICAgIHN0YXRpYyBOb3JtYWxpemUodmVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFZlY3RvcjQuWmVybygpO1xuICAgICAgICBWZWN0b3I0Lk5vcm1hbGl6ZVRvUmVmKHZlY3RvciwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgZnJvbSB0aGUgbm9ybWFsaXphdGlvbiBvZiB0aGUgZ2l2ZW4gb25lLlxuICAgICAqIEBwYXJhbSB2ZWN0b3IgLSB0aGUgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICAgICAqIEBwYXJhbSByZXN1bHQgLSB0aGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5cbiAgICAgKi9cbiAgICBzdGF0aWMgTm9ybWFsaXplVG9SZWYodmVjdG9yLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LmNvcHlGcm9tKHZlY3Rvcik7XG4gICAgICAgIHJlc3VsdC5ub3JtYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHZlY3RvciB3aXRoIHRoZSBtaW5pbXVtIHZhbHVlcyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCB2ZWN0b3JzXG4gICAgICogQHBhcmFtIGxlZnQgLSBsZWZ0IHZlY3RvciB0byBtaW5pbWl6ZVxuICAgICAqIEBwYXJhbSByaWdodCAtIHJpZ2h0IHZlY3RvciB0byBtaW5pbWl6ZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIHRoZSBtaW5pbXVtIG9mIHRoZSBsZWZ0IGFuZCByaWdodCB2ZWN0b3IgdmFsdWVzXG4gICAgICovXG4gICAgc3RhdGljIE1pbmltaXplKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IG5ldyBWZWN0b3I0KGxlZnQueCwgbGVmdC55LCBsZWZ0LnosIGxlZnQudyk7XG4gICAgICAgIG1pbi5taW5pbWl6ZUluUGxhY2UocmlnaHQpO1xuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdmVjdG9yIHdpdGggdGhlIG1heGltdW0gdmFsdWVzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IHZlY3RvcnNcbiAgICAgKiBAcGFyYW0gbGVmdCAtIGxlZnQgdmVjdG9yIHRvIG1heGltaXplXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gcmlnaHQgdmVjdG9yIHRvIG1heGltaXplXG4gICAgICogQHJldHVybnMgYSBuZXcgdmVjdG9yIHdpdGggdGhlIG1heGltdW0gb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IHZlY3RvciB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgTWF4aW1pemUobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gbmV3IFZlY3RvcjQobGVmdC54LCBsZWZ0LnksIGxlZnQueiwgbGVmdC53KTtcbiAgICAgICAgbWF4Lm1heGltaXplSW5QbGFjZShyaWdodCk7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3RhbmNlIChmbG9hdCkgYmV0d2VlbiB0aGUgdmVjdG9ycyBcInZhbHVlMVwiIGFuZCBcInZhbHVlMlwiLlxuICAgICAqIEBwYXJhbSB2YWx1ZTEgLSB2YWx1ZSB0byBjYWx1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlblxuICAgICAqIEBwYXJhbSB2YWx1ZTIgLSB2YWx1ZSB0byBjYWx1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlblxuICAgICAqIEByZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gdmVjdG9yc1xuICAgICAqL1xuICAgIHN0YXRpYyBEaXN0YW5jZSh2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFZlY3RvcjQuRGlzdGFuY2VTcXVhcmVkKHZhbHVlMSwgdmFsdWUyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgKGZsb2F0KSBiZXR3ZWVuIHRoZSB2ZWN0b3JzIFwidmFsdWUxXCIgYW5kIFwidmFsdWUyXCIuXG4gICAgICogQHBhcmFtIHZhbHVlMSAtIHZhbHVlIHRvIGNhbHVsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuXG4gICAgICogQHBhcmFtIHZhbHVlMiAtIHZhbHVlIHRvIGNhbHVsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuXG4gICAgICogQHJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byB2ZWN0b3JzIHNxdWFyZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgRGlzdGFuY2VTcXVhcmVkKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICAgIGNvbnN0IHggPSB2YWx1ZTEueCAtIHZhbHVlMi54O1xuICAgICAgICBjb25zdCB5ID0gdmFsdWUxLnkgLSB2YWx1ZTIueTtcbiAgICAgICAgY29uc3QgeiA9IHZhbHVlMS56IC0gdmFsdWUyLno7XG4gICAgICAgIGNvbnN0IHcgPSB2YWx1ZTEudyAtIHZhbHVlMi53O1xuICAgICAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yNCBsb2NhdGVkIGF0IHRoZSBjZW50ZXIgYmV0d2VlbiB0aGUgdmVjdG9ycyBcInZhbHVlMVwiIGFuZCBcInZhbHVlMlwiLlxuICAgICAqIEBwYXJhbSB2YWx1ZTEgLSB2YWx1ZSB0byBjYWx1bGF0ZSB0aGUgY2VudGVyIGJldHdlZW5cbiAgICAgKiBAcGFyYW0gdmFsdWUyIC0gdmFsdWUgdG8gY2FsdWxhdGUgdGhlIGNlbnRlciBiZXR3ZWVuXG4gICAgICogQHJldHVybnMgdGhlIGNlbnRlciBiZXR3ZWVuIHRoZSB0d28gdmVjdG9yc1xuICAgICAqL1xuICAgIHN0YXRpYyBDZW50ZXIodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gVmVjdG9yNC5BZGQodmFsdWUxLCB2YWx1ZTIpO1xuICAgICAgICBjZW50ZXIuc2NhbGVJblBsYWNlKDAuNSk7XG4gICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yNCBzZXQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBub3JtYWwgdHJhbnNmb3JtYXRpb24gYnkgdGhlIGdpdmVuIG1hdHJpeCBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxuICAgICAqIFRoaXMgbWV0aG9kcyBjb21wdXRlcyB0cmFuc2Zvcm1lZCBub3JtYWxpemVkIGRpcmVjdGlvbiB2ZWN0b3JzIG9ubHkuXG4gICAgICogQHBhcmFtIHZlY3RvciAtIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWF0aW9uIC0gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBhcHBseVxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgdmVjdG9yXG4gICAgICovXG4gICAgc3RhdGljIFRyYW5zZm9ybU5vcm1hbCh2ZWN0b3IsIHRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFZlY3RvcjQuWmVybygpO1xuICAgICAgICBWZWN0b3I0LlRyYW5zZm9ybU5vcm1hbFRvUmVmKHZlY3RvciwgdHJhbnNmb3JtYXRpb24sIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZlY3RvciBcInJlc3VsdFwiIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgbm9ybWFsIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBnaXZlbiBtYXRyaXggb2YgdGhlIGdpdmVuIHZlY3Rvci5cbiAgICAgKiBUaGlzIG1ldGhvZHMgY29tcHV0ZXMgdHJhbnNmb3JtZWQgbm9ybWFsaXplZCBkaXJlY3Rpb24gdmVjdG9ycyBvbmx5LlxuICAgICAqIEBwYXJhbSB2ZWN0b3IgLSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1hdGlvbiAtIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gdGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gICAgICovXG4gICAgc3RhdGljIFRyYW5zZm9ybU5vcm1hbFRvUmVmKHZlY3RvciwgdHJhbnNmb3JtYXRpb24sIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBtID0gdHJhbnNmb3JtYXRpb24ubTtcbiAgICAgICAgY29uc3QgeCA9IHZlY3Rvci54ICogbVswXSArIHZlY3Rvci55ICogbVs0XSArIHZlY3Rvci56ICogbVs4XTtcbiAgICAgICAgY29uc3QgeSA9IHZlY3Rvci54ICogbVsxXSArIHZlY3Rvci55ICogbVs1XSArIHZlY3Rvci56ICogbVs5XTtcbiAgICAgICAgY29uc3QgeiA9IHZlY3Rvci54ICogbVsyXSArIHZlY3Rvci55ICogbVs2XSArIHZlY3Rvci56ICogbVsxMF07XG4gICAgICAgIHJlc3VsdC54ID0geDtcbiAgICAgICAgcmVzdWx0LnkgPSB5O1xuICAgICAgICByZXN1bHQueiA9IHo7XG4gICAgICAgIHJlc3VsdC53ID0gdmVjdG9yLnc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZlY3RvciBcInJlc3VsdFwiIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgbm9ybWFsIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBnaXZlbiBtYXRyaXggb2YgdGhlIGdpdmVuIGZsb2F0cyAoeCwgeSwgeiwgdykuXG4gICAgICogVGhpcyBtZXRob2RzIGNvbXB1dGVzIHRyYW5zZm9ybWVkIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIHZlY3RvcnMgb25seS5cbiAgICAgKiBAcGFyYW0geCAtIHZhbHVlIHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB5IC0gdmFsdWUgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHogLSB2YWx1ZSB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gdyAtIHZhbHVlIHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1hdGlvbiAtIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gdGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0cyBpblxuICAgICAqL1xuICAgIHN0YXRpYyBUcmFuc2Zvcm1Ob3JtYWxGcm9tRmxvYXRzVG9SZWYoeCwgeSwgeiwgdywgdHJhbnNmb3JtYXRpb24sIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBtID0gdHJhbnNmb3JtYXRpb24ubTtcbiAgICAgICAgcmVzdWx0LnggPSB4ICogbVswXSArIHkgKiBtWzRdICsgeiAqIG1bOF07XG4gICAgICAgIHJlc3VsdC55ID0geCAqIG1bMV0gKyB5ICogbVs1XSArIHogKiBtWzldO1xuICAgICAgICByZXN1bHQueiA9IHggKiBtWzJdICsgeSAqIG1bNl0gKyB6ICogbVsxMF07XG4gICAgICAgIHJlc3VsdC53ID0gdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIHdpdGggdGhlIFZlY3RvcjQgY29vcmRpbmF0ZXMuXG4gICAgICogQHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyBhbGwgdGhlIHZlY3RvciB2YWx1ZXNcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICgne1g6ICcgKyB0aGlzLnggKyAnIFk6JyArIHRoaXMueSArICcgWjonICsgdGhpcy56ICsgJyBXOicgKyB0aGlzLncgKyAnfScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgXCJWZWN0b3I0XCIuXG4gICAgICogQHJldHVybnMgXCJWZWN0b3I0XCJcbiAgICAgKi9cbiAgICBnZXRDbGFzc05hbWUoKSB7XG4gICAgICAgIHJldHVybiAnVmVjdG9yNCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFZlY3RvcjQgaGFzaCBjb2RlLlxuICAgICAqIEByZXR1cm5zIGEgdW5pcXVlIGhhc2ggY29kZVxuICAgICAqL1xuICAgIGdldEhhc2hDb2RlKCkge1xuICAgICAgICBsZXQgaGFzaCA9IHRoaXMueCB8fCAwO1xuICAgICAgICBoYXNoID0gKGhhc2ggKiAzOTcpIF4gKHRoaXMueSB8fCAwKTtcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzk3KSBeICh0aGlzLnogfHwgMCk7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIDM5NykgXiAodGhpcy53IHx8IDApO1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gICAgLy8gT3BlcmF0b3JzXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBhcnJheSBwb3B1bGF0ZWQgd2l0aCA0IGVsZW1lbnRzIDogdGhlIFZlY3RvcjQgY29vcmRpbmF0ZXMuXG4gICAgICogQHJldHVybnMgdGhlIHJlc3VsdGluZyBhcnJheVxuICAgICAqL1xuICAgIGFzQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnRvQXJyYXkocmVzdWx0LCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9wdWxhdGVzIHRoZSBnaXZlbiBhcnJheSBmcm9tIHRoZSBnaXZlbiBpbmRleCB3aXRoIHRoZSBWZWN0b3I0IGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSBhcnJheSAtIGFycmF5IHRvIHBvcHVsYXRlXG4gICAgICogQHBhcmFtIGluZGV4IC0gaW5kZXggb2YgdGhlIGFycmF5IHRvIHN0YXJ0IGF0IChkZWZhdWx0OiAwKVxuICAgICAqIEByZXR1cm5zIHRoZSBWZWN0b3I0LlxuICAgICAqL1xuICAgIHRvQXJyYXkoYXJyYXksIGluZGV4ID0gMCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSB0aGlzLng7XG4gICAgICAgIGFycmF5W2luZGV4ICsgMV0gPSB0aGlzLnk7XG4gICAgICAgIGFycmF5W2luZGV4ICsgMl0gPSB0aGlzLno7XG4gICAgICAgIGFycmF5W2luZGV4ICsgM10gPSB0aGlzLnc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gdGhlIGN1cnJlbnQgVmVjdG9yNC5cbiAgICAgKiBAcGFyYW0gb3RoZXJWZWN0b3IgLSB0aGUgdmVjdG9yIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIFZlY3RvcjQuXG4gICAgICovXG4gICAgYWRkSW5QbGFjZShvdGhlclZlY3Rvcikge1xuICAgICAgICB0aGlzLnggKz0gb3RoZXJWZWN0b3IueDtcbiAgICAgICAgdGhpcy55ICs9IG90aGVyVmVjdG9yLnk7XG4gICAgICAgIHRoaXMueiArPSBvdGhlclZlY3Rvci56O1xuICAgICAgICB0aGlzLncgKz0gb3RoZXJWZWN0b3IudztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yNCBhcyB0aGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBWZWN0b3I0IGFuZCB0aGUgZ2l2ZW4gb25lLlxuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIHRoZSB2ZWN0b3IgdG8gYWRkXG4gICAgICogQHJldHVybnMgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKi9cbiAgICBhZGQob3RoZXJWZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3I0KHRoaXMueCArIG90aGVyVmVjdG9yLngsIHRoaXMueSArIG90aGVyVmVjdG9yLnksIHRoaXMueiArIG90aGVyVmVjdG9yLnosIHRoaXMudyArIG90aGVyVmVjdG9yLncpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiB2ZWN0b3IgXCJyZXN1bHRcIiB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IFZlY3RvcjQgYW5kIHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gdGhlIHZlY3RvciB0byBhZGRcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gdGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgVmVjdG9yNC5cbiAgICAgKi9cbiAgICBhZGRUb1JlZihvdGhlclZlY3RvciwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC54ID0gdGhpcy54ICsgb3RoZXJWZWN0b3IueDtcbiAgICAgICAgcmVzdWx0LnkgPSB0aGlzLnkgKyBvdGhlclZlY3Rvci55O1xuICAgICAgICByZXN1bHQueiA9IHRoaXMueiArIG90aGVyVmVjdG9yLno7XG4gICAgICAgIHJlc3VsdC53ID0gdGhpcy53ICsgb3RoZXJWZWN0b3IudztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IGluIHBsYWNlIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGUgY3VycmVudCBWZWN0b3I0LlxuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIHRoZSB2ZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBWZWN0b3I0LlxuICAgICAqL1xuICAgIHN1YnRyYWN0SW5QbGFjZShvdGhlclZlY3Rvcikge1xuICAgICAgICB0aGlzLnggLT0gb3RoZXJWZWN0b3IueDtcbiAgICAgICAgdGhpcy55IC09IG90aGVyVmVjdG9yLnk7XG4gICAgICAgIHRoaXMueiAtPSBvdGhlclZlY3Rvci56O1xuICAgICAgICB0aGlzLncgLT0gb3RoZXJWZWN0b3IudztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yNCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGUgY3VycmVudCBWZWN0b3I0LlxuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIHRoZSB2ZWN0b3IgdG8gYWRkXG4gICAgICogQHJldHVybnMgdGhlIG5ldyB2ZWN0b3Igd2l0aCB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3VidHJhY3Qob3RoZXJWZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3I0KHRoaXMueCAtIG90aGVyVmVjdG9yLngsIHRoaXMueSAtIG90aGVyVmVjdG9yLnksIHRoaXMueiAtIG90aGVyVmVjdG9yLnosIHRoaXMudyAtIG90aGVyVmVjdG9yLncpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2ZWN0b3IgXCJyZXN1bHRcIiB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGUgY3VycmVudCBWZWN0b3I0LlxuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIHRoZSB2ZWN0b3IgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gdGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgVmVjdG9yNC5cbiAgICAgKi9cbiAgICBzdWJ0cmFjdFRvUmVmKG90aGVyVmVjdG9yLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnggPSB0aGlzLnggLSBvdGhlclZlY3Rvci54O1xuICAgICAgICByZXN1bHQueSA9IHRoaXMueSAtIG90aGVyVmVjdG9yLnk7XG4gICAgICAgIHJlc3VsdC56ID0gdGhpcy56IC0gb3RoZXJWZWN0b3IuejtcbiAgICAgICAgcmVzdWx0LncgPSB0aGlzLncgLSBvdGhlclZlY3Rvci53O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3I0IHNldCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBmbG9hdHMgZnJvbSB0aGUgY3VycmVudCBWZWN0b3I0IGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yNCBzZXQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gZmxvYXRzIGZyb20gdGhlIGN1cnJlbnQgVmVjdG9yNCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0geCAtIHZhbHVlIHRvIHN1YnRyYWN0XG4gICAgICogQHBhcmFtIHkgLSB2YWx1ZSB0byBzdWJ0cmFjdFxuICAgICAqIEBwYXJhbSB6IC0gdmFsdWUgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0gdyAtIHZhbHVlIHRvIHN1YnRyYWN0XG4gICAgICogQHJldHVybnMgbmV3IHZlY3RvciBjb250YWluaW5nIHRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBzdWJ0cmFjdEZyb21GbG9hdHMoeCwgeSwgeiwgdykge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjQodGhpcy54IC0geCwgdGhpcy55IC0geSwgdGhpcy56IC0geiwgdGhpcy53IC0gdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZlY3RvciBcInJlc3VsdFwiIHNldCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBmbG9hdHMgZnJvbSB0aGUgY3VycmVudCBWZWN0b3I0IGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB4IC0gdmFsdWUgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0geSAtIHZhbHVlIHRvIHN1YnRyYWN0XG4gICAgICogQHBhcmFtIHogLSB2YWx1ZSB0byBzdWJ0cmFjdFxuICAgICAqIEBwYXJhbSB3IC0gdmFsdWUgdG8gc3VidHJhY3RcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gdGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgVmVjdG9yNC5cbiAgICAgKi9cbiAgICBzdWJ0cmFjdEZyb21GbG9hdHNUb1JlZih4LCB5LCB6LCB3LCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnggPSB0aGlzLnggLSB4O1xuICAgICAgICByZXN1bHQueSA9IHRoaXMueSAtIHk7XG4gICAgICAgIHJlc3VsdC56ID0gdGhpcy56IC0gejtcbiAgICAgICAgcmVzdWx0LncgPSB0aGlzLncgLSB3O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3I0IHNldCB3aXRoIHRoZSBjdXJyZW50IFZlY3RvcjQgbmVnYXRlZCBjb29yZGluYXRlcy5cbiAgICAgKiBAcmV0dXJucyBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgbmVnYXRlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yNCgtdGhpcy54LCAtdGhpcy55LCAtdGhpcy56LCAtdGhpcy53KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgY3VycmVudCBWZWN0b3I0IGNvb3JkaW5hdGVzIGJ5IHNjYWxlIChmbG9hdCkuXG4gICAgICogQHBhcmFtIHNjYWxlIC0gdGhlIG51bWJlciB0byBzY2FsZSB3aXRoXG4gICAgICogQHJldHVybnMgdGhlIHVwZGF0ZWQgVmVjdG9yNC5cbiAgICAgKi9cbiAgICBzY2FsZUluUGxhY2Uoc2NhbGUpIHtcbiAgICAgICAgdGhpcy54ICo9IHNjYWxlO1xuICAgICAgICB0aGlzLnkgKj0gc2NhbGU7XG4gICAgICAgIHRoaXMueiAqPSBzY2FsZTtcbiAgICAgICAgdGhpcy53ICo9IHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3I0IHNldCB3aXRoIHRoZSBjdXJyZW50IFZlY3RvcjQgY29vcmRpbmF0ZXMgbXVsdGlwbGllZCBieSBzY2FsZSAoZmxvYXQpLlxuICAgICAqIEBwYXJhbSBzY2FsZSAtIHRoZSBudW1iZXIgdG8gc2NhbGUgd2l0aFxuICAgICAqIEByZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIHRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBzY2FsZShzY2FsZSkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjQodGhpcy54ICogc2NhbGUsIHRoaXMueSAqIHNjYWxlLCB0aGlzLnogKiBzY2FsZSwgdGhpcy53ICogc2NhbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2ZWN0b3IgXCJyZXN1bHRcIiB3aXRoIHRoZSBjdXJyZW50IFZlY3RvcjQgY29vcmRpbmF0ZXMgbXVsdGlwbGllZCBieSBzY2FsZSAoZmxvYXQpLlxuICAgICAqIEBwYXJhbSBzY2FsZSAtIHRoZSBudW1iZXIgdG8gc2NhbGUgd2l0aFxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBhIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgVmVjdG9yNC5cbiAgICAgKi9cbiAgICBzY2FsZVRvUmVmKHNjYWxlLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnggPSB0aGlzLnggKiBzY2FsZTtcbiAgICAgICAgcmVzdWx0LnkgPSB0aGlzLnkgKiBzY2FsZTtcbiAgICAgICAgcmVzdWx0LnogPSB0aGlzLnogKiBzY2FsZTtcbiAgICAgICAgcmVzdWx0LncgPSB0aGlzLncgKiBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBjdXJyZW50IFZlY3RvcjQgdmFsdWVzIGJ5IGEgZmFjdG9yIGFuZCBhZGQgdGhlIHJlc3VsdCB0byBhIGdpdmVuIFZlY3RvcjRcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsZSBmYWN0b3JcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yNCBvYmplY3Qgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHRoZSB1bm1vZGlmaWVkIGN1cnJlbnQgVmVjdG9yNFxuICAgICAqL1xuICAgIHNjYWxlQW5kQWRkVG9SZWYoc2NhbGUsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCArPSB0aGlzLnggKiBzY2FsZTtcbiAgICAgICAgcmVzdWx0LnkgKz0gdGhpcy55ICogc2NhbGU7XG4gICAgICAgIHJlc3VsdC56ICs9IHRoaXMueiAqIHNjYWxlO1xuICAgICAgICByZXN1bHQudyArPSB0aGlzLncgKiBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJvb2xlYW4gOiBUcnVlIGlmIHRoZSBjdXJyZW50IFZlY3RvcjQgY29vcmRpbmF0ZXMgYXJlIHN0cmljbHkgZXF1YWwgdG8gdGhlIGdpdmVuIG9uZXMuXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gdGhlIHZlY3RvciB0byBjb21wYXJlIGFnYWluc3RcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZXkgYXJlIGVxdWFsXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHJldHVybiAob3RoZXJWZWN0b3IgJiZcbiAgICAgICAgICAgIHRoaXMueCA9PT0gb3RoZXJWZWN0b3IueCAmJlxuICAgICAgICAgICAgdGhpcy55ID09PSBvdGhlclZlY3Rvci55ICYmXG4gICAgICAgICAgICB0aGlzLnogPT09IG90aGVyVmVjdG9yLnogJiZcbiAgICAgICAgICAgIHRoaXMudyA9PT0gb3RoZXJWZWN0b3Iudyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJvb2xlYW4gOiBUcnVlIGlmIHRoZSBjdXJyZW50IFZlY3RvcjQgY29vcmRpbmF0ZXMgYXJlIGVhY2ggYmVuZWF0aCB0aGUgZGlzdGFuY2UgXCJlcHNpbG9uXCIgZnJvbSB0aGUgZ2l2ZW4gdmVjdG9yIG9uZXMuXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gdmVjdG9yIHRvIGNvbXBhcmUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSBlcHNpbG9uIC0gKERlZmF1bHQ6IHZlcnkgc21hbGwgbnVtYmVyKVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhleSBhcmUgZXF1YWxcbiAgICAgKi9cbiAgICBlcXVhbHNXaXRoRXBzaWxvbihvdGhlclZlY3RvciwgZXBzaWxvbiA9IHR5cGVzXzEuRXBzaWxvbikge1xuICAgICAgICByZXR1cm4gKG90aGVyVmVjdG9yICYmXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbih0aGlzLngsIG90aGVyVmVjdG9yLngsIGVwc2lsb24pICYmXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbih0aGlzLnksIG90aGVyVmVjdG9yLnksIGVwc2lsb24pICYmXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbih0aGlzLnosIG90aGVyVmVjdG9yLnosIGVwc2lsb24pICYmXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbih0aGlzLncsIG90aGVyVmVjdG9yLncsIGVwc2lsb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQm9vbGVhbiA6IFRydWUgaWYgdGhlIGdpdmVuIGZsb2F0cyBhcmUgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIGN1cnJlbnQgVmVjdG9yNCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0geCAtIHggdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHkgLSB5IHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB6IC0geiB2YWx1ZSB0byBjb21wYXJlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0gdyAtIHcgdmFsdWUgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBlcXVhbFxuICAgICAqL1xuICAgIGVxdWFsc1RvRmxvYXRzKHgsIHksIHosIHcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0geCAmJiB0aGlzLnkgPT09IHkgJiYgdGhpcy56ID09PSB6ICYmIHRoaXMudyA9PT0gdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBpbiBwbGFjZSB0aGUgY3VycmVudCBWZWN0b3I0IGJ5IHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gdmVjdG9yIHRvIG11bHRpcGxlIHdpdGhcbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBWZWN0b3I0LlxuICAgICAqL1xuICAgIG11bHRpcGx5SW5QbGFjZShvdGhlclZlY3Rvcikge1xuICAgICAgICB0aGlzLnggKj0gb3RoZXJWZWN0b3IueDtcbiAgICAgICAgdGhpcy55ICo9IG90aGVyVmVjdG9yLnk7XG4gICAgICAgIHRoaXMueiAqPSBvdGhlclZlY3Rvci56O1xuICAgICAgICB0aGlzLncgKj0gb3RoZXJWZWN0b3IudztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yNCBzZXQgd2l0aCB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIHRoZSBjdXJyZW50IFZlY3RvcjQgYW5kIHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gdmVjdG9yIHRvIG11bHRpcGxlIHdpdGhcbiAgICAgKiBAcmV0dXJucyByZXN1bHRpbmcgbmV3IHZlY3RvclxuICAgICAqL1xuICAgIG11bHRpcGx5KG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yNCh0aGlzLnggKiBvdGhlclZlY3Rvci54LCB0aGlzLnkgKiBvdGhlclZlY3Rvci55LCB0aGlzLnogKiBvdGhlclZlY3Rvci56LCB0aGlzLncgKiBvdGhlclZlY3Rvci53KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgd2l0aCB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIHRoZSBjdXJyZW50IFZlY3RvcjQgYW5kIHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gdmVjdG9yIHRvIG11bHRpcGxlIHdpdGhcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBWZWN0b3I0LlxuICAgICAqL1xuICAgIG11bHRpcGx5VG9SZWYob3RoZXJWZWN0b3IsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCA9IHRoaXMueCAqIG90aGVyVmVjdG9yLng7XG4gICAgICAgIHJlc3VsdC55ID0gdGhpcy55ICogb3RoZXJWZWN0b3IueTtcbiAgICAgICAgcmVzdWx0LnogPSB0aGlzLnogKiBvdGhlclZlY3Rvci56O1xuICAgICAgICByZXN1bHQudyA9IHRoaXMudyAqIG90aGVyVmVjdG9yLnc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjQgc2V0IHdpdGggdGhlIG11bHRpcGxpY2F0aW9uIHJlc3VsdCBvZiB0aGUgZ2l2ZW4gZmxvYXRzIGFuZCB0aGUgY3VycmVudCBWZWN0b3I0IGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB4IC0geCB2YWx1ZSBtdWx0aXBseSB3aXRoXG4gICAgICogQHBhcmFtIHkgLSB5IHZhbHVlIG11bHRpcGx5IHdpdGhcbiAgICAgKiBAcGFyYW0geiAtIHogdmFsdWUgbXVsdGlwbHkgd2l0aFxuICAgICAqIEBwYXJhbSB3IC0gdyB2YWx1ZSBtdWx0aXBseSB3aXRoXG4gICAgICogQHJldHVybnMgcmVzdWx0aW5nIG5ldyB2ZWN0b3JcbiAgICAgKi9cbiAgICBtdWx0aXBseUJ5RmxvYXRzKHgsIHksIHosIHcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3I0KHRoaXMueCAqIHgsIHRoaXMueSAqIHksIHRoaXMueiAqIHosIHRoaXMudyAqIHcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjQgc2V0IHdpdGggdGhlIGRpdmlzaW9uIHJlc3VsdCBvZiB0aGUgY3VycmVudCBWZWN0b3I0IGJ5IHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gdmVjdG9yIHRvIGRldmlkZSB3aXRoXG4gICAgICogQHJldHVybnMgcmVzdWx0aW5nIG5ldyB2ZWN0b3JcbiAgICAgKi9cbiAgICBkaXZpZGUob3RoZXJWZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3I0KHRoaXMueCAvIG90aGVyVmVjdG9yLngsIHRoaXMueSAvIG90aGVyVmVjdG9yLnksIHRoaXMueiAvIG90aGVyVmVjdG9yLnosIHRoaXMudyAvIG90aGVyVmVjdG9yLncpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiB2ZWN0b3IgXCJyZXN1bHRcIiB3aXRoIHRoZSBkaXZpc2lvbiByZXN1bHQgb2YgdGhlIGN1cnJlbnQgVmVjdG9yNCBieSB0aGUgZ2l2ZW4gb25lLlxuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIHZlY3RvciB0byBkZXZpZGUgd2l0aFxuICAgICAqIEBwYXJhbSByZXN1bHQgLSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IFZlY3RvcjQuXG4gICAgICovXG4gICAgZGl2aWRlVG9SZWYob3RoZXJWZWN0b3IsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCA9IHRoaXMueCAvIG90aGVyVmVjdG9yLng7XG4gICAgICAgIHJlc3VsdC55ID0gdGhpcy55IC8gb3RoZXJWZWN0b3IueTtcbiAgICAgICAgcmVzdWx0LnogPSB0aGlzLnogLyBvdGhlclZlY3Rvci56O1xuICAgICAgICByZXN1bHQudyA9IHRoaXMudyAvIG90aGVyVmVjdG9yLnc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoZSBjdXJyZW50IFZlY3RvcjMgY29vcmRpbmF0ZXMgYnkgdGhlIGdpdmVuIG9uZXMuXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gdmVjdG9yIHRvIGRldmlkZSB3aXRoXG4gICAgICogQHJldHVybnMgdGhlIHVwZGF0ZWQgVmVjdG9yMy5cbiAgICAgKi9cbiAgICBkaXZpZGVJblBsYWNlKG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVRvUmVmKG90aGVyVmVjdG9yLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgVmVjdG9yNCBjb29yZGluYXRlcyB3aXRoIHRoZSBtaW5pbXVtIHZhbHVlcyBiZXR3ZWVuIGl0cyBvd24gYW5kIHRoZSBnaXZlbiB2ZWN0b3Igb25lc1xuICAgICAqIEBwYXJhbSBvdGhlciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBWZWN0b3I0XG4gICAgICovXG4gICAgbWluaW1pemVJblBsYWNlKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci54IDwgdGhpcy54KSB7XG4gICAgICAgICAgICB0aGlzLnggPSBvdGhlci54O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci55IDwgdGhpcy55KSB7XG4gICAgICAgICAgICB0aGlzLnkgPSBvdGhlci55O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci56IDwgdGhpcy56KSB7XG4gICAgICAgICAgICB0aGlzLnogPSBvdGhlci56O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci53IDwgdGhpcy53KSB7XG4gICAgICAgICAgICB0aGlzLncgPSBvdGhlci53O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBWZWN0b3I0IGNvb3JkaW5hdGVzIHdpdGggdGhlIG1heGltdW0gdmFsdWVzIGJldHdlZW4gaXRzIG93biBhbmQgdGhlIGdpdmVuIHZlY3RvciBvbmVzXG4gICAgICogQHBhcmFtIG90aGVyIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjRcbiAgICAgKi9cbiAgICBtYXhpbWl6ZUluUGxhY2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLnggPiB0aGlzLngpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyLnkgPiB0aGlzLnkpIHtcbiAgICAgICAgICAgIHRoaXMueSA9IG90aGVyLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyLnogPiB0aGlzLnopIHtcbiAgICAgICAgICAgIHRoaXMueiA9IG90aGVyLno7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyLncgPiB0aGlzLncpIHtcbiAgICAgICAgICAgIHRoaXMudyA9IG90aGVyLnc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgVmVjdG9yNCBmcm9tIGN1cnJlbnQgVmVjdG9yNCBmbG9vcmVkIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjRcbiAgICAgKi9cbiAgICBmbG9vcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3I0KE1hdGguZmxvb3IodGhpcy54KSwgTWF0aC5mbG9vcih0aGlzLnkpLCBNYXRoLmZsb29yKHRoaXMueiksIE1hdGguZmxvb3IodGhpcy53KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgVmVjdG9yNCBmcm9tIGN1cnJlbnQgVmVjdG9yMyBmbG9vcmVkIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjRcbiAgICAgKi9cbiAgICBmcmFjdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3I0KHRoaXMueCAtIE1hdGguZmxvb3IodGhpcy54KSwgdGhpcy55IC0gTWF0aC5mbG9vcih0aGlzLnkpLCB0aGlzLnogLSBNYXRoLmZsb29yKHRoaXMueiksIHRoaXMudyAtIE1hdGguZmxvb3IodGhpcy53KSk7XG4gICAgfVxuICAgIC8vIFByb3BlcnRpZXNcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBWZWN0b3I0IGxlbmd0aCAoZmxvYXQpLlxuICAgICAqIEByZXR1cm5zIHRoZSBsZW5ndGhcbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVmVjdG9yNCBzcXVhcmVkIGxlbmd0aCAoZmxvYXQpLlxuICAgICAqIEByZXR1cm5zIHRoZSBsZW5ndGggc3F1YXJlZFxuICAgICAqL1xuICAgIGxlbmd0aFNxdWFyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG4gICAgfVxuICAgIC8vIE1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIGluIHBsYWNlIHRoZSBWZWN0b3I0LlxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIFZlY3RvcjQuXG4gICAgICovXG4gICAgbm9ybWFsaXplKCkge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZUluUGxhY2UoMS4wIC8gbGVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIGZyb20gdGhlIFZlY3RvcjQgKHgsIHksIHopIGNvb3JkaW5hdGVzLlxuICAgICAqIEByZXR1cm5zIHRoaXMgY29udmVydGVkIHRvIGEgbmV3IHZlY3RvcjNcbiAgICAgKi9cbiAgICB0b1ZlY3RvcjMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yM18xLlZlY3RvcjModGhpcy54LCB0aGlzLnksIHRoaXMueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yNCBjb3BpZWQgZnJvbSB0aGUgY3VycmVudCBvbmUuXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBjbG9uZWQgdmVjdG9yXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yNCh0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IFZlY3RvcjQgd2l0aCB0aGUgZ2l2ZW4gb25lIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSB0aGUgc291cmNlIHZlY3RvciB0byBjb3B5IGZyb21cbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBWZWN0b3I0LlxuICAgICAqL1xuICAgIGNvcHlGcm9tKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnggPSBzb3VyY2UueDtcbiAgICAgICAgdGhpcy55ID0gc291cmNlLnk7XG4gICAgICAgIHRoaXMueiA9IHNvdXJjZS56O1xuICAgICAgICB0aGlzLncgPSBzb3VyY2UudztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgVmVjdG9yNCBjb29yZGluYXRlcyB3aXRoIHRoZSBnaXZlbiBmbG9hdHMuXG4gICAgICogQHBhcmFtIHggLSBmbG9hdCB0byBjb3B5IGZyb21cbiAgICAgKiBAcGFyYW0geSAtIGZsb2F0IHRvIGNvcHkgZnJvbVxuICAgICAqIEBwYXJhbSB6IC0gZmxvYXQgdG8gY29weSBmcm9tXG4gICAgICogQHBhcmFtIHcgLSBmbG9hdCB0byBjb3B5IGZyb21cbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBWZWN0b3I0LlxuICAgICAqL1xuICAgIGNvcHlGcm9tRmxvYXRzKHgsIHksIHosIHcpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgVmVjdG9yNCBjb29yZGluYXRlcyB3aXRoIHRoZSBnaXZlbiBmbG9hdHMuXG4gICAgICogQHBhcmFtIHggLSBmbG9hdCB0byBzZXQgZnJvbVxuICAgICAqIEBwYXJhbSB5IC0gZmxvYXQgdG8gc2V0IGZyb21cbiAgICAgKiBAcGFyYW0geiAtIGZsb2F0IHRvIHNldCBmcm9tXG4gICAgICogQHBhcmFtIHcgLSBmbG9hdCB0byBzZXQgZnJvbVxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIFZlY3RvcjQuXG4gICAgICovXG4gICAgc2V0KHgsIHksIHosIHcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weUZyb21GbG9hdHMoeCwgeSwgeiwgdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgZ2l2ZW4gZmxvYXQgdG8gdGhlIGN1cnJlbnQgVmVjdG9yMyBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB2IC0gZGVmaW5lcyB0aGUgeCwgeSwgeiBhbmQgdyBjb29yZGluYXRlcyBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgVmVjdG9yM1xuICAgICAqL1xuICAgIHNldEFsbCh2KSB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IHRoaXMudyA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuVmVjdG9yNCA9IFZlY3RvcjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3I0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXRyaXggPSB2b2lkIDA7XG5jb25zdCBWZWN0b3IzXzEgPSByZXF1aXJlKFwiLi9WZWN0b3IzXCIpO1xuY29uc3QgUXVhdGVybmlvbl8xID0gcmVxdWlyZShcIi4vUXVhdGVybmlvblwiKTtcbmNvbnN0IHByZWFsbG9jYXRlZFZhcmlhYmxlc18xID0gcmVxdWlyZShcIi4vcHJlYWxsb2NhdGVkVmFyaWFibGVzXCIpO1xuY29uc3QgVmVjdG9yNF8xID0gcmVxdWlyZShcIi4vVmVjdG9yNFwiKTtcbi8qKlxuICogQ2xhc3MgdXNlZCB0byBzdG9yZSBtYXRyaXggZGF0YSAoNHg0KVxuICogQHB1YmxpY1xuICovXG5jbGFzcyBNYXRyaXgge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgbWF0cml4IChmaWxsZWQgd2l0aCB6ZXJvcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faXNJZGVudGl0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0lkZW50aXR5RGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pc0lkZW50aXR5M3gyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNJZGVudGl0eTN4MkRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbSA9IFtcbiAgICAgICAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fdXBkYXRlSWRlbnRpdHlTdGF0dXMoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbnRlcm5hbCBkYXRhIG9mIHRoZSBtYXRyaXhcbiAgICAgKi9cbiAgICBnZXQgbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX207XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gaWRlbnRpdHkgbWF0cml4IHRoYXQgbXVzdCBub3QgYmUgdXBkYXRlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgSWRlbnRpdHlSZWFkT25seSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdHJpeC5faWRlbnRpdHlSZWFkT25seTtcbiAgICB9XG4gICAgLy8gU3RhdGljc1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhbiBhcnJheVxuICAgICAqIEBwYXJhbSBhcnJheSAtIGRlZmluZXMgdGhlIHNvdXJjZSBhcnJheVxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBkZWZpbmVzIGFuIG9mZnNldCBpbiB0aGUgc291cmNlIGFycmF5XG4gICAgICogQHJldHVybnMgYSBuZXcgTWF0cml4IHNldCBmcm9tIHRoZSBzdGFydGluZyBpbmRleCBvZiB0aGUgZ2l2ZW4gYXJyYXlcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgTWF0cml4LkZyb21BcnJheVRvUmVmKGFycmF5LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgdGhlIGNvbnRlbnQgb2YgYW4gYXJyYXkgaW50byBhIGdpdmVuIG1hdHJpeFxuICAgICAqIEBwYXJhbSBhcnJheSAtIGRlZmluZXMgdGhlIHNvdXJjZSBhcnJheVxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBkZWZpbmVzIGFuIG9mZnNldCBpbiB0aGUgc291cmNlIGFycmF5XG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbUFycmF5VG9SZWYoYXJyYXksIG9mZnNldCwgcmVzdWx0KSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCAxNjsgaW5kZXgrKykge1xuICAgICAgICAgICAgcmVzdWx0Ll9tW2luZGV4XSA9IGFycmF5W2luZGV4ICsgb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuX21hcmtBc1VwZGF0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmVzIGFuIGFycmF5IGludG8gYSBtYXRyaXggYWZ0ZXIgaGF2aW5nIG11bHRpcGxpZWQgZWFjaCBjb21wb25lbnQgYnkgYSBnaXZlbiBmYWN0b3JcbiAgICAgKiBAcGFyYW0gYXJyYXkgLSBkZWZpbmVzIHRoZSBzb3VyY2UgYXJyYXlcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSBzb3VyY2UgYXJyYXlcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsaW5nIGZhY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIEZyb21GbG9hdEFycmF5VG9SZWZTY2FsZWQoYXJyYXksIG9mZnNldCwgc2NhbGUsIHJlc3VsdCkge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgMTY7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5fbVtpbmRleF0gPSBhcnJheVtpbmRleCArIG9mZnNldF0gKiBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuX21hcmtBc1VwZGF0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmVzIGEgbGlzdCBvZiB2YWx1ZXMgKDE2KSBpbnNpZGUgYSBnaXZlbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0xMSAtIGRlZmluZXMgMXN0IHZhbHVlIG9mIDFzdCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0xMiAtIGRlZmluZXMgMm5kIHZhbHVlIG9mIDFzdCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0xMyAtIGRlZmluZXMgM3JkIHZhbHVlIG9mIDFzdCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0xNCAtIGRlZmluZXMgNHRoIHZhbHVlIG9mIDFzdCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0yMSAtIGRlZmluZXMgMXN0IHZhbHVlIG9mIDJuZCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0yMiAtIGRlZmluZXMgMm5kIHZhbHVlIG9mIDJuZCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0yMyAtIGRlZmluZXMgM3JkIHZhbHVlIG9mIDJuZCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0yNCAtIGRlZmluZXMgNHRoIHZhbHVlIG9mIDJuZCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0zMSAtIGRlZmluZXMgMXN0IHZhbHVlIG9mIDNyZCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0zMiAtIGRlZmluZXMgMm5kIHZhbHVlIG9mIDNyZCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0zMyAtIGRlZmluZXMgM3JkIHZhbHVlIG9mIDNyZCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE0zNCAtIGRlZmluZXMgNHRoIHZhbHVlIG9mIDNyZCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE00MSAtIGRlZmluZXMgMXN0IHZhbHVlIG9mIDR0aCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE00MiAtIGRlZmluZXMgMm5kIHZhbHVlIG9mIDR0aCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE00MyAtIGRlZmluZXMgM3JkIHZhbHVlIG9mIDR0aCByb3dcbiAgICAgKiBAcGFyYW0gaW5pdGlhbE00NCAtIGRlZmluZXMgNHRoIHZhbHVlIG9mIDR0aCByb3dcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tVmFsdWVzVG9SZWYoaW5pdGlhbE0xMSwgaW5pdGlhbE0xMiwgaW5pdGlhbE0xMywgaW5pdGlhbE0xNCwgaW5pdGlhbE0yMSwgaW5pdGlhbE0yMiwgaW5pdGlhbE0yMywgaW5pdGlhbE0yNCwgaW5pdGlhbE0zMSwgaW5pdGlhbE0zMiwgaW5pdGlhbE0zMywgaW5pdGlhbE0zNCwgaW5pdGlhbE00MSwgaW5pdGlhbE00MiwgaW5pdGlhbE00MywgaW5pdGlhbE00NCwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IG0gPSByZXN1bHQuX207XG4gICAgICAgIG1bMF0gPSBpbml0aWFsTTExO1xuICAgICAgICBtWzFdID0gaW5pdGlhbE0xMjtcbiAgICAgICAgbVsyXSA9IGluaXRpYWxNMTM7XG4gICAgICAgIG1bM10gPSBpbml0aWFsTTE0O1xuICAgICAgICBtWzRdID0gaW5pdGlhbE0yMTtcbiAgICAgICAgbVs1XSA9IGluaXRpYWxNMjI7XG4gICAgICAgIG1bNl0gPSBpbml0aWFsTTIzO1xuICAgICAgICBtWzddID0gaW5pdGlhbE0yNDtcbiAgICAgICAgbVs4XSA9IGluaXRpYWxNMzE7XG4gICAgICAgIG1bOV0gPSBpbml0aWFsTTMyO1xuICAgICAgICBtWzEwXSA9IGluaXRpYWxNMzM7XG4gICAgICAgIG1bMTFdID0gaW5pdGlhbE0zNDtcbiAgICAgICAgbVsxMl0gPSBpbml0aWFsTTQxO1xuICAgICAgICBtWzEzXSA9IGluaXRpYWxNNDI7XG4gICAgICAgIG1bMTRdID0gaW5pdGlhbE00MztcbiAgICAgICAgbVsxNV0gPSBpbml0aWFsTTQ0O1xuICAgICAgICByZXN1bHQuX21hcmtBc1VwZGF0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgbWF0cml4IGZyb20gYSBsaXN0IG9mIHZhbHVlcyAoMTYpXG4gICAgICogQHBhcmFtIGluaXRpYWxNMTEgLSBkZWZpbmVzIDFzdCB2YWx1ZSBvZiAxc3Qgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMTIgLSBkZWZpbmVzIDJuZCB2YWx1ZSBvZiAxc3Qgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMTMgLSBkZWZpbmVzIDNyZCB2YWx1ZSBvZiAxc3Qgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMTQgLSBkZWZpbmVzIDR0aCB2YWx1ZSBvZiAxc3Qgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMjEgLSBkZWZpbmVzIDFzdCB2YWx1ZSBvZiAybmQgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMjIgLSBkZWZpbmVzIDJuZCB2YWx1ZSBvZiAybmQgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMjMgLSBkZWZpbmVzIDNyZCB2YWx1ZSBvZiAybmQgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMjQgLSBkZWZpbmVzIDR0aCB2YWx1ZSBvZiAybmQgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMzEgLSBkZWZpbmVzIDFzdCB2YWx1ZSBvZiAzcmQgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMzIgLSBkZWZpbmVzIDJuZCB2YWx1ZSBvZiAzcmQgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMzMgLSBkZWZpbmVzIDNyZCB2YWx1ZSBvZiAzcmQgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNMzQgLSBkZWZpbmVzIDR0aCB2YWx1ZSBvZiAzcmQgcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNNDEgLSBkZWZpbmVzIDFzdCB2YWx1ZSBvZiA0dGggcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNNDIgLSBkZWZpbmVzIDJuZCB2YWx1ZSBvZiA0dGggcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNNDMgLSBkZWZpbmVzIDNyZCB2YWx1ZSBvZiA0dGggcm93XG4gICAgICogQHBhcmFtIGluaXRpYWxNNDQgLSBkZWZpbmVzIDR0aCB2YWx1ZSBvZiA0dGggcm93XG4gICAgICogQHJldHVybnMgdGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbVZhbHVlcyhpbml0aWFsTTExLCBpbml0aWFsTTEyLCBpbml0aWFsTTEzLCBpbml0aWFsTTE0LCBpbml0aWFsTTIxLCBpbml0aWFsTTIyLCBpbml0aWFsTTIzLCBpbml0aWFsTTI0LCBpbml0aWFsTTMxLCBpbml0aWFsTTMyLCBpbml0aWFsTTMzLCBpbml0aWFsTTM0LCBpbml0aWFsTTQxLCBpbml0aWFsTTQyLCBpbml0aWFsTTQzLCBpbml0aWFsTTQ0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgY29uc3QgbSA9IHJlc3VsdC5fbTtcbiAgICAgICAgbVswXSA9IGluaXRpYWxNMTE7XG4gICAgICAgIG1bMV0gPSBpbml0aWFsTTEyO1xuICAgICAgICBtWzJdID0gaW5pdGlhbE0xMztcbiAgICAgICAgbVszXSA9IGluaXRpYWxNMTQ7XG4gICAgICAgIG1bNF0gPSBpbml0aWFsTTIxO1xuICAgICAgICBtWzVdID0gaW5pdGlhbE0yMjtcbiAgICAgICAgbVs2XSA9IGluaXRpYWxNMjM7XG4gICAgICAgIG1bN10gPSBpbml0aWFsTTI0O1xuICAgICAgICBtWzhdID0gaW5pdGlhbE0zMTtcbiAgICAgICAgbVs5XSA9IGluaXRpYWxNMzI7XG4gICAgICAgIG1bMTBdID0gaW5pdGlhbE0zMztcbiAgICAgICAgbVsxMV0gPSBpbml0aWFsTTM0O1xuICAgICAgICBtWzEyXSA9IGluaXRpYWxNNDE7XG4gICAgICAgIG1bMTNdID0gaW5pdGlhbE00MjtcbiAgICAgICAgbVsxNF0gPSBpbml0aWFsTTQzO1xuICAgICAgICBtWzE1XSA9IGluaXRpYWxNNDQ7XG4gICAgICAgIHJlc3VsdC5fbWFya0FzVXBkYXRlZCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1hdHJpeCBjb21wb3NlZCBieSBtZXJnaW5nIHNjYWxlICh2ZWN0b3IzKSwgcm90YXRpb24gKHF1YXRlcm5pb24pIGFuZCB0cmFuc2xhdGlvbiAodmVjdG9yMylcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsZSB2ZWN0b3IzXG4gICAgICogQHBhcmFtIHJvdGF0aW9uIC0gZGVmaW5lcyB0aGUgcm90YXRpb24gcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiAtIGRlZmluZXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvcjNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgQ29tcG9zZShzY2FsZSwgcm90YXRpb24sIHRyYW5zbGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgTWF0cml4LkNvbXBvc2VUb1JlZihzY2FsZSwgcm90YXRpb24sIHRyYW5zbGF0aW9uLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbWF0cml4IHRvIGEgdmFsdWUgY29tcG9zZWQgYnkgbWVyZ2luZyBzY2FsZSAodmVjdG9yMyksIHJvdGF0aW9uIChxdWF0ZXJuaW9uKSBhbmQgdHJhbnNsYXRpb24gKHZlY3RvcjMpXG4gICAgICogQHBhcmFtIHNjYWxlIC0gZGVmaW5lcyB0aGUgc2NhbGUgdmVjdG9yM1xuICAgICAqIEBwYXJhbSByb3RhdGlvbiAtIGRlZmluZXMgdGhlIHJvdGF0aW9uIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gdHJhbnNsYXRpb24gLSBkZWZpbmVzIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IzXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgQ29tcG9zZVRvUmVmKHNjYWxlLCByb3RhdGlvbiwgdHJhbnNsYXRpb24sIHJlc3VsdCkge1xuICAgICAgICBNYXRyaXguU2NhbGluZ1RvUmVmKHNjYWxlLngsIHNjYWxlLnksIHNjYWxlLnosIHByZWFsbG9jYXRlZFZhcmlhYmxlc18xLk1hdGhUbXAuTWF0cml4WzFdKTtcbiAgICAgICAgcm90YXRpb24udG9Sb3RhdGlvbk1hdHJpeChwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLk1hdHJpeFswXSk7XG4gICAgICAgIHByZWFsbG9jYXRlZFZhcmlhYmxlc18xLk1hdGhUbXAuTWF0cml4WzFdLm11bHRpcGx5VG9SZWYocHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5NYXRyaXhbMF0sIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5zZXRUcmFuc2xhdGlvbih0cmFuc2xhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0cml4XG4gICAgICogQHJldHVybnMgYSBuZXcgaWRlbnRpdHkgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIElkZW50aXR5KCkge1xuICAgICAgICBjb25zdCBpZGVudGl0eSA9IE1hdHJpeC5Gcm9tVmFsdWVzKDEuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgIGlkZW50aXR5Ll91cGRhdGVJZGVudGl0eVN0YXR1cyh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdHJpeCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gYSBnaXZlbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBJZGVudGl0eVRvUmVmKHJlc3VsdCkge1xuICAgICAgICBNYXRyaXguRnJvbVZhbHVlc1RvUmVmKDEuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDEuMCwgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0Ll91cGRhdGVJZGVudGl0eVN0YXR1cyh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB6ZXJvIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIGEgbmV3IHplcm8gbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIFplcm8oKSB7XG4gICAgICAgIGNvbnN0IHplcm8gPSBNYXRyaXguRnJvbVZhbHVlcygwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICB6ZXJvLl91cGRhdGVJZGVudGl0eVN0YXR1cyhmYWxzZSk7XG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJvdGF0aW9uIG1hdHJpeCBmb3IgXCJhbmdsZVwiIHJhZGlhbnMgYXJvdW5kIHRoZSBYIGF4aXNcbiAgICAgKiBAcGFyYW0gYW5nbGUgLSBkZWZpbmVzIHRoZSBhbmdsZSAoaW4gcmFkaWFucykgdG8gdXNlXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgUm90YXRpb25YKGFuZ2xlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgTWF0cml4LlJvdGF0aW9uWFRvUmVmKGFuZ2xlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1hdHJpeCBhcyB0aGUgaW52ZXJ0IG9mIGEgZ2l2ZW4gbWF0cml4XG4gICAgICogQHBhcmFtIHNvdXJjZSAtIGRlZmluZXMgdGhlIHNvdXJjZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBJbnZlcnQoc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgc291cmNlLmludmVydFRvUmVmKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcm90YXRpb24gbWF0cml4IGZvciBcImFuZ2xlXCIgcmFkaWFucyBhcm91bmQgdGhlIFggYXhpcyBhbmQgc3RvcmVzIGl0IGluIGEgZ2l2ZW4gbWF0cml4XG4gICAgICogQHBhcmFtIGFuZ2xlIC0gZGVmaW5lcyB0aGUgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHVzZVxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIFJvdGF0aW9uWFRvUmVmKGFuZ2xlLCByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZigxLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgYywgcywgMC4wLCAwLjAsIC1zLCBjLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDEuMCwgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0Ll91cGRhdGVJZGVudGl0eVN0YXR1cyhjID09PSAxICYmIHMgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJvdGF0aW9uIG1hdHJpeCBmb3IgXCJhbmdsZVwiIHJhZGlhbnMgYXJvdW5kIHRoZSBZIGF4aXNcbiAgICAgKiBAcGFyYW0gYW5nbGUgLSBkZWZpbmVzIHRoZSBhbmdsZSAoaW4gcmFkaWFucykgdG8gdXNlXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgUm90YXRpb25ZKGFuZ2xlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgTWF0cml4LlJvdGF0aW9uWVRvUmVmKGFuZ2xlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJvdGF0aW9uIG1hdHJpeCBmb3IgXCJhbmdsZVwiIHJhZGlhbnMgYXJvdW5kIHRoZSBZIGF4aXMgYW5kIHN0b3JlcyBpdCBpbiBhIGdpdmVuIG1hdHJpeFxuICAgICAqIEBwYXJhbSBhbmdsZSAtIGRlZmluZXMgdGhlIGFuZ2xlIChpbiByYWRpYW5zKSB0byB1c2VcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBSb3RhdGlvbllUb1JlZihhbmdsZSwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIE1hdHJpeC5Gcm9tVmFsdWVzVG9SZWYoYywgMC4wLCAtcywgMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIHMsIDAuMCwgYywgMC4wLCAwLjAsIDAuMCwgMC4wLCAxLjAsIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5fdXBkYXRlSWRlbnRpdHlTdGF0dXMoYyA9PT0gMSAmJiBzID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByb3RhdGlvbiBtYXRyaXggZm9yIFwiYW5nbGVcIiByYWRpYW5zIGFyb3VuZCB0aGUgWiBheGlzXG4gICAgICogQHBhcmFtIGFuZ2xlIC0gZGVmaW5lcyB0aGUgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIFJvdGF0aW9uWihhbmdsZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIE1hdHJpeC5Sb3RhdGlvblpUb1JlZihhbmdsZSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByb3RhdGlvbiBtYXRyaXggZm9yIFwiYW5nbGVcIiByYWRpYW5zIGFyb3VuZCB0aGUgWiBheGlzIGFuZCBzdG9yZXMgaXQgaW4gYSBnaXZlbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gYW5nbGUgLSBkZWZpbmVzIHRoZSBhbmdsZSAoaW4gcmFkaWFucykgdG8gdXNlXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgUm90YXRpb25aVG9SZWYoYW5nbGUsIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBNYXRyaXguRnJvbVZhbHVlc1RvUmVmKGMsIHMsIDAuMCwgMC4wLCAtcywgYywgMC4wLCAwLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMS4wLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQuX3VwZGF0ZUlkZW50aXR5U3RhdHVzKGMgPT09IDEgJiYgcyA9PT0gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcm90YXRpb24gbWF0cml4IGZvciBcImFuZ2xlXCIgcmFkaWFucyBhcm91bmQgdGhlIGdpdmVuIGF4aXNcbiAgICAgKiBAcGFyYW0gYXhpcyAtIGRlZmluZXMgdGhlIGF4aXMgdG8gdXNlXG4gICAgICogQHBhcmFtIGFuZ2xlIC0gZGVmaW5lcyB0aGUgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHVzZVxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIFJvdGF0aW9uQXhpcyhheGlzLCBhbmdsZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIE1hdHJpeC5Sb3RhdGlvbkF4aXNUb1JlZihheGlzLCBhbmdsZSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByb3RhdGlvbiBtYXRyaXggZm9yIFwiYW5nbGVcIiByYWRpYW5zIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpcyBhbmQgc3RvcmVzIGl0IGluIGEgZ2l2ZW4gbWF0cml4XG4gICAgICogQHBhcmFtIGF4aXMgLSBkZWZpbmVzIHRoZSBheGlzIHRvIHVzZVxuICAgICAqIEBwYXJhbSBhbmdsZSAtIGRlZmluZXMgdGhlIGFuZ2xlIChpbiByYWRpYW5zKSB0byB1c2VcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBSb3RhdGlvbkF4aXNUb1JlZihheGlzLCBhbmdsZSwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICAgICAgY29uc3QgYzEgPSAxIC0gYztcbiAgICAgICAgYXhpcy5ub3JtYWxpemUoKTtcbiAgICAgICAgY29uc3QgbSA9IHJlc3VsdC5fbTtcbiAgICAgICAgbVswXSA9IGF4aXMueCAqIGF4aXMueCAqIGMxICsgYztcbiAgICAgICAgbVsxXSA9IGF4aXMueCAqIGF4aXMueSAqIGMxIC0gYXhpcy56ICogcztcbiAgICAgICAgbVsyXSA9IGF4aXMueCAqIGF4aXMueiAqIGMxICsgYXhpcy55ICogcztcbiAgICAgICAgbVszXSA9IDAuMDtcbiAgICAgICAgbVs0XSA9IGF4aXMueSAqIGF4aXMueCAqIGMxICsgYXhpcy56ICogcztcbiAgICAgICAgbVs1XSA9IGF4aXMueSAqIGF4aXMueSAqIGMxICsgYztcbiAgICAgICAgbVs2XSA9IGF4aXMueSAqIGF4aXMueiAqIGMxIC0gYXhpcy54ICogcztcbiAgICAgICAgbVs3XSA9IDAuMDtcbiAgICAgICAgbVs4XSA9IGF4aXMueiAqIGF4aXMueCAqIGMxIC0gYXhpcy55ICogcztcbiAgICAgICAgbVs5XSA9IGF4aXMueiAqIGF4aXMueSAqIGMxICsgYXhpcy54ICogcztcbiAgICAgICAgbVsxMF0gPSBheGlzLnogKiBheGlzLnogKiBjMSArIGM7XG4gICAgICAgIG1bMTFdID0gMC4wO1xuICAgICAgICBtWzEyXSA9IDAuMDtcbiAgICAgICAgbVsxM10gPSAwLjA7XG4gICAgICAgIG1bMTRdID0gMC4wO1xuICAgICAgICBtWzE1XSA9IDEuMDtcbiAgICAgICAgcmVzdWx0Ll9tYXJrQXNVcGRhdGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByb3RhdGlvbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0geWF3IC0gZGVmaW5lcyB0aGUgeWF3IGFuZ2xlIGluIHJhZGlhbnMgKFkgYXhpcylcbiAgICAgKiBAcGFyYW0gcGl0Y2ggLSBkZWZpbmVzIHRoZSBwaXRjaCBhbmdsZSBpbiByYWRpYW5zIChYIGF4aXMpXG4gICAgICogQHBhcmFtIHJvbGwgLSBkZWZpbmVzIHRoZSByb2xsIGFuZ2xlIGluIHJhZGlhbnMgKFggYXhpcylcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IHJvdGF0aW9uIG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBSb3RhdGlvbllhd1BpdGNoUm9sbCh5YXcsIHBpdGNoLCByb2xsKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgTWF0cml4LlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWYoeWF3LCBwaXRjaCwgcm9sbCwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJvdGF0aW9uIG1hdHJpeCBhbmQgc3RvcmVzIGl0IGluIGEgZ2l2ZW4gbWF0cml4XG4gICAgICogQHBhcmFtIHlhdyAtIGRlZmluZXMgdGhlIHlhdyBhbmdsZSBpbiByYWRpYW5zIChZIGF4aXMpXG4gICAgICogQHBhcmFtIHBpdGNoIC0gZGVmaW5lcyB0aGUgcGl0Y2ggYW5nbGUgaW4gcmFkaWFucyAoWCBheGlzKVxuICAgICAqIEBwYXJhbSByb2xsIC0gZGVmaW5lcyB0aGUgcm9sbCBhbmdsZSBpbiByYWRpYW5zIChYIGF4aXMpXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih5YXcsIHBpdGNoLCByb2xsLCByZXN1bHQpIHtcbiAgICAgICAgUXVhdGVybmlvbl8xLlF1YXRlcm5pb24uUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih5YXcsIHBpdGNoLCByb2xsLCBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLlF1YXRlcm5pb25bMF0pO1xuICAgICAgICBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLlF1YXRlcm5pb25bMF0udG9Sb3RhdGlvbk1hdHJpeChyZXN1bHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2NhbGluZyBtYXRyaXhcbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZXMgdGhlIHNjYWxlIGZhY3RvciBvbiBYIGF4aXNcbiAgICAgKiBAcGFyYW0geSAtIGRlZmluZXMgdGhlIHNjYWxlIGZhY3RvciBvbiBZIGF4aXNcbiAgICAgKiBAcGFyYW0geiAtIGRlZmluZXMgdGhlIHNjYWxlIGZhY3RvciBvbiBaIGF4aXNcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBTY2FsaW5nKHgsIHksIHopIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBNYXRyaXguU2NhbGluZ1RvUmVmKHgsIHksIHosIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzY2FsaW5nIG1hdHJpeCBhbmQgc3RvcmVzIGl0IGluIGEgZ2l2ZW4gbWF0cml4XG4gICAgICogQHBhcmFtIHggLSBkZWZpbmVzIHRoZSBzY2FsZSBmYWN0b3Igb24gWCBheGlzXG4gICAgICogQHBhcmFtIHkgLSBkZWZpbmVzIHRoZSBzY2FsZSBmYWN0b3Igb24gWSBheGlzXG4gICAgICogQHBhcmFtIHogLSBkZWZpbmVzIHRoZSBzY2FsZSBmYWN0b3Igb24gWiBheGlzXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgU2NhbGluZ1RvUmVmKHgsIHksIHosIHJlc3VsdCkge1xuICAgICAgICBNYXRyaXguRnJvbVZhbHVlc1RvUmVmKHgsIDAuMCwgMC4wLCAwLjAsIDAuMCwgeSwgMC4wLCAwLjAsIDAuMCwgMC4wLCB6LCAwLjAsIDAuMCwgMC4wLCAwLjAsIDEuMCwgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0Ll91cGRhdGVJZGVudGl0eVN0YXR1cyh4ID09PSAxICYmIHkgPT09IDEgJiYgeiA9PT0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0cmFuc2xhdGlvbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZXMgdGhlIHRyYW5zbGF0aW9uIG9uIFggYXhpc1xuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgdHJhbnNsYXRpb24gb24gWSBheGlzXG4gICAgICogQHBhcmFtIHogLSBkZWZpbmVzIHRoZSB0cmFuc2xhdGlvbm9uIFogYXhpc1xuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIFRyYW5zbGF0aW9uKHgsIHksIHopIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBNYXRyaXguVHJhbnNsYXRpb25Ub1JlZih4LCB5LCB6LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHJhbnNsYXRpb24gbWF0cml4IGFuZCBzdG9yZXMgaXQgaW4gYSBnaXZlbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZXMgdGhlIHRyYW5zbGF0aW9uIG9uIFggYXhpc1xuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgdHJhbnNsYXRpb24gb24gWSBheGlzXG4gICAgICogQHBhcmFtIHogLSBkZWZpbmVzIHRoZSB0cmFuc2xhdGlvbm9uIFogYXhpc1xuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIFRyYW5zbGF0aW9uVG9SZWYoeCwgeSwgeiwgcmVzdWx0KSB7XG4gICAgICAgIE1hdHJpeC5Gcm9tVmFsdWVzVG9SZWYoMS4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgeCwgeSwgeiwgMS4wLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQuX3VwZGF0ZUlkZW50aXR5U3RhdHVzKHggPT09IDAgJiYgeSA9PT0gMCAmJiB6ID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBNYXRyaXggd2hvc2UgdmFsdWVzIGFyZSB0aGUgaW50ZXJwb2xhdGVkIHZhbHVlcyBmb3IgXCJncmFkaWVudFwiIChmbG9hdCkgYmV0d2VlbiB0aGUgb25lcyBvZiB0aGUgbWF0cmljZXMgXCJzdGFydFZhbHVlXCIgYW5kIFwiZW5kVmFsdWVcIi5cbiAgICAgKiBAcGFyYW0gc3RhcnRWYWx1ZSAtIGRlZmluZXMgdGhlIHN0YXJ0IHZhbHVlXG4gICAgICogQHBhcmFtIGVuZFZhbHVlIC0gZGVmaW5lcyB0aGUgZW5kIHZhbHVlXG4gICAgICogQHBhcmFtIGdyYWRpZW50IC0gZGVmaW5lcyB0aGUgZ3JhZGllbnQgZmFjdG9yXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgTGVycChzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZ3JhZGllbnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBNYXRyaXguTGVycFRvUmVmKHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBncmFkaWVudCwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBnaXZlbiBtYXRyaXggXCJyZXN1bHRcIiBhcyB0aGUgaW50ZXJwb2xhdGVkIHZhbHVlcyBmb3IgXCJncmFkaWVudFwiIChmbG9hdCkgYmV0d2VlbiB0aGUgb25lcyBvZiB0aGUgbWF0cmljZXMgXCJzdGFydFZhbHVlXCIgYW5kIFwiZW5kVmFsdWVcIi5cbiAgICAgKiBAcGFyYW0gc3RhcnRWYWx1ZSAtIGRlZmluZXMgdGhlIHN0YXJ0IHZhbHVlXG4gICAgICogQHBhcmFtIGVuZFZhbHVlIC0gZGVmaW5lcyB0aGUgZW5kIHZhbHVlXG4gICAgICogQHBhcmFtIGdyYWRpZW50IC0gZGVmaW5lcyB0aGUgZ3JhZGllbnQgZmFjdG9yXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIE1hdHJpeCBvYmplY3Qgd2hlcmUgdG8gc3RvcmUgZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBMZXJwVG9SZWYoc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGdyYWRpZW50LCByZXN1bHQpIHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDE2OyBpbmRleCsrKSB7XG4gICAgICAgICAgICByZXN1bHQuX21baW5kZXhdID1cbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlLl9tW2luZGV4XSAqICgxLjAgLSBncmFkaWVudCkgKyBlbmRWYWx1ZS5fbVtpbmRleF0gKiBncmFkaWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuX21hcmtBc1VwZGF0ZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgbmV3IG1hdHJpeCB3aG9zZSB2YWx1ZXMgYXJlIGNvbXB1dGVkIGJ5OlxuICAgICAqICogZGVjb21wb3NpbmcgdGhlIHRoZSBcInN0YXJ0VmFsdWVcIiBhbmQgXCJlbmRWYWx1ZVwiIG1hdHJpY2VzIGludG8gdGhlaXIgcmVzcGVjdGl2ZSBzY2FsZSwgcm90YXRpb24gYW5kIHRyYW5zbGF0aW9uIG1hdHJpY2VzXG4gICAgICogKiBpbnRlcnBvbGF0aW5nIGZvciBcImdyYWRpZW50XCIgKGZsb2F0KSB0aGUgdmFsdWVzIGJldHdlZW4gZWFjaCBvZiB0aGVzZSBkZWNvbXBvc2VkIG1hdHJpY2VzIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCB0aGUgZW5kXG4gICAgICogKiByZWNvbXBvc2luZyBhIG5ldyBtYXRyaXggZnJvbSB0aGVzZSAzIGludGVycG9sYXRlZCBzY2FsZSwgcm90YXRpb24gYW5kIHRyYW5zbGF0aW9uIG1hdHJpY2VzXG4gICAgICogQHBhcmFtIHN0YXJ0VmFsdWUgLSBkZWZpbmVzIHRoZSBmaXJzdCBtYXRyaXhcbiAgICAgKiBAcGFyYW0gZW5kVmFsdWUgLSBkZWZpbmVzIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgICogQHBhcmFtIGdyYWRpZW50IC0gZGVmaW5lcyB0aGUgZ3JhZGllbnQgYmV0d2VlbiB0aGUgdHdvIG1hdHJpY2VzXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgRGVjb21wb3NlTGVycChzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZ3JhZGllbnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBNYXRyaXguRGVjb21wb3NlTGVycFRvUmVmKHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBncmFkaWVudCwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgbWF0cml4IHRvIHZhbHVlcyB3aGljaCBhcmUgY29tcHV0ZWQgYnk6XG4gICAgICogKiBkZWNvbXBvc2luZyB0aGUgdGhlIFwic3RhcnRWYWx1ZVwiIGFuZCBcImVuZFZhbHVlXCIgbWF0cmljZXMgaW50byB0aGVpciByZXNwZWN0aXZlIHNjYWxlLCByb3RhdGlvbiBhbmQgdHJhbnNsYXRpb24gbWF0cmljZXNcbiAgICAgKiAqIGludGVycG9sYXRpbmcgZm9yIFwiZ3JhZGllbnRcIiAoZmxvYXQpIHRoZSB2YWx1ZXMgYmV0d2VlbiBlYWNoIG9mIHRoZXNlIGRlY29tcG9zZWQgbWF0cmljZXMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIHRoZSBlbmRcbiAgICAgKiAqIHJlY29tcG9zaW5nIGEgbmV3IG1hdHJpeCBmcm9tIHRoZXNlIDMgaW50ZXJwb2xhdGVkIHNjYWxlLCByb3RhdGlvbiBhbmQgdHJhbnNsYXRpb24gbWF0cmljZXNcbiAgICAgKiBAcGFyYW0gc3RhcnRWYWx1ZSAtIGRlZmluZXMgdGhlIGZpcnN0IG1hdHJpeFxuICAgICAqIEBwYXJhbSBlbmRWYWx1ZSAtIGRlZmluZXMgdGhlIHNlY29uZCBtYXRyaXhcbiAgICAgKiBAcGFyYW0gZ3JhZGllbnQgLSBkZWZpbmVzIHRoZSBncmFkaWVudCBiZXR3ZWVuIHRoZSB0d28gbWF0cmljZXNcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBEZWNvbXBvc2VMZXJwVG9SZWYoc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGdyYWRpZW50LCByZXN1bHQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTY2FsZSA9IHByZWFsbG9jYXRlZFZhcmlhYmxlc18xLk1hdGhUbXAuVmVjdG9yM1swXTtcbiAgICAgICAgY29uc3Qgc3RhcnRSb3RhdGlvbiA9IHByZWFsbG9jYXRlZFZhcmlhYmxlc18xLk1hdGhUbXAuUXVhdGVybmlvblswXTtcbiAgICAgICAgY29uc3Qgc3RhcnRUcmFuc2xhdGlvbiA9IHByZWFsbG9jYXRlZFZhcmlhYmxlc18xLk1hdGhUbXAuVmVjdG9yM1sxXTtcbiAgICAgICAgc3RhcnRWYWx1ZS5kZWNvbXBvc2Uoc3RhcnRTY2FsZSwgc3RhcnRSb3RhdGlvbiwgc3RhcnRUcmFuc2xhdGlvbik7XG4gICAgICAgIGNvbnN0IGVuZFNjYWxlID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5WZWN0b3IzWzJdO1xuICAgICAgICBjb25zdCBlbmRSb3RhdGlvbiA9IHByZWFsbG9jYXRlZFZhcmlhYmxlc18xLk1hdGhUbXAuUXVhdGVybmlvblsxXTtcbiAgICAgICAgY29uc3QgZW5kVHJhbnNsYXRpb24gPSBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLlZlY3RvcjNbM107XG4gICAgICAgIGVuZFZhbHVlLmRlY29tcG9zZShlbmRTY2FsZSwgZW5kUm90YXRpb24sIGVuZFRyYW5zbGF0aW9uKTtcbiAgICAgICAgY29uc3QgcmVzdWx0U2NhbGUgPSBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLlZlY3RvcjNbNF07XG4gICAgICAgIFZlY3RvcjNfMS5WZWN0b3IzLkxlcnBUb1JlZihzdGFydFNjYWxlLCBlbmRTY2FsZSwgZ3JhZGllbnQsIHJlc3VsdFNjYWxlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0Um90YXRpb24gPSBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLlF1YXRlcm5pb25bMl07XG4gICAgICAgIFF1YXRlcm5pb25fMS5RdWF0ZXJuaW9uLlNsZXJwVG9SZWYoc3RhcnRSb3RhdGlvbiwgZW5kUm90YXRpb24sIGdyYWRpZW50LCByZXN1bHRSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IHJlc3VsdFRyYW5zbGF0aW9uID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5WZWN0b3IzWzVdO1xuICAgICAgICBWZWN0b3IzXzEuVmVjdG9yMy5MZXJwVG9SZWYoc3RhcnRUcmFuc2xhdGlvbiwgZW5kVHJhbnNsYXRpb24sIGdyYWRpZW50LCByZXN1bHRUcmFuc2xhdGlvbik7XG4gICAgICAgIE1hdHJpeC5Db21wb3NlVG9SZWYocmVzdWx0U2NhbGUsIHJlc3VsdFJvdGF0aW9uLCByZXN1bHRUcmFuc2xhdGlvbiwgcmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIG5ldyByb3RhdGlvbiBtYXRyaXggdXNlZCB0byByb3RhdGUgYW4gZW50aXR5IHNvIGFzIGl0IGxvb2tzIGF0IHRoZSB0YXJnZXQgdmVjdG9yMywgZnJvbSB0aGUgZXllIHZlY3RvcjMgcG9zaXRpb24sIHRoZSB1cCB2ZWN0b3IzIGJlaW5nIG9yaWVudGVkIGxpa2UgXCJ1cFwiXG4gICAgICogVGhpcyBmdW5jdGlvbiB3b3JrcyBpbiBsZWZ0IGhhbmRlZCBtb2RlXG4gICAgICogQHBhcmFtIGV5ZSAtIGRlZmluZXMgdGhlIGZpbmFsIHBvc2l0aW9uIG9mIHRoZSBlbnRpdHlcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gZGVmaW5lcyB3aGVyZSB0aGUgZW50aXR5IHNob3VsZCBsb29rIGF0XG4gICAgICogQHBhcmFtIHVwIC0gZGVmaW5lcyB0aGUgdXAgdmVjdG9yIGZvciB0aGUgZW50aXR5XG4gICAgICogQHJldHVybnMgdGhlIG5ldyBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgTG9va0F0TEgoZXllLCB0YXJnZXQsIHVwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgTWF0cml4Lkxvb2tBdExIVG9SZWYoZXllLCB0YXJnZXQsIHVwLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiBcInJlc3VsdFwiIE1hdHJpeCB0byBhIHJvdGF0aW9uIG1hdHJpeCB1c2VkIHRvIHJvdGF0ZSBhbiBlbnRpdHkgc28gdGhhdCBpdCBsb29rcyBhdCB0aGUgdGFyZ2V0IHZlY3RvcjMsIGZyb20gdGhlIGV5ZSB2ZWN0b3IzIHBvc2l0aW9uLCB0aGUgdXAgdmVjdG9yMyBiZWluZyBvcmllbnRlZCBsaWtlIFwidXBcIi5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdvcmtzIGluIGxlZnQgaGFuZGVkIG1vZGVcbiAgICAgKiBAcGFyYW0gZXllIC0gZGVmaW5lcyB0aGUgZmluYWwgcG9zaXRpb24gb2YgdGhlIGVudGl0eVxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBkZWZpbmVzIHdoZXJlIHRoZSBlbnRpdHkgc2hvdWxkIGxvb2sgYXRcbiAgICAgKiBAcGFyYW0gdXAgLSBkZWZpbmVzIHRoZSB1cCB2ZWN0b3IgZm9yIHRoZSBlbnRpdHlcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBMb29rQXRMSFRvUmVmKGV5ZSwgdGFyZ2V0LCB1cCwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHhBeGlzID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5WZWN0b3IzWzBdO1xuICAgICAgICBjb25zdCB5QXhpcyA9IHByZWFsbG9jYXRlZFZhcmlhYmxlc18xLk1hdGhUbXAuVmVjdG9yM1sxXTtcbiAgICAgICAgY29uc3QgekF4aXMgPSBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLlZlY3RvcjNbMl07XG4gICAgICAgIC8vIFogYXhpc1xuICAgICAgICB0YXJnZXQuc3VidHJhY3RUb1JlZihleWUsIHpBeGlzKTtcbiAgICAgICAgekF4aXMubm9ybWFsaXplKCk7XG4gICAgICAgIC8vIFggYXhpc1xuICAgICAgICBWZWN0b3IzXzEuVmVjdG9yMy5Dcm9zc1RvUmVmKHVwLCB6QXhpcywgeEF4aXMpO1xuICAgICAgICBjb25zdCB4U3F1YXJlTGVuZ3RoID0geEF4aXMubGVuZ3RoU3F1YXJlZCgpO1xuICAgICAgICBpZiAoeFNxdWFyZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgeEF4aXMueCA9IDEuMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHhBeGlzLm5vcm1hbGl6ZUZyb21MZW5ndGgoTWF0aC5zcXJ0KHhTcXVhcmVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBZIGF4aXNcbiAgICAgICAgVmVjdG9yM18xLlZlY3RvcjMuQ3Jvc3NUb1JlZih6QXhpcywgeEF4aXMsIHlBeGlzKTtcbiAgICAgICAgeUF4aXMubm9ybWFsaXplKCk7XG4gICAgICAgIC8vIEV5ZSBhbmdsZXNcbiAgICAgICAgY29uc3QgZXggPSAtVmVjdG9yM18xLlZlY3RvcjMuRG90KHhBeGlzLCBleWUpO1xuICAgICAgICBjb25zdCBleSA9IC1WZWN0b3IzXzEuVmVjdG9yMy5Eb3QoeUF4aXMsIGV5ZSk7XG4gICAgICAgIGNvbnN0IGV6ID0gLVZlY3RvcjNfMS5WZWN0b3IzLkRvdCh6QXhpcywgZXllKTtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZih4QXhpcy54LCB5QXhpcy54LCB6QXhpcy54LCAwLjAsIHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAuMCwgeEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMC4wLCBleCwgZXksIGV6LCAxLjAsIHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgcm90YXRpb24gbWF0cml4IHVzZWQgdG8gcm90YXRlIGFuIGVudGl0eSBzbyBhcyBpdCBsb29rcyBhdCB0aGUgdGFyZ2V0IHZlY3RvcjMsIGZyb20gdGhlIGV5ZSB2ZWN0b3IzIHBvc2l0aW9uLCB0aGUgdXAgdmVjdG9yMyBiZWluZyBvcmllbnRlZCBsaWtlIFwidXBcIlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd29ya3MgaW4gcmlnaHQgaGFuZGVkIG1vZGVcbiAgICAgKiBAcGFyYW0gZXllIC0gZGVmaW5lcyB0aGUgZmluYWwgcG9zaXRpb24gb2YgdGhlIGVudGl0eVxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBkZWZpbmVzIHdoZXJlIHRoZSBlbnRpdHkgc2hvdWxkIGxvb2sgYXRcbiAgICAgKiBAcGFyYW0gdXAgLSBkZWZpbmVzIHRoZSB1cCB2ZWN0b3IgZm9yIHRoZSBlbnRpdHlcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBMb29rQXRSSChleWUsIHRhcmdldCwgdXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBNYXRyaXguTG9va0F0UkhUb1JlZihleWUsIHRhcmdldCwgdXAsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIFwicmVzdWx0XCIgTWF0cml4IHRvIGEgcm90YXRpb24gbWF0cml4IHVzZWQgdG8gcm90YXRlIGFuIGVudGl0eSBzbyB0aGF0IGl0IGxvb2tzIGF0IHRoZSB0YXJnZXQgdmVjdG9yMywgZnJvbSB0aGUgZXllIHZlY3RvcjMgcG9zaXRpb24sIHRoZSB1cCB2ZWN0b3IzIGJlaW5nIG9yaWVudGVkIGxpa2UgXCJ1cFwiLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd29ya3MgaW4gcmlnaHQgaGFuZGVkIG1vZGVcbiAgICAgKiBAcGFyYW0gZXllIC0gZGVmaW5lcyB0aGUgZmluYWwgcG9zaXRpb24gb2YgdGhlIGVudGl0eVxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBkZWZpbmVzIHdoZXJlIHRoZSBlbnRpdHkgc2hvdWxkIGxvb2sgYXRcbiAgICAgKiBAcGFyYW0gdXAgLSBkZWZpbmVzIHRoZSB1cCB2ZWN0b3IgZm9yIHRoZSBlbnRpdHlcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBMb29rQXRSSFRvUmVmKGV5ZSwgdGFyZ2V0LCB1cCwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHhBeGlzID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5WZWN0b3IzWzBdO1xuICAgICAgICBjb25zdCB5QXhpcyA9IHByZWFsbG9jYXRlZFZhcmlhYmxlc18xLk1hdGhUbXAuVmVjdG9yM1sxXTtcbiAgICAgICAgY29uc3QgekF4aXMgPSBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLlZlY3RvcjNbMl07XG4gICAgICAgIC8vIFogYXhpc1xuICAgICAgICBleWUuc3VidHJhY3RUb1JlZih0YXJnZXQsIHpBeGlzKTtcbiAgICAgICAgekF4aXMubm9ybWFsaXplKCk7XG4gICAgICAgIC8vIFggYXhpc1xuICAgICAgICBWZWN0b3IzXzEuVmVjdG9yMy5Dcm9zc1RvUmVmKHVwLCB6QXhpcywgeEF4aXMpO1xuICAgICAgICBjb25zdCB4U3F1YXJlTGVuZ3RoID0geEF4aXMubGVuZ3RoU3F1YXJlZCgpO1xuICAgICAgICBpZiAoeFNxdWFyZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgeEF4aXMueCA9IDEuMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHhBeGlzLm5vcm1hbGl6ZUZyb21MZW5ndGgoTWF0aC5zcXJ0KHhTcXVhcmVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBZIGF4aXNcbiAgICAgICAgVmVjdG9yM18xLlZlY3RvcjMuQ3Jvc3NUb1JlZih6QXhpcywgeEF4aXMsIHlBeGlzKTtcbiAgICAgICAgeUF4aXMubm9ybWFsaXplKCk7XG4gICAgICAgIC8vIEV5ZSBhbmdsZXNcbiAgICAgICAgY29uc3QgZXggPSAtVmVjdG9yM18xLlZlY3RvcjMuRG90KHhBeGlzLCBleWUpO1xuICAgICAgICBjb25zdCBleSA9IC1WZWN0b3IzXzEuVmVjdG9yMy5Eb3QoeUF4aXMsIGV5ZSk7XG4gICAgICAgIGNvbnN0IGV6ID0gLVZlY3RvcjNfMS5WZWN0b3IzLkRvdCh6QXhpcywgZXllKTtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZih4QXhpcy54LCB5QXhpcy54LCB6QXhpcy54LCAwLjAsIHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAuMCwgeEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMC4wLCBleCwgZXksIGV6LCAxLjAsIHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGxlZnQtaGFuZGVkIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqIEBwYXJhbSB3aWR0aCAtIGRlZmluZXMgdGhlIHZpZXdwb3J0IHdpZHRoXG4gICAgICogQHBhcmFtIGhlaWdodCAtIGRlZmluZXMgdGhlIHZpZXdwb3J0IGhlaWdodFxuICAgICAqIEBwYXJhbSB6bmVhciAtIGRlZmluZXMgdGhlIG5lYXIgY2xpcCBwbGFuZVxuICAgICAqIEBwYXJhbSB6ZmFyIC0gZGVmaW5lcyB0aGUgZmFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBtYXRyaXggYXMgYSBsZWZ0LWhhbmRlZCBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgT3J0aG9MSCh3aWR0aCwgaGVpZ2h0LCB6bmVhciwgemZhcikge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIE1hdHJpeC5PcnRob0xIVG9SZWYod2lkdGgsIGhlaWdodCwgem5lYXIsIHpmYXIsIG1hdHJpeCk7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3JlIGEgbGVmdC1oYW5kZWQgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gdG8gYSBnaXZlbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBkZWZpbmVzIHRoZSB2aWV3cG9ydCB3aWR0aFxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBkZWZpbmVzIHRoZSB2aWV3cG9ydCBoZWlnaHRcbiAgICAgKiBAcGFyYW0gem5lYXIgLSBkZWZpbmVzIHRoZSBuZWFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcGFyYW0gemZhciAtIGRlZmluZXMgdGhlIGZhciBjbGlwIHBsYW5lXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgT3J0aG9MSFRvUmVmKHdpZHRoLCBoZWlnaHQsIHpuZWFyLCB6ZmFyLCByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgbiA9IHpuZWFyO1xuICAgICAgICBjb25zdCBmID0gemZhcjtcbiAgICAgICAgY29uc3QgYSA9IDIuMCAvIHdpZHRoO1xuICAgICAgICBjb25zdCBiID0gMi4wIC8gaGVpZ2h0O1xuICAgICAgICBjb25zdCBjID0gMi4wIC8gKGYgLSBuKTtcbiAgICAgICAgY29uc3QgZCA9IC0oZiArIG4pIC8gKGYgLSBuKTtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZihhLCAwLjAsIDAuMCwgMC4wLCAwLjAsIGIsIDAuMCwgMC4wLCAwLjAsIDAuMCwgYywgMC4wLCAwLjAsIDAuMCwgZCwgMS4wLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQuX3VwZGF0ZUlkZW50aXR5U3RhdHVzKGEgPT09IDEgJiYgYiA9PT0gMSAmJiBjID09PSAxICYmIGQgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBsZWZ0LWhhbmRlZCBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbGVmdCAtIGRlZmluZXMgdGhlIHZpZXdwb3J0IGxlZnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSByaWdodCAtIGRlZmluZXMgdGhlIHZpZXdwb3J0IHJpZ2h0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gYm90dG9tIC0gZGVmaW5lcyB0aGUgdmlld3BvcnQgYm90dG9tIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gdG9wIC0gZGVmaW5lcyB0aGUgdmlld3BvcnQgdG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gem5lYXIgLSBkZWZpbmVzIHRoZSBuZWFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcGFyYW0gemZhciAtIGRlZmluZXMgdGhlIGZhciBjbGlwIHBsYW5lXG4gICAgICogQHJldHVybnMgYSBuZXcgbWF0cml4IGFzIGEgbGVmdC1oYW5kZWQgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIE9ydGhvT2ZmQ2VudGVyTEgobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCB6bmVhciwgemZhcikge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIE1hdHJpeC5PcnRob09mZkNlbnRlckxIVG9SZWYobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCB6bmVhciwgemZhciwgbWF0cml4KTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmVzIGEgbGVmdC1oYW5kZWQgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gaW50byBhIGdpdmVuIG1hdHJpeFxuICAgICAqIEBwYXJhbSBsZWZ0IC0gZGVmaW5lcyB0aGUgdmlld3BvcnQgbGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyB0aGUgdmlld3BvcnQgcmlnaHQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBib3R0b20gLSBkZWZpbmVzIHRoZSB2aWV3cG9ydCBib3R0b20gY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB0b3AgLSBkZWZpbmVzIHRoZSB2aWV3cG9ydCB0b3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB6bmVhciAtIGRlZmluZXMgdGhlIG5lYXIgY2xpcCBwbGFuZVxuICAgICAqIEBwYXJhbSB6ZmFyIC0gZGVmaW5lcyB0aGUgZmFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBPcnRob09mZkNlbnRlckxIVG9SZWYobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCB6bmVhciwgemZhciwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IG4gPSB6bmVhcjtcbiAgICAgICAgY29uc3QgZiA9IHpmYXI7XG4gICAgICAgIGNvbnN0IGEgPSAyLjAgLyAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgY29uc3QgYiA9IDIuMCAvICh0b3AgLSBib3R0b20pO1xuICAgICAgICBjb25zdCBjID0gMi4wIC8gKGYgLSBuKTtcbiAgICAgICAgY29uc3QgZCA9IC0oZiArIG4pIC8gKGYgLSBuKTtcbiAgICAgICAgY29uc3QgaTAgPSAobGVmdCArIHJpZ2h0KSAvIChsZWZ0IC0gcmlnaHQpO1xuICAgICAgICBjb25zdCBpMSA9ICh0b3AgKyBib3R0b20pIC8gKGJvdHRvbSAtIHRvcCk7XG4gICAgICAgIE1hdHJpeC5Gcm9tVmFsdWVzVG9SZWYoYSwgMC4wLCAwLjAsIDAuMCwgMC4wLCBiLCAwLjAsIDAuMCwgMC4wLCAwLjAsIGMsIDAuMCwgaTAsIGkxLCBkLCAxLjAsIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5fbWFya0FzVXBkYXRlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmlnaHQtaGFuZGVkIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqIEBwYXJhbSBsZWZ0IC0gZGVmaW5lcyB0aGUgdmlld3BvcnQgbGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyB0aGUgdmlld3BvcnQgcmlnaHQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBib3R0b20gLSBkZWZpbmVzIHRoZSB2aWV3cG9ydCBib3R0b20gY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB0b3AgLSBkZWZpbmVzIHRoZSB2aWV3cG9ydCB0b3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB6bmVhciAtIGRlZmluZXMgdGhlIG5lYXIgY2xpcCBwbGFuZVxuICAgICAqIEBwYXJhbSB6ZmFyIC0gZGVmaW5lcyB0aGUgZmFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBtYXRyaXggYXMgYSByaWdodC1oYW5kZWQgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIE9ydGhvT2ZmQ2VudGVyUkgobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCB6bmVhciwgemZhcikge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIE1hdHJpeC5PcnRob09mZkNlbnRlclJIVG9SZWYobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCB6bmVhciwgemZhciwgbWF0cml4KTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmVzIGEgcmlnaHQtaGFuZGVkIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uIGludG8gYSBnaXZlbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbGVmdCAtIGRlZmluZXMgdGhlIHZpZXdwb3J0IGxlZnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSByaWdodCAtIGRlZmluZXMgdGhlIHZpZXdwb3J0IHJpZ2h0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gYm90dG9tIC0gZGVmaW5lcyB0aGUgdmlld3BvcnQgYm90dG9tIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gdG9wIC0gZGVmaW5lcyB0aGUgdmlld3BvcnQgdG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gem5lYXIgLSBkZWZpbmVzIHRoZSBuZWFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcGFyYW0gemZhciAtIGRlZmluZXMgdGhlIGZhciBjbGlwIHBsYW5lXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgT3J0aG9PZmZDZW50ZXJSSFRvUmVmKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgem5lYXIsIHpmYXIsIHJlc3VsdCkge1xuICAgICAgICBNYXRyaXguT3J0aG9PZmZDZW50ZXJMSFRvUmVmKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgem5lYXIsIHpmYXIsIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5fbVsxMF0gKj0gLTE7IC8vIE5vIG5lZWQgdG8gY2FsbCBfbWFya0FzVXBkYXRlZCBhcyBwcmV2aW91cyBmdW5jdGlvbiBhbHJlYWR5IGNhbGxlZCBpdCBhbmQgbGV0IF9pc0lkZW50aXR5RGlydHkgdG8gdHJ1ZVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGVmdC1oYW5kZWQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gd2lkdGggLSBkZWZpbmVzIHRoZSB2aWV3cG9ydCB3aWR0aFxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBkZWZpbmVzIHRoZSB2aWV3cG9ydCBoZWlnaHRcbiAgICAgKiBAcGFyYW0gem5lYXIgLSBkZWZpbmVzIHRoZSBuZWFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcGFyYW0gemZhciAtIGRlZmluZXMgdGhlIGZhciBjbGlwIHBsYW5lXG4gICAgICogQHJldHVybnMgYSBuZXcgbWF0cml4IGFzIGEgbGVmdC1oYW5kZWQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgUGVyc3BlY3RpdmVMSCh3aWR0aCwgaGVpZ2h0LCB6bmVhciwgemZhcikge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIGNvbnN0IG4gPSB6bmVhcjtcbiAgICAgICAgY29uc3QgZiA9IHpmYXI7XG4gICAgICAgIGNvbnN0IGEgPSAoMi4wICogbikgLyB3aWR0aDtcbiAgICAgICAgY29uc3QgYiA9ICgyLjAgKiBuKSAvIGhlaWdodDtcbiAgICAgICAgY29uc3QgYyA9IChmICsgbikgLyAoZiAtIG4pO1xuICAgICAgICBjb25zdCBkID0gKC0yLjAgKiBmICogbikgLyAoZiAtIG4pO1xuICAgICAgICBNYXRyaXguRnJvbVZhbHVlc1RvUmVmKGEsIDAuMCwgMC4wLCAwLjAsIDAuMCwgYiwgMC4wLCAwLjAsIDAuMCwgMC4wLCBjLCAxLjAsIDAuMCwgMC4wLCBkLCAwLjAsIG1hdHJpeCk7XG4gICAgICAgIG1hdHJpeC5fdXBkYXRlSWRlbnRpdHlTdGF0dXMoZmFsc2UpO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGVmdC1oYW5kZWQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gZm92IC0gZGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBmaWVsZCBvZiB2aWV3XG4gICAgICogQHBhcmFtIGFzcGVjdCAtIGRlZmluZXMgdGhlIGFzcGVjdCByYXRpb1xuICAgICAqIEBwYXJhbSB6bmVhciAtIGRlZmluZXMgdGhlIG5lYXIgY2xpcCBwbGFuZVxuICAgICAqIEBwYXJhbSB6ZmFyIC0gZGVmaW5lcyB0aGUgZmFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBtYXRyaXggYXMgYSBsZWZ0LWhhbmRlZCBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBQZXJzcGVjdGl2ZUZvdkxIKGZvdiwgYXNwZWN0LCB6bmVhciwgemZhcikge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIE1hdHJpeC5QZXJzcGVjdGl2ZUZvdkxIVG9SZWYoZm92LCBhc3BlY3QsIHpuZWFyLCB6ZmFyLCBtYXRyaXgpO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgYSBsZWZ0LWhhbmRlZCBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIGludG8gYSBnaXZlbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gZm92IC0gZGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBmaWVsZCBvZiB2aWV3XG4gICAgICogQHBhcmFtIGFzcGVjdCAtIGRlZmluZXMgdGhlIGFzcGVjdCByYXRpb1xuICAgICAqIEBwYXJhbSB6bmVhciAtIGRlZmluZXMgdGhlIG5lYXIgY2xpcCBwbGFuZVxuICAgICAqIEBwYXJhbSB6ZmFyIC0gZGVmaW5lcyB0aGUgZmFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqIEBwYXJhbSBpc1ZlcnRpY2FsRm92Rml4ZWQgLSBkZWZpbmVzIGl0IHRoZSBmb3YgaXMgdmVydGljYWxseSBmaXhlZCAoZGVmYXVsdCkgb3IgaG9yaXpvbnRhbGx5XG4gICAgICovXG4gICAgc3RhdGljIFBlcnNwZWN0aXZlRm92TEhUb1JlZihmb3YsIGFzcGVjdCwgem5lYXIsIHpmYXIsIHJlc3VsdCwgaXNWZXJ0aWNhbEZvdkZpeGVkID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBuID0gem5lYXI7XG4gICAgICAgIGNvbnN0IGYgPSB6ZmFyO1xuICAgICAgICBjb25zdCB0ID0gMS4wIC8gTWF0aC50YW4oZm92ICogMC41KTtcbiAgICAgICAgY29uc3QgYSA9IGlzVmVydGljYWxGb3ZGaXhlZCA/IHQgLyBhc3BlY3QgOiB0O1xuICAgICAgICBjb25zdCBiID0gaXNWZXJ0aWNhbEZvdkZpeGVkID8gdCA6IHQgKiBhc3BlY3Q7XG4gICAgICAgIGNvbnN0IGMgPSAoZiArIG4pIC8gKGYgLSBuKTtcbiAgICAgICAgY29uc3QgZCA9ICgtMi4wICogZiAqIG4pIC8gKGYgLSBuKTtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZihhLCAwLjAsIDAuMCwgMC4wLCAwLjAsIGIsIDAuMCwgMC4wLCAwLjAsIDAuMCwgYywgMS4wLCAwLjAsIDAuMCwgZCwgMC4wLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQuX3VwZGF0ZUlkZW50aXR5U3RhdHVzKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJpZ2h0LWhhbmRlZCBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqIEBwYXJhbSBmb3YgLSBkZWZpbmVzIHRoZSBob3Jpem9udGFsIGZpZWxkIG9mIHZpZXdcbiAgICAgKiBAcGFyYW0gYXNwZWN0IC0gZGVmaW5lcyB0aGUgYXNwZWN0IHJhdGlvXG4gICAgICogQHBhcmFtIHpuZWFyIC0gZGVmaW5lcyB0aGUgbmVhciBjbGlwIHBsYW5lXG4gICAgICogQHBhcmFtIHpmYXIgLSBkZWZpbmVzIHRoZSBmYXIgY2xpcCBwbGFuZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IG1hdHJpeCBhcyBhIHJpZ2h0LWhhbmRlZCBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBQZXJzcGVjdGl2ZUZvdlJIKGZvdiwgYXNwZWN0LCB6bmVhciwgemZhcikge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIE1hdHJpeC5QZXJzcGVjdGl2ZUZvdlJIVG9SZWYoZm92LCBhc3BlY3QsIHpuZWFyLCB6ZmFyLCBtYXRyaXgpO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgYSByaWdodC1oYW5kZWQgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBpbnRvIGEgZ2l2ZW4gbWF0cml4XG4gICAgICogQHBhcmFtIGZvdiAtIGRlZmluZXMgdGhlIGhvcml6b250YWwgZmllbGQgb2Ygdmlld1xuICAgICAqIEBwYXJhbSBhc3BlY3QgLSBkZWZpbmVzIHRoZSBhc3BlY3QgcmF0aW9cbiAgICAgKiBAcGFyYW0gem5lYXIgLSBkZWZpbmVzIHRoZSBuZWFyIGNsaXAgcGxhbmVcbiAgICAgKiBAcGFyYW0gemZhciAtIGRlZmluZXMgdGhlIGZhciBjbGlwIHBsYW5lXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKiBAcGFyYW0gaXNWZXJ0aWNhbEZvdkZpeGVkIC0gZGVmaW5lcyBpdCB0aGUgZm92IGlzIHZlcnRpY2FsbHkgZml4ZWQgKGRlZmF1bHQpIG9yIGhvcml6b250YWxseVxuICAgICAqL1xuICAgIHN0YXRpYyBQZXJzcGVjdGl2ZUZvdlJIVG9SZWYoZm92LCBhc3BlY3QsIHpuZWFyLCB6ZmFyLCByZXN1bHQsIGlzVmVydGljYWxGb3ZGaXhlZCA9IHRydWUpIHtcbiAgICAgICAgLyogYWx0ZXJuYXRpdmVseSB0aGlzIGNvdWxkIGJlIGV4cHJlc3NlZCBhczpcbiAgICAgICAgLy8gICAgbSA9IFBlcnNwZWN0aXZlRm92TEhUb1JlZlxuICAgICAgICAvLyAgICBtWzEwXSAqPSAtMS4wO1xuICAgICAgICAvLyAgICBtWzExXSAqPSAtMS4wO1xuICAgICAgICAqL1xuICAgICAgICBjb25zdCBuID0gem5lYXI7XG4gICAgICAgIGNvbnN0IGYgPSB6ZmFyO1xuICAgICAgICBjb25zdCB0ID0gMS4wIC8gTWF0aC50YW4oZm92ICogMC41KTtcbiAgICAgICAgY29uc3QgYSA9IGlzVmVydGljYWxGb3ZGaXhlZCA/IHQgLyBhc3BlY3QgOiB0O1xuICAgICAgICBjb25zdCBiID0gaXNWZXJ0aWNhbEZvdkZpeGVkID8gdCA6IHQgKiBhc3BlY3Q7XG4gICAgICAgIGNvbnN0IGMgPSAtKGYgKyBuKSAvIChmIC0gbik7XG4gICAgICAgIGNvbnN0IGQgPSAoLTIgKiBmICogbikgLyAoZiAtIG4pO1xuICAgICAgICBNYXRyaXguRnJvbVZhbHVlc1RvUmVmKGEsIDAuMCwgMC4wLCAwLjAsIDAuMCwgYiwgMC4wLCAwLjAsIDAuMCwgMC4wLCBjLCAtMS4wLCAwLjAsIDAuMCwgZCwgMC4wLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQuX3VwZGF0ZUlkZW50aXR5U3RhdHVzKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBmb3IgV2ViVlIgaW5mbyBhIGdpdmVuIG1hdHJpeFxuICAgICAqIEBwYXJhbSBmb3YgLSBkZWZpbmVzIHRoZSBmaWVsZCBvZiB2aWV3XG4gICAgICogQHBhcmFtIHpuZWFyIC0gZGVmaW5lcyB0aGUgbmVhciBjbGlwIHBsYW5lXG4gICAgICogQHBhcmFtIHpmYXIgLSBkZWZpbmVzIHRoZSBmYXIgY2xpcCBwbGFuZVxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgbWF0cml4XG4gICAgICogQHBhcmFtIHJpZ2h0SGFuZGVkIC0gZGVmaW5lcyBpZiB0aGUgbWF0cml4IG11c3QgYmUgaW4gcmlnaHQtaGFuZGVkIG1vZGUgKGZhbHNlIGJ5IGRlZmF1bHQpXG4gICAgICovXG4gICAgc3RhdGljIFBlcnNwZWN0aXZlRm92V2ViVlJUb1JlZihmb3YsIHpuZWFyLCB6ZmFyLCByZXN1bHQsIHJpZ2h0SGFuZGVkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgcmlnaHRIYW5kZWRGYWN0b3IgPSByaWdodEhhbmRlZCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgdXBUYW4gPSBNYXRoLnRhbigoZm92LnVwRGVncmVlcyAqIE1hdGguUEkpIC8gMTgwLjApO1xuICAgICAgICBjb25zdCBkb3duVGFuID0gTWF0aC50YW4oKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkpIC8gMTgwLjApO1xuICAgICAgICBjb25zdCBsZWZ0VGFuID0gTWF0aC50YW4oKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkpIC8gMTgwLjApO1xuICAgICAgICBjb25zdCByaWdodFRhbiA9IE1hdGgudGFuKChmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSSkgLyAxODAuMCk7XG4gICAgICAgIGNvbnN0IHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICAgICAgICBjb25zdCB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcbiAgICAgICAgY29uc3QgbSA9IHJlc3VsdC5fbTtcbiAgICAgICAgbVswXSA9IHhTY2FsZTtcbiAgICAgICAgbVsxXSA9IG1bMl0gPSBtWzNdID0gbVs0XSA9IDAuMDtcbiAgICAgICAgbVs1XSA9IHlTY2FsZTtcbiAgICAgICAgbVs2XSA9IG1bN10gPSAwLjA7XG4gICAgICAgIG1bOF0gPSAobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNTtcbiAgICAgICAgbVs5XSA9IC0oKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgICAgICBtWzEwXSA9IC16ZmFyIC8gKHpuZWFyIC0gemZhcik7XG4gICAgICAgIG1bMTFdID0gMS4wICogcmlnaHRIYW5kZWRGYWN0b3I7XG4gICAgICAgIG1bMTJdID0gbVsxM10gPSBtWzE1XSA9IDAuMDtcbiAgICAgICAgbVsxNF0gPSAtKDIuMCAqIHpmYXIgKiB6bmVhcikgLyAoemZhciAtIHpuZWFyKTtcbiAgICAgICAgcmVzdWx0Ll9tYXJrQXNVcGRhdGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGEgMngyIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gbWF0cml4IGFuZCBzdG9yZSB0aGUgcmVzdWx0IGluIGEgRmxvYXRBcnJheVxuICAgICAqIEBwYXJhbSBtYXRyaXggLSBkZWZpbmVzIHRoZSBtYXRyaXggdG8gdXNlXG4gICAgICogQHJldHVybnMgYSBuZXcgRmxvYXRBcnJheSBhcnJheSB3aXRoIDQgZWxlbWVudHMgOiB0aGUgMngyIG1hdHJpeCBleHRyYWN0ZWQgZnJvbSB0aGUgZ2l2ZW4gbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIEdldEFzTWF0cml4MngyKG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gW21hdHJpeC5fbVswXSwgbWF0cml4Ll9tWzFdLCBtYXRyaXguX21bNF0sIG1hdHJpeC5fbVs1XV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIGEgM3gzIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gbWF0cml4IGFuZCBzdG9yZSB0aGUgcmVzdWx0IGluIGEgRmxvYXRBcnJheVxuICAgICAqIEBwYXJhbSBtYXRyaXggLSBkZWZpbmVzIHRoZSBtYXRyaXggdG8gdXNlXG4gICAgICogQHJldHVybnMgYSBuZXcgRmxvYXRBcnJheSBhcnJheSB3aXRoIDkgZWxlbWVudHMgOiB0aGUgM3gzIG1hdHJpeCBleHRyYWN0ZWQgZnJvbSB0aGUgZ2l2ZW4gbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIEdldEFzTWF0cml4M3gzKG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWF0cml4Ll9tWzBdLFxuICAgICAgICAgICAgbWF0cml4Ll9tWzFdLFxuICAgICAgICAgICAgbWF0cml4Ll9tWzJdLFxuICAgICAgICAgICAgbWF0cml4Ll9tWzRdLFxuICAgICAgICAgICAgbWF0cml4Ll9tWzVdLFxuICAgICAgICAgICAgbWF0cml4Ll9tWzZdLFxuICAgICAgICAgICAgbWF0cml4Ll9tWzhdLFxuICAgICAgICAgICAgbWF0cml4Ll9tWzldLFxuICAgICAgICAgICAgbWF0cml4Ll9tWzEwXVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSB0cmFuc3Bvc2Ugb2YgYSBnaXZlbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gbWF0cml4IC0gZGVmaW5lcyB0aGUgbWF0cml4IHRvIHRyYW5zcG9zZVxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIFRyYW5zcG9zZShtYXRyaXgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBNYXRyaXguVHJhbnNwb3NlVG9SZWYobWF0cml4LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSB0cmFuc3Bvc2Ugb2YgYSBtYXRyaXggYW5kIHN0b3JlIGl0IGluIGEgdGFyZ2V0IG1hdHJpeFxuICAgICAqIEBwYXJhbSBtYXRyaXggLSBkZWZpbmVzIHRoZSBtYXRyaXggdG8gdHJhbnNwb3NlXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgVHJhbnNwb3NlVG9SZWYobWF0cml4LCByZXN1bHQpIHtcbiAgICAgICAgY29uc3Qgcm0gPSByZXN1bHQuX207XG4gICAgICAgIGNvbnN0IG1tID0gbWF0cml4Ll9tO1xuICAgICAgICBybVswXSA9IG1tWzBdO1xuICAgICAgICBybVsxXSA9IG1tWzRdO1xuICAgICAgICBybVsyXSA9IG1tWzhdO1xuICAgICAgICBybVszXSA9IG1tWzEyXTtcbiAgICAgICAgcm1bNF0gPSBtbVsxXTtcbiAgICAgICAgcm1bNV0gPSBtbVs1XTtcbiAgICAgICAgcm1bNl0gPSBtbVs5XTtcbiAgICAgICAgcm1bN10gPSBtbVsxM107XG4gICAgICAgIHJtWzhdID0gbW1bMl07XG4gICAgICAgIHJtWzldID0gbW1bNl07XG4gICAgICAgIHJtWzEwXSA9IG1tWzEwXTtcbiAgICAgICAgcm1bMTFdID0gbW1bMTRdO1xuICAgICAgICBybVsxMl0gPSBtbVszXTtcbiAgICAgICAgcm1bMTNdID0gbW1bN107XG4gICAgICAgIHJtWzE0XSA9IG1tWzExXTtcbiAgICAgICAgcm1bMTVdID0gbW1bMTVdO1xuICAgICAgICAvLyBpZGVudGl0eS1uZXNzIGRvZXMgbm90IGNoYW5nZSB3aGVuIHRyYW5zcG9zaW5nXG4gICAgICAgIHJlc3VsdC5fdXBkYXRlSWRlbnRpdHlTdGF0dXMobWF0cml4Ll9pc0lkZW50aXR5LCBtYXRyaXguX2lzSWRlbnRpdHlEaXJ0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgcmVmbGVjdGlvbiBtYXRyaXggZnJvbSBhIHBsYW5lXG4gICAgICogQHBhcmFtIHBsYW5lIC0gZGVmaW5lcyB0aGUgcmVmbGVjdGlvbiBwbGFuZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IG1hdHJpeFxuICAgICAqL1xuICAgIHN0YXRpYyBSZWZsZWN0aW9uKHBsYW5lKSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgTWF0cml4LlJlZmxlY3Rpb25Ub1JlZihwbGFuZSwgbWF0cml4KTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSByZWZsZWN0aW9uIG1hdHJpeCBmcm9tIGEgcGxhbmVcbiAgICAgKiBAcGFyYW0gcGxhbmUgLSBkZWZpbmVzIHRoZSByZWZsZWN0aW9uIHBsYW5lXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKi9cbiAgICBzdGF0aWMgUmVmbGVjdGlvblRvUmVmKHBsYW5lLCByZXN1bHQpIHtcbiAgICAgICAgcGxhbmUubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IHggPSBwbGFuZS5ub3JtYWwueDtcbiAgICAgICAgY29uc3QgeSA9IHBsYW5lLm5vcm1hbC55O1xuICAgICAgICBjb25zdCB6ID0gcGxhbmUubm9ybWFsLno7XG4gICAgICAgIGNvbnN0IHRlbXAgPSAtMiAqIHg7XG4gICAgICAgIGNvbnN0IHRlbXAyID0gLTIgKiB5O1xuICAgICAgICBjb25zdCB0ZW1wMyA9IC0yICogejtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZih0ZW1wICogeCArIDEsIHRlbXAyICogeCwgdGVtcDMgKiB4LCAwLjAsIHRlbXAgKiB5LCB0ZW1wMiAqIHkgKyAxLCB0ZW1wMyAqIHksIDAuMCwgdGVtcCAqIHosIHRlbXAyICogeiwgdGVtcDMgKiB6ICsgMSwgMC4wLCB0ZW1wICogcGxhbmUuZCwgdGVtcDIgKiBwbGFuZS5kLCB0ZW1wMyAqIHBsYW5lLmQsIDEuMCwgcmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gbWF0cml4IGFzIGEgcm90YXRpb24gbWF0cml4IGNvbXBvc2VkIGZyb20gdGhlIDMgbGVmdCBoYW5kZWQgYXhlc1xuICAgICAqIEBwYXJhbSB4YXhpcyAtIGRlZmluZXMgdGhlIHZhbHVlIG9mIHRoZSAxc3QgYXhpc1xuICAgICAqIEBwYXJhbSB5YXhpcyAtIGRlZmluZXMgdGhlIHZhbHVlIG9mIHRoZSAybmQgYXhpc1xuICAgICAqIEBwYXJhbSB6YXhpcyAtIGRlZmluZXMgdGhlIHZhbHVlIG9mIHRoZSAzcmQgYXhpc1xuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIEZyb21YWVpBeGVzVG9SZWYoeGF4aXMsIHlheGlzLCB6YXhpcywgcmVzdWx0KSB7XG4gICAgICAgIE1hdHJpeC5Gcm9tVmFsdWVzVG9SZWYoeGF4aXMueCwgeGF4aXMueSwgeGF4aXMueiwgMC4wLCB5YXhpcy54LCB5YXhpcy55LCB5YXhpcy56LCAwLjAsIHpheGlzLngsIHpheGlzLnksIHpheGlzLnosIDAuMCwgMC4wLCAwLjAsIDAuMCwgMS4wLCByZXN1bHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcm90YXRpb24gbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIGFuZCBzdG9yZXMgaXQgaW4gYSB0YXJnZXQgbWF0cml4XG4gICAgICogQHBhcmFtIHF1YXQgLSBkZWZpbmVzIHRoZSBxdWF0ZXJuaW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgbWF0cml4XG4gICAgICovXG4gICAgc3RhdGljIEZyb21RdWF0ZXJuaW9uVG9SZWYocXVhdCwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHh4ID0gcXVhdC54ICogcXVhdC54O1xuICAgICAgICBjb25zdCB5eSA9IHF1YXQueSAqIHF1YXQueTtcbiAgICAgICAgY29uc3QgenogPSBxdWF0LnogKiBxdWF0Lno7XG4gICAgICAgIGNvbnN0IHh5ID0gcXVhdC54ICogcXVhdC55O1xuICAgICAgICBjb25zdCB6dyA9IHF1YXQueiAqIHF1YXQudztcbiAgICAgICAgY29uc3QgenggPSBxdWF0LnogKiBxdWF0Lng7XG4gICAgICAgIGNvbnN0IHl3ID0gcXVhdC55ICogcXVhdC53O1xuICAgICAgICBjb25zdCB5eiA9IHF1YXQueSAqIHF1YXQuejtcbiAgICAgICAgY29uc3QgeHcgPSBxdWF0LnggKiBxdWF0Lnc7XG4gICAgICAgIHJlc3VsdC5fbVswXSA9IDEuMCAtIDIuMCAqICh5eSArIHp6KTtcbiAgICAgICAgcmVzdWx0Ll9tWzFdID0gMi4wICogKHh5ICsgencpO1xuICAgICAgICByZXN1bHQuX21bMl0gPSAyLjAgKiAoenggLSB5dyk7XG4gICAgICAgIHJlc3VsdC5fbVszXSA9IDAuMDtcbiAgICAgICAgcmVzdWx0Ll9tWzRdID0gMi4wICogKHh5IC0gencpO1xuICAgICAgICByZXN1bHQuX21bNV0gPSAxLjAgLSAyLjAgKiAoenogKyB4eCk7XG4gICAgICAgIHJlc3VsdC5fbVs2XSA9IDIuMCAqICh5eiArIHh3KTtcbiAgICAgICAgcmVzdWx0Ll9tWzddID0gMC4wO1xuICAgICAgICByZXN1bHQuX21bOF0gPSAyLjAgKiAoenggKyB5dyk7XG4gICAgICAgIHJlc3VsdC5fbVs5XSA9IDIuMCAqICh5eiAtIHh3KTtcbiAgICAgICAgcmVzdWx0Ll9tWzEwXSA9IDEuMCAtIDIuMCAqICh5eSArIHh4KTtcbiAgICAgICAgcmVzdWx0Ll9tWzExXSA9IDAuMDtcbiAgICAgICAgcmVzdWx0Ll9tWzEyXSA9IDAuMDtcbiAgICAgICAgcmVzdWx0Ll9tWzEzXSA9IDAuMDtcbiAgICAgICAgcmVzdWx0Ll9tWzE0XSA9IDAuMDtcbiAgICAgICAgcmVzdWx0Ll9tWzE1XSA9IDEuMDtcbiAgICAgICAgcmVzdWx0Ll9tYXJrQXNVcGRhdGVkKCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbWFya0FzVXBkYXRlZCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGbGFnID0gTWF0cml4Ll91cGRhdGVGbGFnU2VlZCsrO1xuICAgICAgICB0aGlzLl9pc0lkZW50aXR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzSWRlbnRpdHkzeDIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNJZGVudGl0eURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNJZGVudGl0eTN4MkRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUHJvcGVydGllc1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IG1hdHJpeCBpcyBpZGVudGl0eVxuICAgICAqIEByZXR1cm5zIHRydWUgaXMgdGhlIG1hdHJpeCBpcyB0aGUgaWRlbnRpdHkgbWF0cml4XG4gICAgICovXG4gICAgaXNJZGVudGl0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSWRlbnRpdHlEaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5faXNJZGVudGl0eURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBtID0gdGhpcy5fbTtcbiAgICAgICAgICAgIHRoaXMuX2lzSWRlbnRpdHkgPVxuICAgICAgICAgICAgICAgIG1bMF0gPT09IDEuMCAmJlxuICAgICAgICAgICAgICAgICAgICBtWzFdID09PSAwLjAgJiZcbiAgICAgICAgICAgICAgICAgICAgbVsyXSA9PT0gMC4wICYmXG4gICAgICAgICAgICAgICAgICAgIG1bM10gPT09IDAuMCAmJlxuICAgICAgICAgICAgICAgICAgICBtWzRdID09PSAwLjAgJiZcbiAgICAgICAgICAgICAgICAgICAgbVs1XSA9PT0gMS4wICYmXG4gICAgICAgICAgICAgICAgICAgIG1bNl0gPT09IDAuMCAmJlxuICAgICAgICAgICAgICAgICAgICBtWzddID09PSAwLjAgJiZcbiAgICAgICAgICAgICAgICAgICAgbVs4XSA9PT0gMC4wICYmXG4gICAgICAgICAgICAgICAgICAgIG1bOV0gPT09IDAuMCAmJlxuICAgICAgICAgICAgICAgICAgICBtWzEwXSA9PT0gMS4wICYmXG4gICAgICAgICAgICAgICAgICAgIG1bMTFdID09PSAwLjAgJiZcbiAgICAgICAgICAgICAgICAgICAgbVsxMl0gPT09IDAuMCAmJlxuICAgICAgICAgICAgICAgICAgICBtWzEzXSA9PT0gMC4wICYmXG4gICAgICAgICAgICAgICAgICAgIG1bMTRdID09PSAwLjAgJiZcbiAgICAgICAgICAgICAgICAgICAgbVsxNV0gPT09IDEuMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faXNJZGVudGl0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgbWF0cml4IGlzIGlkZW50aXR5IGFzIGEgdGV4dHVyZSBtYXRyaXggKDN4MiBzdG9yZSBpbiA0eDQpXG4gICAgICogQHJldHVybnMgdHJ1ZSBpcyB0aGUgbWF0cml4IGlzIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAgICAgKi9cbiAgICBpc0lkZW50aXR5QXMzeDIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0lkZW50aXR5M3gyRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzSWRlbnRpdHkzeDJEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX21bMF0gIT09IDEuMCB8fCB0aGlzLl9tWzVdICE9PSAxLjAgfHwgdGhpcy5fbVsxNV0gIT09IDEuMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzSWRlbnRpdHkzeDIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX21bMV0gIT09IDAuMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21bMl0gIT09IDAuMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21bM10gIT09IDAuMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21bNF0gIT09IDAuMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21bNl0gIT09IDAuMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21bN10gIT09IDAuMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21bOF0gIT09IDAuMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21bOV0gIT09IDAuMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21bMTBdICE9PSAwLjAgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9tWzExXSAhPT0gMC4wIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fbVsxMl0gIT09IDAuMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21bMTNdICE9PSAwLjAgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9tWzE0XSAhPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNJZGVudGl0eTN4MiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNJZGVudGl0eTN4MiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSWRlbnRpdHkzeDI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRldGVybWluYW50IG9mIHRoZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgbWF0cml4IGRldGVybWluYW50XG4gICAgICovXG4gICAgZGV0ZXJtaW5hbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0lkZW50aXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtID0gdGhpcy5fbTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cbiAgICAgICAgY29uc3QgbTAwID0gbVswXSwgbTAxID0gbVsxXSwgbTAyID0gbVsyXSwgbTAzID0gbVszXTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cbiAgICAgICAgY29uc3QgbTEwID0gbVs0XSwgbTExID0gbVs1XSwgbTEyID0gbVs2XSwgbTEzID0gbVs3XTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cbiAgICAgICAgY29uc3QgbTIwID0gbVs4XSwgbTIxID0gbVs5XSwgbTIyID0gbVsxMF0sIG0yMyA9IG1bMTFdO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b25lLXZhcmlhYmxlLXBlci1kZWNsYXJhdGlvblxuICAgICAgICBjb25zdCBtMzAgPSBtWzEyXSwgbTMxID0gbVsxM10sIG0zMiA9IG1bMTRdLCBtMzMgPSBtWzE1XTtcbiAgICAgICAgLypcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFwbGFjZV9leHBhbnNpb25cbiAgICAgICAgLy8gdG8gY29tcHV0ZSB0aGUgZGV0ZXJybWluYW50IG9mIGEgNHg0IE1hdHJpeCB3ZSBjb21wdXRlIHRoZSBjb2ZhY3RvcnMgb2YgYW55IHJvdyBvciBjb2x1bW4sXG4gICAgICAgIC8vIHRoZW4gd2UgbXVsdGlwbHkgZWFjaCBDb2ZhY3RvciBieSBpdHMgY29ycmVzcG9uZGluZyBtYXRyaXggdmFsdWUgYW5kIHN1bSB0aGVtIGFsbCB0byBnZXQgdGhlIGRldGVybWluYW50XG4gICAgICAgIC8vIENvZmFjdG9yKGksIGopID0gc2lnbihpLGopICogZGV0KE1pbm9yKGksIGopKVxuICAgICAgICAvLyB3aGVyZVxuICAgICAgICAvLyAgLSBzaWduKGksaikgPSAoaStqKSAlIDIgPT09IDAgPyAxIDogLTFcbiAgICAgICAgLy8gIC0gTWlub3IoaSwgaikgaXMgdGhlIDN4MyBtYXRyaXggd2UgZ2V0IGJ5IHJlbW92aW5nIHJvdyBpIGFuZCBjb2x1bW4gaiBmcm9tIGN1cnJlbnQgTWF0cml4XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhlcmUgd2UgZG8gdGhhdCBmb3IgdGhlIDFzdCByb3cuXG4gICAgICAgICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlOnZhcmlhYmxlLW5hbWVcbiAgICAgICAgY29uc3QgZGV0XzIyXzMzID0gbTIyICogbTMzIC0gbTMyICogbTIzO1xuICAgICAgICBjb25zdCBkZXRfMjFfMzMgPSBtMjEgKiBtMzMgLSBtMzEgKiBtMjM7XG4gICAgICAgIGNvbnN0IGRldF8yMV8zMiA9IG0yMSAqIG0zMiAtIG0zMSAqIG0yMjtcbiAgICAgICAgY29uc3QgZGV0XzIwXzMzID0gbTIwICogbTMzIC0gbTMwICogbTIzO1xuICAgICAgICBjb25zdCBkZXRfMjBfMzIgPSBtMjAgKiBtMzIgLSBtMjIgKiBtMzA7XG4gICAgICAgIGNvbnN0IGRldF8yMF8zMSA9IG0yMCAqIG0zMSAtIG0zMCAqIG0yMTtcbiAgICAgICAgY29uc3QgY29mYWN0XzAwID0gKyhtMTEgKiBkZXRfMjJfMzMgLSBtMTIgKiBkZXRfMjFfMzMgKyBtMTMgKiBkZXRfMjFfMzIpO1xuICAgICAgICBjb25zdCBjb2ZhY3RfMDEgPSAtKG0xMCAqIGRldF8yMl8zMyAtIG0xMiAqIGRldF8yMF8zMyArIG0xMyAqIGRldF8yMF8zMik7XG4gICAgICAgIGNvbnN0IGNvZmFjdF8wMiA9ICsobTEwICogZGV0XzIxXzMzIC0gbTExICogZGV0XzIwXzMzICsgbTEzICogZGV0XzIwXzMxKTtcbiAgICAgICAgY29uc3QgY29mYWN0XzAzID0gLShtMTAgKiBkZXRfMjFfMzIgLSBtMTEgKiBkZXRfMjBfMzIgKyBtMTIgKiBkZXRfMjBfMzEpO1xuICAgICAgICAvLyB0c2xpbnQ6ZW5hYmxlOnZhcmlhYmxlLW5hbWVcbiAgICAgICAgcmV0dXJuIG0wMCAqIGNvZmFjdF8wMCArIG0wMSAqIGNvZmFjdF8wMSArIG0wMiAqIGNvZmFjdF8wMiArIG0wMyAqIGNvZmFjdF8wMztcbiAgICB9XG4gICAgLy8gTWV0aG9kc1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdHJpeCBhcyBhIEZsb2F0QXJyYXlcbiAgICAgKiBAcmV0dXJucyB0aGUgbWF0cml4IHVuZGVybHlpbmcgYXJyYXlcbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0cml4IGFzIGEgRmxvYXRBcnJheVxuICAgICAqIEByZXR1cm5zIHRoZSBtYXRyaXggdW5kZXJseWluZyBhcnJheS5cbiAgICAgKi9cbiAgICBhc0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJ0cyB0aGUgY3VycmVudCBtYXRyaXggaW4gcGxhY2VcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBpbnZlcnRlZCBtYXRyaXhcbiAgICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHRoaXMuaW52ZXJ0VG9SZWYodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGFsbCB0aGUgbWF0cml4IGVsZW1lbnRzIHRvIHplcm9cbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZigwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIHRoaXMpO1xuICAgICAgICB0aGlzLl91cGRhdGVJZGVudGl0eVN0YXR1cyhmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIGEgc2Vjb25kIG9uZVxuICAgICAqIEBwYXJhbSBvdGhlciAtIGRlZmluZXMgdGhlIG1hdHJpeCB0byBhZGRcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBtYXRyaXggYXMgdGhlIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IG1hdHJpeCBhbmQgdGhlIGdpdmVuIG9uZVxuICAgICAqL1xuICAgIGFkZChvdGhlcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIHRoaXMuYWRkVG9SZWYob3RoZXIsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIG1hdHJpeCBcInJlc3VsdFwiIHRvIHRoZSBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBtYXRyaXggYW5kIHRoZSBnaXZlbiBvbmVcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBkZWZpbmVzIHRoZSBtYXRyaXggdG8gYWRkXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKi9cbiAgICBhZGRUb1JlZihvdGhlciwgcmVzdWx0KSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCAxNjsgaW5kZXgrKykge1xuICAgICAgICAgICAgcmVzdWx0Ll9tW2luZGV4XSA9IHRoaXMuX21baW5kZXhdICsgb3RoZXIuX21baW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5fbWFya0FzVXBkYXRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBpbiBwbGFjZSB0aGUgZ2l2ZW4gbWF0cml4IHRvIHRoZSBjdXJyZW50IG1hdHJpeFxuICAgICAqIEBwYXJhbSBvdGhlciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBtYXRyaXhcbiAgICAgKi9cbiAgICBhZGRUb1NlbGYob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDE2OyBpbmRleCsrKSB7XG4gICAgICAgICAgICB0aGlzLl9tW2luZGV4XSArPSBvdGhlci5fbVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFya0FzVXBkYXRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gbWF0cml4IHRvIHRoZSBjdXJyZW50IGludmVydGVkIE1hdHJpeFxuICAgICAqIEBwYXJhbSBvdGhlciAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgdW5tb2RpZmllZCBjdXJyZW50IG1hdHJpeFxuICAgICAqL1xuICAgIGludmVydFRvUmVmKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0lkZW50aXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBNYXRyaXguSWRlbnRpdHlUb1JlZihvdGhlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgaW52ZXJzZSBvZiBhIE1hdHJpeCBpcyB0aGUgdHJhbnNwb3NlIG9mIGNvZmFjdG9yIG1hdHJpeCBkaXZpZGVkIGJ5IHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBjb25zdCBtID0gdGhpcy5fbTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGU6b25lLXZhcmlhYmxlLXBlci1kZWNsYXJhdGlvblxuICAgICAgICBjb25zdCBtMDAgPSBtWzBdLCBtMDEgPSBtWzFdLCBtMDIgPSBtWzJdLCBtMDMgPSBtWzNdO1xuICAgICAgICBjb25zdCBtMTAgPSBtWzRdLCBtMTEgPSBtWzVdLCBtMTIgPSBtWzZdLCBtMTMgPSBtWzddO1xuICAgICAgICBjb25zdCBtMjAgPSBtWzhdLCBtMjEgPSBtWzldLCBtMjIgPSBtWzEwXSwgbTIzID0gbVsxMV07XG4gICAgICAgIGNvbnN0IG0zMCA9IG1bMTJdLCBtMzEgPSBtWzEzXSwgbTMyID0gbVsxNF0sIG0zMyA9IG1bMTVdO1xuICAgICAgICAvLyB0c2xpbnQ6ZW5hYmxlOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGU6dmFyaWFibGUtbmFtZVxuICAgICAgICBjb25zdCBkZXRfMjJfMzMgPSBtMjIgKiBtMzMgLSBtMzIgKiBtMjM7XG4gICAgICAgIGNvbnN0IGRldF8yMV8zMyA9IG0yMSAqIG0zMyAtIG0zMSAqIG0yMztcbiAgICAgICAgY29uc3QgZGV0XzIxXzMyID0gbTIxICogbTMyIC0gbTMxICogbTIyO1xuICAgICAgICBjb25zdCBkZXRfMjBfMzMgPSBtMjAgKiBtMzMgLSBtMzAgKiBtMjM7XG4gICAgICAgIGNvbnN0IGRldF8yMF8zMiA9IG0yMCAqIG0zMiAtIG0yMiAqIG0zMDtcbiAgICAgICAgY29uc3QgZGV0XzIwXzMxID0gbTIwICogbTMxIC0gbTMwICogbTIxO1xuICAgICAgICBjb25zdCBjb2ZhY3RfMDAgPSArKG0xMSAqIGRldF8yMl8zMyAtIG0xMiAqIGRldF8yMV8zMyArIG0xMyAqIGRldF8yMV8zMik7XG4gICAgICAgIGNvbnN0IGNvZmFjdF8wMSA9IC0obTEwICogZGV0XzIyXzMzIC0gbTEyICogZGV0XzIwXzMzICsgbTEzICogZGV0XzIwXzMyKTtcbiAgICAgICAgY29uc3QgY29mYWN0XzAyID0gKyhtMTAgKiBkZXRfMjFfMzMgLSBtMTEgKiBkZXRfMjBfMzMgKyBtMTMgKiBkZXRfMjBfMzEpO1xuICAgICAgICBjb25zdCBjb2ZhY3RfMDMgPSAtKG0xMCAqIGRldF8yMV8zMiAtIG0xMSAqIGRldF8yMF8zMiArIG0xMiAqIGRldF8yMF8zMSk7XG4gICAgICAgIGNvbnN0IGRldCA9IG0wMCAqIGNvZmFjdF8wMCArIG0wMSAqIGNvZmFjdF8wMSArIG0wMiAqIGNvZmFjdF8wMiArIG0wMyAqIGNvZmFjdF8wMztcbiAgICAgICAgaWYgKGRldCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gbm90IGludmVydGlibGVcbiAgICAgICAgICAgIG90aGVyLmNvcHlGcm9tKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGV0SW52ID0gMSAvIGRldDtcbiAgICAgICAgY29uc3QgZGV0XzEyXzMzID0gbTEyICogbTMzIC0gbTMyICogbTEzO1xuICAgICAgICBjb25zdCBkZXRfMTFfMzMgPSBtMTEgKiBtMzMgLSBtMzEgKiBtMTM7XG4gICAgICAgIGNvbnN0IGRldF8xMV8zMiA9IG0xMSAqIG0zMiAtIG0zMSAqIG0xMjtcbiAgICAgICAgY29uc3QgZGV0XzEwXzMzID0gbTEwICogbTMzIC0gbTMwICogbTEzO1xuICAgICAgICBjb25zdCBkZXRfMTBfMzIgPSBtMTAgKiBtMzIgLSBtMzAgKiBtMTI7XG4gICAgICAgIGNvbnN0IGRldF8xMF8zMSA9IG0xMCAqIG0zMSAtIG0zMCAqIG0xMTtcbiAgICAgICAgY29uc3QgZGV0XzEyXzIzID0gbTEyICogbTIzIC0gbTIyICogbTEzO1xuICAgICAgICBjb25zdCBkZXRfMTFfMjMgPSBtMTEgKiBtMjMgLSBtMjEgKiBtMTM7XG4gICAgICAgIGNvbnN0IGRldF8xMV8yMiA9IG0xMSAqIG0yMiAtIG0yMSAqIG0xMjtcbiAgICAgICAgY29uc3QgZGV0XzEwXzIzID0gbTEwICogbTIzIC0gbTIwICogbTEzO1xuICAgICAgICBjb25zdCBkZXRfMTBfMjIgPSBtMTAgKiBtMjIgLSBtMjAgKiBtMTI7XG4gICAgICAgIGNvbnN0IGRldF8xMF8yMSA9IG0xMCAqIG0yMSAtIG0yMCAqIG0xMTtcbiAgICAgICAgY29uc3QgY29mYWN0XzEwID0gLShtMDEgKiBkZXRfMjJfMzMgLSBtMDIgKiBkZXRfMjFfMzMgKyBtMDMgKiBkZXRfMjFfMzIpO1xuICAgICAgICBjb25zdCBjb2ZhY3RfMTEgPSArKG0wMCAqIGRldF8yMl8zMyAtIG0wMiAqIGRldF8yMF8zMyArIG0wMyAqIGRldF8yMF8zMik7XG4gICAgICAgIGNvbnN0IGNvZmFjdF8xMiA9IC0obTAwICogZGV0XzIxXzMzIC0gbTAxICogZGV0XzIwXzMzICsgbTAzICogZGV0XzIwXzMxKTtcbiAgICAgICAgY29uc3QgY29mYWN0XzEzID0gKyhtMDAgKiBkZXRfMjFfMzIgLSBtMDEgKiBkZXRfMjBfMzIgKyBtMDIgKiBkZXRfMjBfMzEpO1xuICAgICAgICBjb25zdCBjb2ZhY3RfMjAgPSArKG0wMSAqIGRldF8xMl8zMyAtIG0wMiAqIGRldF8xMV8zMyArIG0wMyAqIGRldF8xMV8zMik7XG4gICAgICAgIGNvbnN0IGNvZmFjdF8yMSA9IC0obTAwICogZGV0XzEyXzMzIC0gbTAyICogZGV0XzEwXzMzICsgbTAzICogZGV0XzEwXzMyKTtcbiAgICAgICAgY29uc3QgY29mYWN0XzIyID0gKyhtMDAgKiBkZXRfMTFfMzMgLSBtMDEgKiBkZXRfMTBfMzMgKyBtMDMgKiBkZXRfMTBfMzEpO1xuICAgICAgICBjb25zdCBjb2ZhY3RfMjMgPSAtKG0wMCAqIGRldF8xMV8zMiAtIG0wMSAqIGRldF8xMF8zMiArIG0wMiAqIGRldF8xMF8zMSk7XG4gICAgICAgIGNvbnN0IGNvZmFjdF8zMCA9IC0obTAxICogZGV0XzEyXzIzIC0gbTAyICogZGV0XzExXzIzICsgbTAzICogZGV0XzExXzIyKTtcbiAgICAgICAgY29uc3QgY29mYWN0XzMxID0gKyhtMDAgKiBkZXRfMTJfMjMgLSBtMDIgKiBkZXRfMTBfMjMgKyBtMDMgKiBkZXRfMTBfMjIpO1xuICAgICAgICBjb25zdCBjb2ZhY3RfMzIgPSAtKG0wMCAqIGRldF8xMV8yMyAtIG0wMSAqIGRldF8xMF8yMyArIG0wMyAqIGRldF8xMF8yMSk7XG4gICAgICAgIGNvbnN0IGNvZmFjdF8zMyA9ICsobTAwICogZGV0XzExXzIyIC0gbTAxICogZGV0XzEwXzIyICsgbTAyICogZGV0XzEwXzIxKTtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZihjb2ZhY3RfMDAgKiBkZXRJbnYsIGNvZmFjdF8xMCAqIGRldEludiwgY29mYWN0XzIwICogZGV0SW52LCBjb2ZhY3RfMzAgKiBkZXRJbnYsIGNvZmFjdF8wMSAqIGRldEludiwgY29mYWN0XzExICogZGV0SW52LCBjb2ZhY3RfMjEgKiBkZXRJbnYsIGNvZmFjdF8zMSAqIGRldEludiwgY29mYWN0XzAyICogZGV0SW52LCBjb2ZhY3RfMTIgKiBkZXRJbnYsIGNvZmFjdF8yMiAqIGRldEludiwgY29mYWN0XzMyICogZGV0SW52LCBjb2ZhY3RfMDMgKiBkZXRJbnYsIGNvZmFjdF8xMyAqIGRldEludiwgY29mYWN0XzIzICogZGV0SW52LCBjb2ZhY3RfMzMgKiBkZXRJbnYsIG90aGVyKTtcbiAgICAgICAgLy8gdHNsaW50OmVuYWJsZTp2YXJpYWJsZS1uYW1lXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGQgYSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSBjdXJyZW50IE1hdHJpeFxuICAgICAqIEBwYXJhbSBpbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgdmFsdWUgd2l0aGluIHRoZSBtYXRyaXguIGJldHdlZW4gMCBhbmQgMTUuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIGFkZGVkXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBtYXRyaXhcbiAgICAgKi9cbiAgICBhZGRBdEluZGV4KGluZGV4LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tW2luZGV4XSArPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fbWFya0FzVXBkYXRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogbXV0aXBseSB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSBjdXJyZW50IE1hdHJpeCBieSBhIHZhbHVlXG4gICAgICogQHBhcmFtIGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSB3aXRoaW4gdGhlIG1hdHJpeC4gYmV0d2VlbiAwIGFuZCAxNS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYmUgYWRkZWRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIG1hdHJpeFxuICAgICAqL1xuICAgIG11bHRpcGx5QXRJbmRleChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbVtpbmRleF0gKj0gdmFsdWU7XG4gICAgICAgIHRoaXMuX21hcmtBc1VwZGF0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciAodXNpbmcgMyBmbG9hdHMpIGluIHRoZSBjdXJyZW50IG1hdHJpeFxuICAgICAqIEBwYXJhbSB4IC0gZGVmaW5lcyB0aGUgMXN0IGNvbXBvbmVudCBvZiB0aGUgdHJhbnNsYXRpb25cbiAgICAgKiBAcGFyYW0geSAtIGRlZmluZXMgdGhlIDJuZCBjb21wb25lbnQgb2YgdGhlIHRyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIHogLSBkZWZpbmVzIHRoZSAzcmQgY29tcG9uZW50IG9mIHRoZSB0cmFuc2xhdGlvblxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgbWF0cml4XG4gICAgICovXG4gICAgc2V0VHJhbnNsYXRpb25Gcm9tRmxvYXRzKHgsIHksIHopIHtcbiAgICAgICAgdGhpcy5fbVsxMl0gPSB4O1xuICAgICAgICB0aGlzLl9tWzEzXSA9IHk7XG4gICAgICAgIHRoaXMuX21bMTRdID0gejtcbiAgICAgICAgdGhpcy5fbWFya0FzVXBkYXRlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGluIHRoZSBjdXJyZW50IG1hdHJpeFxuICAgICAqIEBwYXJhbSB2ZWN0b3IzIC0gZGVmaW5lcyB0aGUgdHJhbnNsYXRpb24gdG8gaW5zZXJ0XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBtYXRyaXhcbiAgICAgKi9cbiAgICBzZXRUcmFuc2xhdGlvbih2ZWN0b3IzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFRyYW5zbGF0aW9uRnJvbUZsb2F0cyh2ZWN0b3IzLngsIHZlY3RvcjMueSwgdmVjdG9yMy56KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdHJhbnNsYXRpb24gdmFsdWUgb2YgdGhlIGN1cnJlbnQgbWF0cml4XG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMyBhcyB0aGUgZXh0cmFjdGVkIHRyYW5zbGF0aW9uIGZyb20gdGhlIG1hdHJpeFxuICAgICAqL1xuICAgIGdldFRyYW5zbGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjNfMS5WZWN0b3IzKHRoaXMuX21bMTJdLCB0aGlzLl9tWzEzXSwgdGhpcy5fbVsxNF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWxsIGEgVmVjdG9yMyB3aXRoIHRoZSBleHRyYWN0ZWQgdHJhbnNsYXRpb24gZnJvbSB0aGUgbWF0cml4XG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIFZlY3RvcjMgd2hlcmUgdG8gc3RvcmUgdGhlIHRyYW5zbGF0aW9uXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgbWF0cml4XG4gICAgICovXG4gICAgZ2V0VHJhbnNsYXRpb25Ub1JlZihyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnggPSB0aGlzLl9tWzEyXTtcbiAgICAgICAgcmVzdWx0LnkgPSB0aGlzLl9tWzEzXTtcbiAgICAgICAgcmVzdWx0LnogPSB0aGlzLl9tWzE0XTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSByb3RhdGlvbiBhbmQgc2NhbGluZyBwYXJ0IGZyb20gdGhlIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIG1hdHJpeFxuICAgICAqL1xuICAgIHJlbW92ZVJvdGF0aW9uQW5kU2NhbGluZygpIHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMubTtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZigxLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCBtWzEyXSwgbVsxM10sIG1bMTRdLCBtWzE1XSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUlkZW50aXR5U3RhdHVzKG1bMTJdID09PSAwICYmIG1bMTNdID09PSAwICYmIG1bMTRdID09PSAwICYmIG1bMTVdID09PSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBtYXRyaWNlc1xuICAgICAqIEBwYXJhbSBvdGhlciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgYSBuZXcgbWF0cml4IHNldCB3aXRoIHRoZSBtdWx0aXBsaWNhdGlvbiByZXN1bHQgb2YgdGhlIGN1cnJlbnQgTWF0cml4IGFuZCB0aGUgZ2l2ZW4gb25lXG4gICAgICovXG4gICAgbXVsdGlwbHkob3RoZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICB0aGlzLm11bHRpcGx5VG9SZWYob3RoZXIsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgdGhlIGN1cnJlbnQgbWF0cml4IGZyb20gdGhlIGdpdmVuIG9uZVxuICAgICAqIEBwYXJhbSBvdGhlciAtIGRlZmluZXMgdGhlIHNvdXJjZSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIG1hdHJpeFxuICAgICAqL1xuICAgIGNvcHlGcm9tKG90aGVyKSB7XG4gICAgICAgIG90aGVyLmNvcHlUb0FycmF5KHRoaXMuX20pO1xuICAgICAgICBjb25zdCBvID0gb3RoZXI7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUlkZW50aXR5U3RhdHVzKG8uX2lzSWRlbnRpdHksIG8uX2lzSWRlbnRpdHlEaXJ0eSwgby5faXNJZGVudGl0eTN4Miwgby5faXNJZGVudGl0eTN4MkRpcnR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyB0aGUgZ2l2ZW4gYXJyYXkgZnJvbSB0aGUgc3RhcnRpbmcgaW5kZXggd2l0aCB0aGUgY3VycmVudCBtYXRyaXggdmFsdWVzXG4gICAgICogQHBhcmFtIGFycmF5IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IGFycmF5XG4gICAgICogQHBhcmFtIG9mZnNldCAtIGRlZmluZXMgdGhlIG9mZnNldCBpbiB0aGUgdGFyZ2V0IGFycmF5IHdoZXJlIHRvIHN0YXJ0IHN0b3JpbmcgdmFsdWVzXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgbWF0cml4XG4gICAgICovXG4gICAgY29weVRvQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDE2OyBpbmRleCsrKSB7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB0aGlzLl9tW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gbWF0cml4IFwicmVzdWx0XCIgd2l0aCB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIHRoZSBjdXJyZW50IE1hdHJpeCBhbmQgdGhlIGdpdmVuIG9uZVxuICAgICAqIEBwYXJhbSBvdGhlciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIG1hdHJpeCB3aGVyZSB0byBzdG9yZSB0aGUgbXVsdGlwbGljYXRpb25cbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKi9cbiAgICBtdWx0aXBseVRvUmVmKG90aGVyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSWRlbnRpdHkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb3B5RnJvbShvdGhlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIuX2lzSWRlbnRpdHkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb3B5RnJvbSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXVsdGlwbHlUb0FycmF5KG90aGVyLCByZXN1bHQuX20sIDApO1xuICAgICAgICByZXN1bHQuX21hcmtBc1VwZGF0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEZsb2F0QXJyYXkgXCJyZXN1bHRcIiBmcm9tIHRoZSBnaXZlbiBpbmRleCBcIm9mZnNldFwiIHdpdGggdGhlIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IG1hdHJpeCBhbmQgdGhlIGdpdmVuIG9uZVxuICAgICAqIEBwYXJhbSBvdGhlciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIGFycmF5IHdoZXJlIHRvIHN0b3JlIHRoZSBtdWx0aXBsaWNhdGlvblxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBkZWZpbmVzIHRoZSBvZmZzZXQgaW4gdGhlIHRhcmdldCBhcnJheSB3aGVyZSB0byBzdGFydCBzdG9yaW5nIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IG1hdHJpeFxuICAgICAqL1xuICAgIG11bHRpcGx5VG9BcnJheShvdGhlciwgcmVzdWx0LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX207XG4gICAgICAgIGNvbnN0IG90aGVyTSA9IG90aGVyLm07XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cbiAgICAgICAgY29uc3QgdG0wID0gbVswXSwgdG0xID0gbVsxXSwgdG0yID0gbVsyXSwgdG0zID0gbVszXTtcbiAgICAgICAgY29uc3QgdG00ID0gbVs0XSwgdG01ID0gbVs1XSwgdG02ID0gbVs2XSwgdG03ID0gbVs3XTtcbiAgICAgICAgY29uc3QgdG04ID0gbVs4XSwgdG05ID0gbVs5XSwgdG0xMCA9IG1bMTBdLCB0bTExID0gbVsxMV07XG4gICAgICAgIGNvbnN0IHRtMTIgPSBtWzEyXSwgdG0xMyA9IG1bMTNdLCB0bTE0ID0gbVsxNF0sIHRtMTUgPSBtWzE1XTtcbiAgICAgICAgY29uc3Qgb20wID0gb3RoZXJNWzBdLCBvbTEgPSBvdGhlck1bMV0sIG9tMiA9IG90aGVyTVsyXSwgb20zID0gb3RoZXJNWzNdO1xuICAgICAgICBjb25zdCBvbTQgPSBvdGhlck1bNF0sIG9tNSA9IG90aGVyTVs1XSwgb202ID0gb3RoZXJNWzZdLCBvbTcgPSBvdGhlck1bN107XG4gICAgICAgIGNvbnN0IG9tOCA9IG90aGVyTVs4XSwgb205ID0gb3RoZXJNWzldLCBvbTEwID0gb3RoZXJNWzEwXSwgb20xMSA9IG90aGVyTVsxMV07XG4gICAgICAgIGNvbnN0IG9tMTIgPSBvdGhlck1bMTJdLCBvbTEzID0gb3RoZXJNWzEzXSwgb20xNCA9IG90aGVyTVsxNF0sIG9tMTUgPSBvdGhlck1bMTVdO1xuICAgICAgICAvLyB0c2xpbnQ6ZW5hYmxlOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cbiAgICAgICAgcmVzdWx0W29mZnNldF0gPSB0bTAgKiBvbTAgKyB0bTEgKiBvbTQgKyB0bTIgKiBvbTggKyB0bTMgKiBvbTEyO1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgMV0gPSB0bTAgKiBvbTEgKyB0bTEgKiBvbTUgKyB0bTIgKiBvbTkgKyB0bTMgKiBvbTEzO1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgMl0gPSB0bTAgKiBvbTIgKyB0bTEgKiBvbTYgKyB0bTIgKiBvbTEwICsgdG0zICogb20xNDtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIDNdID0gdG0wICogb20zICsgdG0xICogb203ICsgdG0yICogb20xMSArIHRtMyAqIG9tMTU7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyA0XSA9IHRtNCAqIG9tMCArIHRtNSAqIG9tNCArIHRtNiAqIG9tOCArIHRtNyAqIG9tMTI7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyA1XSA9IHRtNCAqIG9tMSArIHRtNSAqIG9tNSArIHRtNiAqIG9tOSArIHRtNyAqIG9tMTM7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyA2XSA9IHRtNCAqIG9tMiArIHRtNSAqIG9tNiArIHRtNiAqIG9tMTAgKyB0bTcgKiBvbTE0O1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgN10gPSB0bTQgKiBvbTMgKyB0bTUgKiBvbTcgKyB0bTYgKiBvbTExICsgdG03ICogb20xNTtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIDhdID0gdG04ICogb20wICsgdG05ICogb200ICsgdG0xMCAqIG9tOCArIHRtMTEgKiBvbTEyO1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgOV0gPSB0bTggKiBvbTEgKyB0bTkgKiBvbTUgKyB0bTEwICogb205ICsgdG0xMSAqIG9tMTM7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyAxMF0gPSB0bTggKiBvbTIgKyB0bTkgKiBvbTYgKyB0bTEwICogb20xMCArIHRtMTEgKiBvbTE0O1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgMTFdID0gdG04ICogb20zICsgdG05ICogb203ICsgdG0xMCAqIG9tMTEgKyB0bTExICogb20xNTtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIDEyXSA9IHRtMTIgKiBvbTAgKyB0bTEzICogb200ICsgdG0xNCAqIG9tOCArIHRtMTUgKiBvbTEyO1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgMTNdID0gdG0xMiAqIG9tMSArIHRtMTMgKiBvbTUgKyB0bTE0ICogb205ICsgdG0xNSAqIG9tMTM7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyAxNF0gPSB0bTEyICogb20yICsgdG0xMyAqIG9tNiArIHRtMTQgKiBvbTEwICsgdG0xNSAqIG9tMTQ7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyAxNV0gPSB0bTEyICogb20zICsgdG0xMyAqIG9tNyArIHRtMTQgKiBvbTExICsgdG0xNSAqIG9tMTU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBlcXVhbGl0eSBiZXR3ZWVuIHRoaXMgbWF0cml4IGFuZCBhIHNlY29uZCBvbmVcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBkZWZpbmVzIHRoZSBzZWNvbmQgbWF0cml4IHRvIGNvbXBhcmVcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlzIHRoZSBjdXJyZW50IG1hdHJpeCBhbmQgdGhlIGdpdmVuIG9uZSB2YWx1ZXMgYXJlIHN0cmljdGx5IGVxdWFsXG4gICAgICovXG4gICAgZXF1YWxzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG90aGVyID0gdmFsdWU7XG4gICAgICAgIGlmICghb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNJZGVudGl0eSB8fCBvdGhlci5faXNJZGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0lkZW50aXR5RGlydHkgJiYgIW90aGVyLl9pc0lkZW50aXR5RGlydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNJZGVudGl0eSAmJiBvdGhlci5faXNJZGVudGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtID0gdGhpcy5tO1xuICAgICAgICBjb25zdCBvbSA9IG90aGVyLm07XG4gICAgICAgIHJldHVybiAobVswXSA9PT0gb21bMF0gJiZcbiAgICAgICAgICAgIG1bMV0gPT09IG9tWzFdICYmXG4gICAgICAgICAgICBtWzJdID09PSBvbVsyXSAmJlxuICAgICAgICAgICAgbVszXSA9PT0gb21bM10gJiZcbiAgICAgICAgICAgIG1bNF0gPT09IG9tWzRdICYmXG4gICAgICAgICAgICBtWzVdID09PSBvbVs1XSAmJlxuICAgICAgICAgICAgbVs2XSA9PT0gb21bNl0gJiZcbiAgICAgICAgICAgIG1bN10gPT09IG9tWzddICYmXG4gICAgICAgICAgICBtWzhdID09PSBvbVs4XSAmJlxuICAgICAgICAgICAgbVs5XSA9PT0gb21bOV0gJiZcbiAgICAgICAgICAgIG1bMTBdID09PSBvbVsxMF0gJiZcbiAgICAgICAgICAgIG1bMTFdID09PSBvbVsxMV0gJiZcbiAgICAgICAgICAgIG1bMTJdID09PSBvbVsxMl0gJiZcbiAgICAgICAgICAgIG1bMTNdID09PSBvbVsxM10gJiZcbiAgICAgICAgICAgIG1bMTRdID09PSBvbVsxNF0gJiZcbiAgICAgICAgICAgIG1bMTVdID09PSBvbVsxNV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBtYXRyaXggZnJvbSB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICBtYXRyaXguY29weUZyb20odGhpcyk7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbWF0cml4IGNsYXNzXG4gICAgICogQHJldHVybnMgdGhlIHN0cmluZyBcIk1hdHJpeFwiXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ01hdHJpeCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhhc2ggY29kZSBvZiB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgaGFzaCBjb2RlXG4gICAgICovXG4gICAgZ2V0SGFzaENvZGUoKSB7XG4gICAgICAgIGxldCBoYXNoID0gdGhpcy5fbVswXSB8fCAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIGhhc2ggPSAoaGFzaCAqIDM5NykgXiAodGhpcy5fbVtpXSB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb21wb3NlcyB0aGUgY3VycmVudCBNYXRyaXggaW50byBhIHRyYW5zbGF0aW9uLCByb3RhdGlvbiBhbmQgc2NhbGluZyBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIHNjYWxlIC0gZGVmaW5lcyB0aGUgc2NhbGUgdmVjdG9yMyBnaXZlbiBhcyBhIHJlZmVyZW5jZSB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gcm90YXRpb24gLSBkZWZpbmVzIHRoZSByb3RhdGlvbiBxdWF0ZXJuaW9uIGdpdmVuIGFzIGEgcmVmZXJlbmNlIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbiAtIGRlZmluZXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvcjMgZ2l2ZW4gYXMgYSByZWZlcmVuY2UgdG8gdXBkYXRlXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBvcGVyYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgKi9cbiAgICBkZWNvbXBvc2Uoc2NhbGUsIHJvdGF0aW9uLCB0cmFuc2xhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5faXNJZGVudGl0eSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24uc2V0QWxsKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUuc2V0QWxsKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcm90YXRpb24uY29weUZyb21GbG9hdHMoMCwgMCwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtID0gdGhpcy5fbTtcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbi5jb3B5RnJvbUZsb2F0cyhtWzEyXSwgbVsxM10sIG1bMTRdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VkU2NhbGUgPSBzY2FsZSB8fCBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLlZlY3RvcjNbMF07XG4gICAgICAgIHVzZWRTY2FsZS54ID0gTWF0aC5zcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0gKyBtWzJdICogbVsyXSk7XG4gICAgICAgIHVzZWRTY2FsZS55ID0gTWF0aC5zcXJ0KG1bNF0gKiBtWzRdICsgbVs1XSAqIG1bNV0gKyBtWzZdICogbVs2XSk7XG4gICAgICAgIHVzZWRTY2FsZS56ID0gTWF0aC5zcXJ0KG1bOF0gKiBtWzhdICsgbVs5XSAqIG1bOV0gKyBtWzEwXSAqIG1bMTBdKTtcbiAgICAgICAgaWYgKHRoaXMuZGV0ZXJtaW5hbnQoKSA8PSAwKSB7XG4gICAgICAgICAgICB1c2VkU2NhbGUueSAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlZFNjYWxlLnggPT09IDAgfHwgdXNlZFNjYWxlLnkgPT09IDAgfHwgdXNlZFNjYWxlLnogPT09IDApIHtcbiAgICAgICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHJvdGF0aW9uLmNvcHlGcm9tRmxvYXRzKDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b25lLXZhcmlhYmxlLXBlci1kZWNsYXJhdGlvblxuICAgICAgICAgICAgY29uc3Qgc3ggPSAxIC8gdXNlZFNjYWxlLngsIHN5ID0gMSAvIHVzZWRTY2FsZS55LCBzeiA9IDEgLyB1c2VkU2NhbGUuejtcbiAgICAgICAgICAgIE1hdHJpeC5Gcm9tVmFsdWVzVG9SZWYobVswXSAqIHN4LCBtWzFdICogc3gsIG1bMl0gKiBzeCwgMC4wLCBtWzRdICogc3ksIG1bNV0gKiBzeSwgbVs2XSAqIHN5LCAwLjAsIG1bOF0gKiBzeiwgbVs5XSAqIHN6LCBtWzEwXSAqIHN6LCAwLjAsIDAuMCwgMC4wLCAwLjAsIDEuMCwgcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5NYXRyaXhbMF0pO1xuICAgICAgICAgICAgUXVhdGVybmlvbl8xLlF1YXRlcm5pb24uRnJvbVJvdGF0aW9uTWF0cml4VG9SZWYocHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5NYXRyaXhbMF0sIHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBzcGVjaWZpYyByb3cgb2YgdGhlIG1hdHJpeFxuICAgICAqIEBwYXJhbSBpbmRleCAtIGRlZmluZXMgdGhlIG51bWJlciBvZiB0aGUgcm93IHRvIGdldFxuICAgICAqIEByZXR1cm5zIHRoZSBpbmRleC10aCByb3cgb2YgdGhlIGN1cnJlbnQgbWF0cml4IGFzIGEgbmV3IFZlY3RvcjRcbiAgICAgKi9cbiAgICBnZXRSb3coaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkgPSBpbmRleCAqIDQ7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yNF8xLlZlY3RvcjQodGhpcy5fbVtpICsgMF0sIHRoaXMuX21baSArIDFdLCB0aGlzLl9tW2kgKyAyXSwgdGhpcy5fbVtpICsgM10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbmRleC10aCByb3cgb2YgdGhlIGN1cnJlbnQgbWF0cml4IHRvIHRoZSB2ZWN0b3I0IHZhbHVlc1xuICAgICAqIEBwYXJhbSBpbmRleCAtIGRlZmluZXMgdGhlIG51bWJlciBvZiB0aGUgcm93IHRvIHNldFxuICAgICAqIEBwYXJhbSByb3cgLSBkZWZpbmVzIHRoZSB0YXJnZXQgdmVjdG9yNFxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIGN1cnJlbnQgbWF0cml4XG4gICAgICovXG4gICAgc2V0Um93KGluZGV4LCByb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0Um93RnJvbUZsb2F0cyhpbmRleCwgcm93LngsIHJvdy55LCByb3cueiwgcm93LncpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSB0cmFuc3Bvc2Ugb2YgdGhlIG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgdHJhbnNwb3NlZCBtYXRyaXhcbiAgICAgKi9cbiAgICB0cmFuc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiBNYXRyaXguVHJhbnNwb3NlKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSB0cmFuc3Bvc2Ugb2YgdGhlIG1hdHJpeCBhbmQgc3RvcmUgaXQgaW4gYSBnaXZlbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IG1hdHJpeFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IG1hdHJpeFxuICAgICAqL1xuICAgIHRyYW5zcG9zZVRvUmVmKHJlc3VsdCkge1xuICAgICAgICBNYXRyaXguVHJhbnNwb3NlVG9SZWYodGhpcywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluZGV4LXRoIHJvdyBvZiB0aGUgY3VycmVudCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gNCB4IGZsb2F0IHZhbHVlc1xuICAgICAqIEBwYXJhbSBpbmRleCAtIGRlZmluZXMgdGhlIHJvdyBpbmRleFxuICAgICAqIEBwYXJhbSB4IC0gZGVmaW5lcyB0aGUgeCBjb21wb25lbnQgdG8gc2V0XG4gICAgICogQHBhcmFtIHkgLSBkZWZpbmVzIHRoZSB5IGNvbXBvbmVudCB0byBzZXRcbiAgICAgKiBAcGFyYW0geiAtIGRlZmluZXMgdGhlIHogY29tcG9uZW50IHRvIHNldFxuICAgICAqIEBwYXJhbSB3IC0gZGVmaW5lcyB0aGUgdyBjb21wb25lbnQgdG8gc2V0XG4gICAgICogQHJldHVybnMgdGhlIHVwZGF0ZWQgY3VycmVudCBtYXRyaXhcbiAgICAgKi9cbiAgICBzZXRSb3dGcm9tRmxvYXRzKGluZGV4LCB4LCB5LCB6LCB3KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiAzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpID0gaW5kZXggKiA0O1xuICAgICAgICB0aGlzLl9tW2kgKyAwXSA9IHg7XG4gICAgICAgIHRoaXMuX21baSArIDFdID0geTtcbiAgICAgICAgdGhpcy5fbVtpICsgMl0gPSB6O1xuICAgICAgICB0aGlzLl9tW2kgKyAzXSA9IHc7XG4gICAgICAgIHRoaXMuX21hcmtBc1VwZGF0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgYSBuZXcgbWF0cml4IHNldCB3aXRoIHRoZSBjdXJyZW50IG1hdHJpeCB2YWx1ZXMgbXVsdGlwbGllZCBieSBzY2FsZSAoZmxvYXQpXG4gICAgICogQHBhcmFtIHNjYWxlIC0gZGVmaW5lcyB0aGUgc2NhbGUgZmFjdG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgbWF0cml4XG4gICAgICovXG4gICAgc2NhbGUoc2NhbGUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICB0aGlzLnNjYWxlVG9SZWYoc2NhbGUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBjdXJyZW50IG1hdHJpeCB2YWx1ZXMgYnkgYSBmYWN0b3IgdG8gYSBnaXZlbiByZXN1bHQgbWF0cml4XG4gICAgICogQHBhcmFtIHNjYWxlIC0gZGVmaW5lcyB0aGUgc2NhbGUgZmFjdG9yXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIG1hdHJpeCB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgbWF0cml4XG4gICAgICovXG4gICAgc2NhbGVUb1JlZihzY2FsZSwgcmVzdWx0KSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCAxNjsgaW5kZXgrKykge1xuICAgICAgICAgICAgcmVzdWx0Ll9tW2luZGV4XSA9IHRoaXMuX21baW5kZXhdICogc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Ll9tYXJrQXNVcGRhdGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZSB0aGUgY3VycmVudCBtYXRyaXggdmFsdWVzIGJ5IGEgZmFjdG9yIGFuZCBhZGQgdGhlIHJlc3VsdCB0byBhIGdpdmVuIG1hdHJpeFxuICAgICAqIEBwYXJhbSBzY2FsZSAtIGRlZmluZXMgdGhlIHNjYWxlIGZhY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBNYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IG1hdHJpeFxuICAgICAqL1xuICAgIHNjYWxlQW5kQWRkVG9SZWYoc2NhbGUsIHJlc3VsdCkge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgMTY7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5fbVtpbmRleF0gKz0gdGhpcy5fbVtpbmRleF0gKiBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuX21hcmtBc1VwZGF0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyB0byB0aGUgZ2l2ZW4gbWF0cml4IGEgbm9ybWFsIG1hdHJpeCwgY29tcHV0ZWQgZnJvbSB0aGlzIG9uZSAodXNpbmcgdmFsdWVzIGZyb20gaWRlbnRpdHkgbWF0cml4IGZvciBmb3VydGggcm93IGFuZCBjb2x1bW4pLlxuICAgICAqIEBwYXJhbSByZWYgLSBtYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIHRvTm9ybWFsTWF0cml4KHJlZikge1xuICAgICAgICBjb25zdCB0bXAgPSBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLk1hdHJpeFswXTtcbiAgICAgICAgdGhpcy5pbnZlcnRUb1JlZih0bXApO1xuICAgICAgICB0bXAudHJhbnNwb3NlVG9SZWYocmVmKTtcbiAgICAgICAgY29uc3QgbSA9IHJlZi5fbTtcbiAgICAgICAgTWF0cml4LkZyb21WYWx1ZXNUb1JlZihtWzBdLCBtWzFdLCBtWzJdLCAwLjAsIG1bNF0sIG1bNV0sIG1bNl0sIDAuMCwgbVs4XSwgbVs5XSwgbVsxMF0sIDAuMCwgMC4wLCAwLjAsIDAuMCwgMS4wLCByZWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9ubHkgcm90YXRpb24gcGFydCBvZiB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBtYXRyaXggc2V0cyB0byB0aGUgZXh0cmFjdGVkIHJvdGF0aW9uIG1hdHJpeCBmcm9tIHRoZSBjdXJyZW50IG9uZVxuICAgICAqL1xuICAgIGdldFJvdGF0aW9uTWF0cml4KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIHRoaXMuZ2V0Um90YXRpb25NYXRyaXhUb1JlZihyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgcm90YXRpb24gbWF0cml4IGZyb20gdGhlIGN1cnJlbnQgb25lIGFuZCBzZXRzIGl0IGFzIHRoZSBnaXZlbiBcInJlc3VsdFwiXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXggdG8gc3RvcmUgZGF0YSB0b1xuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IG1hdHJpeFxuICAgICAqL1xuICAgIGdldFJvdGF0aW9uTWF0cml4VG9SZWYocmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5WZWN0b3IzWzBdO1xuICAgICAgICBpZiAoIXRoaXMuZGVjb21wb3NlKHNjYWxlKSkge1xuICAgICAgICAgICAgTWF0cml4LklkZW50aXR5VG9SZWYocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9tO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b25lLXZhcmlhYmxlLXBlci1kZWNsYXJhdGlvblxuICAgICAgICBjb25zdCBzeCA9IDEgLyBzY2FsZS54LCBzeSA9IDEgLyBzY2FsZS55LCBzeiA9IDEgLyBzY2FsZS56O1xuICAgICAgICBNYXRyaXguRnJvbVZhbHVlc1RvUmVmKG1bMF0gKiBzeCwgbVsxXSAqIHN4LCBtWzJdICogc3gsIDAuMCwgbVs0XSAqIHN5LCBtWzVdICogc3ksIG1bNl0gKiBzeSwgMC4wLCBtWzhdICogc3osIG1bOV0gKiBzeiwgbVsxMF0gKiBzeiwgMC4wLCAwLjAsIDAuMCwgMC4wLCAxLjAsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIG1vZGVsIG1hdHJpeCBmcm9tIGJlaW5nIHJpZ2h0IGhhbmRlZCB0byBsZWZ0IGhhbmRlZCBpbiBwbGFjZSBhbmQgdmljZSB2ZXJzYVxuICAgICAqL1xuICAgIHRvZ2dsZU1vZGVsTWF0cml4SGFuZEluUGxhY2UoKSB7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9tO1xuICAgICAgICBtWzJdICo9IC0xO1xuICAgICAgICBtWzZdICo9IC0xO1xuICAgICAgICBtWzhdICo9IC0xO1xuICAgICAgICBtWzldICo9IC0xO1xuICAgICAgICBtWzE0XSAqPSAtMTtcbiAgICAgICAgdGhpcy5fbWFya0FzVXBkYXRlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHByb2plY3Rpb24gbWF0cml4IGZyb20gYmVpbmcgcmlnaHQgaGFuZGVkIHRvIGxlZnQgaGFuZGVkIGluIHBsYWNlIGFuZCB2aWNlIHZlcnNhXG4gICAgICovXG4gICAgdG9nZ2xlUHJvamVjdGlvbk1hdHJpeEhhbmRJblBsYWNlKCkge1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fbTtcbiAgICAgICAgbVs4XSAqPSAtMTtcbiAgICAgICAgbVs5XSAqPSAtMTtcbiAgICAgICAgbVsxMF0gKj0gLTE7XG4gICAgICAgIG1bMTFdICo9IC0xO1xuICAgICAgICB0aGlzLl9tYXJrQXNVcGRhdGVkKCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlSWRlbnRpdHlTdGF0dXMoaXNJZGVudGl0eSwgaXNJZGVudGl0eURpcnR5ID0gZmFsc2UsIGlzSWRlbnRpdHkzeDIgPSBmYWxzZSwgaXNJZGVudGl0eTN4MkRpcnR5ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZsYWcgPSBNYXRyaXguX3VwZGF0ZUZsYWdTZWVkKys7XG4gICAgICAgIHRoaXMuX2lzSWRlbnRpdHkgPSBpc0lkZW50aXR5O1xuICAgICAgICB0aGlzLl9pc0lkZW50aXR5M3gyID0gaXNJZGVudGl0eSB8fCBpc0lkZW50aXR5M3gyO1xuICAgICAgICB0aGlzLl9pc0lkZW50aXR5RGlydHkgPSB0aGlzLl9pc0lkZW50aXR5ID8gZmFsc2UgOiBpc0lkZW50aXR5RGlydHk7XG4gICAgICAgIHRoaXMuX2lzSWRlbnRpdHkzeDJEaXJ0eSA9IHRoaXMuX2lzSWRlbnRpdHkzeDIgPyBmYWxzZSA6IGlzSWRlbnRpdHkzeDJEaXJ0eTtcbiAgICB9XG59XG5leHBvcnRzLk1hdHJpeCA9IE1hdHJpeDtcbk1hdHJpeC5fdXBkYXRlRmxhZ1NlZWQgPSAwO1xuTWF0cml4Ll9pZGVudGl0eVJlYWRPbmx5ID0gTWF0cml4LklkZW50aXR5KCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRyaXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1YXRlcm5pb24gPSB2b2lkIDA7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbmNvbnN0IFZlY3RvcjNfMSA9IHJlcXVpcmUoXCIuL1ZlY3RvcjNcIik7XG5jb25zdCBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMSA9IHJlcXVpcmUoXCIuL3ByZWFsbG9jYXRlZFZhcmlhYmxlc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IFNjYWxhcl8xID0gcmVxdWlyZShcIi4vU2NhbGFyXCIpO1xuLyoqXG4gKiBDbGFzcyB1c2VkIHRvIHN0b3JlIHF1YXRlcm5pb24gZGF0YVxuICoge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1YXRlcm5pb24gfVxuICoge0BsaW5rIGh0dHA6Ly9kb2MuYmFieWxvbmpzLmNvbS9mZWF0dXJlcy9wb3NpdGlvbixfcm90YXRpb24sX3NjYWxpbmcgfVxuICogQHB1YmxpY1xuICovXG5jbGFzcyBRdWF0ZXJuaW9uIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gZmxvYXRzXG4gICAgICogQHBhcmFtIHggLSBkZWZpbmVzIHRoZSBmaXJzdCBjb21wb25lbnQgKDAgYnkgZGVmYXVsdClcbiAgICAgKiBAcGFyYW0geSAtIGRlZmluZXMgdGhlIHNlY29uZCBjb21wb25lbnQgKDAgYnkgZGVmYXVsdClcbiAgICAgKiBAcGFyYW0geiAtIGRlZmluZXMgdGhlIHRoaXJkIGNvbXBvbmVudCAoMCBieSBkZWZhdWx0KVxuICAgICAqIEBwYXJhbSB3IC0gZGVmaW5lcyB0aGUgZm91cnRoIGNvbXBvbmVudCAoMS4wIGJ5IGRlZmF1bHQpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIGRlZmluZXMgdGhlIGZpcnN0IGNvbXBvbmVudCAoMCBieSBkZWZhdWx0KSAqL1xuICAgIHggPSAwLjAsIFxuICAgIC8qKiBkZWZpbmVzIHRoZSBzZWNvbmQgY29tcG9uZW50ICgwIGJ5IGRlZmF1bHQpICovXG4gICAgeSA9IDAuMCwgXG4gICAgLyoqIGRlZmluZXMgdGhlIHRoaXJkIGNvbXBvbmVudCAoMCBieSBkZWZhdWx0KSAqL1xuICAgIHogPSAwLjAsIFxuICAgIC8qKiBkZWZpbmVzIHRoZSBmb3VydGggY29tcG9uZW50ICgxLjAgYnkgZGVmYXVsdCkgKi9cbiAgICB3ID0gMS4wKSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgfVxuICAgIC8vIFN0YXRpY3NcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHF1YXRlcm5pb24gZnJvbSBhIHJvdGF0aW9uIG1hdHJpeFxuICAgICAqIEBwYXJhbSBtYXRyaXggLSBkZWZpbmVzIHRoZSBzb3VyY2UgbWF0cml4XG4gICAgICogQHJldHVybnMgYSBuZXcgcXVhdGVybmlvbiBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIHJvdGF0aW9uIG1hdHJpeCB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbVJvdGF0aW9uTWF0cml4KG1hdHJpeCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgICBRdWF0ZXJuaW9uLkZyb21Sb3RhdGlvbk1hdHJpeFRvUmVmKG1hdHJpeCwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gcXVhdGVybmlvbiB3aXRoIHRoZSBnaXZlbiByb3RhdGlvbiBtYXRyaXggdmFsdWVzXG4gICAgICogQHBhcmFtIG1hdHJpeCAtIGRlZmluZXMgdGhlIHNvdXJjZSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbVJvdGF0aW9uTWF0cml4VG9SZWYobWF0cml4LCByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG1hdHJpeC5tO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpvbmUtdmFyaWFibGUtcGVyLWRlY2xhcmF0aW9uXG4gICAgICAgIGNvbnN0IG0xMSA9IGRhdGFbMF0sIG0xMiA9IGRhdGFbNF0sIG0xMyA9IGRhdGFbOF07XG4gICAgICAgIGNvbnN0IG0yMSA9IGRhdGFbMV0sIG0yMiA9IGRhdGFbNV0sIG0yMyA9IGRhdGFbOV07XG4gICAgICAgIGNvbnN0IG0zMSA9IGRhdGFbMl0sIG0zMiA9IGRhdGFbNl0sIG0zMyA9IGRhdGFbMTBdO1xuICAgICAgICAvLyB0c2xpbnQ6ZW5hYmxlOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cbiAgICAgICAgY29uc3QgdHJhY2UgPSBtMTEgKyBtMjIgKyBtMzM7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBpZiAodHJhY2UgPiAwKSB7XG4gICAgICAgICAgICBzID0gMC41IC8gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKTtcbiAgICAgICAgICAgIHJlc3VsdC53ID0gMC4yNSAvIHM7XG4gICAgICAgICAgICByZXN1bHQueCA9IChtMzIgLSBtMjMpICogcztcbiAgICAgICAgICAgIHJlc3VsdC55ID0gKG0xMyAtIG0zMSkgKiBzO1xuICAgICAgICAgICAgcmVzdWx0LnogPSAobTIxIC0gbTEyKSAqIHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobTExID4gbTIyICYmIG0xMSA+IG0zMykge1xuICAgICAgICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCgxLjAgKyBtMTEgLSBtMjIgLSBtMzMpO1xuICAgICAgICAgICAgcmVzdWx0LncgPSAobTMyIC0gbTIzKSAvIHM7XG4gICAgICAgICAgICByZXN1bHQueCA9IDAuMjUgKiBzO1xuICAgICAgICAgICAgcmVzdWx0LnkgPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICByZXN1bHQueiA9IChtMTMgKyBtMzEpIC8gcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtMjIgPiBtMzMpIHtcbiAgICAgICAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTExIC0gbTMzKTtcbiAgICAgICAgICAgIHJlc3VsdC53ID0gKG0xMyAtIG0zMSkgLyBzO1xuICAgICAgICAgICAgcmVzdWx0LnggPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICAgICAgICByZXN1bHQueSA9IDAuMjUgKiBzO1xuICAgICAgICAgICAgcmVzdWx0LnogPSAobTIzICsgbTMyKSAvIHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzID0gMi4wICogTWF0aC5zcXJ0KDEuMCArIG0zMyAtIG0xMSAtIG0yMik7XG4gICAgICAgICAgICByZXN1bHQudyA9IChtMjEgLSBtMTIpIC8gcztcbiAgICAgICAgICAgIHJlc3VsdC54ID0gKG0xMyArIG0zMSkgLyBzO1xuICAgICAgICAgICAgcmVzdWx0LnkgPSAobTIzICsgbTMyKSAvIHM7XG4gICAgICAgICAgICByZXN1bHQueiA9IDAuMjUgKiBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IChmbG9hdCkgYmV0d2VlbiB0aGUgcXVhdGVybmlvbnMgXCJsZWZ0XCIgYW5kIFwicmlnaHRcIlxuICAgICAqIEBwYXJhbSBsZWZ0IC0gZGVmaW5lcyB0aGUgbGVmdCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyB0aGUgcmlnaHQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBEb3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIChsZWZ0LnggKiByaWdodC54ICsgbGVmdC55ICogcmlnaHQueSArIGxlZnQueiAqIHJpZ2h0LnogKyBsZWZ0LncgKiByaWdodC53KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSB0d28gcXVhdGVybmlvbnMgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXJcbiAgICAgKiBAcGFyYW0gcXVhdDAgLSBkZWZpbmVzIHRoZSBmaXJzdCBxdWF0ZXJuaW9uIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHF1YXQxIC0gZGVmaW5lcyB0aGUgc2Vjb25kIHF1YXRlcm5pb24gdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB0d28gcXVhdGVybmlvbnMgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgQXJlQ2xvc2UocXVhdDAsIHF1YXQxKSB7XG4gICAgICAgIGNvbnN0IGRvdCA9IFF1YXRlcm5pb24uRG90KHF1YXQwLCBxdWF0MSk7XG4gICAgICAgIHJldHVybiBkb3QgPj0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlbXB0eSBxdWF0ZXJuaW9uXG4gICAgICogQHJldHVybnMgYSBuZXcgcXVhdGVybmlvbiBzZXQgdG8gKDAuMCwgMC4wLCAwLjApXG4gICAgICovXG4gICAgc3RhdGljIFplcm8oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIGEgZ2l2ZW4gcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBxIC0gZGVmaW5lcyB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAgICAgKiBAcmV0dXJucyBhIG5ldyBxdWF0ZXJuaW9uIGFzIHRoZSBpbnZlcnRlZCBjdXJyZW50IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBzdGF0aWMgSW52ZXJzZShxKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbigtcS54LCAtcS55LCAtcS56LCBxLncpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBnaXZlbiBxdWF0ZXJuaW9uIGlzIGlkZW50aXR5XG4gICAgICogQHBhcmFtIHF1YXRlcm5pb24gLSBkZWZpbmVzIHRoZSBxdWF0ZXJuaW9uIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcXVhdGVybmlvbiBpcyBpZGVudGl0eVxuICAgICAqL1xuICAgIHN0YXRpYyBJc0lkZW50aXR5KHF1YXRlcm5pb24pIHtcbiAgICAgICAgcmV0dXJuIChxdWF0ZXJuaW9uICYmXG4gICAgICAgICAgICBxdWF0ZXJuaW9uLnggPT09IDAgJiZcbiAgICAgICAgICAgIHF1YXRlcm5pb24ueSA9PT0gMCAmJlxuICAgICAgICAgICAgcXVhdGVybmlvbi56ID09PSAwICYmXG4gICAgICAgICAgICBxdWF0ZXJuaW9uLncgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIGEgcm90YXRpb24gYXJvdW5kIGFuIGF4aXNcbiAgICAgKiBAcGFyYW0gYXhpcyAtIGRlZmluZXMgdGhlIGF4aXMgdG8gdXNlXG4gICAgICogQHBhcmFtIGFuZ2xlIC0gZGVmaW5lcyB0aGUgYW5nbGUgdG8gdXNlIChpbiBFdWxlciBkZWdyZWVzKVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHF1YXRlcm5pb24gY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBheGlzIChWZWN0b3IzKSBhbmQgYW5nbGUgaW4gcmFkaWFucyAoZmxvYXQpXG4gICAgICovXG4gICAgc3RhdGljIFJvdGF0aW9uQXhpcyhheGlzLCBhbmdsZSkge1xuICAgICAgICBjb25zdCBhbmdsZVJhZCA9IGFuZ2xlICogdHlwZXNfMS5ERUcyUkFEO1xuICAgICAgICByZXR1cm4gUXVhdGVybmlvbi5Sb3RhdGlvbkF4aXNUb1JlZihheGlzLCBhbmdsZVJhZCwgbmV3IFF1YXRlcm5pb24oKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByb3RhdGlvbiBhcm91bmQgYW4gYXhpcyBhbmQgc3RvcmVzIGl0IGludG8gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gYXhpcyAtIGRlZmluZXMgdGhlIGF4aXMgdG8gdXNlXG4gICAgICogQHBhcmFtIGFuZ2xlIC0gZGVmaW5lcyB0aGUgYW5nbGUgdG8gdXNlIChpbiBFdWxlciBkZWdyZWVzKVxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgcXVhdGVybmlvblxuICAgICAqIEByZXR1cm5zIHRoZSB0YXJnZXQgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHN0YXRpYyBSb3RhdGlvbkF4aXNUb1JlZihheGlzLCBhbmdsZSwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkID0gYW5nbGUgKiB0eXBlc18xLkRFRzJSQUQ7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlUmFkIC8gMik7XG4gICAgICAgIGF4aXMubm9ybWFsaXplKCk7XG4gICAgICAgIHJlc3VsdC53ID0gTWF0aC5jb3MoYW5nbGVSYWQgLyAyKTtcbiAgICAgICAgcmVzdWx0LnggPSBheGlzLnggKiBzaW47XG4gICAgICAgIHJlc3VsdC55ID0gYXhpcy55ICogc2luO1xuICAgICAgICByZXN1bHQueiA9IGF4aXMueiAqIHNpbjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBxdWF0ZXJuaW9uIGZyb20gZGF0YSBzdG9yZWQgaW50byBhbiBhcnJheVxuICAgICAqIEBwYXJhbSBhcnJheSAtIGRlZmluZXMgdGhlIGRhdGEgc291cmNlXG4gICAgICogQHBhcmFtIG9mZnNldCAtIGRlZmluZXMgdGhlIG9mZnNldCBpbiB0aGUgc291cmNlIGFycmF5IHdoZXJlIHRoZSBkYXRhIHN0YXJ0c1xuICAgICAqIEByZXR1cm5zIGEgbmV3IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbihhcnJheVtvZmZzZXRdLCBhcnJheVtvZmZzZXQgKyAxXSwgYXJyYXlbb2Zmc2V0ICsgMl0sIGFycmF5W29mZnNldCArIDNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBxdWF0ZXJuaW9uIGZyb20gYSBzZXQgb2YgZXVsZXIgYW5nbGVzIGFuZCBzdG9yZXMgaXQgaW4gdGhlIHRhcmdldCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgc3RhdGljIEZyb21FdWxlckFuZ2xlc1JlZih4LCB5LCB6LCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIFF1YXRlcm5pb24uUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih5ICogdHlwZXNfMS5ERUcyUkFELCB4ICogdHlwZXNfMS5ERUcyUkFELCB6ICogdHlwZXNfMS5ERUcyUkFELCByZXN1bHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gRXVsZXIgZmxvYXQgYW5nbGVzICh5LCB4LCB6KVxuICAgICAqIEBwYXJhbSB5YXcgLSBkZWZpbmVzIHRoZSByb3RhdGlvbiBhcm91bmQgWSBheGlzXG4gICAgICogQHBhcmFtIHBpdGNoIC0gZGVmaW5lcyB0aGUgcm90YXRpb24gYXJvdW5kIFggYXhpc1xuICAgICAqIEBwYXJhbSByb2xsIC0gZGVmaW5lcyB0aGUgcm90YXRpb24gYXJvdW5kIFogYXhpc1xuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHN0YXRpYyBSb3RhdGlvbllhd1BpdGNoUm9sbCh5YXcsIHBpdGNoLCByb2xsKSB7XG4gICAgICAgIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgICBRdWF0ZXJuaW9uLlJvdGF0aW9uWWF3UGl0Y2hSb2xsVG9SZWYoeWF3LCBwaXRjaCwgcm9sbCwgcSk7XG4gICAgICAgIHJldHVybiBxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJvdGF0aW9uIGZyb20gdGhlIGdpdmVuIEV1bGVyIGZsb2F0IGFuZ2xlcyAoeSwgeCwgeikgYW5kIHN0b3JlcyBpdCBpbiB0aGUgdGFyZ2V0IHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0geWF3IC0gZGVmaW5lcyB0aGUgcm90YXRpb24gYXJvdW5kIFkgYXhpc1xuICAgICAqIEBwYXJhbSBwaXRjaCAtIGRlZmluZXMgdGhlIHJvdGF0aW9uIGFyb3VuZCBYIGF4aXNcbiAgICAgKiBAcGFyYW0gcm9sbCAtIGRlZmluZXMgdGhlIHJvdGF0aW9uIGFyb3VuZCBaIGF4aXNcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBzdGF0aWMgUm90YXRpb25ZYXdQaXRjaFJvbGxUb1JlZih5YXcsIHBpdGNoLCByb2xsLCByZXN1bHQpIHtcbiAgICAgICAgLy8gSW1wbGVtZW50ZWQgdW5pdHktYmFzZWQgY2FsY3VsYXRpb25zIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NjA1NTgxM1xuICAgICAgICBjb25zdCBoYWxmUGl0Y2ggPSBwaXRjaCAqIDAuNTtcbiAgICAgICAgY29uc3QgaGFsZllhdyA9IHlhdyAqIDAuNTtcbiAgICAgICAgY29uc3QgaGFsZlJvbGwgPSByb2xsICogMC41O1xuICAgICAgICBjb25zdCBjMSA9IE1hdGguY29zKGhhbGZQaXRjaCk7XG4gICAgICAgIGNvbnN0IGMyID0gTWF0aC5jb3MoaGFsZllhdyk7XG4gICAgICAgIGNvbnN0IGMzID0gTWF0aC5jb3MoaGFsZlJvbGwpO1xuICAgICAgICBjb25zdCBzMSA9IE1hdGguc2luKGhhbGZQaXRjaCk7XG4gICAgICAgIGNvbnN0IHMyID0gTWF0aC5zaW4oaGFsZllhdyk7XG4gICAgICAgIGNvbnN0IHMzID0gTWF0aC5zaW4oaGFsZlJvbGwpO1xuICAgICAgICByZXN1bHQueCA9IGMyICogczEgKiBjMyArIHMyICogYzEgKiBzMztcbiAgICAgICAgcmVzdWx0LnkgPSBzMiAqIGMxICogYzMgLSBjMiAqIHMxICogczM7XG4gICAgICAgIHJlc3VsdC56ID0gYzIgKiBjMSAqIHMzIC0gczIgKiBzMSAqIGMzO1xuICAgICAgICByZXN1bHQudyA9IGMyICogYzEgKiBjMyArIHMyICogczEgKiBzMztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIEV1bGVyIGZsb2F0IGFuZ2xlcyBleHByZXNzZWQgaW4gei14LXogb3JpZW50YXRpb25cbiAgICAgKiBAcGFyYW0gYWxwaGEgLSBkZWZpbmVzIHRoZSByb3RhdGlvbiBhcm91bmQgZmlyc3QgYXhpc1xuICAgICAqIEBwYXJhbSBiZXRhIC0gZGVmaW5lcyB0aGUgcm90YXRpb24gYXJvdW5kIHNlY29uZCBheGlzXG4gICAgICogQHBhcmFtIGdhbW1hIC0gZGVmaW5lcyB0aGUgcm90YXRpb24gYXJvdW5kIHRoaXJkIGF4aXNcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBzdGF0aWMgUm90YXRpb25BbHBoYUJldGFHYW1tYShhbHBoYSwgYmV0YSwgZ2FtbWEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgICAgUXVhdGVybmlvbi5Sb3RhdGlvbkFscGhhQmV0YUdhbW1hVG9SZWYoYWxwaGEsIGJldGEsIGdhbW1hLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gRXVsZXIgZmxvYXQgYW5nbGVzIGV4cHJlc3NlZCBpbiB6LXgteiBvcmllbnRhdGlvbiBhbmQgc3RvcmVzIGl0IGluIHRoZSB0YXJnZXQgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBhbHBoYSAtIGRlZmluZXMgdGhlIHJvdGF0aW9uIGFyb3VuZCBmaXJzdCBheGlzXG4gICAgICogQHBhcmFtIGJldGEgLSBkZWZpbmVzIHRoZSByb3RhdGlvbiBhcm91bmQgc2Vjb25kIGF4aXNcbiAgICAgKiBAcGFyYW0gZ2FtbWEgLSBkZWZpbmVzIHRoZSByb3RhdGlvbiBhcm91bmQgdGhpcmQgYXhpc1xuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHN0YXRpYyBSb3RhdGlvbkFscGhhQmV0YUdhbW1hVG9SZWYoYWxwaGEsIGJldGEsIGdhbW1hLCByZXN1bHQpIHtcbiAgICAgICAgLy8gUHJvZHVjZXMgYSBxdWF0ZXJuaW9uIGZyb20gRXVsZXIgYW5nbGVzIGluIHRoZSB6LXgteiBvcmllbnRhdGlvblxuICAgICAgICBjb25zdCBoYWxmR2FtbWFQbHVzQWxwaGEgPSAoZ2FtbWEgKyBhbHBoYSkgKiAwLjU7XG4gICAgICAgIGNvbnN0IGhhbGZHYW1tYU1pbnVzQWxwaGEgPSAoZ2FtbWEgLSBhbHBoYSkgKiAwLjU7XG4gICAgICAgIGNvbnN0IGhhbGZCZXRhID0gYmV0YSAqIDAuNTtcbiAgICAgICAgcmVzdWx0LnggPSBNYXRoLmNvcyhoYWxmR2FtbWFNaW51c0FscGhhKSAqIE1hdGguc2luKGhhbGZCZXRhKTtcbiAgICAgICAgcmVzdWx0LnkgPSBNYXRoLnNpbihoYWxmR2FtbWFNaW51c0FscGhhKSAqIE1hdGguc2luKGhhbGZCZXRhKTtcbiAgICAgICAgcmVzdWx0LnogPSBNYXRoLnNpbihoYWxmR2FtbWFQbHVzQWxwaGEpICogTWF0aC5jb3MoaGFsZkJldGEpO1xuICAgICAgICByZXN1bHQudyA9IE1hdGguY29zKGhhbGZHYW1tYVBsdXNBbHBoYSkgKiBNYXRoLmNvcyhoYWxmQmV0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcXVhdGVybmlvbiBjb250YWluaW5nIHRoZSByb3RhdGlvbiB2YWx1ZSB0byByZWFjaCB0aGUgdGFyZ2V0IChheGlzMSwgYXhpczIsIGF4aXMzKSBvcmllbnRhdGlvbiBhcyBhIHJvdGF0ZWQgWFlaIHN5c3RlbSAoYXhpczEsIGF4aXMyIGFuZCBheGlzMyBhcmUgbm9ybWFsaXplZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24pXG4gICAgICogQHBhcmFtIGF4aXMxIC0gZGVmaW5lcyB0aGUgZmlyc3QgYXhpc1xuICAgICAqIEBwYXJhbSBheGlzMiAtIGRlZmluZXMgdGhlIHNlY29uZCBheGlzXG4gICAgICogQHBhcmFtIGF4aXMzIC0gZGVmaW5lcyB0aGUgdGhpcmQgYXhpc1xuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHN0YXRpYyBSb3RhdGlvblF1YXRlcm5pb25Gcm9tQXhpcyhheGlzMSwgYXhpczIsIGF4aXMzKSB7XG4gICAgICAgIGNvbnN0IHF1YXQgPSBuZXcgUXVhdGVybmlvbigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICBRdWF0ZXJuaW9uLlJvdGF0aW9uUXVhdGVybmlvbkZyb21BeGlzVG9SZWYoYXhpczEsIGF4aXMyLCBheGlzMywgcXVhdCk7XG4gICAgICAgIHJldHVybiBxdWF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcm90YXRpb24gdmFsdWUgdG8gcmVhY2ggdGhlIHRhcmdldCAoYXhpczEsIGF4aXMyLCBheGlzMykgb3JpZW50YXRpb24gYXMgYSByb3RhdGVkIFhZWiBzeXN0ZW0gKGF4aXMxLCBheGlzMiBhbmQgYXhpczMgYXJlIG5vcm1hbGl6ZWQgZHVyaW5nIHRoaXMgb3BlcmF0aW9uKSBhbmQgc3RvcmVzIGl0IGluIHRoZSB0YXJnZXQgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBheGlzMSAtIGRlZmluZXMgdGhlIGZpcnN0IGF4aXNcbiAgICAgKiBAcGFyYW0gYXhpczIgLSBkZWZpbmVzIHRoZSBzZWNvbmQgYXhpc1xuICAgICAqIEBwYXJhbSBheGlzMyAtIGRlZmluZXMgdGhlIHRoaXJkIGF4aXNcbiAgICAgKiBAcGFyYW0gcmVmIC0gZGVmaW5lcyB0aGUgdGFyZ2V0IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBzdGF0aWMgUm90YXRpb25RdWF0ZXJuaW9uRnJvbUF4aXNUb1JlZihheGlzMSwgYXhpczIsIGF4aXMzLCByZWYpIHtcbiAgICAgICAgY29uc3Qgcm90TWF0ID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5NYXRyaXhbMF07XG4gICAgICAgIE1hdHJpeF8xLk1hdHJpeC5Gcm9tWFlaQXhlc1RvUmVmKGF4aXMxLm5vcm1hbGl6ZSgpLCBheGlzMi5ub3JtYWxpemUoKSwgYXhpczMubm9ybWFsaXplKCksIHJvdE1hdCk7XG4gICAgICAgIFF1YXRlcm5pb24uRnJvbVJvdGF0aW9uTWF0cml4VG9SZWYocm90TWF0LCByZWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcnBvbGF0ZXMgYmV0d2VlbiB0d28gcXVhdGVybmlvbnNcbiAgICAgKiBAcGFyYW0gbGVmdCAtIGRlZmluZXMgZmlyc3QgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSByaWdodCAtIGRlZmluZXMgc2Vjb25kIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gZGVmaW5lcyB0aGUgZ3JhZGllbnQgdG8gdXNlXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBpbnRlcnBvbGF0ZWQgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHN0YXRpYyBTbGVycChsZWZ0LCByaWdodCwgYW1vdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFF1YXRlcm5pb24uSWRlbnRpdHk7XG4gICAgICAgIFF1YXRlcm5pb24uU2xlcnBUb1JlZihsZWZ0LCByaWdodCwgYW1vdW50LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcnBvbGF0ZXMgYmV0d2VlbiB0d28gcXVhdGVybmlvbnMgYW5kIHN0b3JlcyBpdCBpbnRvIGEgdGFyZ2V0IHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gbGVmdCAtIGRlZmluZXMgZmlyc3QgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSByaWdodCAtIGRlZmluZXMgc2Vjb25kIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gZGVmaW5lcyB0aGUgZ3JhZGllbnQgdG8gdXNlXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgc3RhdGljIFNsZXJwVG9SZWYobGVmdCwgcmlnaHQsIGFtb3VudCwgcmVzdWx0KSB7XG4gICAgICAgIGxldCBudW0yO1xuICAgICAgICBsZXQgbnVtMztcbiAgICAgICAgbGV0IG51bTQgPSBsZWZ0LnggKiByaWdodC54ICsgbGVmdC55ICogcmlnaHQueSArIGxlZnQueiAqIHJpZ2h0LnogKyBsZWZ0LncgKiByaWdodC53O1xuICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xuICAgICAgICBpZiAobnVtNCA8IDApIHtcbiAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgbnVtNCA9IC1udW00O1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW00ID4gMC45OTk5OTkpIHtcbiAgICAgICAgICAgIG51bTMgPSAxIC0gYW1vdW50O1xuICAgICAgICAgICAgbnVtMiA9IGZsYWcgPyAtYW1vdW50IDogYW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbnVtNSA9IE1hdGguYWNvcyhudW00KTtcbiAgICAgICAgICAgIGNvbnN0IG51bTYgPSAxLjAgLyBNYXRoLnNpbihudW01KTtcbiAgICAgICAgICAgIG51bTMgPSBNYXRoLnNpbigoMS4wIC0gYW1vdW50KSAqIG51bTUpICogbnVtNjtcbiAgICAgICAgICAgIG51bTIgPSBmbGFnXG4gICAgICAgICAgICAgICAgPyAtTWF0aC5zaW4oYW1vdW50ICogbnVtNSkgKiBudW02XG4gICAgICAgICAgICAgICAgOiBNYXRoLnNpbihhbW91bnQgKiBudW01KSAqIG51bTY7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnggPSBudW0zICogbGVmdC54ICsgbnVtMiAqIHJpZ2h0Lng7XG4gICAgICAgIHJlc3VsdC55ID0gbnVtMyAqIGxlZnQueSArIG51bTIgKiByaWdodC55O1xuICAgICAgICByZXN1bHQueiA9IG51bTMgKiBsZWZ0LnogKyBudW0yICogcmlnaHQuejtcbiAgICAgICAgcmVzdWx0LncgPSBudW0zICogbGVmdC53ICsgbnVtMiAqIHJpZ2h0Lnc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVycG9sYXRlIGJldHdlZW4gdHdvIHF1YXRlcm5pb25zIHVzaW5nIEhlcm1pdGUgaW50ZXJwb2xhdGlvblxuICAgICAqIEBwYXJhbSB2YWx1ZTEgLSBkZWZpbmVzIGZpcnN0IHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gdGFuZ2VudDEgLSBkZWZpbmVzIHRoZSBpbmNvbWluZyB0YW5nZW50XG4gICAgICogQHBhcmFtIHZhbHVlMiAtIGRlZmluZXMgc2Vjb25kIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gdGFuZ2VudDIgLSBkZWZpbmVzIHRoZSBvdXRnb2luZyB0YW5nZW50XG4gICAgICogQHBhcmFtIGFtb3VudCAtIGRlZmluZXMgdGhlIHRhcmdldCBxdWF0ZXJuaW9uXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBpbnRlcnBvbGF0ZWQgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHN0YXRpYyBIZXJtaXRlKHZhbHVlMSwgdGFuZ2VudDEsIHZhbHVlMiwgdGFuZ2VudDIsIGFtb3VudCkge1xuICAgICAgICBjb25zdCBzcXVhcmVkID0gYW1vdW50ICogYW1vdW50O1xuICAgICAgICBjb25zdCBjdWJlZCA9IGFtb3VudCAqIHNxdWFyZWQ7XG4gICAgICAgIGNvbnN0IHBhcnQxID0gMi4wICogY3ViZWQgLSAzLjAgKiBzcXVhcmVkICsgMS4wO1xuICAgICAgICBjb25zdCBwYXJ0MiA9IC0yLjAgKiBjdWJlZCArIDMuMCAqIHNxdWFyZWQ7XG4gICAgICAgIGNvbnN0IHBhcnQzID0gY3ViZWQgLSAyLjAgKiBzcXVhcmVkICsgYW1vdW50O1xuICAgICAgICBjb25zdCBwYXJ0NCA9IGN1YmVkIC0gc3F1YXJlZDtcbiAgICAgICAgY29uc3QgeCA9IHZhbHVlMS54ICogcGFydDEgK1xuICAgICAgICAgICAgdmFsdWUyLnggKiBwYXJ0MiArXG4gICAgICAgICAgICB0YW5nZW50MS54ICogcGFydDMgK1xuICAgICAgICAgICAgdGFuZ2VudDIueCAqIHBhcnQ0O1xuICAgICAgICBjb25zdCB5ID0gdmFsdWUxLnkgKiBwYXJ0MSArXG4gICAgICAgICAgICB2YWx1ZTIueSAqIHBhcnQyICtcbiAgICAgICAgICAgIHRhbmdlbnQxLnkgKiBwYXJ0MyArXG4gICAgICAgICAgICB0YW5nZW50Mi55ICogcGFydDQ7XG4gICAgICAgIGNvbnN0IHogPSB2YWx1ZTEueiAqIHBhcnQxICtcbiAgICAgICAgICAgIHZhbHVlMi56ICogcGFydDIgK1xuICAgICAgICAgICAgdGFuZ2VudDEueiAqIHBhcnQzICtcbiAgICAgICAgICAgIHRhbmdlbnQyLnogKiBwYXJ0NDtcbiAgICAgICAgY29uc3QgdyA9IHZhbHVlMS53ICogcGFydDEgK1xuICAgICAgICAgICAgdmFsdWUyLncgKiBwYXJ0MiArXG4gICAgICAgICAgICB0YW5nZW50MS53ICogcGFydDMgK1xuICAgICAgICAgICAgdGFuZ2VudDIudyAqIHBhcnQ0O1xuICAgICAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oeCwgeSwgeiwgdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaWRlbnRpdHkgcXVhdGVybmlvblxuICAgICAqIEByZXR1cm5zIC0gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IElkZW50aXR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oMC4wLCAwLjAsIDAuMCwgMS4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW5nbGUgaW4gZGVncmVlcyBiZXR3ZWVuIHR3byByb3RhdGlvbnMgYSBhbmQgYi5cbiAgICAgKiBAcGFyYW0gcXVhdDEgLSBkZWZpbmVzIHRoZSBmaXJzdCBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIHF1YXQyIC0gZGVmaW5lcyB0aGUgc2Vjb25kIHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBzdGF0aWMgQW5nbGUocXVhdDEsIHF1YXQyKSB7XG4gICAgICAgIGNvbnN0IGRvdCA9IFF1YXRlcm5pb24uRG90KHF1YXQxLCBxdWF0Mik7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5hYnMoZG90KSwgMSkpICogMiAqIHR5cGVzXzEuUkFEMkRFRztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJvdGF0aW9uIHRoYXQgcm90YXRlcyB6IGRlZ3JlZXMgYXJvdW5kIHRoZSB6IGF4aXMsIHggZGVncmVlcyBhcm91bmQgdGhlIHggYXhpcywgYW5kIHkgZGVncmVlcyBhcm91bmQgdGhlIHkgYXhpcy5cbiAgICAgKiBAcGFyYW0geCAtIHRoZSByb3RhdGlvbiBvbiB0aGUgeCBheGlzIGluIGV1bGVyIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0geSAtIHRoZSByb3RhdGlvbiBvbiB0aGUgeSBheGlzIGluIGV1bGVyIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0geiAtIHRoZSByb3RhdGlvbiBvbiB0aGUgeiBheGlzIGluIGV1bGVyIGRlZ3JlZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgRXVsZXIoeCwgeSwgeikge1xuICAgICAgICByZXR1cm4gUXVhdGVybmlvbi5Sb3RhdGlvbllhd1BpdGNoUm9sbCh5ICogdHlwZXNfMS5ERUcyUkFELCB4ICogdHlwZXNfMS5ERUcyUkFELCB6ICogdHlwZXNfMS5ERUcyUkFEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJvdGF0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBmb3J3YXJkIGFuZCB1cHdhcmRzIGRpcmVjdGlvbnMuXG4gICAgICogQHBhcmFtIGZvcndhcmQgLSB0aGUgZGlyZWN0aW9uIHRvIGxvb2sgaW5cbiAgICAgKiBAcGFyYW0gdXAgLSB0aGUgdmVjdG9yIHRoYXQgZGVmaW5lcyBpbiB3aGljaCBkaXJlY3Rpb24gdXAgaXNcbiAgICAgKi9cbiAgICBzdGF0aWMgTG9va1JvdGF0aW9uKGZvcndhcmQsIHVwID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5zdGF0aWNVcCkge1xuICAgICAgICBjb25zdCBmb3J3YXJkTmV3ID0gVmVjdG9yM18xLlZlY3RvcjMuTm9ybWFsaXplKGZvcndhcmQpO1xuICAgICAgICBjb25zdCByaWdodCA9IFZlY3RvcjNfMS5WZWN0b3IzLk5vcm1hbGl6ZShWZWN0b3IzXzEuVmVjdG9yMy5Dcm9zcyh1cCwgZm9yd2FyZE5ldykpO1xuICAgICAgICBjb25zdCB1cE5ldyA9IFZlY3RvcjNfMS5WZWN0b3IzLkNyb3NzKGZvcndhcmROZXcsIHJpZ2h0KTtcbiAgICAgICAgY29uc3QgbTAwID0gcmlnaHQueDtcbiAgICAgICAgY29uc3QgbTAxID0gcmlnaHQueTtcbiAgICAgICAgY29uc3QgbTAyID0gcmlnaHQuejtcbiAgICAgICAgY29uc3QgbTEwID0gdXBOZXcueDtcbiAgICAgICAgY29uc3QgbTExID0gdXBOZXcueTtcbiAgICAgICAgY29uc3QgbTEyID0gdXBOZXcuejtcbiAgICAgICAgY29uc3QgbTIwID0gZm9yd2FyZE5ldy54O1xuICAgICAgICBjb25zdCBtMjEgPSBmb3J3YXJkTmV3Lnk7XG4gICAgICAgIGNvbnN0IG0yMiA9IGZvcndhcmROZXcuejtcbiAgICAgICAgY29uc3QgbnVtOCA9IG0wMCArIG0xMSArIG0yMjtcbiAgICAgICAgY29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICAgIGlmIChudW04ID4gMCkge1xuICAgICAgICAgICAgbGV0IG51bSA9IE1hdGguc3FydChudW04ICsgMSk7XG4gICAgICAgICAgICBxdWF0ZXJuaW9uLncgPSBudW0gKiAwLjU7XG4gICAgICAgICAgICBudW0gPSAwLjUgLyBudW07XG4gICAgICAgICAgICBxdWF0ZXJuaW9uLnggPSAobTEyIC0gbTIxKSAqIG51bTtcbiAgICAgICAgICAgIHF1YXRlcm5pb24ueSA9IChtMjAgLSBtMDIpICogbnVtO1xuICAgICAgICAgICAgcXVhdGVybmlvbi56ID0gKG0wMSAtIG0xMCkgKiBudW07XG4gICAgICAgICAgICByZXR1cm4gcXVhdGVybmlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobTAwID49IG0xMSAmJiBtMDAgPj0gbTIyKSB7XG4gICAgICAgICAgICBjb25zdCBudW03ID0gTWF0aC5zcXJ0KDEgKyBtMDAgLSBtMTEgLSBtMjIpO1xuICAgICAgICAgICAgY29uc3QgbnVtNCA9IDAuNSAvIG51bTc7XG4gICAgICAgICAgICBxdWF0ZXJuaW9uLnggPSAwLjUgKiBudW03O1xuICAgICAgICAgICAgcXVhdGVybmlvbi55ID0gKG0wMSArIG0xMCkgKiBudW00O1xuICAgICAgICAgICAgcXVhdGVybmlvbi56ID0gKG0wMiArIG0yMCkgKiBudW00O1xuICAgICAgICAgICAgcXVhdGVybmlvbi53ID0gKG0xMiAtIG0yMSkgKiBudW00O1xuICAgICAgICAgICAgcmV0dXJuIHF1YXRlcm5pb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0xMSA+IG0yMikge1xuICAgICAgICAgICAgY29uc3QgbnVtNiA9IE1hdGguc3FydCgxICsgbTExIC0gbTAwIC0gbTIyKTtcbiAgICAgICAgICAgIGNvbnN0IG51bTMgPSAwLjUgLyBudW02O1xuICAgICAgICAgICAgcXVhdGVybmlvbi54ID0gKG0xMCArIG0wMSkgKiBudW0zO1xuICAgICAgICAgICAgcXVhdGVybmlvbi55ID0gMC41ICogbnVtNjtcbiAgICAgICAgICAgIHF1YXRlcm5pb24ueiA9IChtMjEgKyBtMTIpICogbnVtMztcbiAgICAgICAgICAgIHF1YXRlcm5pb24udyA9IChtMjAgLSBtMDIpICogbnVtMztcbiAgICAgICAgICAgIHJldHVybiBxdWF0ZXJuaW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bTUgPSBNYXRoLnNxcnQoMSArIG0yMiAtIG0wMCAtIG0xMSk7XG4gICAgICAgIGNvbnN0IG51bTIgPSAwLjUgLyBudW01O1xuICAgICAgICBxdWF0ZXJuaW9uLnggPSAobTIwICsgbTAyKSAqIG51bTI7XG4gICAgICAgIHF1YXRlcm5pb24ueSA9IChtMjEgKyBtMTIpICogbnVtMjtcbiAgICAgICAgcXVhdGVybmlvbi56ID0gMC41ICogbnVtNTtcbiAgICAgICAgcXVhdGVybmlvbi53ID0gKG0wMSAtIG0xMCkgKiBudW0yO1xuICAgICAgICByZXR1cm4gcXVhdGVybmlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZyb20gcXVhdGVybmlvbiBpcyByb3RhdGVkIHRvd2FyZHMgdG8gYnkgYW4gYW5ndWxhciBzdGVwIG9mIG1heERlZ3JlZXNEZWx0YS5cbiAgICAgKiBAcGFyYW0gZnJvbSAtIGRlZmluZXMgdGhlIGZpcnN0IHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gdG8gLSBkZWZpbmVzIHRoZSBzZWNvbmQgcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBtYXhEZWdyZWVzRGVsdGEgLSB0aGUgaW50ZXJ2YWwgc3RlcFxuICAgICAqL1xuICAgIHN0YXRpYyBSb3RhdGVUb3dhcmRzKGZyb20sIHRvLCBtYXhEZWdyZWVzRGVsdGEpIHtcbiAgICAgICAgY29uc3QgbnVtID0gUXVhdGVybmlvbi5BbmdsZShmcm9tLCB0byk7XG4gICAgICAgIGlmIChudW0gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ID0gTWF0aC5taW4oMSwgbWF4RGVncmVlc0RlbHRhIC8gbnVtKTtcbiAgICAgICAgcmV0dXJuIFF1YXRlcm5pb24uU2xlcnAoZnJvbSwgdG8sIHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcm90YXRpb24gd2hpY2ggcm90YXRlcyBmcm9tIGZyb21EaXJlY3Rpb24gdG8gdG9EaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIGZyb20gLSBkZWZpbmVzIHRoZSBmaXJzdCBkaXJlY3Rpb24gVmVjdG9yXG4gICAgICogQHBhcmFtIHRvIC0gZGVmaW5lcyB0aGUgdGFyZ2V0IGRpcmVjdGlvbiBWZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbVRvUm90YXRpb24oZnJvbSwgdG8sIHVwID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5zdGF0aWNVcCkge1xuICAgICAgICAvLyBVbml0eS1iYXNlZCBjYWxjdWxhdGlvbnMgaW1wbGVtZW50ZWQgZnJvbSBodHRwczovL2ZvcnVtLnVuaXR5LmNvbS90aHJlYWRzL3F1YXRlcm5pb24tbG9va3JvdGF0aW9uLWFyb3VuZC1hbi1heGlzLjYwODQ3MC8jcG9zdC00MDY5ODg4XG4gICAgICAgIGNvbnN0IHYwID0gZnJvbS5ub3JtYWxpemUoKTtcbiAgICAgICAgY29uc3QgdjEgPSB0by5ub3JtYWxpemUoKTtcbiAgICAgICAgY29uc3QgYSA9IFZlY3RvcjNfMS5WZWN0b3IzLkNyb3NzKHYwLCB2MSk7XG4gICAgICAgIGNvbnN0IHcgPSBNYXRoLnNxcnQodjAubGVuZ3RoU3F1YXJlZCgpICogdjEubGVuZ3RoU3F1YXJlZCgpKSArIFZlY3RvcjNfMS5WZWN0b3IzLkRvdCh2MCwgdjEpO1xuICAgICAgICBpZiAoYS5sZW5ndGhTcXVhcmVkKCkgPCAwLjAwMDEpIHtcbiAgICAgICAgICAgIC8vIHRoZSB2ZWN0b3JzIGFyZSBwYXJhbGxlbCwgY2hlY2sgdyB0byBmaW5kIGRpcmVjdGlvblxuICAgICAgICAgICAgLy8gaWYgdyBpcyAwIHRoZW4gdmFsdWVzIGFyZSBvcHBvc2l0ZSwgYW5kIHdlIHNvdWxkIHJvdGF0ZSAxODAgZGVncmVlcyBhcm91bmQgdGhlIHN1cHBsaWVkIGF4aXNcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGUgdmVjdG9ycyBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gYW5kIG5vIHJvdGF0aW9uIHNob3VsZCBvY2N1clxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHcpIDwgMC4wMDAxXG4gICAgICAgICAgICAgICAgPyBuZXcgUXVhdGVybmlvbih1cC54LCB1cC55LCB1cC56LCAwKS5ub3JtYWxpemVkXG4gICAgICAgICAgICAgICAgOiBRdWF0ZXJuaW9uLklkZW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKGEueCwgYS55LCBhLnosIHcpLm5vcm1hbGl6ZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBxdWF0ZXJuaW9uIHRvIG9uZSB3aXRoIHRoZSBzYW1lIG9yaWVudGF0aW9uIGJ1dCB3aXRoIGEgbWFnbml0dWRlIG9mIDEuXG4gICAgICovXG4gICAgZ2V0IG5vcm1hbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcm90YXRpb24gd2hpY2ggcm90YXRlcyBmcm9tIGZyb21EaXJlY3Rpb24gdG8gdG9EaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIGZyb20gLSBkZWZpbmVzIHRoZSBmaXJzdCBWZWN0b3JcbiAgICAgKiBAcGFyYW0gdG8gLSBkZWZpbmVzIHRoZSBzZWNvbmQgVmVjdG9yXG4gICAgICogQHBhcmFtIHVwIC0gZGVmaW5lcyB0aGUgZGlyZWN0aW9uXG4gICAgICovXG4gICAgc2V0RnJvbVRvUm90YXRpb24oZnJvbSwgdG8sIHVwID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5zdGF0aWNVcCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBRdWF0ZXJuaW9uLkZyb21Ub1JvdGF0aW9uKGZyb20sIHRvLCB1cCk7XG4gICAgICAgIHRoaXMueCA9IHJlc3VsdC54O1xuICAgICAgICB0aGlzLnkgPSByZXN1bHQueTtcbiAgICAgICAgdGhpcy56ID0gcmVzdWx0Lno7XG4gICAgICAgIHRoaXMudyA9IHJlc3VsdC53O1xuICAgIH1cbiAgICBzZXQgZXVsZXJBbmdsZXMoZXVsZXIpIHtcbiAgICAgICAgdGhpcy5zZXRFdWxlcihldWxlci54LCBldWxlci55LCBldWxlci56KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBldWxlciBhbmdsZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm90YXRpb24uXG4gICAgICogSW1wbGVtZW50ZWQgdW5pdHktYmFzZWQgY2FsY3VsYXRpb25zIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NjA1NTgxM1xuICAgICAqL1xuICAgIGdldCBldWxlckFuZ2xlcygpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFZlY3RvcjNfMS5WZWN0b3IzKCk7XG4gICAgICAgIC8vIGlmIHRoZSBpbnB1dCBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgaXMgZXhhY3RseSBvbmUuIE90aGVyd2lzZSwgdGhpcyBhY3RzIGFzIGEgY29ycmVjdGlvbiBmYWN0b3IgZm9yIHRoZSBxdWF0ZXJuaW9uJ3Mgbm90LW5vcm1hbGl6ZWRuZXNzXG4gICAgICAgIGNvbnN0IHVuaXQgPSB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBoYXZlIGEgbWFnbml0dWRlIG9mIDAuNSBvciBncmVhdGVyIGlmIGFuZCBvbmx5IGlmIHRoaXMgaXMgYSBzaW5ndWxhcml0eSBjYXNlXG4gICAgICAgIGNvbnN0IHRlc3QgPSB0aGlzLnggKiB0aGlzLncgLSB0aGlzLnkgKiB0aGlzLno7XG4gICAgICAgIGlmICh0ZXN0ID4gMC40OTk1ICogdW5pdCkge1xuICAgICAgICAgICAgLy8gc2luZ3VsYXJpdHkgYXQgbm9ydGggcG9sZVxuICAgICAgICAgICAgb3V0LnggPSBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgIG91dC55ID0gMiAqIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgICAgICAgICAgb3V0LnogPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRlc3QgPCAtMC40OTk1ICogdW5pdCkge1xuICAgICAgICAgICAgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZVxuICAgICAgICAgICAgb3V0LnggPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgICAgICBvdXQueSA9IC0yICogTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgICAgICAgICBvdXQueiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBzaW5ndWxhcml0eSAtIHRoaXMgaXMgdGhlIG1ham9yaXR5IG9mIGNhc2VzXG4gICAgICAgICAgICBvdXQueCA9IE1hdGguYXNpbigyICogKHRoaXMudyAqIHRoaXMueCAtIHRoaXMueSAqIHRoaXMueikpO1xuICAgICAgICAgICAgb3V0LnkgPSBNYXRoLmF0YW4yKDIgKiB0aGlzLncgKiB0aGlzLnkgKyAyICogdGhpcy56ICogdGhpcy54LCAxIC0gMiAqICh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpKTtcbiAgICAgICAgICAgIG91dC56ID0gTWF0aC5hdGFuMigyICogdGhpcy53ICogdGhpcy56ICsgMiAqIHRoaXMueCAqIHRoaXMueSwgMSAtIDIgKiAodGhpcy56ICogdGhpcy56ICsgdGhpcy54ICogdGhpcy54KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnggKj0gdHlwZXNfMS5SQUQyREVHO1xuICAgICAgICBvdXQueSAqPSB0eXBlc18xLlJBRDJERUc7XG4gICAgICAgIG91dC56ICo9IHR5cGVzXzEuUkFEMkRFRztcbiAgICAgICAgLy8gZW5zdXJlIHRoZSBkZWdyZWUgdmFsdWVzIGFyZSBiZXR3ZWVuIDAgYW5kIDM2MFxuICAgICAgICBvdXQueCA9IFNjYWxhcl8xLlNjYWxhci5SZXBlYXQob3V0LngsIDM2MCk7XG4gICAgICAgIG91dC55ID0gU2NhbGFyXzEuU2NhbGFyLlJlcGVhdChvdXQueSwgMzYwKTtcbiAgICAgICAgb3V0LnogPSBTY2FsYXJfMS5TY2FsYXIuUmVwZWF0KG91dC56LCAzNjApO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICogQHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgUXVhdGVybmlvbiBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCgke3RoaXMueH0sICR7dGhpcy55fSwgJHt0aGlzLnp9LCAke3RoaXMud30pYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBsZW5ndGggb2YgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICogQHJldHVybnMgdGhlIHF1YXRlcm5pb24gbGVuZ3RoIChmbG9hdClcbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3F1YXJlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgbGVuZ3RoIG9mIGN1cnJlbnQgcXVhdGVybmlvblxuICAgICAqIEByZXR1cm5zIHRoZSBxdWF0ZXJuaW9uIGxlbmd0aCAoZmxvYXQpXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aFNxdWFyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIHF1YXRlcm5pb25cbiAgICAgKiBAcmV0dXJucyB0aGUgc3RyaW5nIFwiUXVhdGVybmlvblwiXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ1F1YXRlcm5pb24nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgaGFzaCBjb2RlIGZvciB0aGlzIHF1YXRlcm5pb25cbiAgICAgKiBAcmV0dXJucyB0aGUgcXVhdGVybmlvbiBoYXNoIGNvZGVcbiAgICAgKi9cbiAgICBnZXRIYXNoQ29kZSgpIHtcbiAgICAgICAgbGV0IGhhc2ggPSB0aGlzLnggfHwgMDtcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzk3KSBeICh0aGlzLnkgfHwgMCk7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIDM5NykgXiAodGhpcy56IHx8IDApO1xuICAgICAgICBoYXNoID0gKGhhc2ggKiAzOTcpIF4gKHRoaXMudyB8fCAwKTtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgdGhlIHF1YXRlcm5pb24gdG8gYW4gYXJyYXlcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBhcnJheSBwb3B1bGF0ZWQgd2l0aCA0IGVsZW1lbnRzIGZyb20gdGhlIHF1YXRlcm5pb24gY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBhc0FycmF5KCkge1xuICAgICAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMud107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byBxdWF0ZXJuaW9ucyBhcmUgZXF1YWxzXG4gICAgICogQHBhcmFtIG90aGVyUXVhdGVybmlvbiAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBxdWF0ZXJuaW9uIGFuZCB0aGUgZ2l2ZW4gb25lIGNvb3JkaW5hdGVzIGFyZSBzdHJpY3RseSBlcXVhbHNcbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXJRdWF0ZXJuaW9uKSB7XG4gICAgICAgIHJldHVybiAob3RoZXJRdWF0ZXJuaW9uICYmXG4gICAgICAgICAgICB0aGlzLnggPT09IG90aGVyUXVhdGVybmlvbi54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPT09IG90aGVyUXVhdGVybmlvbi55ICYmXG4gICAgICAgICAgICB0aGlzLnogPT09IG90aGVyUXVhdGVybmlvbi56ICYmXG4gICAgICAgICAgICB0aGlzLncgPT09IG90aGVyUXVhdGVybmlvbi53KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmUgdGhlIGN1cnJlbnQgcXVhdGVybmlvblxuICAgICAqIEByZXR1cm5zIGEgbmV3IHF1YXRlcm5pb24gY29waWVkIGZyb20gdGhlIGN1cnJlbnQgb25lXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3B5IGEgcXVhdGVybmlvbiB0byB0aGUgY3VycmVudCBvbmVcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBkZWZpbmVzIHRoZSBvdGhlciBxdWF0ZXJuaW9uXG4gICAgICogQHJldHVybnMgdGhlIHVwZGF0ZWQgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgY29weUZyb20ob3RoZXIpIHtcbiAgICAgICAgdGhpcy54ID0gb3RoZXIueDtcbiAgICAgICAgdGhpcy55ID0gb3RoZXIueTtcbiAgICAgICAgdGhpcy56ID0gb3RoZXIuejtcbiAgICAgICAgdGhpcy53ID0gb3RoZXIudztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgcXVhdGVybmlvbiB3aXRoIHRoZSBnaXZlbiBmbG9hdCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB4IC0gZGVmaW5lcyB0aGUgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHkgLSBkZWZpbmVzIHRoZSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0geiAtIGRlZmluZXMgdGhlIHogY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB3IC0gZGVmaW5lcyB0aGUgdyBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMgdGhlIHVwZGF0ZWQgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgY29weUZyb21GbG9hdHMoeCwgeSwgeiwgdykge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGZsb2F0IGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHggLSBkZWZpbmVzIHRoZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0geSAtIGRlZmluZXMgdGhlIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB6IC0gZGVmaW5lcyB0aGUgeiBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHcgLSBkZWZpbmVzIHRoZSB3IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBjdXJyZW50IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBzZXQoeCwgeSwgeiwgdykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5RnJvbUZsb2F0cyh4LCB5LCB6LCB3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGV1bGVyIGFuZ2xlc1xuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIGN1cnJlbnQgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHNldEV1bGVyKHgsIHksIHopIHtcbiAgICAgICAgUXVhdGVybmlvbi5Sb3RhdGlvbllhd1BpdGNoUm9sbFRvUmVmKHkgKiB0eXBlc18xLkRFRzJSQUQsIHggKiB0eXBlc18xLkRFRzJSQUQsIHogKiB0eXBlc18xLkRFRzJSQUQsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQWRkcyB0d28gcXVhdGVybmlvbnNcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBkZWZpbmVzIHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIGEgbmV3IHF1YXRlcm5pb24gYXMgdGhlIGFkZGl0aW9uIHJlc3VsdCBvZiB0aGUgZ2l2ZW4gb25lIGFuZCB0aGUgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLnggKyBvdGhlci54LCB0aGlzLnkgKyBvdGhlci55LCB0aGlzLnogKyBvdGhlci56LCB0aGlzLncgKyBvdGhlci53KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQWRkIGEgcXVhdGVybmlvbiB0byB0aGUgY3VycmVudCBvbmVcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBkZWZpbmVzIHRoZSBxdWF0ZXJuaW9uIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBhZGRJblBsYWNlKG90aGVyKSB7XG4gICAgICAgIHRoaXMueCArPSBvdGhlci54O1xuICAgICAgICB0aGlzLnkgKz0gb3RoZXIueTtcbiAgICAgICAgdGhpcy56ICs9IG90aGVyLno7XG4gICAgICAgIHRoaXMudyArPSBvdGhlci53O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIHF1YXRlcm5pb25zXG4gICAgICogQHBhcmFtIG90aGVyIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBxdWF0ZXJuaW9uIGFzIHRoZSBzdWJ0cmFjdGlvbiByZXN1bHQgb2YgdGhlIGdpdmVuIG9uZSBmcm9tIHRoZSBjdXJyZW50IG9uZVxuICAgICAqL1xuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55LCB0aGlzLnogLSBvdGhlci56LCB0aGlzLncgLSBvdGhlci53KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgY3VycmVudCBxdWF0ZXJuaW9uIGJ5IGEgc2NhbGUgZmFjdG9yXG4gICAgICogQHBhcmFtIHZhbHVlIC0gZGVmaW5lcyB0aGUgc2NhbGUgZmFjdG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgcXVhdGVybmlvbiBzZXQgYnkgbXVsdGlwbHlpbmcgdGhlIGN1cnJlbnQgcXVhdGVybmlvbiBjb29yZGluYXRlcyBieSB0aGUgZmxvYXQgXCJzY2FsZVwiXG4gICAgICovXG4gICAgc2NhbGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHRoaXMueCAqIHZhbHVlLCB0aGlzLnkgKiB2YWx1ZSwgdGhpcy56ICogdmFsdWUsIHRoaXMudyAqIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGUgdGhlIGN1cnJlbnQgcXVhdGVybmlvbiB2YWx1ZXMgYnkgYSBmYWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IHRvIGEgZ2l2ZW4gcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBzY2FsZSAtIGRlZmluZXMgdGhlIHNjYWxlIGZhY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBRdWF0ZXJuaW9uIG9iamVjdCB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICogQHJldHVybnMgdGhlIHVubW9kaWZpZWQgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgc2NhbGVUb1JlZihzY2FsZSwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC54ID0gdGhpcy54ICogc2NhbGU7XG4gICAgICAgIHJlc3VsdC55ID0gdGhpcy55ICogc2NhbGU7XG4gICAgICAgIHJlc3VsdC56ID0gdGhpcy56ICogc2NhbGU7XG4gICAgICAgIHJlc3VsdC53ID0gdGhpcy53ICogc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGluIHBsYWNlIHRoZSBjdXJyZW50IHF1YXRlcm5pb24gYnkgYSBzY2FsZSBmYWN0b3JcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBkZWZpbmVzIHRoZSBzY2FsZSBmYWN0b3JcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBtb2RpZmllZCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgc2NhbGVJblBsYWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMueCAqPSB2YWx1ZTtcbiAgICAgICAgdGhpcy55ICo9IHZhbHVlO1xuICAgICAgICB0aGlzLnogKj0gdmFsdWU7XG4gICAgICAgIHRoaXMudyAqPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBjdXJyZW50IHF1YXRlcm5pb24gdmFsdWVzIGJ5IGEgZmFjdG9yIGFuZCBhZGQgdGhlIHJlc3VsdCB0byBhIGdpdmVuIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsZSBmYWN0b3JcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgUXVhdGVybmlvbiBvYmplY3Qgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHRoZSB1bm1vZGlmaWVkIGN1cnJlbnQgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHNjYWxlQW5kQWRkVG9SZWYoc2NhbGUsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCArPSB0aGlzLnggKiBzY2FsZTtcbiAgICAgICAgcmVzdWx0LnkgKz0gdGhpcy55ICogc2NhbGU7XG4gICAgICAgIHJlc3VsdC56ICs9IHRoaXMueiAqIHNjYWxlO1xuICAgICAgICByZXN1bHQudyArPSB0aGlzLncgKiBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdHdvIHF1YXRlcm5pb25zXG4gICAgICogQHBhcmFtIHExIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBxdWF0ZXJuaW9uIHNldCBhcyB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIHRoZSBjdXJyZW50IG9uZSB3aXRoIHRoZSBnaXZlbiBvbmUgXCJxMVwiXG4gICAgICovXG4gICAgbXVsdGlwbHkocTEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFF1YXRlcm5pb24oMCwgMCwgMCwgMS4wKTtcbiAgICAgICAgdGhpcy5tdWx0aXBseVRvUmVmKHExLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiBcInJlc3VsdFwiIGFzIHRoZSB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIHRoZSBjdXJyZW50IG9uZSB3aXRoIHRoZSBnaXZlbiBvbmUgXCJxMVwiXG4gICAgICogQHBhcmFtIHExIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IHF1YXRlcm5pb25cbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgbXVsdGlwbHlUb1JlZihxMSwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnggKiBxMS53ICsgdGhpcy55ICogcTEueiAtIHRoaXMueiAqIHExLnkgKyB0aGlzLncgKiBxMS54O1xuICAgICAgICBjb25zdCB5ID0gLXRoaXMueCAqIHExLnogKyB0aGlzLnkgKiBxMS53ICsgdGhpcy56ICogcTEueCArIHRoaXMudyAqIHExLnk7XG4gICAgICAgIGNvbnN0IHogPSB0aGlzLnggKiBxMS55IC0gdGhpcy55ICogcTEueCArIHRoaXMueiAqIHExLncgKyB0aGlzLncgKiBxMS56O1xuICAgICAgICBjb25zdCB3ID0gLXRoaXMueCAqIHExLnggLSB0aGlzLnkgKiBxMS55IC0gdGhpcy56ICogcTEueiArIHRoaXMudyAqIHExLnc7XG4gICAgICAgIHJlc3VsdC5jb3B5RnJvbUZsb2F0cyh4LCB5LCB6LCB3KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgcXVhdGVybmlvbiB3aXRoIHRoZSBtdWx0aXBsaWNhdGlvbiBvZiBpdHNlbGYgd2l0aCB0aGUgZ2l2ZW4gb25lIFwicTFcIlxuICAgICAqIEBwYXJhbSBxMSAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnR1cGRhdGVkIHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBtdWx0aXBseUluUGxhY2UocTEpIHtcbiAgICAgICAgdGhpcy5tdWx0aXBseVRvUmVmKHExLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmp1Z2F0ZXMgKDEtcSkgdGhlIGN1cnJlbnQgcXVhdGVybmlvbiBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gcmVmIC0gZGVmaW5lcyB0aGUgdGFyZ2V0IHF1YXRlcm5pb25cbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgY29uanVnYXRlVG9SZWYocmVmKSB7XG4gICAgICAgIHJlZi5jb3B5RnJvbUZsb2F0cygtdGhpcy54LCAtdGhpcy55LCAtdGhpcy56LCB0aGlzLncpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uanVnYXRlcyBpbiBwbGFjZSAoMS1xKSB0aGUgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgY29uanVnYXRlSW5QbGFjZSgpIHtcbiAgICAgICAgdGhpcy54ICo9IC0xO1xuICAgICAgICB0aGlzLnkgKj0gLTE7XG4gICAgICAgIHRoaXMueiAqPSAtMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmp1Z2F0ZXMgaW4gcGxhY2UgKDEtcSkgdGhlIGN1cnJlbnQgcXVhdGVybmlvblxuICAgICAqIEByZXR1cm5zIGEgbmV3IHF1YXRlcm5pb25cbiAgICAgKi9cbiAgICBjb25qdWdhdGUoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBRdWF0ZXJuaW9uKC10aGlzLngsIC10aGlzLnksIC10aGlzLnosIHRoaXMudyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBpbiBwbGFjZSB0aGUgY3VycmVudCBxdWF0ZXJuaW9uXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgbm9ybWFsaXplKCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSAxLjAgLyB0aGlzLmxlbmd0aDtcbiAgICAgICAgdGhpcy54ICo9IGxlbmd0aDtcbiAgICAgICAgdGhpcy55ICo9IGxlbmd0aDtcbiAgICAgICAgdGhpcy56ICo9IGxlbmd0aDtcbiAgICAgICAgdGhpcy53ICo9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFuZ2xlQXhpcyhkZWdyZXNzLCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzLmxlbmd0aFNxdWFyZWQoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFF1YXRlcm5pb24uSWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUXVhdGVybmlvbi5JZGVudGl0eTtcbiAgICAgICAgbGV0IHJhZGlhbnMgPSBkZWdyZXNzICogdHlwZXNfMS5ERUcyUkFEO1xuICAgICAgICByYWRpYW5zICo9IDAuNTtcbiAgICAgICAgbGV0IGEyID0gYXhpcy5ub3JtYWxpemUoKTtcbiAgICAgICAgYTIgPSBheGlzLnNjYWxlSW5QbGFjZShNYXRoLnNpbihyYWRpYW5zKSk7XG4gICAgICAgIHJlc3VsdC54ID0gYTIueDtcbiAgICAgICAgcmVzdWx0LnkgPSBhMi55O1xuICAgICAgICByZXN1bHQueiA9IGEyLno7XG4gICAgICAgIHJlc3VsdC53ID0gTWF0aC5jb3MocmFkaWFucyk7XG4gICAgICAgIHJldHVybiByZXN1bHQubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIHJvdGF0aW9uIG1hdHJpeCB3aXRoIHRoZSBjdXJyZW50IHF1YXRlcm5pb24gdmFsdWVzXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1bmNoYW5nZWQgcXVhdGVybmlvblxuICAgICAqL1xuICAgIHRvUm90YXRpb25NYXRyaXgocmVzdWx0KSB7XG4gICAgICAgIE1hdHJpeF8xLk1hdHJpeC5Gcm9tUXVhdGVybmlvblRvUmVmKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gcm90YXRpb24gbWF0cml4IHZhbHVlc1xuICAgICAqIEBwYXJhbSBtYXRyaXggLSBkZWZpbmVzIHRoZSBzb3VyY2UgbWF0cml4XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgZnJvbVJvdGF0aW9uTWF0cml4KG1hdHJpeCkge1xuICAgICAgICBRdWF0ZXJuaW9uLkZyb21Sb3RhdGlvbk1hdHJpeFRvUmVmKG1hdHJpeCwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuUXVhdGVybmlvbiA9IFF1YXRlcm5pb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWF0ZXJuaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WZWN0b3IzID0gdm9pZCAwO1xuY29uc3QgcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEgPSByZXF1aXJlKFwiLi9wcmVhbGxvY2F0ZWRWYXJpYWJsZXNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBRdWF0ZXJuaW9uXzEgPSByZXF1aXJlKFwiLi9RdWF0ZXJuaW9uXCIpO1xuY29uc3QgU2NhbGFyXzEgPSByZXF1aXJlKFwiLi9TY2FsYXJcIik7XG4vKipcbiAqIENsYXNzZWQgdXNlZCB0byBzdG9yZSAoeCx5LHopIHZlY3RvciByZXByZXNlbnRhdGlvblxuICogQSBWZWN0b3IzIGlzIHRoZSBtYWluIG9iamVjdCB1c2VkIGluIDNEIGdlb21ldHJ5XG4gKiBJdCBjYW4gcmVwcmVzZW50IGV0aWhlciB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCB0aGUgc3BhY2UsIGVpdGhlciBhIGRpcmVjdGlvblxuICogUmVtaW5kZXI6IEJhYnlsb24uanMgdXNlcyBhIGxlZnQgaGFuZGVkIGZvcndhcmQgZmFjaW5nIHN5c3RlbVxuICogQHB1YmxpY1xuICovXG5jbGFzcyBWZWN0b3IzIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZlY3RvcjMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIHgsIHksIHogKGZsb2F0cykgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHggLSBkZWZpbmVzIHRoZSBmaXJzdCBjb29yZGluYXRlcyAob24gWCBheGlzKVxuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgc2Vjb25kIGNvb3JkaW5hdGVzIChvbiBZIGF4aXMpXG4gICAgICogQHBhcmFtIHogLSBkZWZpbmVzIHRoZSB0aGlyZCBjb29yZGluYXRlcyAob24gWiBheGlzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGZpcnN0IGNvb3JkaW5hdGVzIChvbiBYIGF4aXMpXG4gICAgICovXG4gICAgeCA9IDAsIFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIHNlY29uZCBjb29yZGluYXRlcyAob24gWSBheGlzKVxuICAgICAqL1xuICAgIHkgPSAwLCBcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSB0aGlyZCBjb29yZGluYXRlcyAob24gWiBheGlzKVxuICAgICAqL1xuICAgIHogPSAwKSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgdmVjdG9yIGlzIG5vbiB1bmlmb3JtIG1lYW5pbmcgeCwgeSBvciB6IGFyZSBub3QgYWxsIHRoZSBzYW1lXG4gICAgICovXG4gICAgZ2V0IGlzTm9uVW5pZm9ybSgpIHtcbiAgICAgICAgY29uc3QgYWJzWCA9IE1hdGguYWJzKHRoaXMueCk7XG4gICAgICAgIGNvbnN0IGFic1kgPSBNYXRoLmFicyh0aGlzLnkpO1xuICAgICAgICBpZiAoYWJzWCAhPT0gYWJzWSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJzWiA9IE1hdGguYWJzKHRoaXMueik7XG4gICAgICAgIGlmIChhYnNYICE9PSBhYnNaKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJzWSAhPT0gYWJzWikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBTdGF0aWNzXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIGFzIHRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uIG9mIHRoZSB0d28gZ2l2ZW4gdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0gdmVjdG9yMSAtIHRoZSBmaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdmVjdG9yMiAtIHRoZSBzZWNvbmQgdmVjdG9yXG4gICAgICogQHJldHVybnMgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgQWRkKHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHZlY3RvcjEueCwgdmVjdG9yMS55LCB2ZWN0b3IxLnopLmFkZEluUGxhY2UodmVjdG9yMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xpcCBmYWN0b3IgYmV0d2VlbiB0d28gdmVjdG9yc1xuICAgICAqIEBwYXJhbSB2ZWN0b3IwIC0gZGVmaW5lcyB0aGUgZmlyc3Qgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB2ZWN0b3IxIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcGFyYW0gYXhpcyAtIGRlZmluZXMgdGhlIGF4aXMgdG8gdXNlXG4gICAgICogQHBhcmFtIHNpemUgLSBkZWZpbmVzIHRoZSBzaXplIGFsb25nIHRoZSBheGlzXG4gICAgICogQHJldHVybnMgdGhlIGNsaXAgZmFjdG9yXG4gICAgICovXG4gICAgc3RhdGljIEdldENsaXBGYWN0b3IodmVjdG9yMCwgdmVjdG9yMSwgYXhpcywgc2l6ZSkge1xuICAgICAgICBjb25zdCBkMCA9IFZlY3RvcjMuRG90KHZlY3RvcjAsIGF4aXMpIC0gc2l6ZTtcbiAgICAgICAgY29uc3QgZDEgPSBWZWN0b3IzLkRvdCh2ZWN0b3IxLCBheGlzKSAtIHNpemU7XG4gICAgICAgIGNvbnN0IHMgPSBkMCAvIChkMCAtIGQxKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzXG4gICAgICogQHBhcmFtIHZlY3RvcjAgLSBhbmdsZSBiZXR3ZWVuIHZlY3RvcjAgYW5kIHZlY3RvcjFcbiAgICAgKiBAcGFyYW0gdmVjdG9yMSAtIGFuZ2xlIGJldHdlZW4gdmVjdG9yMCBhbmQgdmVjdG9yMVxuICAgICAqIEBwYXJhbSBub3JtYWwgLSBkaXJlY3Rpb24gb2YgdGhlIG5vcm1hbFxuICAgICAqIEByZXR1cm5zIHRoZSBhbmdsZSBiZXR3ZWVuIHZlY3RvcjAgYW5kIHZlY3RvcjFcbiAgICAgKi9cbiAgICBzdGF0aWMgR2V0QW5nbGVCZXR3ZWVuVmVjdG9ycyh2ZWN0b3IwLCB2ZWN0b3IxLCBub3JtYWwpIHtcbiAgICAgICAgY29uc3QgdjAgPSB2ZWN0b3IwLm5vcm1hbGl6ZVRvUmVmKHByZWFsbG9jYXRlZFZhcmlhYmxlc18xLk1hdGhUbXAuVmVjdG9yM1sxXSk7XG4gICAgICAgIGNvbnN0IHYxID0gdmVjdG9yMS5ub3JtYWxpemVUb1JlZihwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLlZlY3RvcjNbMl0pO1xuICAgICAgICBjb25zdCBkb3QgPSBWZWN0b3IzLkRvdCh2MCwgdjEpO1xuICAgICAgICBjb25zdCBuID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5WZWN0b3IzWzNdO1xuICAgICAgICBWZWN0b3IzLkNyb3NzVG9SZWYodjAsIHYxLCBuKTtcbiAgICAgICAgaWYgKFZlY3RvcjMuRG90KG4sIG5vcm1hbCkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hY29zKGRvdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC1NYXRoLmFjb3MoZG90KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIHNldCBmcm9tIHRoZSBpbmRleCBcIm9mZnNldFwiIG9mIHRoZSBnaXZlbiBhcnJheVxuICAgICAqIEBwYXJhbSBhcnJheSAtIGRlZmluZXMgdGhlIHNvdXJjZSBhcnJheVxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBkZWZpbmVzIHRoZSBvZmZzZXQgaW4gdGhlIHNvdXJjZSBhcnJheVxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKGFycmF5W29mZnNldF0sIGFycmF5W29mZnNldCArIDFdLCBhcnJheVtvZmZzZXQgKyAyXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yMyBzZXQgZnJvbSB0aGUgaW5kZXggXCJvZmZzZXRcIiBvZiB0aGUgZ2l2ZW4gRmxvYXRBcnJheVxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZC4gIFVzZSBGcm9tQXJyYXkgaW5zdGVhZFxuICAgICAqIEBwYXJhbSBhcnJheSAtIGRlZmluZXMgdGhlIHNvdXJjZSBhcnJheVxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBkZWZpbmVzIHRoZSBvZmZzZXQgaW4gdGhlIHNvdXJjZSBhcnJheVxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tRmxvYXRBcnJheShhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBWZWN0b3IzLkZyb21BcnJheShhcnJheSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgd2l0aCB0aGUgZWxlbWVudCB2YWx1ZXMgZnJvbSB0aGUgaW5kZXggXCJvZmZzZXRcIiBvZiB0aGUgZ2l2ZW4gYXJyYXlcbiAgICAgKiBAcGFyYW0gYXJyYXkgLSBkZWZpbmVzIHRoZSBzb3VyY2UgYXJyYXlcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSBzb3VyY2UgYXJyYXlcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIEZyb21BcnJheVRvUmVmKGFycmF5LCBvZmZzZXQsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCA9IGFycmF5W29mZnNldF07XG4gICAgICAgIHJlc3VsdC55ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG4gICAgICAgIHJlc3VsdC56ID0gYXJyYXlbb2Zmc2V0ICsgMl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZlY3RvciBcInJlc3VsdFwiIHdpdGggdGhlIGVsZW1lbnQgdmFsdWVzIGZyb20gdGhlIGluZGV4IFwib2Zmc2V0XCIgb2YgdGhlIGdpdmVuIEZsb2F0QXJyYXlcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQuICBVc2UgRnJvbUFycmF5VG9SZWYgaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gYXJyYXkgLSBkZWZpbmVzIHRoZSBzb3VyY2UgYXJyYXlcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSBzb3VyY2UgYXJyYXlcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIEZyb21GbG9hdEFycmF5VG9SZWYoYXJyYXksIG9mZnNldCwgcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBWZWN0b3IzLkZyb21BcnJheVRvUmVmKGFycmF5LCBvZmZzZXQsIHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZlY3RvciBcInJlc3VsdFwiIHdpdGggdGhlIGdpdmVuIGZsb2F0cy5cbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZXMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgc291cmNlXG4gICAgICogQHBhcmFtIHkgLSBkZWZpbmVzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHNvdXJjZVxuICAgICAqIEBwYXJhbSB6IC0gZGVmaW5lcyB0aGUgeiBjb29yZGluYXRlIG9mIHRoZSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIEZyb21GbG9hdHNUb1JlZih4LCB5LCB6LCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LmNvcHlGcm9tRmxvYXRzKHgsIHksIHopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjMgc2V0IHRvICgwLjAsIDAuMCwgMC4wKVxuICAgICAqIEByZXR1cm5zIGEgbmV3IGVtcHR5IFZlY3RvcjNcbiAgICAgKi9cbiAgICBzdGF0aWMgWmVybygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKDAuMCwgMC4wLCAwLjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjMgc2V0IHRvICgxLjAsIDEuMCwgMS4wKVxuICAgICAqIEByZXR1cm5zIGEgbmV3IHVuaXQgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBPbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMygxLjAsIDEuMCwgMS4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIHNldCB0byAoMC4wLCAxLjAsIDAuMClcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB1cCBWZWN0b3IzXG4gICAgICovXG4gICAgc3RhdGljIFVwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoMC4wLCAxLjAsIDAuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yMyBzZXQgdG8gKDAuMCwgLTEuMCwgMC4wKVxuICAgICAqIEByZXR1cm5zIGEgbmV3IGRvd24gVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBEb3duKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoMC4wLCAtMS4wLCAwLjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjMgc2V0IHRvICgwLjAsIDAuMCwgMS4wKVxuICAgICAqIEByZXR1cm5zIGEgbmV3IGZvcndhcmQgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBGb3J3YXJkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoMC4wLCAwLjAsIDEuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yMyBzZXQgdG8gKDAuMCwgMC4wLCAtMS4wKVxuICAgICAqIEByZXR1cm5zIGEgbmV3IGZvcndhcmQgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBCYWNrd2FyZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKDAuMCwgMC4wLCAtMS4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIHNldCB0byAoMS4wLCAwLjAsIDAuMClcbiAgICAgKiBAcmV0dXJucyBhIG5ldyByaWdodCBWZWN0b3IzXG4gICAgICovXG4gICAgc3RhdGljIFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoMS4wLCAwLjAsIDAuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yMyBzZXQgdG8gKC0xLjAsIDAuMCwgMC4wKVxuICAgICAqIEByZXR1cm5zIGEgbmV3IGxlZnQgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBMZWZ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoLTEuMCwgMC4wLCAwLjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjMgc2V0IHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIGdpdmVuIG1hdHJpeCBvZiB0aGUgZ2l2ZW4gdmVjdG9yLlxuICAgICAqIFRoaXMgbWV0aG9kIGNvbXB1dGVzIHRyYW5mb3JtZWQgY29vcmRpbmF0ZXMgb25seSwgbm90IHRyYW5zZm9ybWVkIGRpcmVjdGlvbiB2ZWN0b3JzIChpZS4gaXQgdGFrZXMgdHJhbnNsYXRpb24gaW4gYWNjb3VudClcbiAgICAgKiBAcGFyYW0gdmVjdG9yIC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtYXRpb24gLSBkZWZpbmVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBUcmFuc2Zvcm1Db29yZGluYXRlcyh2ZWN0b3IsIHRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFZlY3RvcjMuWmVybygpO1xuICAgICAgICBWZWN0b3IzLlRyYW5zZm9ybUNvb3JkaW5hdGVzVG9SZWYodmVjdG9yLCB0cmFuc2Zvcm1hdGlvbiwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgY29vcmRpbmF0ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgZ2l2ZW4gbWF0cml4IG9mIHRoZSBnaXZlbiB2ZWN0b3JcbiAgICAgKiBUaGlzIG1ldGhvZCBjb21wdXRlcyB0cmFuZm9ybWVkIGNvb3JkaW5hdGVzIG9ubHksIG5vdCB0cmFuc2Zvcm1lZCBkaXJlY3Rpb24gdmVjdG9ycyAoaWUuIGl0IHRha2VzIHRyYW5zbGF0aW9uIGluIGFjY291bnQpXG4gICAgICogQHBhcmFtIHZlY3RvciAtIGRlZmluZXMgdGhlIFZlY3RvcjMgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWF0aW9uIC0gZGVmaW5lcyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIFZlY3RvcjMgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIHN0YXRpYyBUcmFuc2Zvcm1Db29yZGluYXRlc1RvUmVmKHZlY3RvciwgdHJhbnNmb3JtYXRpb24sIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlc0Zyb21GbG9hdHNUb1JlZih2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56LCB0cmFuc2Zvcm1hdGlvbiwgcmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgY29vcmRpbmF0ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgZ2l2ZW4gbWF0cml4IG9mIHRoZSBnaXZlbiBmbG9hdHMgKHgsIHksIHopXG4gICAgICogVGhpcyBtZXRob2QgY29tcHV0ZXMgdHJhbmZvcm1lZCBjb29yZGluYXRlcyBvbmx5LCBub3QgdHJhbnNmb3JtZWQgZGlyZWN0aW9uIHZlY3RvcnNcbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZSB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBzb3VyY2UgdmVjdG9yXG4gICAgICogQHBhcmFtIHkgLSBkZWZpbmUgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgc291cmNlIHZlY3RvclxuICAgICAqIEBwYXJhbSB6IC0gZGVmaW5lIHRoZSB6IGNvb3JkaW5hdGUgb2YgdGhlIHNvdXJjZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtYXRpb24gLSBkZWZpbmVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIFRyYW5zZm9ybUNvb3JkaW5hdGVzRnJvbUZsb2F0c1RvUmVmKHgsIHksIHosIHRyYW5zZm9ybWF0aW9uLCByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgbSA9IHRyYW5zZm9ybWF0aW9uLm07XG4gICAgICAgIGNvbnN0IHJ4ID0geCAqIG1bMF0gKyB5ICogbVs0XSArIHogKiBtWzhdICsgbVsxMl07XG4gICAgICAgIGNvbnN0IHJ5ID0geCAqIG1bMV0gKyB5ICogbVs1XSArIHogKiBtWzldICsgbVsxM107XG4gICAgICAgIGNvbnN0IHJ6ID0geCAqIG1bMl0gKyB5ICogbVs2XSArIHogKiBtWzEwXSArIG1bMTRdO1xuICAgICAgICBjb25zdCBydyA9IDEgLyAoeCAqIG1bM10gKyB5ICogbVs3XSArIHogKiBtWzExXSArIG1bMTVdKTtcbiAgICAgICAgcmVzdWx0LnggPSByeCAqIHJ3O1xuICAgICAgICByZXN1bHQueSA9IHJ5ICogcnc7XG4gICAgICAgIHJlc3VsdC56ID0gcnogKiBydztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIHNldCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIG5vcm1hbCB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgZ2l2ZW4gbWF0cml4IG9mIHRoZSBnaXZlbiB2ZWN0b3JcbiAgICAgKiBUaGlzIG1ldGhvZHMgY29tcHV0ZXMgdHJhbnNmb3JtZWQgbm9ybWFsaXplZCBkaXJlY3Rpb24gdmVjdG9ycyBvbmx5IChpZS4gaXQgZG9lcyBub3QgYXBwbHkgdHJhbnNsYXRpb24pXG4gICAgICogQHBhcmFtIHZlY3RvciAtIGRlZmluZXMgdGhlIFZlY3RvcjMgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWF0aW9uIC0gZGVmaW5lcyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICogQHJldHVybnMgdGhlIG5ldyBWZWN0b3IzXG4gICAgICovXG4gICAgc3RhdGljIFRyYW5zZm9ybU5vcm1hbCh2ZWN0b3IsIHRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFZlY3RvcjMuWmVybygpO1xuICAgICAgICBWZWN0b3IzLlRyYW5zZm9ybU5vcm1hbFRvUmVmKHZlY3RvciwgdHJhbnNmb3JtYXRpb24sIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZlY3RvciBcInJlc3VsdFwiIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgbm9ybWFsIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBnaXZlbiBtYXRyaXggb2YgdGhlIGdpdmVuIHZlY3RvclxuICAgICAqIFRoaXMgbWV0aG9kcyBjb21wdXRlcyB0cmFuc2Zvcm1lZCBub3JtYWxpemVkIGRpcmVjdGlvbiB2ZWN0b3JzIG9ubHkgKGllLiBpdCBkb2VzIG5vdCBhcHBseSB0cmFuc2xhdGlvbilcbiAgICAgKiBAcGFyYW0gdmVjdG9yIC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtYXRpb24gLSBkZWZpbmVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIFRyYW5zZm9ybU5vcm1hbFRvUmVmKHZlY3RvciwgdHJhbnNmb3JtYXRpb24sIHJlc3VsdCkge1xuICAgICAgICB0aGlzLlRyYW5zZm9ybU5vcm1hbEZyb21GbG9hdHNUb1JlZih2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56LCB0cmFuc2Zvcm1hdGlvbiwgcmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBub3JtYWwgdHJhbnNmb3JtYXRpb24gYnkgdGhlIGdpdmVuIG1hdHJpeCBvZiB0aGUgZ2l2ZW4gZmxvYXRzICh4LCB5LCB6KVxuICAgICAqIFRoaXMgbWV0aG9kcyBjb21wdXRlcyB0cmFuc2Zvcm1lZCBub3JtYWxpemVkIGRpcmVjdGlvbiB2ZWN0b3JzIG9ubHkgKGllLiBpdCBkb2VzIG5vdCBhcHBseSB0cmFuc2xhdGlvbilcbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZSB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBzb3VyY2UgdmVjdG9yXG4gICAgICogQHBhcmFtIHkgLSBkZWZpbmUgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgc291cmNlIHZlY3RvclxuICAgICAqIEBwYXJhbSB6IC0gZGVmaW5lIHRoZSB6IGNvb3JkaW5hdGUgb2YgdGhlIHNvdXJjZSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtYXRpb24gLSBkZWZpbmVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIFRyYW5zZm9ybU5vcm1hbEZyb21GbG9hdHNUb1JlZih4LCB5LCB6LCB0cmFuc2Zvcm1hdGlvbiwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IG0gPSB0cmFuc2Zvcm1hdGlvbi5tO1xuICAgICAgICByZXN1bHQueCA9IHggKiBtWzBdICsgeSAqIG1bNF0gKyB6ICogbVs4XTtcbiAgICAgICAgcmVzdWx0LnkgPSB4ICogbVsxXSArIHkgKiBtWzVdICsgeiAqIG1bOV07XG4gICAgICAgIHJlc3VsdC56ID0geCAqIG1bMl0gKyB5ICogbVs2XSArIHogKiBtWzEwXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIGxvY2F0ZWQgZm9yIFwiYW1vdW50XCIgb24gdGhlIENhdG11bGxSb20gaW50ZXJwb2xhdGlvbiBzcGxpbmUgZGVmaW5lZCBieSB0aGUgdmVjdG9ycyBcInZhbHVlMVwiLCBcInZhbHVlMlwiLCBcInZhbHVlM1wiLCBcInZhbHVlNFwiXG4gICAgICogQHBhcmFtIHZhbHVlMSAtIGRlZmluZXMgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICAgKiBAcGFyYW0gdmFsdWUyIC0gZGVmaW5lcyB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgICAgKiBAcGFyYW0gdmFsdWUzIC0gZGVmaW5lcyB0aGUgdGhpcmQgY29udHJvbCBwb2ludFxuICAgICAqIEBwYXJhbSB2YWx1ZTQgLSBkZWZpbmVzIHRoZSBmb3VydGggY29udHJvbCBwb2ludFxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBkZWZpbmVzIHRoZSBhbW91bnQgb24gdGhlIHNwbGluZSB0byB1c2VcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBzdGF0aWMgQ2F0bXVsbFJvbSh2YWx1ZTEsIHZhbHVlMiwgdmFsdWUzLCB2YWx1ZTQsIGFtb3VudCkge1xuICAgICAgICBjb25zdCBzcXVhcmVkID0gYW1vdW50ICogYW1vdW50O1xuICAgICAgICBjb25zdCBjdWJlZCA9IGFtb3VudCAqIHNxdWFyZWQ7XG4gICAgICAgIGNvbnN0IHggPSAwLjUgKlxuICAgICAgICAgICAgKDIuMCAqIHZhbHVlMi54ICtcbiAgICAgICAgICAgICAgICAoLXZhbHVlMS54ICsgdmFsdWUzLngpICogYW1vdW50ICtcbiAgICAgICAgICAgICAgICAoMi4wICogdmFsdWUxLnggLSA1LjAgKiB2YWx1ZTIueCArIDQuMCAqIHZhbHVlMy54IC0gdmFsdWU0LngpICpcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlZCArXG4gICAgICAgICAgICAgICAgKC12YWx1ZTEueCArIDMuMCAqIHZhbHVlMi54IC0gMy4wICogdmFsdWUzLnggKyB2YWx1ZTQueCkgKiBjdWJlZCk7XG4gICAgICAgIGNvbnN0IHkgPSAwLjUgKlxuICAgICAgICAgICAgKDIuMCAqIHZhbHVlMi55ICtcbiAgICAgICAgICAgICAgICAoLXZhbHVlMS55ICsgdmFsdWUzLnkpICogYW1vdW50ICtcbiAgICAgICAgICAgICAgICAoMi4wICogdmFsdWUxLnkgLSA1LjAgKiB2YWx1ZTIueSArIDQuMCAqIHZhbHVlMy55IC0gdmFsdWU0LnkpICpcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlZCArXG4gICAgICAgICAgICAgICAgKC12YWx1ZTEueSArIDMuMCAqIHZhbHVlMi55IC0gMy4wICogdmFsdWUzLnkgKyB2YWx1ZTQueSkgKiBjdWJlZCk7XG4gICAgICAgIGNvbnN0IHogPSAwLjUgKlxuICAgICAgICAgICAgKDIuMCAqIHZhbHVlMi56ICtcbiAgICAgICAgICAgICAgICAoLXZhbHVlMS56ICsgdmFsdWUzLnopICogYW1vdW50ICtcbiAgICAgICAgICAgICAgICAoMi4wICogdmFsdWUxLnogLSA1LjAgKiB2YWx1ZTIueiArIDQuMCAqIHZhbHVlMy56IC0gdmFsdWU0LnopICpcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlZCArXG4gICAgICAgICAgICAgICAgKC12YWx1ZTEueiArIDMuMCAqIHZhbHVlMi56IC0gMy4wICogdmFsdWUzLnogKyB2YWx1ZTQueikgKiBjdWJlZCk7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh4LCB5LCB6KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIHNldCB3aXRoIHRoZSBjb29yZGluYXRlcyBvZiBcInZhbHVlXCIsIGlmIHRoZSB2ZWN0b3IgXCJ2YWx1ZVwiIGlzIGluIHRoZSBjdWJlIGRlZmluZWQgYnkgdGhlIHZlY3RvcnMgXCJtaW5cIiBhbmQgXCJtYXhcIlxuICAgICAqIElmIGEgY29vcmRpbmF0ZSB2YWx1ZSBvZiBcInZhbHVlXCIgaXMgbG93ZXIgdGhhbiBvbmUgb2YgdGhlIFwibWluXCIgY29vcmRpbmF0ZSwgdGhlbiB0aGlzIFwidmFsdWVcIiBjb29yZGluYXRlIGlzIHNldCB3aXRoIHRoZSBcIm1pblwiIG9uZVxuICAgICAqIElmIGEgY29vcmRpbmF0ZSB2YWx1ZSBvZiBcInZhbHVlXCIgaXMgZ3JlYXRlciB0aGFuIG9uZSBvZiB0aGUgXCJtYXhcIiBjb29yZGluYXRlLCB0aGVuIHRoaXMgXCJ2YWx1ZVwiIGNvb3JkaW5hdGUgaXMgc2V0IHdpdGggdGhlIFwibWF4XCIgb25lXG4gICAgICogQHBhcmFtIHZhbHVlIC0gZGVmaW5lcyB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAqIEBwYXJhbSBtaW4gLSBkZWZpbmVzIHRoZSBsb3dlciByYW5nZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBtYXggLSBkZWZpbmVzIHRoZSB1cHBlciByYW5nZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBDbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIFZlY3RvcjMuQ2xhbXBUb1JlZih2YWx1ZSwgbWluLCBtYXgsIHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgd2l0aCB0aGUgY29vcmRpbmF0ZXMgb2YgXCJ2YWx1ZVwiLCBpZiB0aGUgdmVjdG9yIFwidmFsdWVcIiBpcyBpbiB0aGUgY3ViZSBkZWZpbmVkIGJ5IHRoZSB2ZWN0b3JzIFwibWluXCIgYW5kIFwibWF4XCJcbiAgICAgKiBJZiBhIGNvb3JkaW5hdGUgdmFsdWUgb2YgXCJ2YWx1ZVwiIGlzIGxvd2VyIHRoYW4gb25lIG9mIHRoZSBcIm1pblwiIGNvb3JkaW5hdGUsIHRoZW4gdGhpcyBcInZhbHVlXCIgY29vcmRpbmF0ZSBpcyBzZXQgd2l0aCB0aGUgXCJtaW5cIiBvbmVcbiAgICAgKiBJZiBhIGNvb3JkaW5hdGUgdmFsdWUgb2YgXCJ2YWx1ZVwiIGlzIGdyZWF0ZXIgdGhhbiBvbmUgb2YgdGhlIFwibWF4XCIgY29vcmRpbmF0ZSwgdGhlbiB0aGlzIFwidmFsdWVcIiBjb29yZGluYXRlIGlzIHNldCB3aXRoIHRoZSBcIm1heFwiIG9uZVxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIGRlZmluZXMgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgKiBAcGFyYW0gbWluIC0gZGVmaW5lcyB0aGUgbG93ZXIgcmFuZ2UgdmFsdWVcbiAgICAgKiBAcGFyYW0gbWF4IC0gZGVmaW5lcyB0aGUgdXBwZXIgcmFuZ2UgdmFsdWVcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIENsYW1wVG9SZWYodmFsdWUsIG1pbiwgbWF4LCByZXN1bHQpIHtcbiAgICAgICAgbGV0IHggPSB2YWx1ZS54O1xuICAgICAgICB4ID0geCA+IG1heC54ID8gbWF4LnggOiB4O1xuICAgICAgICB4ID0geCA8IG1pbi54ID8gbWluLnggOiB4O1xuICAgICAgICBsZXQgeSA9IHZhbHVlLnk7XG4gICAgICAgIHkgPSB5ID4gbWF4LnkgPyBtYXgueSA6IHk7XG4gICAgICAgIHkgPSB5IDwgbWluLnkgPyBtaW4ueSA6IHk7XG4gICAgICAgIGxldCB6ID0gdmFsdWUuejtcbiAgICAgICAgeiA9IHogPiBtYXgueiA/IG1heC56IDogejtcbiAgICAgICAgeiA9IHogPCBtaW4ueiA/IG1pbi56IDogejtcbiAgICAgICAgcmVzdWx0LmNvcHlGcm9tRmxvYXRzKHgsIHksIHopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjMgbG9jYXRlZCBmb3IgXCJhbW91bnRcIiAoZmxvYXQpIG9uIHRoZSBIZXJtaXRlIGludGVycG9sYXRpb24gc3BsaW5lIGRlZmluZWQgYnkgdGhlIHZlY3RvcnMgXCJ2YWx1ZTFcIiwgXCJ0YW5nZW50MVwiLCBcInZhbHVlMlwiLCBcInRhbmdlbnQyXCJcbiAgICAgKiBAcGFyYW0gdmFsdWUxIC0gZGVmaW5lcyB0aGUgZmlyc3QgY29udHJvbCBwb2ludFxuICAgICAqIEBwYXJhbSB0YW5nZW50MSAtIGRlZmluZXMgdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yXG4gICAgICogQHBhcmFtIHZhbHVlMiAtIGRlZmluZXMgdGhlIHNlY29uZCBjb250cm9sIHBvaW50XG4gICAgICogQHBhcmFtIHRhbmdlbnQyIC0gZGVmaW5lcyB0aGUgc2Vjb25kIHRhbmdlbnQgdmVjdG9yXG4gICAgICogQHBhcmFtIGFtb3VudCAtIGRlZmluZXMgdGhlIGFtb3VudCBvbiB0aGUgaW50ZXJwb2xhdGlvbiBzcGxpbmUgKGJldHdlZW4gMCBhbmQgMSlcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBzdGF0aWMgSGVybWl0ZSh2YWx1ZTEsIHRhbmdlbnQxLCB2YWx1ZTIsIHRhbmdlbnQyLCBhbW91bnQpIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlZCA9IGFtb3VudCAqIGFtb3VudDtcbiAgICAgICAgY29uc3QgY3ViZWQgPSBhbW91bnQgKiBzcXVhcmVkO1xuICAgICAgICBjb25zdCBwYXJ0MSA9IDIuMCAqIGN1YmVkIC0gMy4wICogc3F1YXJlZCArIDEuMDtcbiAgICAgICAgY29uc3QgcGFydDIgPSAtMi4wICogY3ViZWQgKyAzLjAgKiBzcXVhcmVkO1xuICAgICAgICBjb25zdCBwYXJ0MyA9IGN1YmVkIC0gMi4wICogc3F1YXJlZCArIGFtb3VudDtcbiAgICAgICAgY29uc3QgcGFydDQgPSBjdWJlZCAtIHNxdWFyZWQ7XG4gICAgICAgIGNvbnN0IHggPSB2YWx1ZTEueCAqIHBhcnQxICtcbiAgICAgICAgICAgIHZhbHVlMi54ICogcGFydDIgK1xuICAgICAgICAgICAgdGFuZ2VudDEueCAqIHBhcnQzICtcbiAgICAgICAgICAgIHRhbmdlbnQyLnggKiBwYXJ0NDtcbiAgICAgICAgY29uc3QgeSA9IHZhbHVlMS55ICogcGFydDEgK1xuICAgICAgICAgICAgdmFsdWUyLnkgKiBwYXJ0MiArXG4gICAgICAgICAgICB0YW5nZW50MS55ICogcGFydDMgK1xuICAgICAgICAgICAgdGFuZ2VudDIueSAqIHBhcnQ0O1xuICAgICAgICBjb25zdCB6ID0gdmFsdWUxLnogKiBwYXJ0MSArXG4gICAgICAgICAgICB2YWx1ZTIueiAqIHBhcnQyICtcbiAgICAgICAgICAgIHRhbmdlbnQxLnogKiBwYXJ0MyArXG4gICAgICAgICAgICB0YW5nZW50Mi56ICogcGFydDQ7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh4LCB5LCB6KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIGxvY2F0ZWQgZm9yIFwiYW1vdW50XCIgKGZsb2F0KSBvbiB0aGUgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0aGUgdmVjdG9ycyBcInN0YXJ0XCIgYW5kIFwiZW5kXCJcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBkZWZpbmVzIHRoZSBzdGFydCB2YWx1ZVxuICAgICAqIEBwYXJhbSBlbmQgLSBkZWZpbmVzIHRoZSBlbmQgdmFsdWVcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gbWF4IGRlZmluZXMgYW1vdW50IGJldHdlZW4gYm90aCAoYmV0d2VlbiAwIGFuZCAxKVxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBMZXJwKHN0YXJ0LCBlbmQsIGFtb3VudCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICAgICAgVmVjdG9yMy5MZXJwVG9SZWYoc3RhcnQsIGVuZCwgYW1vdW50LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2ZWN0b3IgXCJyZXN1bHRcIiB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGxpbmVhciBpbnRlcnBvbGF0aW9uIGZyb20gdGhlIHZlY3RvciBcInN0YXJ0XCIgZm9yIFwiYW1vdW50XCIgdG8gdGhlIHZlY3RvciBcImVuZFwiXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gZGVmaW5lcyB0aGUgc3RhcnQgdmFsdWVcbiAgICAgKiBAcGFyYW0gZW5kIC0gZGVmaW5lcyB0aGUgZW5kIHZhbHVlXG4gICAgICogQHBhcmFtIGFtb3VudCAtIG1heCBkZWZpbmVzIGFtb3VudCBiZXR3ZWVuIGJvdGggKGJldHdlZW4gMCBhbmQgMSlcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIExlcnBUb1JlZihzdGFydCwgZW5kLCBhbW91bnQsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCA9IHN0YXJ0LnggKyAoZW5kLnggLSBzdGFydC54KSAqIGFtb3VudDtcbiAgICAgICAgcmVzdWx0LnkgPSBzdGFydC55ICsgKGVuZC55IC0gc3RhcnQueSkgKiBhbW91bnQ7XG4gICAgICAgIHJlc3VsdC56ID0gc3RhcnQueiArIChlbmQueiAtIHN0YXJ0LnopICogYW1vdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdCAoZmxvYXQpIGJldHdlZW4gdGhlIHZlY3RvcnMgXCJsZWZ0XCIgYW5kIFwicmlnaHRcIlxuICAgICAqIEBwYXJhbSBsZWZ0IC0gZGVmaW5lcyB0aGUgbGVmdCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyB0aGUgcmlnaHQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSBkb3QgcHJvZHVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBEb3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQueCAqIHJpZ2h0LnggKyBsZWZ0LnkgKiByaWdodC55ICsgbGVmdC56ICogcmlnaHQuejtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIGFzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoZSB2ZWN0b3JzIFwibGVmdFwiIGFuZCBcInJpZ2h0XCJcbiAgICAgKiBUaGUgY3Jvc3MgcHJvZHVjdCBpcyB0aGVuIG9ydGhvZ29uYWwgdG8gYm90aCBcImxlZnRcIiBhbmQgXCJyaWdodFwiXG4gICAgICogQHBhcmFtIGxlZnQgLSBkZWZpbmVzIHRoZSBsZWZ0IG9wZXJhbmRcbiAgICAgKiBAcGFyYW0gcmlnaHQgLSBkZWZpbmVzIHRoZSByaWdodCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIGNyb3NzIHByb2R1Y3RcbiAgICAgKi9cbiAgICBzdGF0aWMgQ3Jvc3MobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIFZlY3RvcjMuQ3Jvc3NUb1JlZihsZWZ0LCByaWdodCwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgd2l0aCB0aGUgY3Jvc3MgcHJvZHVjdCBvZiBcImxlZnRcIiBhbmQgXCJyaWdodFwiXG4gICAgICogVGhlIGNyb3NzIHByb2R1Y3QgaXMgdGhlbiBvcnRob2dvbmFsIHRvIGJvdGggXCJsZWZ0XCIgYW5kIFwicmlnaHRcIlxuICAgICAqIEBwYXJhbSBsZWZ0IC0gZGVmaW5lcyB0aGUgbGVmdCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyB0aGUgcmlnaHQgb3BlcmFuZFxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBWZWN0b3IzIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBzdGF0aWMgQ3Jvc3NUb1JlZihsZWZ0LCByaWdodCwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHggPSBsZWZ0LnkgKiByaWdodC56IC0gbGVmdC56ICogcmlnaHQueTtcbiAgICAgICAgY29uc3QgeSA9IGxlZnQueiAqIHJpZ2h0LnggLSBsZWZ0LnggKiByaWdodC56O1xuICAgICAgICBjb25zdCB6ID0gbGVmdC54ICogcmlnaHQueSAtIGxlZnQueSAqIHJpZ2h0Lng7XG4gICAgICAgIHJlc3VsdC5jb3B5RnJvbUZsb2F0cyh4LCB5LCB6KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIGFzIHRoZSBub3JtYWxpemF0aW9uIG9mIHRoZSBnaXZlbiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdmVjdG9yIC0gZGVmaW5lcyB0aGUgVmVjdG9yMyB0byBub3JtYWxpemVcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBzdGF0aWMgTm9ybWFsaXplKHZlY3Rvcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBWZWN0b3IzLlplcm8oKTtcbiAgICAgICAgVmVjdG9yMy5Ob3JtYWxpemVUb1JlZih2ZWN0b3IsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZlY3RvciBcInJlc3VsdFwiIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gb2YgdGhlIGdpdmVuIGZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB2ZWN0b3IgLSBkZWZpbmVzIHRoZSBWZWN0b3IzIHRvIG5vcm1hbGl6ZVxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBWZWN0b3IzIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBzdGF0aWMgTm9ybWFsaXplVG9SZWYodmVjdG9yLCByZXN1bHQpIHtcbiAgICAgICAgdmVjdG9yLm5vcm1hbGl6ZVRvUmVmKHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1pbmltYWwgY29vcmRpbmF0ZSB2YWx1ZXMgYmV0d2VlbiB0d28gVmVjdG9yM1xuICAgICAqIEBwYXJhbSBsZWZ0IC0gZGVmaW5lcyB0aGUgZmlyc3Qgb3BlcmFuZFxuICAgICAqIEBwYXJhbSByaWdodCAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBWZWN0b3IzXG4gICAgICovXG4gICAgc3RhdGljIE1pbmltaXplKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IG5ldyBWZWN0b3IzKGxlZnQueCwgbGVmdC55LCBsZWZ0LnopO1xuICAgICAgICBtaW4ubWluaW1pemVJblBsYWNlKHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWF4aW1hbCBjb29yZGluYXRlIHZhbHVlcyBiZXR3ZWVuIHR3byBWZWN0b3IzXG4gICAgICogQHBhcmFtIGxlZnQgLSBkZWZpbmVzIHRoZSBmaXJzdCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBzdGF0aWMgTWF4aW1pemUobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gbmV3IFZlY3RvcjMobGVmdC54LCBsZWZ0LnksIGxlZnQueik7XG4gICAgICAgIG1heC5tYXhpbWl6ZUluUGxhY2UocmlnaHQpO1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB2ZWN0b3JzIFwidmFsdWUxXCIgYW5kIFwidmFsdWUyXCJcbiAgICAgKiBAcGFyYW0gdmFsdWUxIC0gZGVmaW5lcyB0aGUgZmlyc3Qgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB2YWx1ZTIgLSBkZWZpbmVzIHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSBkaXN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBEaXN0YW5jZSh2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFZlY3RvcjMuRGlzdGFuY2VTcXVhcmVkKHZhbHVlMSwgdmFsdWUyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdmVjdG9ycyBcInZhbHVlMVwiIGFuZCBcInZhbHVlMlwiXG4gICAgICogQHBhcmFtIHZhbHVlMSAtIGRlZmluZXMgdGhlIGZpcnN0IG9wZXJhbmRcbiAgICAgKiBAcGFyYW0gdmFsdWUyIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgc3F1YXJlZCBkaXN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBEaXN0YW5jZVNxdWFyZWQodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAgICAgY29uc3QgeCA9IHZhbHVlMS54IC0gdmFsdWUyLng7XG4gICAgICAgIGNvbnN0IHkgPSB2YWx1ZTEueSAtIHZhbHVlMi55O1xuICAgICAgICBjb25zdCB6ID0gdmFsdWUxLnogLSB2YWx1ZTIuejtcbiAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIGxvY2F0ZWQgYXQgdGhlIGNlbnRlciBiZXR3ZWVuIFwidmFsdWUxXCIgYW5kIFwidmFsdWUyXCJcbiAgICAgKiBAcGFyYW0gdmFsdWUxIC0gZGVmaW5lcyB0aGUgZmlyc3Qgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB2YWx1ZTIgLSBkZWZpbmVzIHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgVmVjdG9yM1xuICAgICAqL1xuICAgIHN0YXRpYyBDZW50ZXIodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gVmVjdG9yMy5BZGQodmFsdWUxLCB2YWx1ZTIpO1xuICAgICAgICBjZW50ZXIuc2NhbGVJblBsYWNlKDAuNSk7XG4gICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRocmVlIG9ydGhvZ29uYWwgbm9ybWFsaXplZCBsZWZ0LWhhbmRlZCBvcmllbnRlZCBWZWN0b3IzIGF4aXMgaW4gc3BhY2UgKHRhcmdldCBzeXN0ZW0pLFxuICAgICAqIFJvdGF0aW9uRnJvbUF4aXMoKSByZXR1cm5zIHRoZSByb3RhdGlvbiBFdWxlciBhbmdsZXMgKGV4IDogcm90YXRpb24ueCwgcm90YXRpb24ueSwgcm90YXRpb24ueikgdG8gYXBwbHlcbiAgICAgKiB0byBzb21ldGhpbmcgaW4gb3JkZXIgdG8gcm90YXRlIGl0IGZyb20gaXRzIGxvY2FsIHN5c3RlbSB0byB0aGUgZ2l2ZW4gdGFyZ2V0IHN5c3RlbVxuICAgICAqIE5vdGU6IGF4aXMxLCBheGlzMiBhbmQgYXhpczMgYXJlIG5vcm1hbGl6ZWQgZHVyaW5nIHRoaXMgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIGF4aXMxIC0gZGVmaW5lcyB0aGUgZmlyc3QgYXhpc1xuICAgICAqIEBwYXJhbSBheGlzMiAtIGRlZmluZXMgdGhlIHNlY29uZCBheGlzXG4gICAgICogQHBhcmFtIGF4aXMzIC0gZGVmaW5lcyB0aGUgdGhpcmQgYXhpc1xuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBzdGF0aWMgUm90YXRpb25Gcm9tQXhpcyhheGlzMSwgYXhpczIsIGF4aXMzKSB7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgIFZlY3RvcjMuUm90YXRpb25Gcm9tQXhpc1RvUmVmKGF4aXMxLCBheGlzMiwgYXhpczMsIHJvdGF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSB0aGFuIFJvdGF0aW9uRnJvbUF4aXMgYnV0IHVwZGF0ZXMgdGhlIGdpdmVuIHJlZiBWZWN0b3IzIHBhcmFtZXRlciBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG5ldyBWZWN0b3IzXG4gICAgICogQHBhcmFtIGF4aXMxIC0gZGVmaW5lcyB0aGUgZmlyc3QgYXhpc1xuICAgICAqIEBwYXJhbSBheGlzMiAtIGRlZmluZXMgdGhlIHNlY29uZCBheGlzXG4gICAgICogQHBhcmFtIGF4aXMzIC0gZGVmaW5lcyB0aGUgdGhpcmQgYXhpc1xuICAgICAqIEBwYXJhbSByZWYgLSBkZWZpbmVzIHRoZSBWZWN0b3IzIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBzdGF0aWMgUm90YXRpb25Gcm9tQXhpc1RvUmVmKGF4aXMxLCBheGlzMiwgYXhpczMsIHJlZikge1xuICAgICAgICBjb25zdCBxdWF0ID0gcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEuTWF0aFRtcC5RdWF0ZXJuaW9uWzBdO1xuICAgICAgICBRdWF0ZXJuaW9uXzEuUXVhdGVybmlvbi5Sb3RhdGlvblF1YXRlcm5pb25Gcm9tQXhpc1RvUmVmKGF4aXMxLCBheGlzMiwgYXhpczMsIHF1YXQpO1xuICAgICAgICByZWYuY29weUZyb20ocXVhdC5ldWxlckFuZ2xlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZlY3RvcjNcbiAgICAgKiBAcmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBWZWN0b3IzIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCgke3RoaXMueH0sICR7dGhpcy55fSwgJHt0aGlzLnp9KWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNsYXNzIG5hbWVcbiAgICAgKiBAcmV0dXJucyB0aGUgc3RyaW5nIFwiVmVjdG9yM1wiXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ1ZlY3RvcjMnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBWZWN0b3IzIGhhc2ggY29kZVxuICAgICAqIEByZXR1cm5zIGEgbnVtYmVyIHdoaWNoIHRlbmRzIHRvIGJlIHVuaXF1ZSBiZXR3ZWVuIFZlY3RvcjMgaW5zdGFuY2VzXG4gICAgICovXG4gICAgZ2V0SGFzaENvZGUoKSB7XG4gICAgICAgIGxldCBoYXNoID0gdGhpcy54IHx8IDA7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIDM5NykgXiAodGhpcy55IHx8IDApO1xuICAgICAgICBoYXNoID0gKGhhc2ggKiAzOTcpIF4gKHRoaXMueiB8fCAwKTtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIC8vIE9wZXJhdG9yc1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aHJlZSBlbGVtZW50cyA6IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgVmVjdG9yM1xuICAgICAqIEByZXR1cm5zIGEgbmV3IGFycmF5IG9mIG51bWJlcnNcbiAgICAgKi9cbiAgICBhc0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy50b0FycmF5KHJlc3VsdCwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyB0aGUgZ2l2ZW4gYXJyYXkgb3IgRmxvYXRBcnJheSBmcm9tIHRoZSBnaXZlbiBpbmRleCB3aXRoIHRoZSBzdWNjZXNzaXZlIGNvb3JkaW5hdGVzIG9mIHRoZSBWZWN0b3IzXG4gICAgICogQHBhcmFtIGFycmF5IC0gZGVmaW5lcyB0aGUgZGVzdGluYXRpb24gYXJyYXlcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBkZWZpbmVzIHRoZSBvZmZzZXQgaW4gdGhlIGRlc3RpbmF0aW9uIGFycmF5XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgVmVjdG9yM1xuICAgICAqL1xuICAgIHRvQXJyYXkoYXJyYXksIGluZGV4ID0gMCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSB0aGlzLng7XG4gICAgICAgIGFycmF5W2luZGV4ICsgMV0gPSB0aGlzLnk7XG4gICAgICAgIGFycmF5W2luZGV4ICsgMl0gPSB0aGlzLno7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCBWZWN0b3IzIGludG8gYSBxdWF0ZXJuaW9uIChjb25zaWRlcmluZyB0aGF0IHRoZSBWZWN0b3IzIGNvbnRhaW5zIEV1bGVyIGFuZ2xlcyByZXByZXNlbnRhdGlvbiBvZiBhIHJvdGF0aW9uKVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFF1YXRlcm5pb24gb2JqZWN0LCBjb21wdXRlZCBmcm9tIHRoZSBWZWN0b3IzIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgdG9RdWF0ZXJuaW9uKCkge1xuICAgICAgICByZXR1cm4gUXVhdGVybmlvbl8xLlF1YXRlcm5pb24uSWRlbnRpdHkuc2V0RXVsZXIodGhpcy55LCB0aGlzLngsIHRoaXMueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZlY3RvciB0byB0aGUgY3VycmVudCBWZWN0b3IzXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjNcbiAgICAgKi9cbiAgICBhZGRJblBsYWNlKG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEluUGxhY2VGcm9tRmxvYXRzKG90aGVyVmVjdG9yLngsIG90aGVyVmVjdG9yLnksIG90aGVyVmVjdG9yLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBjb29yZGluYXRlcyB0byB0aGUgY3VycmVudCBWZWN0b3IzXG4gICAgICogQHBhcmFtIHggLSBkZWZpbmVzIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG9wZXJhbmRcbiAgICAgKiBAcGFyYW0geSAtIGRlZmluZXMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB6IC0gZGVmaW5lcyB0aGUgeiBjb29yZGluYXRlIG9mIHRoZSBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBWZWN0b3IzXG4gICAgICovXG4gICAgYWRkSW5QbGFjZUZyb21GbG9hdHMoeCwgeSwgeikge1xuICAgICAgICB0aGlzLnggKz0geDtcbiAgICAgICAgdGhpcy55ICs9IHk7XG4gICAgICAgIHRoaXMueiArPSB6O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIG5ldyBWZWN0b3IzLCByZXN1bHQgb2YgdGhlIGFkZGl0aW9uIHRoZSBjdXJyZW50IFZlY3RvcjMgYW5kIHRoZSBnaXZlbiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gb3RoZXJWZWN0b3IgLSBkZWZpbmVzIHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSByZXN1bHRpbmcgVmVjdG9yM1xuICAgICAqL1xuICAgIGFkZChvdGhlclZlY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy54ICsgb3RoZXJWZWN0b3IueCwgdGhpcy55ICsgb3RoZXJWZWN0b3IueSwgdGhpcy56ICsgb3RoZXJWZWN0b3Iueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGN1cnJlbnQgVmVjdG9yMyB0byB0aGUgZ2l2ZW4gb25lIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgdmVjdG9yIFwicmVzdWx0XCJcbiAgICAgKiBAcGFyYW0gb3RoZXJWZWN0b3IgLSBkZWZpbmVzIHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBWZWN0b3IzIG9iamVjdCB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgVmVjdG9yM1xuICAgICAqL1xuICAgIGFkZFRvUmVmKG90aGVyVmVjdG9yLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5RnJvbUZsb2F0cyh0aGlzLnggKyBvdGhlclZlY3Rvci54LCB0aGlzLnkgKyBvdGhlclZlY3Rvci55LCB0aGlzLnogKyBvdGhlclZlY3Rvci56KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdGhlIGdpdmVuIHZlY3RvciBmcm9tIHRoZSBjdXJyZW50IFZlY3RvcjNcbiAgICAgKiBAcGFyYW0gb3RoZXJWZWN0b3IgLSBkZWZpbmVzIHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgVmVjdG9yM1xuICAgICAqL1xuICAgIHN1YnRyYWN0SW5QbGFjZShvdGhlclZlY3Rvcikge1xuICAgICAgICB0aGlzLnggLT0gb3RoZXJWZWN0b3IueDtcbiAgICAgICAgdGhpcy55IC09IG90aGVyVmVjdG9yLnk7XG4gICAgICAgIHRoaXMueiAtPSBvdGhlclZlY3Rvci56O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzLCByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiB2ZWN0b3IgZnJvbSB0aGUgY3VycmVudCBWZWN0b3IzXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVzdWx0aW5nIFZlY3RvcjNcbiAgICAgKi9cbiAgICBzdWJ0cmFjdChvdGhlclZlY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy54IC0gb3RoZXJWZWN0b3IueCwgdGhpcy55IC0gb3RoZXJWZWN0b3IueSwgdGhpcy56IC0gb3RoZXJWZWN0b3Iueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gdmVjdG9yIGZyb20gdGhlIGN1cnJlbnQgVmVjdG9yMyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIHZlY3RvciBcInJlc3VsdFwiLlxuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIFZlY3RvcjMgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBWZWN0b3IzXG4gICAgICovXG4gICAgc3VidHJhY3RUb1JlZihvdGhlclZlY3RvciwgcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0RnJvbUZsb2F0c1RvUmVmKG90aGVyVmVjdG9yLngsIG90aGVyVmVjdG9yLnksIG90aGVyVmVjdG9yLnosIHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yMyBzZXQgd2l0aCB0aGUgc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIGZsb2F0cyBmcm9tIHRoZSBjdXJyZW50IFZlY3RvcjMgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZXMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSBvcGVyYW5kXG4gICAgICogQHBhcmFtIHogLSBkZWZpbmVzIHRoZSB6IGNvb3JkaW5hdGUgb2YgdGhlIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVzdWx0aW5nIFZlY3RvcjNcbiAgICAgKi9cbiAgICBzdWJ0cmFjdEZyb21GbG9hdHMoeCwgeSwgeikge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy54IC0geCwgdGhpcy55IC0geSwgdGhpcy56IC0geik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gZmxvYXRzIGZyb20gdGhlIGN1cnJlbnQgVmVjdG9yMyBjb29yZGluYXRlcyBhbmQgc2V0IHRoZSBnaXZlbiB2ZWN0b3IgXCJyZXN1bHRcIiB3aXRoIHRoaXMgcmVzdWx0XG4gICAgICogQHBhcmFtIHggLSBkZWZpbmVzIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG9wZXJhbmRcbiAgICAgKiBAcGFyYW0geSAtIGRlZmluZXMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB6IC0gZGVmaW5lcyB0aGUgeiBjb29yZGluYXRlIG9mIHRoZSBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIFZlY3RvcjMgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBWZWN0b3IzXG4gICAgICovXG4gICAgc3VidHJhY3RGcm9tRmxvYXRzVG9SZWYoeCwgeSwgeiwgcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29weUZyb21GbG9hdHModGhpcy54IC0geCwgdGhpcy55IC0geSwgdGhpcy56IC0geik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3IgKHdpdGggYW4gaW1wbGljaXQgMSBpbiB0aGUgNHRoIGRpbWVuc2lvbikgYW5kIG0sIGFuZCBkaXZpZGVzIGJ5IHBlcnNwZWN0aXZlXG4gICAgICogQHBhcmFtIG1hdHJpeCAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgKi9cbiAgICBhcHBseU1hdHJpeDQobWF0cml4KSB7XG4gICAgICAgIHRoaXMuYXBwbHlNYXRyaXg0VG9SZWYobWF0cml4LCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHZlY3RvciAod2l0aCBhbiBpbXBsaWNpdCAxIGluIHRoZSA0dGggZGltZW5zaW9uKSBhbmQgbSwgYW5kIGRpdmlkZXMgYnkgcGVyc3BlY3RpdmUgYW5kIHNldCB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgd2l0aCB0aGlzIHJlc3VsdFxuICAgICAqIEBwYXJhbSBtYXRyaXggLSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIFZlY3RvcjMgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBWZWN0b3IzXG4gICAgICovXG4gICAgYXBwbHlNYXRyaXg0VG9SZWYobWF0cml4LCByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgeyB4LCB5LCB6IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG0gfSA9IG1hdHJpeDtcbiAgICAgICAgY29uc3QgdyA9IDEgLyAobVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdKTtcbiAgICAgICAgcmVzdWx0LnggPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pICogdztcbiAgICAgICAgcmVzdWx0LnkgPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pICogdztcbiAgICAgICAgcmVzdWx0LnogPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAqIHc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIGN1cnJlbnQgVmVjdG9yMyBiYXNlZCBvbiB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICAgICAqIEBwYXJhbSBxIC0gZGVmaW5lcyB0aGUgUXVhdGVybmlvblxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IFZlY3RvcjNcbiAgICAgKi9cbiAgICByb3RhdGUocSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVUb1JlZihxLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyBjdXJyZW50IFZlY3RvcjMgYmFzZWQgb24gdGhlIGdpdmVuIHF1YXRlcm5pb24sIGJ1dCBhcHBsaWVzIHRoZSByb3RhdGlvbiB0byB0YXJnZXQgVmVjdG9yMy5cbiAgICAgKiBAcGFyYW0gcSAtIGRlZmluZXMgdGhlIFF1YXRlcm5pb25cbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IFZlY3RvcjNcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBWZWN0b3IzXG4gICAgICovXG4gICAgcm90YXRlVG9SZWYocSwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4OiBxeCwgeTogcXksIHo6IHF6LCB3OiBxdyB9ID0gcTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcbiAgICAgICAgY29uc3QgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gICAgICAgIGNvbnN0IGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICAgICAgICBjb25zdCBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgICAgICAgY29uc3QgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuICAgICAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgICAgIHJlc3VsdC54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICAgICAgcmVzdWx0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgICAgICByZXN1bHQueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgVmVjdG9yMyBzZXQgd2l0aCB0aGUgY3VycmVudCBWZWN0b3IzIG5lZ2F0ZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IzXG4gICAgICovXG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoLXRoaXMueCwgLXRoaXMueSwgLXRoaXMueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIFZlY3RvcjMgY29vcmRpbmF0ZXMgYnkgdGhlIGZsb2F0IFwic2NhbGVcIlxuICAgICAqIEBwYXJhbSBzY2FsZSAtIGRlZmluZXMgdGhlIG11bHRpcGxpZXIgZmFjdG9yXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBWZWN0b3IzXG4gICAgICovXG4gICAgc2NhbGVJblBsYWNlKHNjYWxlKSB7XG4gICAgICAgIHRoaXMueCAqPSBzY2FsZTtcbiAgICAgICAgdGhpcy55ICo9IHNjYWxlO1xuICAgICAgICB0aGlzLnogKj0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjMgc2V0IHdpdGggdGhlIGN1cnJlbnQgVmVjdG9yMyBjb29yZGluYXRlcyBtdWx0aXBsaWVkIGJ5IHRoZSBmbG9hdCBcInNjYWxlXCJcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBtdWx0aXBsaWVyIGZhY3RvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBzY2FsZShzY2FsZSkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy54ICogc2NhbGUsIHRoaXMueSAqIHNjYWxlLCB0aGlzLnogKiBzY2FsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIGN1cnJlbnQgVmVjdG9yMyBjb29yZGluYXRlcyBieSB0aGUgZmxvYXQgXCJzY2FsZVwiIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgZ2l2ZW4gdmVjdG9yIFwicmVzdWx0XCIgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBtdWx0aXBsaWVyIGZhY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBWZWN0b3IzIG9iamVjdCB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgVmVjdG9yM1xuICAgICAqL1xuICAgIHNjYWxlVG9SZWYoc2NhbGUsIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHlGcm9tRmxvYXRzKHRoaXMueCAqIHNjYWxlLCB0aGlzLnkgKiBzY2FsZSwgdGhpcy56ICogc2NhbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZSB0aGUgY3VycmVudCBWZWN0b3IzIHZhbHVlcyBieSBhIGZhY3RvciBhbmQgYWRkIHRoZSByZXN1bHQgdG8gYSBnaXZlbiBWZWN0b3IzXG4gICAgICogQHBhcmFtIHNjYWxlIC0gZGVmaW5lcyB0aGUgc2NhbGUgZmFjdG9yXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIFZlY3RvcjMgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgdW5tb2RpZmllZCBjdXJyZW50IFZlY3RvcjNcbiAgICAgKi9cbiAgICBzY2FsZUFuZEFkZFRvUmVmKHNjYWxlLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5hZGRJblBsYWNlRnJvbUZsb2F0cyh0aGlzLnggKiBzY2FsZSwgdGhpcy55ICogc2NhbGUsIHRoaXMueiAqIHNjYWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IFZlY3RvcjMgYW5kIHRoZSBnaXZlbiB2ZWN0b3IgY29vcmRpbmF0ZXMgYXJlIHN0cmljdGx5IGVxdWFsXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGJvdGggdmVjdG9ycyBhcmUgZXF1YWxzXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHJldHVybiAob3RoZXJWZWN0b3IgJiZcbiAgICAgICAgICAgIHRoaXMueCA9PT0gb3RoZXJWZWN0b3IueCAmJlxuICAgICAgICAgICAgdGhpcy55ID09PSBvdGhlclZlY3Rvci55ICYmXG4gICAgICAgICAgICB0aGlzLnogPT09IG90aGVyVmVjdG9yLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgVmVjdG9yMyBhbmQgdGhlIGdpdmVuIHZlY3RvciBjb29yZGluYXRlcyBhcmUgZGlzdGFudCBsZXNzIHRoYW4gZXBzaWxvblxuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHBhcmFtIGVwc2lsb24gLSBkZWZpbmVzIHRoZSBtaW5pbWFsIGRpc3RhbmNlIHRvIGRlZmluZSB2YWx1ZXMgYXMgZXF1YWxzXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBib3RoIHZlY3RvcnMgYXJlIGRpc3RhbnQgbGVzcyB0aGFuIGVwc2lsb25cbiAgICAgKi9cbiAgICBlcXVhbHNXaXRoRXBzaWxvbihvdGhlclZlY3RvciwgZXBzaWxvbiA9IHR5cGVzXzEuRXBzaWxvbikge1xuICAgICAgICByZXR1cm4gKG90aGVyVmVjdG9yICYmXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbih0aGlzLngsIG90aGVyVmVjdG9yLngsIGVwc2lsb24pICYmXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbih0aGlzLnksIG90aGVyVmVjdG9yLnksIGVwc2lsb24pICYmXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbih0aGlzLnosIG90aGVyVmVjdG9yLnosIGVwc2lsb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IFZlY3RvcjMgY29vcmRpbmF0ZXMgZXF1YWxzIHRoZSBnaXZlbiBmbG9hdHNcbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZXMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSBvcGVyYW5kXG4gICAgICogQHBhcmFtIHogLSBkZWZpbmVzIHRoZSB6IGNvb3JkaW5hdGUgb2YgdGhlIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGJvdGggdmVjdG9ycyBhcmUgZXF1YWxzXG4gICAgICovXG4gICAgZXF1YWxzVG9GbG9hdHMoeCwgeSwgeikge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSB4ICYmIHRoaXMueSA9PT0geSAmJiB0aGlzLnogPT09IHo7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIGN1cnJlbnQgVmVjdG9yMyBjb29yZGluYXRlcyBieSB0aGUgZ2l2ZW4gb25lc1xuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBWZWN0b3IzXG4gICAgICovXG4gICAgbXVsdGlwbHlJblBsYWNlKG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHRoaXMueCAqPSBvdGhlclZlY3Rvci54O1xuICAgICAgICB0aGlzLnkgKj0gb3RoZXJWZWN0b3IueTtcbiAgICAgICAgdGhpcy56ICo9IG90aGVyVmVjdG9yLno7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjMsIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgVmVjdG9yMyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBtdWx0aXBseShvdGhlclZlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseUJ5RmxvYXRzKG90aGVyVmVjdG9yLngsIG90aGVyVmVjdG9yLnksIG90aGVyVmVjdG9yLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoZSBjdXJyZW50IFZlY3RvcjMgYnkgdGhlIGdpdmVuIG9uZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIGdpdmVuIHZlY3RvciBcInJlc3VsdFwiXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgVmVjdG9yMyBvYmplY3Qgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IFZlY3RvcjNcbiAgICAgKi9cbiAgICBtdWx0aXBseVRvUmVmKG90aGVyVmVjdG9yLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5RnJvbUZsb2F0cyh0aGlzLnggKiBvdGhlclZlY3Rvci54LCB0aGlzLnkgKiBvdGhlclZlY3Rvci55LCB0aGlzLnogKiBvdGhlclZlY3Rvci56KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IzIHNldCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIG11bGxpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IFZlY3RvcjMgY29vcmRpbmF0ZXMgYnkgdGhlIGdpdmVuIGZsb2F0c1xuICAgICAqIEBwYXJhbSB4IC0gZGVmaW5lcyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBvcGVyYW5kXG4gICAgICogQHBhcmFtIHkgLSBkZWZpbmVzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG9wZXJhbmRcbiAgICAgKiBAcGFyYW0geiAtIGRlZmluZXMgdGhlIHogY29vcmRpbmF0ZSBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgVmVjdG9yM1xuICAgICAqL1xuICAgIG11bHRpcGx5QnlGbG9hdHMoeCwgeSwgeikge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy54ICogeCwgdGhpcy55ICogeSwgdGhpcy56ICogeik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yMyBzZXQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBWZWN0b3IzIGNvb3JkaW5hdGVzIGJ5IHRoZSBnaXZlbiBvbmVzXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBkaXZpZGUob3RoZXJWZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCAvIG90aGVyVmVjdG9yLngsIHRoaXMueSAvIG90aGVyVmVjdG9yLnksIHRoaXMueiAvIG90aGVyVmVjdG9yLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoZSBjdXJyZW50IFZlY3RvcjMgY29vcmRpbmF0ZXMgYnkgdGhlIGdpdmVuIG9uZXMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSBnaXZlbiB2ZWN0b3IgXCJyZXN1bHRcIlxuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIFZlY3RvcjMgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBWZWN0b3IzXG4gICAgICovXG4gICAgZGl2aWRlVG9SZWYob3RoZXJWZWN0b3IsIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvcHlGcm9tRmxvYXRzKHRoaXMueCAvIG90aGVyVmVjdG9yLngsIHRoaXMueSAvIG90aGVyVmVjdG9yLnksIHRoaXMueiAvIG90aGVyVmVjdG9yLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoZSBjdXJyZW50IFZlY3RvcjMgY29vcmRpbmF0ZXMgYnkgdGhlIGdpdmVuIG9uZXMuXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjNcbiAgICAgKi9cbiAgICBkaXZpZGVJblBsYWNlKG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVRvUmVmKG90aGVyVmVjdG9yLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBWZWN0b3IzIHdpdGggdGhlIG1pbmltYWwgY29vcmRpbmF0ZSB2YWx1ZXMgYmV0d2VlbiBpdHMgYW5kIHRoZSBnaXZlbiB2ZWN0b3Igb25lc1xuICAgICAqIEBwYXJhbSBvdGhlciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBWZWN0b3IzXG4gICAgICovXG4gICAgbWluaW1pemVJblBsYWNlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbmltaXplSW5QbGFjZUZyb21GbG9hdHMob3RoZXIueCwgb3RoZXIueSwgb3RoZXIueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgVmVjdG9yMyB3aXRoIHRoZSBtYXhpbWFsIGNvb3JkaW5hdGUgdmFsdWVzIGJldHdlZW4gaXRzIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yIG9uZXMuXG4gICAgICogQHBhcmFtIG90aGVyIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjNcbiAgICAgKi9cbiAgICBtYXhpbWl6ZUluUGxhY2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4aW1pemVJblBsYWNlRnJvbUZsb2F0cyhvdGhlci54LCBvdGhlci55LCBvdGhlci56KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBWZWN0b3IzIHdpdGggdGhlIG1pbmltYWwgY29vcmRpbmF0ZSB2YWx1ZXMgYmV0d2VlbiBpdHMgYW5kIHRoZSBnaXZlbiBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB4IC0gZGVmaW5lcyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBvcGVyYW5kXG4gICAgICogQHBhcmFtIHkgLSBkZWZpbmVzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG9wZXJhbmRcbiAgICAgKiBAcGFyYW0geiAtIGRlZmluZXMgdGhlIHogY29vcmRpbmF0ZSBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgVmVjdG9yM1xuICAgICAqL1xuICAgIG1pbmltaXplSW5QbGFjZUZyb21GbG9hdHMoeCwgeSwgeikge1xuICAgICAgICBpZiAoeCA8IHRoaXMueCkge1xuICAgICAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA8IHRoaXMueSkge1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeiA8IHRoaXMueikge1xuICAgICAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudCBWZWN0b3IzIHdpdGggdGhlIG1heGltYWwgY29vcmRpbmF0ZSB2YWx1ZXMgYmV0d2VlbiBpdHMgYW5kIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZXMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSBvcGVyYW5kXG4gICAgICogQHBhcmFtIHogLSBkZWZpbmVzIHRoZSB6IGNvb3JkaW5hdGUgb2YgdGhlIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjNcbiAgICAgKi9cbiAgICBtYXhpbWl6ZUluUGxhY2VGcm9tRmxvYXRzKHgsIHksIHopIHtcbiAgICAgICAgaWYgKHggPiB0aGlzLngpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPiB0aGlzLnkpIHtcbiAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHogPiB0aGlzLnopIHtcbiAgICAgICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgVmVjdG9yMyBmcm9tIGN1cnJlbnQgVmVjdG9yMyBmbG9vcmVkIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBmbG9vcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKE1hdGguZmxvb3IodGhpcy54KSwgTWF0aC5mbG9vcih0aGlzLnkpLCBNYXRoLmZsb29yKHRoaXMueikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IFZlY3RvcjMgZnJvbSBjdXJyZW50IFZlY3RvcjMgZmxvb3JlZCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IzXG4gICAgICovXG4gICAgZnJhY3QoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLnggLSBNYXRoLmZsb29yKHRoaXMueCksIHRoaXMueSAtIE1hdGguZmxvb3IodGhpcy55KSwgdGhpcy56IC0gTWF0aC5mbG9vcih0aGlzLnopKTtcbiAgICB9XG4gICAgLy8gUHJvcGVydGllc1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxlbmd0aCBvZiB0aGUgVmVjdG9yM1xuICAgICAqIEByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIFZlY3RvM1xuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGUgVmVjdG9yM1xuICAgICAqIEByZXR1cm5zIHNxdWFyZWQgbGVuZ3RoIG9mIHRoZSBWZWN0b3IzXG4gICAgICovXG4gICAgbGVuZ3RoU3F1YXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHRoZSBjdXJyZW50IFZlY3RvcjMuXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIGlzIGFuIGluIHBsYWNlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjNcbiAgICAgKi9cbiAgICBub3JtYWxpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUZyb21MZW5ndGgodGhpcy5sZW5ndGgoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0aGUgY3VycmVudCBWZWN0b3IzIHdpdGggdGhlIGdpdmVuIGlucHV0IGxlbmd0aC5cbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgaXMgYW4gaW4gcGxhY2Ugb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBsZW4gLSB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjNcbiAgICAgKi9cbiAgICBub3JtYWxpemVGcm9tTGVuZ3RoKGxlbikge1xuICAgICAgICBpZiAobGVuID09PSAwIHx8IGxlbiA9PT0gMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZUluUGxhY2UoMS4wIC8gbGVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHRoZSBjdXJyZW50IFZlY3RvcjMgdG8gYSBuZXcgdmVjdG9yXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBWZWN0b3IzXG4gICAgICovXG4gICAgbm9ybWFsaXplVG9OZXcoKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVUb1JlZihub3JtYWxpemVkKTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0aGUgY3VycmVudCBWZWN0b3IzIHRvIHRoZSByZWZlcmVuY2VcbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlIC0gZGVmaW5lIHRoZSBWZWN0b3IzIHRvIHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIFZlY3RvcjNcbiAgICAgKi9cbiAgICBub3JtYWxpemVUb1JlZihyZWZlcmVuY2UpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCB8fCBsZW4gPT09IDEuMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZS5jb3B5RnJvbUZsb2F0cyh0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVRvUmVmKDEuMCAvIGxlbiwgcmVmZXJlbmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWZWN0b3IzIGNvcGllZCBmcm9tIHRoZSBjdXJyZW50IFZlY3RvcjNcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IFZlY3RvcjNcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIGdpdmVuIHZlY3RvciBjb29yZGluYXRlcyB0byB0aGUgY3VycmVudCBWZWN0b3IzIG9uZXNcbiAgICAgKiBAcGFyYW0gc291cmNlIC0gZGVmaW5lcyB0aGUgc291cmNlIFZlY3RvcjNcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjNcbiAgICAgKi9cbiAgICBjb3B5RnJvbShzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weUZyb21GbG9hdHMoc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgZ2l2ZW4gZmxvYXRzIHRvIHRoZSBjdXJyZW50IFZlY3RvcjMgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZXMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSBvcGVyYW5kXG4gICAgICogQHBhcmFtIHogLSBkZWZpbmVzIHRoZSB6IGNvb3JkaW5hdGUgb2YgdGhlIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjNcbiAgICAgKi9cbiAgICBjb3B5RnJvbUZsb2F0cyh4LCB5LCB6KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIGdpdmVuIGZsb2F0cyB0byB0aGUgY3VycmVudCBWZWN0b3IzIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHggLSBkZWZpbmVzIHRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG9wZXJhbmRcbiAgICAgKiBAcGFyYW0geSAtIGRlZmluZXMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB6IC0gZGVmaW5lcyB0aGUgeiBjb29yZGluYXRlIG9mIHRoZSBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBWZWN0b3IzXG4gICAgICovXG4gICAgc2V0KHgsIHksIHopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weUZyb21GbG9hdHMoeCwgeSwgeik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgZ2l2ZW4gZmxvYXQgdG8gdGhlIGN1cnJlbnQgVmVjdG9yMyBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB2IC0gZGVmaW5lcyB0aGUgeCwgeSBhbmQgeiBjb29yZGluYXRlcyBvZiB0aGUgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgVmVjdG9yM1xuICAgICAqL1xuICAgIHNldEFsbCh2KSB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuVmVjdG9yMyA9IFZlY3RvcjM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3IzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXRoVG1wID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgVmVjdG9yM18xID0gcmVxdWlyZShcIi4vVmVjdG9yM1wiKTtcbmNvbnN0IFF1YXRlcm5pb25fMSA9IHJlcXVpcmUoXCIuL1F1YXRlcm5pb25cIik7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbi8vIFRlbXBvcmFyeSBwcmUtYWxsb2NhdGVkIG9iamVjdHMgZm9yIGVuZ2luZSBpbnRlcm5hbCB1c2Vcbi8vIHVzYWdlIGluIGFueSBpbnRlcm5hbCBmdW5jdGlvbiA6XG4vLyB2YXIgdG1wID0gVG1wLlZlY3RvcjNbMF07ICAgPD0gZ2V0cyBhY2Nlc3MgdG8gdGhlIGZpcnN0IHByZS1jcmVhdGVkIFZlY3RvcjNcbi8vIFRoZXJlJ3MgYSBUbXAgYXJyYXkgcGVyIG9iamVjdCB0eXBlIDogaW50LCBmbG9hdCwgVmVjdG9yMiwgVmVjdG9yMywgVmVjdG9yNCwgUXVhdGVybmlvbiwgTWF0cml4XG4vKipcbiAqIEBwdWJsaWNcbiAqIFNhbWUgYXMgVG1wIGJ1dCBub3QgZXhwb3J0ZWQgdG8ga2VlcCBpdCBvbmx5IGZvciBtYXRoIGZ1bmN0aW9ucyB0byBhdm9pZCBjb25mbGljdHNcbiAqL1xuZXhwb3J0cy5NYXRoVG1wID0ge1xuICAgIFZlY3RvcjM6ICgwLCB1dGlsc18xLmJ1aWxkQXJyYXkpKDYsIFZlY3RvcjNfMS5WZWN0b3IzLlplcm8pLFxuICAgIE1hdHJpeDogKDAsIHV0aWxzXzEuYnVpbGRBcnJheSkoMiwgTWF0cml4XzEuTWF0cml4LklkZW50aXR5KSxcbiAgICBRdWF0ZXJuaW9uOiAoMCwgdXRpbHNfMS5idWlsZEFycmF5KSgzLCBRdWF0ZXJuaW9uXzEuUXVhdGVybmlvbi5aZXJvKSxcbiAgICBzdGF0aWNVcDogVmVjdG9yM18xLlZlY3RvcjMuVXAoKSxcbiAgICB0bXBNYXRyaXg6IE1hdHJpeF8xLk1hdHJpeC5aZXJvKClcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhbGxvY2F0ZWRWYXJpYWJsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFuZ2xlID0gdm9pZCAwO1xuLyoqXG4gKiBEZWZpbmVzIGFuZ2xlIHJlcHJlc2VudGF0aW9uXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEFuZ2xlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEFuZ2xlIG9iamVjdCBvZiBcInJhZGlhbnNcIiByYWRpYW5zIChmbG9hdCkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmFkaWFucykge1xuICAgICAgICB0aGlzLl9yYWRpYW5zID0gcmFkaWFucztcbiAgICAgICAgaWYgKHRoaXMuX3JhZGlhbnMgPCAwLjApIHtcbiAgICAgICAgICAgIHRoaXMuX3JhZGlhbnMgKz0gMi4wICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IEFuZ2xlIG9iamVjdCB2YWx1ZWQgd2l0aCB0aGUgYW5nbGUgdmFsdWUgaW4gcmFkaWFucyBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gdmVjdG9yc1xuICAgICAqIEBwYXJhbSBhIC0gZGVmaW5lcyBmaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gYiAtIGRlZmluZXMgc2Vjb25kIHZlY3RvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IEFuZ2xlXG4gICAgICovXG4gICAgc3RhdGljIEJldHdlZW5Ud29Qb2ludHMoYSwgYikge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGIuc3VidHJhY3QoYSk7XG4gICAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hdGFuMihkZWx0YS55LCBkZWx0YS54KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmdsZSh0aGV0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgQW5nbGUgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGZsb2F0IGluIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0gcmFkaWFucyAtIGRlZmluZXMgdGhlIGFuZ2xlIHZhbHVlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBBbmdsZVxuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tUmFkaWFucyhyYWRpYW5zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5nbGUocmFkaWFucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgQW5nbGUgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGZsb2F0IGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0gZGVncmVlcyAtIGRlZmluZXMgdGhlIGFuZ2xlIHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBBbmdsZVxuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tRGVncmVlcyhkZWdyZWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5nbGUoKGRlZ3JlZXMgKiBNYXRoLlBJKSAvIDE4MC4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJucyB0aGUgQW5nbGUgdmFsdWUgaW4gZGVncmVlcyAoZmxvYXQpXG4gICAgICovXG4gICAgZGVncmVlcygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9yYWRpYW5zICogMTgwLjApIC8gTWF0aC5QSTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJucyB0aGUgQW5nbGUgdmFsdWUgaW4gcmFkaWFucyAoZmxvYXQpXG4gICAgICovXG4gICAgcmFkaWFucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGlhbnM7XG4gICAgfVxufVxuZXhwb3J0cy5BbmdsZSA9IEFuZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5nbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZlY3RvcjIgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBTY2FsYXJfMSA9IHJlcXVpcmUoXCIuL1NjYWxhclwiKTtcbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgdmVjdG9yIGNvbnRhaW5pbmcgMiBjb29yZGluYXRlc1xuICogQHB1YmxpY1xuICovXG5jbGFzcyBWZWN0b3IyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZlY3RvcjIgZnJvbSB0aGUgZ2l2ZW4geCBhbmQgeSBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB4IC0gZGVmaW5lcyB0aGUgZmlyc3QgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgc2Vjb25kIGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogZGVmaW5lcyB0aGUgZmlyc3QgY29vcmRpbmF0ZSAqL1xuICAgIHggPSAwLCBcbiAgICAvKiogZGVmaW5lcyB0aGUgc2Vjb25kIGNvb3JkaW5hdGUgKi9cbiAgICB5ID0gMCkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IFZlY3RvcjIoMCwgMClcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IyXG4gICAgICovXG4gICAgc3RhdGljIFplcm8oKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMigwLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIG5ldyBWZWN0b3IyKDEsIDEpXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMlxuICAgICAqL1xuICAgIHN0YXRpYyBPbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMigxLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IyIGFzIHRoZSByZXN1bHQgb2YgdGhlIGFkZGl0aW9uIG9mIHRoZSB0d28gZ2l2ZW4gdmVjdG9ycy5cbiAgICAgKiBAcGFyYW0gdmVjdG9yMSAtIHRoZSBmaXJzdCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdmVjdG9yMiAtIHRoZSBzZWNvbmQgdmVjdG9yXG4gICAgICogQHJldHVybnMgdGhlIHJlc3VsdGluZyB2ZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgQWRkKHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHZlY3RvcjEueCwgdmVjdG9yMS55KS5hZGRJblBsYWNlKHZlY3RvcjIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IFZlY3RvcjIgc2V0IGZyb20gdGhlIGdpdmVuIGluZGV4IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGFycmF5XG4gICAgICogQHBhcmFtIGFycmF5IC0gZGVmaW5lcyB0aGUgZGF0YSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSBkYXRhIHNvdXJjZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjJcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihhcnJheVtvZmZzZXRdLCBhcnJheVtvZmZzZXQgKyAxXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgXCJyZXN1bHRcIiBmcm9tIHRoZSBnaXZlbiBpbmRleCBlbGVtZW50IG9mIHRoZSBnaXZlbiBhcnJheVxuICAgICAqIEBwYXJhbSBhcnJheSAtIGRlZmluZXMgdGhlIGRhdGEgc291cmNlXG4gICAgICogQHBhcmFtIG9mZnNldCAtIGRlZmluZXMgdGhlIG9mZnNldCBpbiB0aGUgZGF0YSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IHZlY3RvclxuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tQXJyYXlUb1JlZihhcnJheSwgb2Zmc2V0LCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnggPSBhcnJheVtvZmZzZXRdO1xuICAgICAgICByZXN1bHQueSA9IGFycmF5W29mZnNldCArIDFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IFZlY3RvcjIgbG9jYXRlZCBmb3IgXCJhbW91bnRcIiAoZmxvYXQpIG9uIHRoZSBDYXRtdWxsUm9tIHNwbGluZSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBmb3VyIFZlY3RvcjJcbiAgICAgKiBAcGFyYW0gdmFsdWUxIC0gZGVmaW5lcyAxc3QgcG9pbnQgb2YgY29udHJvbFxuICAgICAqIEBwYXJhbSB2YWx1ZTIgLSBkZWZpbmVzIDJuZCBwb2ludCBvZiBjb250cm9sXG4gICAgICogQHBhcmFtIHZhbHVlMyAtIGRlZmluZXMgM3JkIHBvaW50IG9mIGNvbnRyb2xcbiAgICAgKiBAcGFyYW0gdmFsdWU0IC0gZGVmaW5lcyA0dGggcG9pbnQgb2YgY29udHJvbFxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBkZWZpbmVzIHRoZSBpbnRlcnBvbGF0aW9uIGZhY3RvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjJcbiAgICAgKi9cbiAgICBzdGF0aWMgQ2F0bXVsbFJvbSh2YWx1ZTEsIHZhbHVlMiwgdmFsdWUzLCB2YWx1ZTQsIGFtb3VudCkge1xuICAgICAgICBjb25zdCBzcXVhcmVkID0gYW1vdW50ICogYW1vdW50O1xuICAgICAgICBjb25zdCBjdWJlZCA9IGFtb3VudCAqIHNxdWFyZWQ7XG4gICAgICAgIGNvbnN0IHggPSAwLjUgKlxuICAgICAgICAgICAgKDIuMCAqIHZhbHVlMi54ICtcbiAgICAgICAgICAgICAgICAoLXZhbHVlMS54ICsgdmFsdWUzLngpICogYW1vdW50ICtcbiAgICAgICAgICAgICAgICAoMi4wICogdmFsdWUxLnggLSA1LjAgKiB2YWx1ZTIueCArIDQuMCAqIHZhbHVlMy54IC0gdmFsdWU0LngpICpcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlZCArXG4gICAgICAgICAgICAgICAgKC12YWx1ZTEueCArIDMuMCAqIHZhbHVlMi54IC0gMy4wICogdmFsdWUzLnggKyB2YWx1ZTQueCkgKiBjdWJlZCk7XG4gICAgICAgIGNvbnN0IHkgPSAwLjUgKlxuICAgICAgICAgICAgKDIuMCAqIHZhbHVlMi55ICtcbiAgICAgICAgICAgICAgICAoLXZhbHVlMS55ICsgdmFsdWUzLnkpICogYW1vdW50ICtcbiAgICAgICAgICAgICAgICAoMi4wICogdmFsdWUxLnkgLSA1LjAgKiB2YWx1ZTIueSArIDQuMCAqIHZhbHVlMy55IC0gdmFsdWU0LnkpICpcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlZCArXG4gICAgICAgICAgICAgICAgKC12YWx1ZTEueSArIDMuMCAqIHZhbHVlMi55IC0gMy4wICogdmFsdWUzLnkgKyB2YWx1ZTQueSkgKiBjdWJlZCk7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih4LCB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IyIHNldCB3aXRoIHNhbWUgdGhlIGNvb3JkaW5hdGVzIHRoYW4gXCJ2YWx1ZVwiIG9uZXMgaWYgdGhlIHZlY3RvciBcInZhbHVlXCIgaXMgaW4gdGhlIHNxdWFyZSBkZWZpbmVkIGJ5IFwibWluXCIgYW5kIFwibWF4XCIuXG4gICAgICogSWYgYSBjb29yZGluYXRlIG9mIFwidmFsdWVcIiBpcyBsb3dlciB0aGFuIFwibWluXCIgY29vcmRpbmF0ZXMsIHRoZSByZXR1cm5lZCBWZWN0b3IyIGlzIGdpdmVuIHRoaXMgXCJtaW5cIiBjb29yZGluYXRlLlxuICAgICAqIElmIGEgY29vcmRpbmF0ZSBvZiBcInZhbHVlXCIgaXMgZ3JlYXRlciB0aGFuIFwibWF4XCIgY29vcmRpbmF0ZXMsIHRoZSByZXR1cm5lZCBWZWN0b3IyIGlzIGdpdmVuIHRoaXMgXCJtYXhcIiBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHZhbHVlIC0gZGVmaW5lcyB0aGUgdmFsdWUgdG8gY2xhbXBcbiAgICAgKiBAcGFyYW0gbWluIC0gZGVmaW5lcyB0aGUgbG93ZXIgbGltaXRcbiAgICAgKiBAcGFyYW0gbWF4IC0gZGVmaW5lcyB0aGUgdXBwZXIgbGltaXRcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IyXG4gICAgICovXG4gICAgc3RhdGljIENsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICBsZXQgeCA9IHZhbHVlLng7XG4gICAgICAgIHggPSB4ID4gbWF4LnggPyBtYXgueCA6IHg7XG4gICAgICAgIHggPSB4IDwgbWluLnggPyBtaW4ueCA6IHg7XG4gICAgICAgIGxldCB5ID0gdmFsdWUueTtcbiAgICAgICAgeSA9IHkgPiBtYXgueSA/IG1heC55IDogeTtcbiAgICAgICAgeSA9IHkgPCBtaW4ueSA/IG1pbi55IDogeTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHgsIHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjIgbG9jYXRlZCBmb3IgXCJhbW91bnRcIiAoZmxvYXQpIG9uIHRoZSBIZXJtaXRlIHNwbGluZSBkZWZpbmVkIGJ5IHRoZSB2ZWN0b3JzIFwidmFsdWUxXCIsIFwidmFsdWUzXCIsIFwidGFuZ2VudDFcIiwgXCJ0YW5nZW50MlwiXG4gICAgICogQHBhcmFtIHZhbHVlMSAtIGRlZmluZXMgdGhlIDFzdCBjb250cm9sIHBvaW50XG4gICAgICogQHBhcmFtIHRhbmdlbnQxIC0gZGVmaW5lcyB0aGUgb3V0Z29pbmcgdGFuZ2VudFxuICAgICAqIEBwYXJhbSB2YWx1ZTIgLSBkZWZpbmVzIHRoZSAybmQgY29udHJvbCBwb2ludFxuICAgICAqIEBwYXJhbSB0YW5nZW50MiAtIGRlZmluZXMgdGhlIGluY29taW5nIHRhbmdlbnRcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gZGVmaW5lcyB0aGUgaW50ZXJwb2xhdGlvbiBmYWN0b3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IyXG4gICAgICovXG4gICAgc3RhdGljIEhlcm1pdGUodmFsdWUxLCB0YW5nZW50MSwgdmFsdWUyLCB0YW5nZW50MiwgYW1vdW50KSB7XG4gICAgICAgIGNvbnN0IHNxdWFyZWQgPSBhbW91bnQgKiBhbW91bnQ7XG4gICAgICAgIGNvbnN0IGN1YmVkID0gYW1vdW50ICogc3F1YXJlZDtcbiAgICAgICAgY29uc3QgcGFydDEgPSAyLjAgKiBjdWJlZCAtIDMuMCAqIHNxdWFyZWQgKyAxLjA7XG4gICAgICAgIGNvbnN0IHBhcnQyID0gLTIuMCAqIGN1YmVkICsgMy4wICogc3F1YXJlZDtcbiAgICAgICAgY29uc3QgcGFydDMgPSBjdWJlZCAtIDIuMCAqIHNxdWFyZWQgKyBhbW91bnQ7XG4gICAgICAgIGNvbnN0IHBhcnQ0ID0gY3ViZWQgLSBzcXVhcmVkO1xuICAgICAgICBjb25zdCB4ID0gdmFsdWUxLnggKiBwYXJ0MSArXG4gICAgICAgICAgICB2YWx1ZTIueCAqIHBhcnQyICtcbiAgICAgICAgICAgIHRhbmdlbnQxLnggKiBwYXJ0MyArXG4gICAgICAgICAgICB0YW5nZW50Mi54ICogcGFydDQ7XG4gICAgICAgIGNvbnN0IHkgPSB2YWx1ZTEueSAqIHBhcnQxICtcbiAgICAgICAgICAgIHZhbHVlMi55ICogcGFydDIgK1xuICAgICAgICAgICAgdGFuZ2VudDEueSAqIHBhcnQzICtcbiAgICAgICAgICAgIHRhbmdlbnQyLnkgKiBwYXJ0NDtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHgsIHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFZlY3RvcjIgbG9jYXRlZCBmb3IgXCJhbW91bnRcIiAoZmxvYXQpIG9uIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoZSB2ZWN0b3IgXCJzdGFydFwiIGFkbiB0aGUgdmVjdG9yIFwiZW5kXCIuXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gZGVmaW5lcyB0aGUgc3RhcnQgdmVjdG9yXG4gICAgICogQHBhcmFtIGVuZCAtIGRlZmluZXMgdGhlIGVuZCB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gZGVmaW5lcyB0aGUgaW50ZXJwb2xhdGlvbiBmYWN0b3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IyXG4gICAgICovXG4gICAgc3RhdGljIExlcnAoc3RhcnQsIGVuZCwgYW1vdW50KSB7XG4gICAgICAgIGNvbnN0IHggPSBzdGFydC54ICsgKGVuZC54IC0gc3RhcnQueCkgKiBhbW91bnQ7XG4gICAgICAgIGNvbnN0IHkgPSBzdGFydC55ICsgKGVuZC55IC0gc3RhcnQueSkgKiBhbW91bnQ7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih4LCB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhlIHZlY3RvciBcImxlZnRcIiBhbmQgdGhlIHZlY3RvciBcInJpZ2h0XCJcbiAgICAgKiBAcGFyYW0gbGVmdCAtIGRlZmluZXMgZmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyBzZWNvbmQgdmVjdG9yXG4gICAgICogQHJldHVybnMgdGhlIGRvdCBwcm9kdWN0IChmbG9hdClcbiAgICAgKi9cbiAgICBzdGF0aWMgRG90KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0LnggKiByaWdodC54ICsgbGVmdC55ICogcmlnaHQueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IyIGVxdWFsIHRvIHRoZSBub3JtYWxpemVkIGdpdmVuIHZlY3RvclxuICAgICAqIEBwYXJhbSB2ZWN0b3IgLSBkZWZpbmVzIHRoZSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMlxuICAgICAqL1xuICAgIHN0YXRpYyBOb3JtYWxpemUodmVjdG9yKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZlY3RvciA9IG5ldyBWZWN0b3IyKHZlY3Rvci54LCB2ZWN0b3IueSk7XG4gICAgICAgIG5ld1ZlY3Rvci5ub3JtYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIG5ld1ZlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIG5ldyBWZWN0b3IyIHNldCB3aXRoIHRoZSBtaW5pbWFsIGNvb3JkaW5hdGUgdmFsdWVzIGZyb20gdGhlIFwibGVmdFwiIGFuZCBcInJpZ2h0XCIgdmVjdG9yc1xuICAgICAqIEBwYXJhbSBsZWZ0IC0gZGVmaW5lcyAxc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyAybmQgdmVjdG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMlxuICAgICAqL1xuICAgIHN0YXRpYyBNaW5pbWl6ZShsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCB4ID0gbGVmdC54IDwgcmlnaHQueCA/IGxlZnQueCA6IHJpZ2h0Lng7XG4gICAgICAgIGNvbnN0IHkgPSBsZWZ0LnkgPCByaWdodC55ID8gbGVmdC55IDogcmlnaHQueTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHgsIHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IFZlY3RvMiBzZXQgd2l0aCB0aGUgbWF4aW1hbCBjb29yZGluYXRlIHZhbHVlcyBmcm9tIHRoZSBcImxlZnRcIiBhbmQgXCJyaWdodFwiIHZlY3RvcnNcbiAgICAgKiBAcGFyYW0gbGVmdCAtIGRlZmluZXMgMXN0IHZlY3RvclxuICAgICAqIEBwYXJhbSByaWdodCAtIGRlZmluZXMgMm5kIHZlY3RvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjJcbiAgICAgKi9cbiAgICBzdGF0aWMgTWF4aW1pemUobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgeCA9IGxlZnQueCA+IHJpZ2h0LnggPyBsZWZ0LnggOiByaWdodC54O1xuICAgICAgICBjb25zdCB5ID0gbGVmdC55ID4gcmlnaHQueSA/IGxlZnQueSA6IHJpZ2h0Lnk7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih4LCB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIG5ldyBWZWN0b3IyIHNldCB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gdmVjdG9yIGJ5IHRoZSBnaXZlbiB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgKiBAcGFyYW0gdmVjdG9yIC0gZGVmaW5lcyB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1hdGlvbiAtIGRlZmluZXMgdGhlIG1hdHJpeCB0byBhcHBseVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjJcbiAgICAgKi9cbiAgICBzdGF0aWMgVHJhbnNmb3JtKHZlY3RvciwgdHJhbnNmb3JtYXRpb24pIHtcbiAgICAgICAgY29uc3QgciA9IFZlY3RvcjIuWmVybygpO1xuICAgICAgICBWZWN0b3IyLlRyYW5zZm9ybVRvUmVmKHZlY3RvciwgdHJhbnNmb3JtYXRpb24sIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gdmVjdG9yIGNvb3JkaW5hdGVzIGJ5IHRoZSBnaXZlbiB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIHRoZSB2ZWN0b3IgXCJyZXN1bHRcIiBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB2ZWN0b3IgLSBkZWZpbmVzIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWF0aW9uIC0gZGVmaW5lcyB0aGUgbWF0cml4IHRvIGFwcGx5XG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIHRhcmdldCB2ZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgVHJhbnNmb3JtVG9SZWYodmVjdG9yLCB0cmFuc2Zvcm1hdGlvbiwgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IG0gPSB0cmFuc2Zvcm1hdGlvbi5tO1xuICAgICAgICBjb25zdCB4ID0gdmVjdG9yLnggKiBtWzBdICsgdmVjdG9yLnkgKiBtWzRdICsgbVsxMl07XG4gICAgICAgIGNvbnN0IHkgPSB2ZWN0b3IueCAqIG1bMV0gKyB2ZWN0b3IueSAqIG1bNV0gKyBtWzEzXTtcbiAgICAgICAgcmVzdWx0LnggPSB4O1xuICAgICAgICByZXN1bHQueSA9IHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2ZWN0b3IgaXMgaW5jbHVkZWQgaW4gYSB0cmlhbmdsZVxuICAgICAqIEBwYXJhbSBwIC0gZGVmaW5lcyB0aGUgdmVjdG9yIHRvIHRlc3RcbiAgICAgKiBAcGFyYW0gcDAgLSBkZWZpbmVzIDFzdCB0cmlhbmdsZSBwb2ludFxuICAgICAqIEBwYXJhbSBwMSAtIGRlZmluZXMgMm5kIHRyaWFuZ2xlIHBvaW50XG4gICAgICogQHBhcmFtIHAyIC0gZGVmaW5lcyAzcmQgdHJpYW5nbGUgcG9pbnRcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBcInBcIiBpcyBpbiB0aGUgdHJpYW5nbGUgZGVmaW5lZCBieSB0aGUgdmVydG9ycyBcInAwXCIsIFwicDFcIiwgXCJwMlwiXG4gICAgICovXG4gICAgc3RhdGljIFBvaW50SW5UcmlhbmdsZShwLCBwMCwgcDEsIHAyKSB7XG4gICAgICAgIGNvbnN0IGEgPSAoMSAvIDIpICpcbiAgICAgICAgICAgICgtcDEueSAqIHAyLnggK1xuICAgICAgICAgICAgICAgIHAwLnkgKiAoLXAxLnggKyBwMi54KSArXG4gICAgICAgICAgICAgICAgcDAueCAqIChwMS55IC0gcDIueSkgK1xuICAgICAgICAgICAgICAgIHAxLnggKiBwMi55KTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IGEgPCAwID8gLTEgOiAxO1xuICAgICAgICBjb25zdCBzID0gKHAwLnkgKiBwMi54IC0gcDAueCAqIHAyLnkgKyAocDIueSAtIHAwLnkpICogcC54ICsgKHAwLnggLSBwMi54KSAqIHAueSkgKlxuICAgICAgICAgICAgc2lnbjtcbiAgICAgICAgY29uc3QgdCA9IChwMC54ICogcDEueSAtIHAwLnkgKiBwMS54ICsgKHAwLnkgLSBwMS55KSAqIHAueCArIChwMS54IC0gcDAueCkgKiBwLnkpICpcbiAgICAgICAgICAgIHNpZ247XG4gICAgICAgIHJldHVybiBzID4gMCAmJiB0ID4gMCAmJiBzICsgdCA8IDIgKiBhICogc2lnbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdmVjdG9ycyBcInZhbHVlMVwiIGFuZCBcInZhbHVlMlwiXG4gICAgICogQHBhcmFtIHZhbHVlMSAtIGRlZmluZXMgZmlyc3QgdmVjdG9yXG4gICAgICogQHBhcmFtIHZhbHVlMiAtIGRlZmluZXMgc2Vjb25kIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHZlY3RvcnNcbiAgICAgKi9cbiAgICBzdGF0aWMgRGlzdGFuY2UodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChWZWN0b3IyLkRpc3RhbmNlU3F1YXJlZCh2YWx1ZTEsIHZhbHVlMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdGhlIHZlY3RvcnMgXCJ2YWx1ZTFcIiBhbmQgXCJ2YWx1ZTJcIlxuICAgICAqIEBwYXJhbSB2YWx1ZTEgLSBkZWZpbmVzIGZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB2YWx1ZTIgLSBkZWZpbmVzIHNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHZlY3RvcnNcbiAgICAgKi9cbiAgICBzdGF0aWMgRGlzdGFuY2VTcXVhcmVkKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICAgIGNvbnN0IHggPSB2YWx1ZTEueCAtIHZhbHVlMi54O1xuICAgICAgICBjb25zdCB5ID0gdmFsdWUxLnkgLSB2YWx1ZTIueTtcbiAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgVmVjdG9yMiBsb2NhdGVkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIHZlY3RvcnMgXCJ2YWx1ZTFcIiBhbmQgXCJ2YWx1ZTJcIlxuICAgICAqIEBwYXJhbSB2YWx1ZTEgLSBkZWZpbmVzIGZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSB2YWx1ZTIgLSBkZWZpbmVzIHNlY29uZCB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IyXG4gICAgICovXG4gICAgc3RhdGljIENlbnRlcih2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBWZWN0b3IyLkFkZCh2YWx1ZTEsIHZhbHVlMik7XG4gICAgICAgIGNlbnRlci5zY2FsZUluUGxhY2UoMC41KTtcbiAgICAgICAgcmV0dXJuIGNlbnRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgKGZsb2F0KSBiZXR3ZWVuIHRoZSBwb2ludCBcInBcIiBhbmQgdGhlIHNlZ21lbnQgZGVmaW5lZCBieSB0aGUgdHdvIHBvaW50cyBcInNlZ0FcIiBhbmQgXCJzZWdCXCIuXG4gICAgICogQHBhcmFtIHAgLSBkZWZpbmVzIHRoZSBtaWRkbGUgcG9pbnRcbiAgICAgKiBAcGFyYW0gc2VnQSAtIGRlZmluZXMgb25lIHBvaW50IG9mIHRoZSBzZWdtZW50XG4gICAgICogQHBhcmFtIHNlZ0IgLSBkZWZpbmVzIHRoZSBvdGhlciBwb2ludCBvZiB0aGUgc2VnbWVudFxuICAgICAqIEByZXR1cm5zIHRoZSBzaG9ydGVzdCBkaXN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBEaXN0YW5jZU9mUG9pbnRGcm9tU2VnbWVudChwLCBzZWdBLCBzZWdCKSB7XG4gICAgICAgIGNvbnN0IGwyID0gVmVjdG9yMi5EaXN0YW5jZVNxdWFyZWQoc2VnQSwgc2VnQik7XG4gICAgICAgIGlmIChsMiA9PT0gMC4wKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yMi5EaXN0YW5jZShwLCBzZWdBKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ID0gc2VnQi5zdWJ0cmFjdChzZWdBKTtcbiAgICAgICAgY29uc3QgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIFZlY3RvcjIuRG90KHAuc3VidHJhY3Qoc2VnQSksIHYpIC8gbDIpKTtcbiAgICAgICAgY29uc3QgcHJvaiA9IHNlZ0EuYWRkKHYubXVsdGlwbHlCeUZsb2F0cyh0LCB0KSk7XG4gICAgICAgIHJldHVybiBWZWN0b3IyLkRpc3RhbmNlKHAsIHByb2opO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc3RyaW5nIHdpdGggdGhlIFZlY3RvcjIgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBWZWN0b3IyIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAne1g6ICcgKyB0aGlzLnggKyAnIFk6JyArIHRoaXMueSArICd9JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjbGFzcyBuYW1lXG4gICAgICogQHJldHVybnMgdGhlIHN0cmluZyBcIlZlY3RvcjJcIlxuICAgICAqL1xuICAgIGdldENsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdWZWN0b3IyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjdXJyZW50IHZlY3RvciBoYXNoIGNvZGVcbiAgICAgKiBAcmV0dXJucyB0aGUgVmVjdG9yMiBoYXNoIGNvZGUgYXMgYSBudW1iZXJcbiAgICAgKi9cbiAgICBnZXRIYXNoQ29kZSgpIHtcbiAgICAgICAgbGV0IGhhc2ggPSB0aGlzLnggfHwgMDtcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzk3KSBeICh0aGlzLnkgfHwgMCk7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgICAvLyBPcGVyYXRvcnNcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBWZWN0b3IyIGNvb3JkaW5hdGVzIGluIHRoZSBnaXZlbiBhcnJheSBvciBGbG9hdEFycmF5IGZyb20gdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSBhcnJheSAtIGRlZmluZXMgdGhlIHNvdXJjZSBhcnJheVxuICAgICAqIEBwYXJhbSBpbmRleCAtIGRlZmluZXMgdGhlIG9mZnNldCBpbiBzb3VyY2UgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBWZWN0b3IyXG4gICAgICovXG4gICAgdG9BcnJheShhcnJheSwgaW5kZXggPSAwKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHRoaXMueDtcbiAgICAgICAgYXJyYXlbaW5kZXggKyAxXSA9IHRoaXMueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHkgdGhlIGN1cnJlbnQgdmVjdG9yIHRvIGFuIGFycmF5XG4gICAgICogQHJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCAyIGVsZW1lbnRzOiB0aGUgVmVjdG9yMiBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBhc0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy50b0FycmF5KHJlc3VsdCwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFZlY3RvcjIgY29vcmRpbmF0ZXMgd2l0aCB0aGUgZ2l2ZW4gVmVjdG9yMiBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBkZWZpbmVzIHRoZSBzb3VyY2UgVmVjdG9yMlxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgVmVjdG9yMlxuICAgICAqL1xuICAgIGNvcHlGcm9tKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnggPSBzb3VyY2UueDtcbiAgICAgICAgdGhpcy55ID0gc291cmNlLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBWZWN0b3IyIGNvb3JkaW5hdGVzIHdpdGggdGhlIGdpdmVuIGZsb2F0c1xuICAgICAqIEBwYXJhbSB4IC0gZGVmaW5lcyB0aGUgZmlyc3QgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgc2Vjb25kIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjJcbiAgICAgKi9cbiAgICBjb3B5RnJvbUZsb2F0cyh4LCB5KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBWZWN0b3IyIGNvb3JkaW5hdGVzIHdpdGggdGhlIGdpdmVuIGZsb2F0c1xuICAgICAqIEBwYXJhbSB4IC0gZGVmaW5lcyB0aGUgZmlyc3QgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB5IC0gZGVmaW5lcyB0aGUgc2Vjb25kIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjJcbiAgICAgKi9cbiAgICBzZXQoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5RnJvbUZsb2F0cyh4LCB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFub3RoZXIgdmVjdG9yIHdpdGggdGhlIGN1cnJlbnQgb25lXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgb3RoZXIgdmVjdG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMiBzZXQgd2l0aCB0aGUgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgVmVjdG9yMiBhbmQgdGhlIGdpdmVuIG9uZSBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIGFkZChvdGhlclZlY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54ICsgb3RoZXJWZWN0b3IueCwgdGhpcy55ICsgb3RoZXJWZWN0b3IueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFwicmVzdWx0XCIgY29vcmRpbmF0ZXMgd2l0aCB0aGUgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgVmVjdG9yMiBhbmQgdGhlIGdpdmVuIG9uZSBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIG90aGVyIHZlY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgdmVjdG9yXG4gICAgICogQHJldHVybnMgdGhlIHVubW9kaWZpZWQgY3VycmVudCBWZWN0b3IyXG4gICAgICovXG4gICAgYWRkVG9SZWYob3RoZXJWZWN0b3IsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCA9IHRoaXMueCArIG90aGVyVmVjdG9yLng7XG4gICAgICAgIHJlc3VsdC55ID0gdGhpcy55ICsgb3RoZXJWZWN0b3IueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgVmVjdG9yMiBjb29yZGluYXRlcyBieSBhZGRpbmcgdGhlIGdpdmVuIFZlY3RvcjIgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gb3RoZXJWZWN0b3IgLSBkZWZpbmVzIHRoZSBvdGhlciB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjJcbiAgICAgKi9cbiAgICBhZGRJblBsYWNlKG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHRoaXMueCArPSBvdGhlclZlY3Rvci54O1xuICAgICAgICB0aGlzLnkgKz0gb3RoZXJWZWN0b3IueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgVmVjdG9yMiBieSBhZGRpbmcgdGhlIGN1cnJlbnQgVmVjdG9yMiBjb29yZGluYXRlcyB0byB0aGUgZ2l2ZW4gVmVjdG9yMyB4LCB5IGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgb3RoZXIgdmVjdG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMlxuICAgICAqL1xuICAgIGFkZFZlY3RvcjMob3RoZXJWZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMueCArIG90aGVyVmVjdG9yLngsIHRoaXMueSArIG90aGVyVmVjdG9yLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IFZlY3RvcjIgc2V0IHdpdGggdGhlIHN1YnRyYWN0ZWQgY29vcmRpbmF0ZXMgb2YgdGhlIGdpdmVuIG9uZSBmcm9tIHRoZSBjdXJyZW50IFZlY3RvcjJcbiAgICAgKiBAcGFyYW0gb3RoZXJWZWN0b3IgLSBkZWZpbmVzIHRoZSBvdGhlciB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IyXG4gICAgICovXG4gICAgc3VidHJhY3Qob3RoZXJWZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMueCAtIG90aGVyVmVjdG9yLngsIHRoaXMueSAtIG90aGVyVmVjdG9yLnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBcInJlc3VsdFwiIGNvb3JkaW5hdGVzIHdpdGggdGhlIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBvbmUgZnJvbSB0aGUgY3VycmVudCBWZWN0b3IyIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIG90aGVyIHZlY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgdmVjdG9yXG4gICAgICogQHJldHVybnMgdGhlIHVubW9kaWZpZWQgY3VycmVudCBWZWN0b3IyXG4gICAgICovXG4gICAgc3VidHJhY3RUb1JlZihvdGhlclZlY3RvciwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC54ID0gdGhpcy54IC0gb3RoZXJWZWN0b3IueDtcbiAgICAgICAgcmVzdWx0LnkgPSB0aGlzLnkgLSBvdGhlclZlY3Rvci55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBWZWN0b3IyIGNvb3JkaW5hdGVzIGJ5IHN1YnRyYWN0aW5nIGZyb20gaXQgdGhlIGdpdmVuIG9uZSBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIG90aGVyIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgVmVjdG9yMlxuICAgICAqL1xuICAgIHN1YnRyYWN0SW5QbGFjZShvdGhlclZlY3Rvcikge1xuICAgICAgICB0aGlzLnggLT0gb3RoZXJWZWN0b3IueDtcbiAgICAgICAgdGhpcy55IC09IG90aGVyVmVjdG9yLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIGluIHBsYWNlIHRoZSBjdXJyZW50IFZlY3RvcjIgY29vcmRpbmF0ZXMgYnkgdGhlIGdpdmVuIG9uZXNcbiAgICAgKiBAcGFyYW0gb3RoZXJWZWN0b3IgLSBkZWZpbmVzIHRoZSBvdGhlciB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIFZlY3RvcjJcbiAgICAgKi9cbiAgICBtdWx0aXBseUluUGxhY2Uob3RoZXJWZWN0b3IpIHtcbiAgICAgICAgdGhpcy54ICo9IG90aGVyVmVjdG9yLng7XG4gICAgICAgIHRoaXMueSAqPSBvdGhlclZlY3Rvci55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWN0b3IyIHNldCB3aXRoIHRoZSBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBWZWN0b3IyIGFuZCB0aGUgZ2l2ZW4gb25lIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgb3RoZXIgdmVjdG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMlxuICAgICAqL1xuICAgIG11bHRpcGx5KG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnggKiBvdGhlclZlY3Rvci54LCB0aGlzLnkgKiBvdGhlclZlY3Rvci55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBcInJlc3VsdFwiIGNvb3JkaW5hdGVzIHdpdGggdGhlIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IFZlY3RvcjIgYW5kIHRoZSBnaXZlbiBvbmUgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gb3RoZXJWZWN0b3IgLSBkZWZpbmVzIHRoZSBvdGhlciB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgdGFyZ2V0IHZlY3RvclxuICAgICAqIEByZXR1cm5zIHRoZSB1bm1vZGlmaWVkIGN1cnJlbnQgVmVjdG9yMlxuICAgICAqL1xuICAgIG11bHRpcGx5VG9SZWYob3RoZXJWZWN0b3IsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCA9IHRoaXMueCAqIG90aGVyVmVjdG9yLng7XG4gICAgICAgIHJlc3VsdC55ID0gdGhpcy55ICogb3RoZXJWZWN0b3IueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBuZXcgVmVjdG9yMiBzZXQgd2l0aCB0aGUgVmVjdG9yMiBjb29yZGluYXRlcyBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBmbG9hdHNcbiAgICAgKiBAcGFyYW0geCAtIGRlZmluZXMgdGhlIGZpcnN0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0geSAtIGRlZmluZXMgdGhlIHNlY29uZCBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMlxuICAgICAqL1xuICAgIG11bHRpcGx5QnlGbG9hdHMoeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54ICogeCwgdGhpcy55ICogeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yMiBzZXQgd2l0aCB0aGUgVmVjdG9yMiBjb29yZGluYXRlcyBkaXZpZGVkIGJ5IHRoZSBnaXZlbiBvbmUgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gb3RoZXJWZWN0b3IgLSBkZWZpbmVzIHRoZSBvdGhlciB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IyXG4gICAgICovXG4gICAgZGl2aWRlKG90aGVyVmVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnggLyBvdGhlclZlY3Rvci54LCB0aGlzLnkgLyBvdGhlclZlY3Rvci55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgXCJyZXN1bHRcIiBjb29yZGluYXRlcyB3aXRoIHRoZSBWZWN0b3IyIGRpdmlkZWQgYnkgdGhlIGdpdmVuIG9uZSBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIG90aGVyIHZlY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSB0YXJnZXQgdmVjdG9yXG4gICAgICogQHJldHVybnMgdGhlIHVubW9kaWZpZWQgY3VycmVudCBWZWN0b3IyXG4gICAgICovXG4gICAgZGl2aWRlVG9SZWYob3RoZXJWZWN0b3IsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQueCA9IHRoaXMueCAvIG90aGVyVmVjdG9yLng7XG4gICAgICAgIHJlc3VsdC55ID0gdGhpcy55IC8gb3RoZXJWZWN0b3IueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhlIGN1cnJlbnQgVmVjdG9yMiBjb29yZGluYXRlcyBieSB0aGUgZ2l2ZW4gb25lc1xuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIG90aGVyIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgVmVjdG9yMlxuICAgICAqL1xuICAgIGRpdmlkZUluUGxhY2Uob3RoZXJWZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlVG9SZWYob3RoZXJWZWN0b3IsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IFZlY3RvcjIgd2l0aCBjdXJyZW50IFZlY3RvcjIgbmVnYXRlZCBjb29yZGluYXRlc1xuICAgICAqIEByZXR1cm5zIGEgbmV3IFZlY3RvcjJcbiAgICAgKi9cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMigtdGhpcy54LCAtdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdGhlIFZlY3RvcjIgY29vcmRpbmF0ZXMgYnkgc2NhbGVcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsaW5nIGZhY3RvclxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgVmVjdG9yMlxuICAgICAqL1xuICAgIHNjYWxlSW5QbGFjZShzY2FsZSkge1xuICAgICAgICB0aGlzLnggKj0gc2NhbGU7XG4gICAgICAgIHRoaXMueSAqPSBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjdG9yMiBzY2FsZWQgYnkgXCJzY2FsZVwiIGZyb20gdGhlIGN1cnJlbnQgVmVjdG9yMlxuICAgICAqIEBwYXJhbSBzY2FsZSAtIGRlZmluZXMgdGhlIHNjYWxpbmcgZmFjdG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMlxuICAgICAqL1xuICAgIHNjYWxlKHNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBWZWN0b3IyKDAsIDApO1xuICAgICAgICB0aGlzLnNjYWxlVG9SZWYoc2NhbGUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlIHRoZSBjdXJyZW50IFZlY3RvcjIgdmFsdWVzIGJ5IGEgZmFjdG9yIHRvIGEgZ2l2ZW4gVmVjdG9yMlxuICAgICAqIEBwYXJhbSBzY2FsZSAtIGRlZmluZXMgdGhlIHNjYWxlIGZhY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBWZWN0b3IyIG9iamVjdCB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICogQHJldHVybnMgdGhlIHVubW9kaWZpZWQgY3VycmVudCBWZWN0b3IyXG4gICAgICovXG4gICAgc2NhbGVUb1JlZihzY2FsZSwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC54ID0gdGhpcy54ICogc2NhbGU7XG4gICAgICAgIHJlc3VsdC55ID0gdGhpcy55ICogc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZSB0aGUgY3VycmVudCBWZWN0b3IyIHZhbHVlcyBieSBhIGZhY3RvciBhbmQgYWRkIHRoZSByZXN1bHQgdG8gYSBnaXZlbiBWZWN0b3IyXG4gICAgICogQHBhcmFtIHNjYWxlIC0gZGVmaW5lcyB0aGUgc2NhbGUgZmFjdG9yXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIFZlY3RvcjIgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgdW5tb2RpZmllZCBjdXJyZW50IFZlY3RvcjJcbiAgICAgKi9cbiAgICBzY2FsZUFuZEFkZFRvUmVmKHNjYWxlLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnggKz0gdGhpcy54ICogc2NhbGU7XG4gICAgICAgIHJlc3VsdC55ICs9IHRoaXMueSAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJvb2xlYW4gaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsc1xuICAgICAqIEBwYXJhbSBvdGhlclZlY3RvciAtIGRlZmluZXMgdGhlIG90aGVyIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZlY3RvciBjb29yZGluYXRlcyBzdHJpY3RseSBlcXVhbCB0aGUgY3VycmVudCBWZWN0b3IyIG9uZXNcbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXJWZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyVmVjdG9yICYmIHRoaXMueCA9PT0gb3RoZXJWZWN0b3IueCAmJiB0aGlzLnkgPT09IG90aGVyVmVjdG9yLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBib29sZWFuIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbHMgKHVzaW5nIGFuIGVwc2lsb24gdmFsdWUpXG4gICAgICogQHBhcmFtIG90aGVyVmVjdG9yIC0gZGVmaW5lcyB0aGUgb3RoZXIgdmVjdG9yXG4gICAgICogQHBhcmFtIGVwc2lsb24gLSBkZWZpbmVzIHRoZSBtaW5pbWFsIGRpc3RhbmNlIHRvIGNvbnNpZGVyIGVxdWFsaXR5XG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmVjdG9yIGNvb3JkaW5hdGVzIGFyZSBjbG9zZSB0byB0aGUgY3VycmVudCBvbmVzIGJ5IGEgZGlzdGFuY2Ugb2YgZXBzaWxvbi5cbiAgICAgKi9cbiAgICBlcXVhbHNXaXRoRXBzaWxvbihvdGhlclZlY3RvciwgZXBzaWxvbiA9IHR5cGVzXzEuRXBzaWxvbikge1xuICAgICAgICByZXR1cm4gKG90aGVyVmVjdG9yICYmXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbih0aGlzLngsIG90aGVyVmVjdG9yLngsIGVwc2lsb24pICYmXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbih0aGlzLnksIG90aGVyVmVjdG9yLnksIGVwc2lsb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIG5ldyBWZWN0b3IyIGZyb20gY3VycmVudCBWZWN0b3IyIGZsb29yZWQgdmFsdWVzXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMlxuICAgICAqL1xuICAgIGZsb29yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoTWF0aC5mbG9vcih0aGlzLngpLCBNYXRoLmZsb29yKHRoaXMueSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IFZlY3RvcjIgZnJvbSBjdXJyZW50IFZlY3RvcjIgZmxvb3JlZCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IyXG4gICAgICovXG4gICAgZnJhY3QoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnggLSBNYXRoLmZsb29yKHRoaXMueCksIHRoaXMueSAtIE1hdGguZmxvb3IodGhpcy55KSk7XG4gICAgfVxuICAgIC8vIFByb3BlcnRpZXNcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHRoZSB2ZWN0b3IgbGVuZ3RoIChmbG9hdClcbiAgICAgKi9cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmVjdG9yIHNxdWFyZWQgbGVuZ3RoXG4gICAgICogQHJldHVybnMgdGhlIHZlY3RvciBzcXVhcmVkIGxlbmd0aCAoZmxvYXQpXG4gICAgICovXG4gICAgbGVuZ3RoU3F1YXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcbiAgICB9XG4gICAgLy8gTWV0aG9kc1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0aGUgdmVjdG9yXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBWZWN0b3IyXG4gICAgICovXG4gICAgbm9ybWFsaXplKCkge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSAxLjAgLyBsZW47XG4gICAgICAgIHRoaXMueCAqPSBudW07XG4gICAgICAgIHRoaXMueSAqPSBudW07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmV3IFZlY3RvcjIgY29waWVkIGZyb20gdGhlIFZlY3RvcjJcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBWZWN0b3IyXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLngsIHRoaXMueSk7XG4gICAgfVxufVxuZXhwb3J0cy5WZWN0b3IyID0gVmVjdG9yMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3RvcjIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFyYzIgPSB2b2lkIDA7XG5jb25zdCBBbmdsZV8xID0gcmVxdWlyZShcIi4vQW5nbGVcIik7XG5jb25zdCBWZWN0b3IyXzEgPSByZXF1aXJlKFwiLi9WZWN0b3IyXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuLyoqXG4gKiBUaGlzIHJlcHJlc2VudHMgYW4gYXJjIGluIGEgMmQgc3BhY2UuXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEFyYzIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQXJjIG9iamVjdCBmcm9tIHRoZSB0aHJlZSBnaXZlbiBwb2ludHMgOiBzdGFydCwgbWlkZGxlIGFuZCBlbmQuXG4gICAgICogQHBhcmFtIHN0YXJ0UG9pbnQgLSBEZWZpbmVzIHRoZSBzdGFydCBwb2ludCBvZiB0aGUgYXJjXG4gICAgICogQHBhcmFtIG1pZFBvaW50IC0gRGVmaW5lcyB0aGUgbWlkbGxlIHBvaW50IG9mIHRoZSBhcmNcbiAgICAgKiBAcGFyYW0gZW5kUG9pbnQgLSBEZWZpbmVzIHRoZSBlbmQgcG9pbnQgb2YgdGhlIGFyY1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBEZWZpbmVzIHRoZSBzdGFydCBwb2ludCBvZiB0aGUgYXJjICovXG4gICAgc3RhcnRQb2ludCwgXG4gICAgLyoqIERlZmluZXMgdGhlIG1pZCBwb2ludCBvZiB0aGUgYXJjICovXG4gICAgbWlkUG9pbnQsIFxuICAgIC8qKiBEZWZpbmVzIHRoZSBlbmQgcG9pbnQgb2YgdGhlIGFyYyAqL1xuICAgIGVuZFBvaW50KSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gICAgICAgIHRoaXMubWlkUG9pbnQgPSBtaWRQb2ludDtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IGVuZFBvaW50O1xuICAgICAgICBjb25zdCB0ZW1wID0gTWF0aC5wb3cobWlkUG9pbnQueCwgMikgKyBNYXRoLnBvdyhtaWRQb2ludC55LCAyKTtcbiAgICAgICAgY29uc3Qgc3RhcnRUb01pZCA9IChNYXRoLnBvdyhzdGFydFBvaW50LngsIDIpICsgTWF0aC5wb3coc3RhcnRQb2ludC55LCAyKSAtIHRlbXApIC8gMjtcbiAgICAgICAgY29uc3QgbWlkVG9FbmQgPSAodGVtcCAtIE1hdGgucG93KGVuZFBvaW50LngsIDIpIC0gTWF0aC5wb3coZW5kUG9pbnQueSwgMikpIC8gMjtcbiAgICAgICAgY29uc3QgZGV0ID0gKHN0YXJ0UG9pbnQueCAtIG1pZFBvaW50LngpICogKG1pZFBvaW50LnkgLSBlbmRQb2ludC55KSAtXG4gICAgICAgICAgICAobWlkUG9pbnQueCAtIGVuZFBvaW50LngpICogKHN0YXJ0UG9pbnQueSAtIG1pZFBvaW50LnkpO1xuICAgICAgICB0aGlzLmNlbnRlclBvaW50ID0gbmV3IFZlY3RvcjJfMS5WZWN0b3IyKChzdGFydFRvTWlkICogKG1pZFBvaW50LnkgLSBlbmRQb2ludC55KSAtXG4gICAgICAgICAgICBtaWRUb0VuZCAqIChzdGFydFBvaW50LnkgLSBtaWRQb2ludC55KSkgL1xuICAgICAgICAgICAgZGV0LCAoKHN0YXJ0UG9pbnQueCAtIG1pZFBvaW50LngpICogbWlkVG9FbmQgLVxuICAgICAgICAgICAgKG1pZFBvaW50LnggLSBlbmRQb2ludC54KSAqIHN0YXJ0VG9NaWQpIC9cbiAgICAgICAgICAgIGRldCk7XG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy5jZW50ZXJQb2ludC5zdWJ0cmFjdCh0aGlzLnN0YXJ0UG9pbnQpLmxlbmd0aCgpO1xuICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgPSBBbmdsZV8xLkFuZ2xlLkJldHdlZW5Ud29Qb2ludHModGhpcy5jZW50ZXJQb2ludCwgdGhpcy5zdGFydFBvaW50KTtcbiAgICAgICAgY29uc3QgYTEgPSB0aGlzLnN0YXJ0QW5nbGUuZGVncmVlcygpO1xuICAgICAgICBsZXQgYTIgPSBBbmdsZV8xLkFuZ2xlLkJldHdlZW5Ud29Qb2ludHModGhpcy5jZW50ZXJQb2ludCwgdGhpcy5taWRQb2ludCkuZGVncmVlcygpO1xuICAgICAgICBsZXQgYTMgPSBBbmdsZV8xLkFuZ2xlLkJldHdlZW5Ud29Qb2ludHModGhpcy5jZW50ZXJQb2ludCwgdGhpcy5lbmRQb2ludCkuZGVncmVlcygpO1xuICAgICAgICAvLyBhbmdsZXMgY29ycmVjdGlvblxuICAgICAgICBpZiAoYTIgLSBhMSA+ICsxODAuMCkge1xuICAgICAgICAgICAgYTIgLT0gMzYwLjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEyIC0gYTEgPCAtMTgwLjApIHtcbiAgICAgICAgICAgIGEyICs9IDM2MC4wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhMyAtIGEyID4gKzE4MC4wKSB7XG4gICAgICAgICAgICBhMyAtPSAzNjAuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYTMgLSBhMiA8IC0xODAuMCkge1xuICAgICAgICAgICAgYTMgKz0gMzYwLjA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IGEyIC0gYTEgPCAwID8gdHlwZXNfMS5PcmllbnRhdGlvbi5DVyA6IHR5cGVzXzEuT3JpZW50YXRpb24uQ0NXO1xuICAgICAgICB0aGlzLmFuZ2xlID0gQW5nbGVfMS5BbmdsZS5Gcm9tRGVncmVlcyh0aGlzLm9yaWVudGF0aW9uID09PSB0eXBlc18xLk9yaWVudGF0aW9uLkNXID8gYTEgLSBhMyA6IGEzIC0gYTEpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXJjMiA9IEFyYzI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcmMyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BeGlzID0gdm9pZCAwO1xuY29uc3QgVmVjdG9yM18xID0gcmVxdWlyZShcIi4vVmVjdG9yM1wiKTtcbi8qKlxuICogRGVmaW5lcyB0aGUgMyBtYWluIGF4ZXNcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQXhpcyB7XG59XG5leHBvcnRzLkF4aXMgPSBBeGlzO1xuLyoqIFggYXhpcyAqL1xuQXhpcy5YID0gbmV3IFZlY3RvcjNfMS5WZWN0b3IzKDEuMCwgMC4wLCAwLjApO1xuLyoqIFkgYXhpcyAqL1xuQXhpcy5ZID0gbmV3IFZlY3RvcjNfMS5WZWN0b3IzKDAuMCwgMS4wLCAwLjApO1xuLyoqIFogYXhpcyAqL1xuQXhpcy5aID0gbmV3IFZlY3RvcjNfMS5WZWN0b3IzKDAuMCwgMC4wLCAxLjApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXhpcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmV6aWVyQ3VydmUgPSB2b2lkIDA7XG4vKipcbiAqIENsYXNzIHVzZWQgdG8gcmVwcmVzZW50IGEgQmV6aWVyIGN1cnZlXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEJlemllckN1cnZlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdWJpYyBCZXppZXIgaW50ZXJwb2xhdGVkIHZhbHVlIChmbG9hdCkgYXQgXCJ0XCIgKGZsb2F0KSBmcm9tIHRoZSBnaXZlbiB4MSwgeTEsIHgyLCB5MiBmbG9hdHNcbiAgICAgKiBAcGFyYW0gdCAtIGRlZmluZXMgdGhlIHRpbWVcbiAgICAgKiBAcGFyYW0geDEgLSBkZWZpbmVzIHRoZSBsZWZ0IGNvb3JkaW5hdGUgb24gWCBheGlzXG4gICAgICogQHBhcmFtIHkxIC0gZGVmaW5lcyB0aGUgbGVmdCBjb29yZGluYXRlIG9uIFkgYXhpc1xuICAgICAqIEBwYXJhbSB4MiAtIGRlZmluZXMgdGhlIHJpZ2h0IGNvb3JkaW5hdGUgb24gWCBheGlzXG4gICAgICogQHBhcmFtIHkyIC0gZGVmaW5lcyB0aGUgcmlnaHQgY29vcmRpbmF0ZSBvbiBZIGF4aXNcbiAgICAgKiBAcmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIEludGVycG9sYXRlKHQsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgWCAod2hpY2ggaXMgZXF1YWwgdG8gdGltZSBoZXJlKVxuICAgICAgICBjb25zdCBmMCA9IDEgLSAzICogeDIgKyAzICogeDE7XG4gICAgICAgIGNvbnN0IGYxID0gMyAqIHgyIC0gNiAqIHgxO1xuICAgICAgICBjb25zdCBmMiA9IDMgKiB4MTtcbiAgICAgICAgbGV0IHJlZmluZWRUID0gdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZmluZWRUMiA9IHJlZmluZWRUICogcmVmaW5lZFQ7XG4gICAgICAgICAgICBjb25zdCByZWZpbmVkVDMgPSByZWZpbmVkVDIgKiByZWZpbmVkVDtcbiAgICAgICAgICAgIGNvbnN0IHggPSBmMCAqIHJlZmluZWRUMyArIGYxICogcmVmaW5lZFQyICsgZjIgKiByZWZpbmVkVDtcbiAgICAgICAgICAgIGNvbnN0IHNsb3BlID0gMS4wIC8gKDMuMCAqIGYwICogcmVmaW5lZFQyICsgMi4wICogZjEgKiByZWZpbmVkVCArIGYyKTtcbiAgICAgICAgICAgIHJlZmluZWRUIC09ICh4IC0gdCkgKiBzbG9wZTtcbiAgICAgICAgICAgIHJlZmluZWRUID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgcmVmaW5lZFQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNvbHZlIGN1YmljIGJlemllciBmb3IgdGhlIGdpdmVuIHhcbiAgICAgICAgcmV0dXJuICgzICogTWF0aC5wb3coMSAtIHJlZmluZWRULCAyKSAqIHJlZmluZWRUICogeTEgK1xuICAgICAgICAgICAgMyAqICgxIC0gcmVmaW5lZFQpICogTWF0aC5wb3cocmVmaW5lZFQsIDIpICogeTIgK1xuICAgICAgICAgICAgTWF0aC5wb3cocmVmaW5lZFQsIDMpKTtcbiAgICB9XG59XG5leHBvcnRzLkJlemllckN1cnZlID0gQmV6aWVyQ3VydmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CZXppZXJDdXJ2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sb3I0ID0gdm9pZCAwO1xuY29uc3QgU2NhbGFyXzEgPSByZXF1aXJlKFwiLi9TY2FsYXJcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG4vKipcbiAqIENsYXNzIHVzZWQgdG8gaG9sZCBhIFJCR0EgY29sb3JcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQ29sb3I0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yNCBvYmplY3QgZnJvbSByZWQsIGdyZWVuLCBibHVlIHZhbHVlcywgYWxsIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSByIC0gZGVmaW5lcyB0aGUgcmVkIGNvbXBvbmVudCAoYmV0d2VlbiAwIGFuZCAxLCBkZWZhdWx0IGlzIDApXG4gICAgICogQHBhcmFtIGcgLSBkZWZpbmVzIHRoZSBncmVlbiBjb21wb25lbnQgKGJldHdlZW4gMCBhbmQgMSwgZGVmYXVsdCBpcyAwKVxuICAgICAqIEBwYXJhbSBiIC0gZGVmaW5lcyB0aGUgYmx1ZSBjb21wb25lbnQgKGJldHdlZW4gMCBhbmQgMSwgZGVmYXVsdCBpcyAwKVxuICAgICAqIEBwYXJhbSBhIC0gZGVmaW5lcyB0aGUgYWxwaGEgY29tcG9uZW50IChiZXR3ZWVuIDAgYW5kIDEsIGRlZmF1bHQgaXMgMSlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSByZWQgY29tcG9uZW50IChiZXR3ZWVuIDAgYW5kIDEsIGRlZmF1bHQgaXMgMClcbiAgICAgKi9cbiAgICByID0gMCwgXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgZ3JlZW4gY29tcG9uZW50IChiZXR3ZWVuIDAgYW5kIDEsIGRlZmF1bHQgaXMgMClcbiAgICAgKi9cbiAgICBnID0gMCwgXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgYmx1ZSBjb21wb25lbnQgKGJldHdlZW4gMCBhbmQgMSwgZGVmYXVsdCBpcyAwKVxuICAgICAqL1xuICAgIGIgPSAwLCBcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSBhbHBoYSBjb21wb25lbnQgKGJldHdlZW4gMCBhbmQgMSwgZGVmYXVsdCBpcyAxKVxuICAgICAqL1xuICAgIGEgPSAxKSB7XG4gICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgfVxuICAgIC8vIFN0YXRpY3NcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yNCBmcm9tIHRoZSBzdHJpbmcgY29udGFpbmluZyB2YWxpZCBoZXhhZGVjaW1hbCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gaGV4IC0gZGVmaW5lcyBhIHN0cmluZyBjb250YWluaW5nIHZhbGlkIGhleGFkZWNpbWFsIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbUhleFN0cmluZyhoZXgpIHtcbiAgICAgICAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMSkgIT09ICcjJyB8fCBoZXgubGVuZ3RoICE9PSA5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDEsIDMpLCAxNik7XG4gICAgICAgIGNvbnN0IGcgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDMsIDUpLCAxNik7XG4gICAgICAgIGNvbnN0IGIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDUsIDcpLCAxNik7XG4gICAgICAgIGNvbnN0IGEgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDcsIDkpLCAxNik7XG4gICAgICAgIHJldHVybiBDb2xvcjQuRnJvbUludHMociwgZywgYiwgYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3I0IG9iamVjdCBzZXQgd2l0aCB0aGUgbGluZWFybHkgaW50ZXJwb2xhdGVkIHZhbHVlcyBvZiBcImFtb3VudFwiIGJldHdlZW4gdGhlIGxlZnQgQ29sb3I0IG9iamVjdCBhbmQgdGhlIHJpZ2h0IENvbG9yNCBvYmplY3RcbiAgICAgKiBAcGFyYW0gbGVmdCAtIGRlZmluZXMgdGhlIHN0YXJ0IHZhbHVlXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyB0aGUgZW5kIHZhbHVlXG4gICAgICogQHBhcmFtIGFtb3VudCAtIGRlZmluZXMgdGhlIGdyYWRpZW50IGZhY3RvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgTGVycChsZWZ0LCByaWdodCwgYW1vdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBDb2xvcjQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgQ29sb3I0LkxlcnBUb1JlZihsZWZ0LCByaWdodCwgYW1vdW50LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGdpdmVuIFwicmVzdWx0XCIgd2l0aCB0aGUgbGluZWFybHkgaW50ZXJwb2xhdGVkIHZhbHVlcyBvZiBcImFtb3VudFwiIGJldHdlZW4gdGhlIGxlZnQgQ29sb3I0IG9iamVjdCBhbmQgdGhlIHJpZ2h0IENvbG9yNCBvYmplY3RcbiAgICAgKiBAcGFyYW0gbGVmdCAtIGRlZmluZXMgdGhlIHN0YXJ0IHZhbHVlXG4gICAgICogQHBhcmFtIHJpZ2h0IC0gZGVmaW5lcyB0aGUgZW5kIHZhbHVlXG4gICAgICogQHBhcmFtIGFtb3VudCAtIGRlZmluZXMgdGhlIGdyYWRpZW50IGZhY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBDb2xvcjQgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgTGVycFRvUmVmKGxlZnQsIHJpZ2h0LCBhbW91bnQsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuciA9IGxlZnQuciArIChyaWdodC5yIC0gbGVmdC5yKSAqIGFtb3VudDtcbiAgICAgICAgcmVzdWx0LmcgPSBsZWZ0LmcgKyAocmlnaHQuZyAtIGxlZnQuZykgKiBhbW91bnQ7XG4gICAgICAgIHJlc3VsdC5iID0gbGVmdC5iICsgKHJpZ2h0LmIgLSBsZWZ0LmIpICogYW1vdW50O1xuICAgICAgICByZXN1bHQuYSA9IGxlZnQuYSArIChyaWdodC5hIC0gbGVmdC5hKSAqIGFtb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yNCB2YWx1ZSBjb250YWluaW5nIGEgcmVkIGNvbG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3IzIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBSZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3I0KDEuMCwgMCwgMCwgMS4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yNCB2YWx1ZSBjb250YWluaW5nIGEgZ3JlZW4gY29sb3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIEdyZWVuKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNCgwLCAxLjAsIDAsIDEuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDb2xvcjQgdmFsdWUgY29udGFpbmluZyBhIGJsdWUgY29sb3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIEJsdWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3I0KDAsIDAsIDEuMCwgMS4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yNCB2YWx1ZSBjb250YWluaW5nIGEgYmxhY2sgY29sb3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIEJsYWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNCgwLCAwLCAwLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yNCB2YWx1ZSBjb250YWluaW5nIGEgd2hpdGUgY29sb3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIFdoaXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNCgxLCAxLCAxLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yNCB2YWx1ZSBjb250YWluaW5nIGEgcHVycGxlIGNvbG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3I0IG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBQdXJwbGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3I0KDAuNSwgMCwgMC41LCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yNCB2YWx1ZSBjb250YWluaW5nIGEgbWFnZW50YSBjb2xvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgTWFnZW50YSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjQoMSwgMCwgMSwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDb2xvcjQgdmFsdWUgY29udGFpbmluZyBhIHllbGxvdyBjb2xvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgWWVsbG93KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNCgxLCAxLCAwLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yNCB2YWx1ZSBjb250YWluaW5nIGEgZ3JheSBjb2xvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgR3JheSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjQoMC41LCAwLjUsIDAuNSwgMS4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yNCB2YWx1ZSBjb250YWluaW5nIGEgdGVhbCBjb2xvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgVGVhbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjQoMCwgMS4wLCAxLjAsIDEuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDb2xvcjQgdmFsdWUgY29udGFpbmluZyBhIHRyYW5zcGFyZW50IGNvbG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3I0IG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBDbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjQoMCwgMCwgMCwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3I0IGZyb20gYSBDb2xvcjMgYW5kIGFuIGFscGhhIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbG9yMyAtIGRlZmluZXMgdGhlIHNvdXJjZSBDb2xvcjMgdG8gcmVhZCBmcm9tXG4gICAgICogQHBhcmFtIGFscGhhIC0gZGVmaW5lcyB0aGUgYWxwaGEgY29tcG9uZW50ICgxLjAgYnkgZGVmYXVsdClcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIEZyb21Db2xvcjMoY29sb3IzLCBhbHBoYSA9IDEuMCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNChjb2xvcjMuciwgY29sb3IzLmcsIGNvbG9yMy5iLCBhbHBoYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3I0IGZyb20gdGhlIHN0YXJ0aW5nIGluZGV4IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGFycmF5XG4gICAgICogQHBhcmFtIGFycmF5IC0gZGVmaW5lcyB0aGUgc291cmNlIGFycmF5IHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBkZWZpbmVzIHRoZSBvZmZzZXQgaW4gdGhlIHNvdXJjZSBhcnJheVxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3I0KGFycmF5W29mZnNldF0sIGFycmF5W29mZnNldCArIDFdLCBhcnJheVtvZmZzZXQgKyAyXSwgYXJyYXlbb2Zmc2V0ICsgM10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yMyBmcm9tIGludGVnZXIgdmFsdWVzIChsZXNzIHRoYW4gMjU2KVxuICAgICAqIEBwYXJhbSByIC0gZGVmaW5lcyB0aGUgcmVkIGNvbXBvbmVudCB0byByZWFkIGZyb20gKHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1KVxuICAgICAqIEBwYXJhbSBnIC0gZGVmaW5lcyB0aGUgZ3JlZW4gY29tcG9uZW50IHRvIHJlYWQgZnJvbSAodmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUpXG4gICAgICogQHBhcmFtIGIgLSBkZWZpbmVzIHRoZSBibHVlIGNvbXBvbmVudCB0byByZWFkIGZyb20gKHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1KVxuICAgICAqIEBwYXJhbSBhIC0gZGVmaW5lcyB0aGUgYWxwaGEgY29tcG9uZW50IHRvIHJlYWQgZnJvbSAodmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUpXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3IzIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tSW50cyhyLCBnLCBiLCBhKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3I0KHIgLyAyNTUuMCwgZyAvIDI1NS4wLCBiIC8gMjU1LjAsIGEgLyAyNTUuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBjb250ZW50IG9mIGEgZ2l2ZW4gYXJyYXkgYW5kIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgY29udGFpbmluZyBSR0JBIGRhdGFcbiAgICAgKiBJZiB0aGUgb3JpZ2luYWwgYXJyYXkgd2FzIGFscmVhZHkgY29udGFpbmluZyBjb3VudCAqIDQgdmFsdWVzIHRoZW4gaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHlcbiAgICAgKiBAcGFyYW0gY29sb3JzIC0gZGVmaW5lcyB0aGUgYXJyYXkgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gY291bnQgLSBkZWZpbmVzIHRoZSBudW1iZXIgb2YgUkdCQSBkYXRhIHRvIGV4cGVjdFxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgY291bnQgKiA0IHZhbHVlcyAoUkdCQSlcbiAgICAgKi9cbiAgICBzdGF0aWMgQ2hlY2tDb2xvcnM0KGNvbG9ycywgY291bnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgY29sb3IzIHdhcyB1c2VkXG4gICAgICAgIGlmIChjb2xvcnMubGVuZ3RoID09PSBjb3VudCAqIDMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yczQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjb2xvcnMubGVuZ3RoOyBpbmRleCArPSAzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SW5kZXggPSAoaW5kZXggLyAzKSAqIDQ7XG4gICAgICAgICAgICAgICAgY29sb3JzNFtuZXdJbmRleF0gPSBjb2xvcnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbG9yczRbbmV3SW5kZXggKyAxXSA9IGNvbG9yc1tpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIGNvbG9yczRbbmV3SW5kZXggKyAyXSA9IGNvbG9yc1tpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGNvbG9yczRbbmV3SW5kZXggKyAzXSA9IDEuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2xvcnM0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcnM7XG4gICAgfVxuICAgIC8vIE9wZXJhdG9yc1xuICAgIC8qKlxuICAgICAqIEFkZHMgaW4gcGxhY2UgdGhlIGdpdmVuIENvbG9yNCB2YWx1ZXMgdG8gdGhlIGN1cnJlbnQgQ29sb3I0IG9iamVjdFxuICAgICAqIEBwYXJhbSByaWdodCAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgYWRkSW5QbGFjZShyaWdodCkge1xuICAgICAgICB0aGlzLnIgKz0gcmlnaHQucjtcbiAgICAgICAgdGhpcy5nICs9IHJpZ2h0Lmc7XG4gICAgICAgIHRoaXMuYiArPSByaWdodC5iO1xuICAgICAgICB0aGlzLmEgKz0gcmlnaHQuYTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgcG9wdWxhdGVkIHdpdGggNCBudW1lcmljIGVsZW1lbnRzIDogcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEgdmFsdWVzXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBhcnJheVxuICAgICAqL1xuICAgIGFzQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnRvQXJyYXkocmVzdWx0LCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcmVzIGZyb20gdGhlIHN0YXJ0aW5nIGluZGV4IGluIHRoZSBnaXZlbiBhcnJheSB0aGUgQ29sb3I0IHN1Y2Nlc3NpdmUgdmFsdWVzXG4gICAgICogQHBhcmFtIGFycmF5IC0gZGVmaW5lcyB0aGUgYXJyYXkgd2hlcmUgdG8gc3RvcmUgdGhlIHIsZyxiIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBkZWZpbmVzIGFuIG9wdGlvbmFsIGluZGV4IGluIHRoZSB0YXJnZXQgYXJyYXkgdG8gZGVmaW5lIHdoZXJlIHRvIHN0YXJ0IHN0b3JpbmcgdmFsdWVzXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgQ29sb3I0IG9iamVjdFxuICAgICAqL1xuICAgIHRvQXJyYXkoYXJyYXksIGluZGV4ID0gMCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSB0aGlzLnI7XG4gICAgICAgIGFycmF5W2luZGV4ICsgMV0gPSB0aGlzLmc7XG4gICAgICAgIGFycmF5W2luZGV4ICsgMl0gPSB0aGlzLmI7XG4gICAgICAgIGFycmF5W2luZGV4ICsgM10gPSB0aGlzLmE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yNCBzZXQgd2l0aCB0aGUgYWRkZWQgdmFsdWVzIG9mIHRoZSBjdXJyZW50IENvbG9yNCBhbmQgb2YgdGhlIGdpdmVuIG9uZVxuICAgICAqIEBwYXJhbSByaWdodCAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3I0IG9iamVjdFxuICAgICAqL1xuICAgIGFkZChyaWdodCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNCh0aGlzLnIgKyByaWdodC5yLCB0aGlzLmcgKyByaWdodC5nLCB0aGlzLmIgKyByaWdodC5iLCB0aGlzLmEgKyByaWdodC5hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvcjQgc2V0IHdpdGggdGhlIHN1YnRyYWN0ZWQgdmFsdWVzIG9mIHRoZSBnaXZlbiBvbmUgZnJvbSB0aGUgY3VycmVudCBDb2xvcjRcbiAgICAgKiBAcGFyYW0gcmlnaHQgLSBkZWZpbmVzIHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBzdWJ0cmFjdChyaWdodCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNCh0aGlzLnIgLSByaWdodC5yLCB0aGlzLmcgLSByaWdodC5nLCB0aGlzLmIgLSByaWdodC5iLCB0aGlzLmEgLSByaWdodC5hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHRoZSBnaXZlbiBvbmVzIGZyb20gdGhlIGN1cnJlbnQgQ29sb3I0IHZhbHVlcyBhbmQgc3RvcmVzIHRoZSByZXN1bHRzIGluIFwicmVzdWx0XCJcbiAgICAgKiBAcGFyYW0gcmlnaHQgLSBkZWZpbmVzIHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBDb2xvcjQgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgc3VidHJhY3RUb1JlZihyaWdodCwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5yID0gdGhpcy5yIC0gcmlnaHQucjtcbiAgICAgICAgcmVzdWx0LmcgPSB0aGlzLmcgLSByaWdodC5nO1xuICAgICAgICByZXN1bHQuYiA9IHRoaXMuYiAtIHJpZ2h0LmI7XG4gICAgICAgIHJlc3VsdC5hID0gdGhpcy5hIC0gcmlnaHQuYTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3I0IHdpdGggdGhlIGN1cnJlbnQgQ29sb3I0IHZhbHVlcyBtdWx0aXBsaWVkIGJ5IHNjYWxlXG4gICAgICogQHBhcmFtIHNjYWxlIC0gZGVmaW5lcyB0aGUgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHlcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgc2NhbGUoc2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjQodGhpcy5yICogc2NhbGUsIHRoaXMuZyAqIHNjYWxlLCB0aGlzLmIgKiBzY2FsZSwgdGhpcy5hICogc2NhbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoZSBjdXJyZW50IENvbG9yNCB2YWx1ZXMgYnkgc2NhbGUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIFwicmVzdWx0XCJcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsaW5nIGZhY3RvciB0byBhcHBseVxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBDb2xvcjQgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1bm1vZGlmaWVkIENvbG9yNFxuICAgICAqL1xuICAgIHNjYWxlVG9SZWYoc2NhbGUsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuciA9IHRoaXMuciAqIHNjYWxlO1xuICAgICAgICByZXN1bHQuZyA9IHRoaXMuZyAqIHNjYWxlO1xuICAgICAgICByZXN1bHQuYiA9IHRoaXMuYiAqIHNjYWxlO1xuICAgICAgICByZXN1bHQuYSA9IHRoaXMuYSAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGUgdGhlIGN1cnJlbnQgQ29sb3I0IHZhbHVlcyBieSBhIGZhY3RvciBhbmQgYWRkIHRoZSByZXN1bHQgdG8gYSBnaXZlbiBDb2xvcjRcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsZSBmYWN0b3JcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgQ29sb3I0IG9iamVjdCB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICogQHJldHVybnMgdGhlIHVubW9kaWZpZWQgY3VycmVudCBDb2xvcjRcbiAgICAgKi9cbiAgICBzY2FsZUFuZEFkZFRvUmVmKHNjYWxlLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnIgKz0gdGhpcy5yICogc2NhbGU7XG4gICAgICAgIHJlc3VsdC5nICs9IHRoaXMuZyAqIHNjYWxlO1xuICAgICAgICByZXN1bHQuYiArPSB0aGlzLmIgKiBzY2FsZTtcbiAgICAgICAgcmVzdWx0LmEgKz0gdGhpcy5hICogc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgdGhlIHJnYiB2YWx1ZXMgYnkgdGhlIG1pbiBhbmQgbWF4IHZhbHVlcyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBcInJlc3VsdFwiXG4gICAgICogQHBhcmFtIG1pbiAtIGRlZmluZXMgbWluaW11bSBjbGFtcGluZyB2YWx1ZSAoZGVmYXVsdCBpcyAwKVxuICAgICAqIEBwYXJhbSBtYXggLSBkZWZpbmVzIG1heGltdW0gY2xhbXBpbmcgdmFsdWUgKGRlZmF1bHQgaXMgMSlcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyBjb2xvciB0byBzdG9yZSB0aGUgcmVzdWx0IGludG8uXG4gICAgICogQHJldHVybnMgdGhlIGN1dXJlbnQgQ29sb3I0XG4gICAgICovXG4gICAgY2xhbXBUb1JlZihtaW4gPSAwLCBtYXggPSAxLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnIgPSBTY2FsYXJfMS5TY2FsYXIuQ2xhbXAodGhpcy5yLCBtaW4sIG1heCk7XG4gICAgICAgIHJlc3VsdC5nID0gU2NhbGFyXzEuU2NhbGFyLkNsYW1wKHRoaXMuZywgbWluLCBtYXgpO1xuICAgICAgICByZXN1bHQuYiA9IFNjYWxhcl8xLlNjYWxhci5DbGFtcCh0aGlzLmIsIG1pbiwgbWF4KTtcbiAgICAgICAgcmVzdWx0LmEgPSBTY2FsYXJfMS5TY2FsYXIuQ2xhbXAodGhpcy5hLCBtaW4sIG1heCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXB5IGFuIENvbG9yNCB2YWx1ZSBieSBhbm90aGVyIGFuZCByZXR1cm4gYSBuZXcgQ29sb3I0IG9iamVjdFxuICAgICAqIEBwYXJhbSBjb2xvciAtIGRlZmluZXMgdGhlIENvbG9yNCB2YWx1ZSB0byBtdWx0aXBseSBieVxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBtdWx0aXBseShjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNCh0aGlzLnIgKiBjb2xvci5yLCB0aGlzLmcgKiBjb2xvci5nLCB0aGlzLmIgKiBjb2xvci5iLCB0aGlzLmEgKiBjb2xvci5hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlweSBhIENvbG9yNCB2YWx1ZSBieSBhbm90aGVyIGFuZCBwdXNoIHRoZSByZXN1bHQgaW4gYSByZWZlcmVuY2UgdmFsdWVcbiAgICAgKiBAcGFyYW0gY29sb3IgLSBkZWZpbmVzIHRoZSBDb2xvcjQgdmFsdWUgdG8gbXVsdGlwbHkgYnlcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgQ29sb3I0IHRvIGZpbGwgdGhlIHJlc3VsdCBpblxuICAgICAqIEByZXR1cm5zIHRoZSByZXN1bHQgQ29sb3I0XG4gICAgICovXG4gICAgbXVsdGlwbHlUb1JlZihjb2xvciwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5yID0gdGhpcy5yICogY29sb3IucjtcbiAgICAgICAgcmVzdWx0LmcgPSB0aGlzLmcgKiBjb2xvci5nO1xuICAgICAgICByZXN1bHQuYiA9IHRoaXMuYiAqIGNvbG9yLmI7XG4gICAgICAgIHJlc3VsdC5hID0gdGhpcy5hICogY29sb3IuYTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmluZyB3aXRoIHRoZSBDb2xvcjQgY3VycmVudCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoJ3tSOiAnICsgdGhpcy5yICsgJyBHOicgKyB0aGlzLmcgKyAnIEI6JyArIHRoaXMuYiArICcgQTonICsgdGhpcy5hICsgJ30nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIFwiQ29sb3I0XCJcbiAgICAgKiBAcmV0dXJucyBcIkNvbG9yNFwiXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0NvbG9yNCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIENvbG9yNCBoYXNoIGNvZGVcbiAgICAgKiBAcmV0dXJucyBhbiB1bmlxdWUgbnVtYmVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gaGFzaCBDb2xvcjQgb2JqZWN0c1xuICAgICAqL1xuICAgIGdldEhhc2hDb2RlKCkge1xuICAgICAgICBsZXQgaGFzaCA9IHRoaXMuciB8fCAwO1xuICAgICAgICBoYXNoID0gKGhhc2ggKiAzOTcpIF4gKHRoaXMuZyB8fCAwKTtcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzk3KSBeICh0aGlzLmIgfHwgMCk7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIDM5NykgXiAodGhpcy5hIHx8IDApO1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvcjQgY29waWVkIGZyb20gdGhlIGN1cnJlbnQgb25lXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3I0IG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIGdpdmVuIENvbG9yNCB2YWx1ZXMgaW50byB0aGUgY3VycmVudCBvbmVcbiAgICAgKiBAcGFyYW0gc291cmNlIC0gZGVmaW5lcyB0aGUgc291cmNlIENvbG9yNCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cGRhdGVkIENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICBjb3B5RnJvbShzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5yID0gc291cmNlLnI7XG4gICAgICAgIHRoaXMuZyA9IHNvdXJjZS5nO1xuICAgICAgICB0aGlzLmIgPSBzb3VyY2UuYjtcbiAgICAgICAgdGhpcy5hID0gc291cmNlLmE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIGdpdmVuIGZsb2F0IHZhbHVlcyBpbnRvIHRoZSBjdXJyZW50IG9uZVxuICAgICAqIEBwYXJhbSByIC0gZGVmaW5lcyB0aGUgcmVkIGNvbXBvbmVudCB0byByZWFkIGZyb21cbiAgICAgKiBAcGFyYW0gZyAtIGRlZmluZXMgdGhlIGdyZWVuIGNvbXBvbmVudCB0byByZWFkIGZyb21cbiAgICAgKiBAcGFyYW0gYiAtIGRlZmluZXMgdGhlIGJsdWUgY29tcG9uZW50IHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBhIC0gZGVmaW5lcyB0aGUgYWxwaGEgY29tcG9uZW50IHRvIHJlYWQgZnJvbVxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZWQgQ29sb3I0IG9iamVjdFxuICAgICAqL1xuICAgIGNvcHlGcm9tRmxvYXRzKHIsIGcsIGIsIGEpIHtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5nID0gZztcbiAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgdGhpcy5hID0gYTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgZ2l2ZW4gZmxvYXQgdmFsdWVzIGludG8gdGhlIGN1cnJlbnQgb25lXG4gICAgICogQHBhcmFtIHIgLSBkZWZpbmVzIHRoZSByZWQgY29tcG9uZW50IHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBnIC0gZGVmaW5lcyB0aGUgZ3JlZW4gY29tcG9uZW50IHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBiIC0gZGVmaW5lcyB0aGUgYmx1ZSBjb21wb25lbnQgdG8gcmVhZCBmcm9tXG4gICAgICogQHBhcmFtIGEgLSBkZWZpbmVzIHRoZSBhbHBoYSBjb21wb25lbnQgdG8gcmVhZCBmcm9tXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlZCBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgc2V0KHIsIGcsIGIsIGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weUZyb21GbG9hdHMociwgZywgYiwgYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIENvbG9yNCBoZXhhZGVjaW1hbCBjb2RlIGFzIGEgc3RyaW5nXG4gICAgICogQHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIENvbG9yNCBvYmplY3RcbiAgICAgKi9cbiAgICB0b0hleFN0cmluZygpIHtcbiAgICAgICAgY29uc3QgaW50UiA9ICh0aGlzLnIgKiAyNTUpIHwgMDtcbiAgICAgICAgY29uc3QgaW50RyA9ICh0aGlzLmcgKiAyNTUpIHwgMDtcbiAgICAgICAgY29uc3QgaW50QiA9ICh0aGlzLmIgKiAyNTUpIHwgMDtcbiAgICAgICAgY29uc3QgaW50QSA9ICh0aGlzLmEgKiAyNTUpIHwgMDtcbiAgICAgICAgcmV0dXJuICgnIycgK1xuICAgICAgICAgICAgU2NhbGFyXzEuU2NhbGFyLlRvSGV4KGludFIpICtcbiAgICAgICAgICAgIFNjYWxhcl8xLlNjYWxhci5Ub0hleChpbnRHKSArXG4gICAgICAgICAgICBTY2FsYXJfMS5TY2FsYXIuVG9IZXgoaW50QikgK1xuICAgICAgICAgICAgU2NhbGFyXzEuU2NhbGFyLlRvSGV4KGludEEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSBuZXcgQ29sb3I0IGNvbnZlcnRlZCBmcm9tIHRoZSBjdXJyZW50IG9uZSB0byBsaW5lYXIgc3BhY2VcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjQgb2JqZWN0XG4gICAgICovXG4gICAgdG9MaW5lYXJTcGFjZSgpIHtcbiAgICAgICAgY29uc3QgY29udmVydGVkQ29sb3IgPSBuZXcgQ29sb3I0KCk7XG4gICAgICAgIHRoaXMudG9MaW5lYXJTcGFjZVRvUmVmKGNvbnZlcnRlZENvbG9yKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlZENvbG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgQ29sb3I0IHZhbHVlcyB0byBsaW5lYXIgc3BhY2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGluIFwiY29udmVydGVkQ29sb3JcIlxuICAgICAqIEBwYXJhbSBjb252ZXJ0ZWRDb2xvciAtIGRlZmluZXMgdGhlIENvbG9yNCBvYmplY3Qgd2hlcmUgdG8gc3RvcmUgdGhlIGxpbmVhciBzcGFjZSB2ZXJzaW9uXG4gICAgICogQHJldHVybnMgdGhlIHVubW9kaWZpZWQgQ29sb3I0XG4gICAgICovXG4gICAgdG9MaW5lYXJTcGFjZVRvUmVmKGNvbnZlcnRlZENvbG9yKSB7XG4gICAgICAgIGNvbnZlcnRlZENvbG9yLnIgPSBNYXRoLnBvdyh0aGlzLnIsIHR5cGVzXzEuVG9MaW5lYXJTcGFjZSk7XG4gICAgICAgIGNvbnZlcnRlZENvbG9yLmcgPSBNYXRoLnBvdyh0aGlzLmcsIHR5cGVzXzEuVG9MaW5lYXJTcGFjZSk7XG4gICAgICAgIGNvbnZlcnRlZENvbG9yLmIgPSBNYXRoLnBvdyh0aGlzLmIsIHR5cGVzXzEuVG9MaW5lYXJTcGFjZSk7XG4gICAgICAgIGNvbnZlcnRlZENvbG9yLmEgPSB0aGlzLmE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhIG5ldyBDb2xvcjQgY29udmVydGVkIGZyb20gdGhlIGN1cnJlbnQgb25lIHRvIGdhbW1hIHNwYWNlXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3I0IG9iamVjdFxuICAgICAqL1xuICAgIHRvR2FtbWFTcGFjZSgpIHtcbiAgICAgICAgY29uc3QgY29udmVydGVkQ29sb3IgPSBuZXcgQ29sb3I0KCk7XG4gICAgICAgIHRoaXMudG9HYW1tYVNwYWNlVG9SZWYoY29udmVydGVkQ29sb3IpO1xuICAgICAgICByZXR1cm4gY29udmVydGVkQ29sb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBDb2xvcjQgdmFsdWVzIHRvIGdhbW1hIHNwYWNlIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiBcImNvbnZlcnRlZENvbG9yXCJcbiAgICAgKiBAcGFyYW0gY29udmVydGVkQ29sb3IgLSBkZWZpbmVzIHRoZSBDb2xvcjQgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSBnYW1tYSBzcGFjZSB2ZXJzaW9uXG4gICAgICogQHJldHVybnMgdGhlIHVubW9kaWZpZWQgQ29sb3I0XG4gICAgICovXG4gICAgdG9HYW1tYVNwYWNlVG9SZWYoY29udmVydGVkQ29sb3IpIHtcbiAgICAgICAgY29udmVydGVkQ29sb3IuciA9IE1hdGgucG93KHRoaXMuciwgdHlwZXNfMS5Ub0dhbW1hU3BhY2UpO1xuICAgICAgICBjb252ZXJ0ZWRDb2xvci5nID0gTWF0aC5wb3codGhpcy5nLCB0eXBlc18xLlRvR2FtbWFTcGFjZSk7XG4gICAgICAgIGNvbnZlcnRlZENvbG9yLmIgPSBNYXRoLnBvdyh0aGlzLmIsIHR5cGVzXzEuVG9HYW1tYVNwYWNlKTtcbiAgICAgICAgY29udmVydGVkQ29sb3IuYSA9IHRoaXMuYTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5Db2xvcjQgPSBDb2xvcjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xvcjQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbG9yMyA9IHZvaWQgMDtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IENvbG9yNF8xID0gcmVxdWlyZShcIi4vQ29sb3I0XCIpO1xuY29uc3QgU2NhbGFyXzEgPSByZXF1aXJlKFwiLi9TY2FsYXJcIik7XG4vKipcbiAqIENsYXNzIHVzZWQgdG8gaG9sZCBhIFJCRyBjb2xvclxuICogQHB1YmxpY1xuICovXG5jbGFzcyBDb2xvcjMge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3IzIG9iamVjdCBmcm9tIHJlZCwgZ3JlZW4sIGJsdWUgdmFsdWVzLCBhbGwgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHIgLSBkZWZpbmVzIHRoZSByZWQgY29tcG9uZW50IChiZXR3ZWVuIDAgYW5kIDEsIGRlZmF1bHQgaXMgMClcbiAgICAgKiBAcGFyYW0gZyAtIGRlZmluZXMgdGhlIGdyZWVuIGNvbXBvbmVudCAoYmV0d2VlbiAwIGFuZCAxLCBkZWZhdWx0IGlzIDApXG4gICAgICogQHBhcmFtIGIgLSBkZWZpbmVzIHRoZSBibHVlIGNvbXBvbmVudCAoYmV0d2VlbiAwIGFuZCAxLCBkZWZhdWx0IGlzIDApXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0aGUgcmVkIGNvbXBvbmVudCAoYmV0d2VlbiAwIGFuZCAxLCBkZWZhdWx0IGlzIDApXG4gICAgICovXG4gICAgciA9IDAsIFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGdyZWVuIGNvbXBvbmVudCAoYmV0d2VlbiAwIGFuZCAxLCBkZWZhdWx0IGlzIDApXG4gICAgICovXG4gICAgZyA9IDAsIFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIGJsdWUgY29tcG9uZW50IChiZXR3ZWVuIDAgYW5kIDEsIGRlZmF1bHQgaXMgMClcbiAgICAgKi9cbiAgICBiID0gMCkge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLmcgPSBnO1xuICAgICAgICB0aGlzLmIgPSBiO1xuICAgIH1cbiAgICAvLyBTdGF0aWNzXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvcjMgZnJvbSB0aGUgc3RyaW5nIGNvbnRhaW5pbmcgdmFsaWQgaGV4YWRlY2ltYWwgdmFsdWVzXG4gICAgICogQHBhcmFtIGhleCAtIGRlZmluZXMgYSBzdHJpbmcgY29udGFpbmluZyB2YWxpZCBoZXhhZGVjaW1hbCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIEZyb21IZXhTdHJpbmcoaGV4KSB7XG4gICAgICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDEpICE9PSAnIycgfHwgaGV4Lmxlbmd0aCAhPT0gNykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjMoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMSwgMyksIDE2KTtcbiAgICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMywgNSksIDE2KTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoNSwgNyksIDE2KTtcbiAgICAgICAgcmV0dXJuIENvbG9yMy5Gcm9tSW50cyhyLCBnLCBiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWZWN0b3IzIGZyb20gdGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBnaXZlbiBhcnJheVxuICAgICAqIEBwYXJhbSBhcnJheSAtIGRlZmluZXMgdGhlIHNvdXJjZSBhcnJheVxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBkZWZpbmVzIGFuIG9mZnNldCBpbiB0aGUgc291cmNlIGFycmF5XG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3IzIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjMoYXJyYXlbb2Zmc2V0XSwgYXJyYXlbb2Zmc2V0ICsgMV0sIGFycmF5W29mZnNldCArIDJdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvcjMgZnJvbSBpbnRlZ2VyIHZhbHVlcyAobGVzcyB0aGFuIDI1NilcbiAgICAgKiBAcGFyYW0gciAtIGRlZmluZXMgdGhlIHJlZCBjb21wb25lbnQgdG8gcmVhZCBmcm9tICh2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSlcbiAgICAgKiBAcGFyYW0gZyAtIGRlZmluZXMgdGhlIGdyZWVuIGNvbXBvbmVudCB0byByZWFkIGZyb20gKHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1KVxuICAgICAqIEBwYXJhbSBiIC0gZGVmaW5lcyB0aGUgYmx1ZSBjb21wb25lbnQgdG8gcmVhZCBmcm9tICh2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSlcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIEZyb21JbnRzKHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjMociAvIDI1NS4wLCBnIC8gMjU1LjAsIGIgLyAyNTUuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3IzIHdpdGggdmFsdWVzIGxpbmVhcmx5IGludGVycG9sYXRlZCBvZiBcImFtb3VudFwiIGJldHdlZW4gdGhlIHN0YXJ0IENvbG9yMyBhbmQgdGhlIGVuZCBDb2xvcjNcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBkZWZpbmVzIHRoZSBzdGFydCBDb2xvcjMgdmFsdWVcbiAgICAgKiBAcGFyYW0gZW5kIC0gZGVmaW5lcyB0aGUgZW5kIENvbG9yMyB2YWx1ZVxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBkZWZpbmVzIHRoZSBncmFkaWVudCB2YWx1ZSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmRcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIExlcnAoc3RhcnQsIGVuZCwgYW1vdW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBDb2xvcjMoMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIENvbG9yMy5MZXJwVG9SZWYoc3RhcnQsIGVuZCwgYW1vdW50LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yMyB3aXRoIHZhbHVlcyBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgb2YgXCJhbW91bnRcIiBiZXR3ZWVuIHRoZSBzdGFydCBDb2xvcjMgYW5kIHRoZSBlbmQgQ29sb3IzXG4gICAgICogQHBhcmFtIGxlZnQgLSBkZWZpbmVzIHRoZSBzdGFydCB2YWx1ZVxuICAgICAqIEBwYXJhbSByaWdodCAtIGRlZmluZXMgdGhlIGVuZCB2YWx1ZVxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBkZWZpbmVzIHRoZSBncmFkaWVudCBmYWN0b3JcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyB0aGUgQ29sb3IzIG9iamVjdCB3aGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIExlcnBUb1JlZihsZWZ0LCByaWdodCwgYW1vdW50LCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnIgPSBsZWZ0LnIgKyAocmlnaHQuciAtIGxlZnQucikgKiBhbW91bnQ7XG4gICAgICAgIHJlc3VsdC5nID0gbGVmdC5nICsgKHJpZ2h0LmcgLSBsZWZ0LmcpICogYW1vdW50O1xuICAgICAgICByZXN1bHQuYiA9IGxlZnQuYiArIChyaWdodC5iIC0gbGVmdC5iKSAqIGFtb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yMyB2YWx1ZSBjb250YWluaW5nIGEgcmVkIGNvbG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3IzIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBSZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IzKDEsIDAsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQ29sb3IzIHZhbHVlIGNvbnRhaW5pbmcgYSBncmVlbiBjb2xvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yMyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgR3JlZW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IzKDAsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQ29sb3IzIHZhbHVlIGNvbnRhaW5pbmcgYSBibHVlIGNvbG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3IzIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBCbHVlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yMygwLCAwLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yMyB2YWx1ZSBjb250YWluaW5nIGEgYmxhY2sgY29sb3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIEJsYWNrKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yMygwLCAwLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yMyB2YWx1ZSBjb250YWluaW5nIGEgd2hpdGUgY29sb3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIFdoaXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yMygxLCAxLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yMyB2YWx1ZSBjb250YWluaW5nIGEgcHVycGxlIGNvbG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3IzIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBQdXJwbGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IzKDAuNSwgMCwgMC41KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yMyB2YWx1ZSBjb250YWluaW5nIGEgbWFnZW50YSBjb2xvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yMyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgTWFnZW50YSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjMoMSwgMCwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDb2xvcjMgdmFsdWUgY29udGFpbmluZyBhIHllbGxvdyBjb2xvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yMyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgWWVsbG93KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yMygxLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yMyB2YWx1ZSBjb250YWluaW5nIGEgZ3JheSBjb2xvclxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yMyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgR3JheSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcjMoMC41LCAwLjUsIDAuNSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDb2xvcjMgdmFsdWUgY29udGFpbmluZyBhIHRlYWwgY29sb3JcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIFRlYWwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IzKDAsIDEuMCwgMS4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIENvbG9yMyB2YWx1ZSBjb250YWluaW5nIGEgcmFuZG9tIGNvbG9yXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3IzIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBSYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IzKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIHdpdGggdGhlIENvbG9yMyBjdXJyZW50IHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIENvbG9yMyBvYmplY3RcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICd7UjogJyArIHRoaXMuciArICcgRzonICsgdGhpcy5nICsgJyBCOicgKyB0aGlzLmIgKyAnfSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0cmluZyBcIkNvbG9yM1wiXG4gICAgICogQHJldHVybnMgXCJDb2xvcjNcIlxuICAgICAqL1xuICAgIGdldENsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdDb2xvcjMnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBDb2xvcjMgaGFzaCBjb2RlXG4gICAgICogQHJldHVybnMgYW4gdW5pcXVlIG51bWJlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGhhc2ggQ29sb3IzIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXRIYXNoQ29kZSgpIHtcbiAgICAgICAgbGV0IGhhc2ggPSB0aGlzLnIgfHwgMDtcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzk3KSBeICh0aGlzLmcgfHwgMCk7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIDM5NykgXiAodGhpcy5iIHx8IDApO1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gICAgLy8gT3BlcmF0b3JzXG4gICAgLyoqXG4gICAgICogU3RvcmVzIGluIHRoZSBnaXZlbiBhcnJheSBmcm9tIHRoZSBnaXZlbiBzdGFydGluZyBpbmRleCB0aGUgcmVkLCBncmVlbiwgYmx1ZSB2YWx1ZXMgYXMgc3VjY2Vzc2l2ZSBlbGVtZW50c1xuICAgICAqIEBwYXJhbSBhcnJheSAtIGRlZmluZXMgdGhlIGFycmF5IHdoZXJlIHRvIHN0b3JlIHRoZSByLGcsYiBjb21wb25lbnRzXG4gICAgICogQHBhcmFtIGluZGV4IC0gZGVmaW5lcyBhbiBvcHRpb25hbCBpbmRleCBpbiB0aGUgdGFyZ2V0IGFycmF5IHRvIGRlZmluZSB3aGVyZSB0byBzdGFydCBzdG9yaW5nIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IENvbG9yMyBvYmplY3RcbiAgICAgKi9cbiAgICB0b0FycmF5KGFycmF5LCBpbmRleCA9IDApIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdGhpcy5yO1xuICAgICAgICBhcnJheVtpbmRleCArIDFdID0gdGhpcy5nO1xuICAgICAgICBhcnJheVtpbmRleCArIDJdID0gdGhpcy5iO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBDb2xvcjQgb2JqZWN0IGZyb20gdGhlIGN1cnJlbnQgQ29sb3IzIGFuZCB0aGUgZ2l2ZW4gYWxwaGFcbiAgICAgKiBAcGFyYW0gYWxwaGEgLSBkZWZpbmVzIHRoZSBhbHBoYSBjb21wb25lbnQgb24gdGhlIG5ldyBDb2xvcjQgb2JqZWN0IChkZWZhdWx0IGlzIDEpXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3I0IG9iamVjdFxuICAgICAqL1xuICAgIHRvQ29sb3I0KGFscGhhID0gMSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yNF8xLkNvbG9yNCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCBhbHBoYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgcG9wdWxhdGVkIHdpdGggMyBudW1lcmljIGVsZW1lbnRzIDogcmVkLCBncmVlbiBhbmQgYmx1ZSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IGFycmF5XG4gICAgICovXG4gICAgYXNBcnJheSgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMudG9BcnJheShyZXN1bHQsIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsdW1pbmFuY2UgdmFsdWVcbiAgICAgKiBAcmV0dXJucyBhIGZsb2F0IHZhbHVlXG4gICAgICovXG4gICAgdG9MdW1pbmFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnIgKiAwLjMgKyB0aGlzLmcgKiAwLjU5ICsgdGhpcy5iICogMC4xMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgZWFjaCBDb2xvcjMgcmdiIHZhbHVlcyBieSB0aGUgZ2l2ZW4gQ29sb3IzIHJnYiB2YWx1ZXMgaW4gYSBuZXcgQ29sb3IzIG9iamVjdFxuICAgICAqIEBwYXJhbSBvdGhlckNvbG9yIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IENvbG9yMyBvYmplY3RcbiAgICAgKi9cbiAgICBtdWx0aXBseShvdGhlckNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IzKHRoaXMuciAqIG90aGVyQ29sb3IuciwgdGhpcy5nICogb3RoZXJDb2xvci5nLCB0aGlzLmIgKiBvdGhlckNvbG9yLmIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0aGUgcmdiIHZhbHVlcyBvZiB0aGUgQ29sb3IzIGFuZCB0aGUgZ2l2ZW4gQ29sb3IzIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgb2JqZWN0IFwicmVzdWx0XCJcbiAgICAgKiBAcGFyYW0gb3RoZXJDb2xvciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgdGhlIENvbG9yMyBvYmplY3Qgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IENvbG9yM1xuICAgICAqL1xuICAgIG11bHRpcGx5VG9SZWYob3RoZXJDb2xvciwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5yID0gdGhpcy5yICogb3RoZXJDb2xvci5yO1xuICAgICAgICByZXN1bHQuZyA9IHRoaXMuZyAqIG90aGVyQ29sb3IuZztcbiAgICAgICAgcmVzdWx0LmIgPSB0aGlzLmIgKiBvdGhlckNvbG9yLmI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGVxdWFsaXR5IGJldHdlZW4gQ29sb3IzIG9iamVjdHNcbiAgICAgKiBAcGFyYW0gb3RoZXJDb2xvciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmdiIHZhbHVlcyBhcmUgZXF1YWwgdG8gdGhlIGdpdmVuIG9uZXNcbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXJDb2xvcikge1xuICAgICAgICByZXR1cm4gKG90aGVyQ29sb3IgJiZcbiAgICAgICAgICAgIHRoaXMuciA9PT0gb3RoZXJDb2xvci5yICYmXG4gICAgICAgICAgICB0aGlzLmcgPT09IG90aGVyQ29sb3IuZyAmJlxuICAgICAgICAgICAgdGhpcy5iID09PSBvdGhlckNvbG9yLmIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGVxdWFsaXR5IGJldHdlZW4gdGhlIGN1cnJlbnQgQ29sb3IzIG9iamVjdCBhbmQgYSBzZXQgb2YgcixiLGcgdmFsdWVzXG4gICAgICogQHBhcmFtIHIgLSBkZWZpbmVzIHRoZSByZWQgY29tcG9uZW50IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIGcgLSBkZWZpbmVzIHRoZSBncmVlbiBjb21wb25lbnQgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gYiAtIGRlZmluZXMgdGhlIGJsdWUgY29tcG9uZW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmdiIHZhbHVlcyBhcmUgZXF1YWwgdG8gdGhlIGdpdmVuIG9uZXNcbiAgICAgKi9cbiAgICBlcXVhbHNGbG9hdHMociwgZywgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5yID09PSByICYmIHRoaXMuZyA9PT0gZyAmJiB0aGlzLmIgPT09IGI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgaW4gcGxhY2UgZWFjaCByZ2IgdmFsdWUgYnkgc2NhbGVcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsaW5nIGZhY3RvclxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIENvbG9yM1xuICAgICAqL1xuICAgIHNjYWxlKHNjYWxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IzKHRoaXMuciAqIHNjYWxlLCB0aGlzLmcgKiBzY2FsZSwgdGhpcy5iICogc2NhbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoZSByZ2IgdmFsdWVzIGJ5IHNjYWxlIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIFwicmVzdWx0XCJcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsaW5nIGZhY3RvclxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIHRoZSBDb2xvcjMgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAgICAgKiBAcmV0dXJucyB0aGUgdW5tb2RpZmllZCBjdXJyZW50IENvbG9yM1xuICAgICAqL1xuICAgIHNjYWxlVG9SZWYoc2NhbGUsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuciA9IHRoaXMuciAqIHNjYWxlO1xuICAgICAgICByZXN1bHQuZyA9IHRoaXMuZyAqIHNjYWxlO1xuICAgICAgICByZXN1bHQuYiA9IHRoaXMuYiAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGUgdGhlIGN1cnJlbnQgQ29sb3IzIHZhbHVlcyBieSBhIGZhY3RvciBhbmQgYWRkIHRoZSByZXN1bHQgdG8gYSBnaXZlbiBDb2xvcjNcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBkZWZpbmVzIHRoZSBzY2FsZSBmYWN0b3JcbiAgICAgKiBAcGFyYW0gcmVzdWx0IC0gZGVmaW5lcyBjb2xvciB0byBzdG9yZSB0aGUgcmVzdWx0IGludG9cbiAgICAgKiBAcmV0dXJucyB0aGUgdW5tb2RpZmllZCBjdXJyZW50IENvbG9yM1xuICAgICAqL1xuICAgIHNjYWxlQW5kQWRkVG9SZWYoc2NhbGUsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuciArPSB0aGlzLnIgKiBzY2FsZTtcbiAgICAgICAgcmVzdWx0LmcgKz0gdGhpcy5nICogc2NhbGU7XG4gICAgICAgIHJlc3VsdC5iICs9IHRoaXMuYiAqIHNjYWxlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHRoZSByZ2IgdmFsdWVzIGJ5IHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gXCJyZXN1bHRcIlxuICAgICAqIEBwYXJhbSBtaW4gLSBkZWZpbmVzIG1pbmltdW0gY2xhbXBpbmcgdmFsdWUgKGRlZmF1bHQgaXMgMClcbiAgICAgKiBAcGFyYW0gbWF4IC0gZGVmaW5lcyBtYXhpbXVtIGNsYW1waW5nIHZhbHVlIChkZWZhdWx0IGlzIDEpXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgY29sb3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbnRvXG4gICAgICogQHJldHVybnMgdGhlIG9yaWdpbmFsIENvbG9yM1xuICAgICAqL1xuICAgIGNsYW1wVG9SZWYobWluID0gMCwgbWF4ID0gMSwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5yID0gU2NhbGFyXzEuU2NhbGFyLkNsYW1wKHRoaXMuciwgbWluLCBtYXgpO1xuICAgICAgICByZXN1bHQuZyA9IFNjYWxhcl8xLlNjYWxhci5DbGFtcCh0aGlzLmcsIG1pbiwgbWF4KTtcbiAgICAgICAgcmVzdWx0LmIgPSBTY2FsYXJfMS5TY2FsYXIuQ2xhbXAodGhpcy5iLCBtaW4sIG1heCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yMyBzZXQgd2l0aCB0aGUgYWRkZWQgdmFsdWVzIG9mIHRoZSBjdXJyZW50IENvbG9yMyBhbmQgb2YgdGhlIGdpdmVuIG9uZVxuICAgICAqIEBwYXJhbSBvdGhlckNvbG9yIC0gZGVmaW5lcyB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IENvbG9yM1xuICAgICAqL1xuICAgIGFkZChvdGhlckNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IzKHRoaXMuciArIG90aGVyQ29sb3IuciwgdGhpcy5nICsgb3RoZXJDb2xvci5nLCB0aGlzLmIgKyBvdGhlckNvbG9yLmIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIHJlc3VsdCBvZiB0aGUgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgQ29sb3IzIGFuZCBnaXZlbiBvbmUgcmdiIHZhbHVlcyBpbnRvIFwicmVzdWx0XCJcbiAgICAgKiBAcGFyYW0gb3RoZXJDb2xvciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHBhcmFtIHJlc3VsdCAtIGRlZmluZXMgQ29sb3IzIG9iamVjdCB0byBzdG9yZSB0aGUgcmVzdWx0IGludG9cbiAgICAgKiBAcmV0dXJucyB0aGUgdW5tb2RpZmllZCBjdXJyZW50IENvbG9yM1xuICAgICAqL1xuICAgIGFkZFRvUmVmKG90aGVyQ29sb3IsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuciA9IHRoaXMuciArIG90aGVyQ29sb3IucjtcbiAgICAgICAgcmVzdWx0LmcgPSB0aGlzLmcgKyBvdGhlckNvbG9yLmc7XG4gICAgICAgIHJlc3VsdC5iID0gdGhpcy5iICsgb3RoZXJDb2xvci5iO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBDb2xvcjMgc2V0IHdpdGggdGhlIHN1YnRyYWN0ZWQgdmFsdWVzIG9mIHRoZSBnaXZlbiBvbmUgZnJvbSB0aGUgY3VycmVudCBDb2xvcjNcbiAgICAgKiBAcGFyYW0gb3RoZXJDb2xvciAtIGRlZmluZXMgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAgICogQHJldHVybnMgdGhlIG5ldyBDb2xvcjNcbiAgICAgKi9cbiAgICBzdWJ0cmFjdChvdGhlckNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IzKHRoaXMuciAtIG90aGVyQ29sb3IuciwgdGhpcy5nIC0gb3RoZXJDb2xvci5nLCB0aGlzLmIgLSBvdGhlckNvbG9yLmIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIHJlc3VsdCBvZiB0aGUgc3VidHJhY3Rpb24gb2YgZ2l2ZW4gb25lIGZyb20gdGhlIGN1cnJlbnQgQ29sb3IzIHJnYiB2YWx1ZXMgaW50byBcInJlc3VsdFwiXG4gICAgICogQHBhcmFtIG90aGVyQ29sb3IgLSBkZWZpbmVzIHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEBwYXJhbSByZXN1bHQgLSBkZWZpbmVzIENvbG9yMyBvYmplY3QgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbnRvXG4gICAgICogQHJldHVybnMgdGhlIHVubW9kaWZpZWQgY3VycmVudCBDb2xvcjNcbiAgICAgKi9cbiAgICBzdWJ0cmFjdFRvUmVmKG90aGVyQ29sb3IsIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuciA9IHRoaXMuciAtIG90aGVyQ29sb3IucjtcbiAgICAgICAgcmVzdWx0LmcgPSB0aGlzLmcgLSBvdGhlckNvbG9yLmc7XG4gICAgICAgIHJlc3VsdC5iID0gdGhpcy5iIC0gb3RoZXJDb2xvci5iO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29weSB0aGUgY3VycmVudCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBDb2xvcjMgY29waWVkIHRoZSBjdXJyZW50IG9uZVxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yMyh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSByZ2IgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBpbiB0aGUgY3VycmVudCBDb2xvcjNcbiAgICAgKiBAcGFyYW0gc291cmNlIC0gZGVmaW5lcyB0aGUgc291cmNlIENvbG9yMyBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBDb2xvcjMgb2JqZWN0XG4gICAgICovXG4gICAgY29weUZyb20oc291cmNlKSB7XG4gICAgICAgIHRoaXMuciA9IHNvdXJjZS5yO1xuICAgICAgICB0aGlzLmcgPSBzb3VyY2UuZztcbiAgICAgICAgdGhpcy5iID0gc291cmNlLmI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBDb2xvcjMgcmdiIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBmbG9hdHNcbiAgICAgKiBAcGFyYW0gciAtIGRlZmluZXMgdGhlIHJlZCBjb21wb25lbnQgdG8gcmVhZCBmcm9tXG4gICAgICogQHBhcmFtIGcgLSBkZWZpbmVzIHRoZSBncmVlbiBjb21wb25lbnQgdG8gcmVhZCBmcm9tXG4gICAgICogQHBhcmFtIGIgLSBkZWZpbmVzIHRoZSBibHVlIGNvbXBvbmVudCB0byByZWFkIGZyb21cbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBDb2xvcjMgb2JqZWN0XG4gICAgICovXG4gICAgY29weUZyb21GbG9hdHMociwgZywgYikge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLmcgPSBnO1xuICAgICAgICB0aGlzLmIgPSBiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgQ29sb3IzIHJnYiB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gZmxvYXRzXG4gICAgICogQHBhcmFtIHIgLSBkZWZpbmVzIHRoZSByZWQgY29tcG9uZW50IHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBnIC0gZGVmaW5lcyB0aGUgZ3JlZW4gY29tcG9uZW50IHRvIHJlYWQgZnJvbVxuICAgICAqIEBwYXJhbSBiIC0gZGVmaW5lcyB0aGUgYmx1ZSBjb21wb25lbnQgdG8gcmVhZCBmcm9tXG4gICAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgQ29sb3IzIG9iamVjdFxuICAgICAqL1xuICAgIHNldChyLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHlGcm9tRmxvYXRzKHIsIGcsIGIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBDb2xvcjMgaGV4YWRlY2ltYWwgY29kZSBhcyBhIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBDb2xvcjMgb2JqZWN0XG4gICAgICovXG4gICAgdG9IZXhTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGludFIgPSAodGhpcy5yICogMjU1KSB8IDA7XG4gICAgICAgIGNvbnN0IGludEcgPSAodGhpcy5nICogMjU1KSB8IDA7XG4gICAgICAgIGNvbnN0IGludEIgPSAodGhpcy5iICogMjU1KSB8IDA7XG4gICAgICAgIHJldHVybiAnIycgKyBTY2FsYXJfMS5TY2FsYXIuVG9IZXgoaW50UikgKyBTY2FsYXJfMS5TY2FsYXIuVG9IZXgoaW50RykgKyBTY2FsYXJfMS5TY2FsYXIuVG9IZXgoaW50Qik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgbmV3IENvbG9yMyBjb252ZXJ0ZWQgZnJvbSB0aGUgY3VycmVudCBvbmUgdG8gbGluZWFyIHNwYWNlXG4gICAgICogQHJldHVybnMgYSBuZXcgQ29sb3IzIG9iamVjdFxuICAgICAqL1xuICAgIHRvTGluZWFyU3BhY2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZENvbG9yID0gbmV3IENvbG9yMygpO1xuICAgICAgICB0aGlzLnRvTGluZWFyU3BhY2VUb1JlZihjb252ZXJ0ZWRDb2xvcik7XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZWRDb2xvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIENvbG9yMyB2YWx1ZXMgdG8gbGluZWFyIHNwYWNlIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiBcImNvbnZlcnRlZENvbG9yXCJcbiAgICAgKiBAcGFyYW0gY29udmVydGVkQ29sb3IgLSBkZWZpbmVzIHRoZSBDb2xvcjMgb2JqZWN0IHdoZXJlIHRvIHN0b3JlIHRoZSBsaW5lYXIgc3BhY2UgdmVyc2lvblxuICAgICAqIEByZXR1cm5zIHRoZSB1bm1vZGlmaWVkIENvbG9yM1xuICAgICAqL1xuICAgIHRvTGluZWFyU3BhY2VUb1JlZihjb252ZXJ0ZWRDb2xvcikge1xuICAgICAgICBjb252ZXJ0ZWRDb2xvci5yID0gTWF0aC5wb3codGhpcy5yLCB0eXBlc18xLlRvTGluZWFyU3BhY2UpO1xuICAgICAgICBjb252ZXJ0ZWRDb2xvci5nID0gTWF0aC5wb3codGhpcy5nLCB0eXBlc18xLlRvTGluZWFyU3BhY2UpO1xuICAgICAgICBjb252ZXJ0ZWRDb2xvci5iID0gTWF0aC5wb3codGhpcy5iLCB0eXBlc18xLlRvTGluZWFyU3BhY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYSBuZXcgQ29sb3IzIGNvbnZlcnRlZCBmcm9tIHRoZSBjdXJyZW50IG9uZSB0byBnYW1tYSBzcGFjZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IENvbG9yMyBvYmplY3RcbiAgICAgKi9cbiAgICB0b0dhbW1hU3BhY2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZENvbG9yID0gbmV3IENvbG9yMygpO1xuICAgICAgICB0aGlzLnRvR2FtbWFTcGFjZVRvUmVmKGNvbnZlcnRlZENvbG9yKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlZENvbG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgQ29sb3IzIHZhbHVlcyB0byBnYW1tYSBzcGFjZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gXCJjb252ZXJ0ZWRDb2xvclwiXG4gICAgICogQHBhcmFtIGNvbnZlcnRlZENvbG9yIC0gZGVmaW5lcyB0aGUgQ29sb3IzIG9iamVjdCB3aGVyZSB0byBzdG9yZSB0aGUgZ2FtbWEgc3BhY2UgdmVyc2lvblxuICAgICAqIEByZXR1cm5zIHRoZSB1bm1vZGlmaWVkIENvbG9yM1xuICAgICAqL1xuICAgIHRvR2FtbWFTcGFjZVRvUmVmKGNvbnZlcnRlZENvbG9yKSB7XG4gICAgICAgIGNvbnZlcnRlZENvbG9yLnIgPSBNYXRoLnBvdyh0aGlzLnIsIHR5cGVzXzEuVG9HYW1tYVNwYWNlKTtcbiAgICAgICAgY29udmVydGVkQ29sb3IuZyA9IE1hdGgucG93KHRoaXMuZywgdHlwZXNfMS5Ub0dhbW1hU3BhY2UpO1xuICAgICAgICBjb252ZXJ0ZWRDb2xvci5iID0gTWF0aC5wb3codGhpcy5iLCB0eXBlc18xLlRvR2FtbWFTcGFjZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIENvbG9yM1xuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHRoaXMucixcbiAgICAgICAgICAgIGc6IHRoaXMuZyxcbiAgICAgICAgICAgIGI6IHRoaXMuYlxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ29sb3IzID0gQ29sb3IzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sb3IzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DdXJ2ZTMgPSB2b2lkIDA7XG5jb25zdCBWZWN0b3IzXzEgPSByZXF1aXJlKFwiLi9WZWN0b3IzXCIpO1xuLyoqXG4gKiBBIEN1cnZlMyBvYmplY3QgaXMgYSBsb2dpY2FsIG9iamVjdCwgc28gbm90IGEgbWVzaCwgdG8gaGFuZGxlIGN1cnZlcyBpbiB0aGUgM0QgZ2VvbWV0cmljIHNwYWNlLlxuICogQSBDdXJ2ZTMgaXMgZGVzaWduZWQgZnJvbSBhIHNlcmllcyBvZiBzdWNjZXNzaXZlIFZlY3RvcjMuXG4gKiB7QGxpbmsgaHR0cHM6Ly9kb2MuYmFieWxvbmpzLmNvbS9ob3dfdG8vaG93X3RvX3VzZV9jdXJ2ZTMgfVxuICogQHB1YmxpY1xuICovXG5jbGFzcyBDdXJ2ZTMge1xuICAgIC8qKlxuICAgICAqIEEgQ3VydmUzIG9iamVjdCBpcyBhIGxvZ2ljYWwgb2JqZWN0LCBzbyBub3QgYSBtZXNoLCB0byBoYW5kbGUgY3VydmVzIGluIHRoZSAzRCBnZW9tZXRyaWMgc3BhY2UuXG4gICAgICogQSBDdXJ2ZTMgaXMgZGVzaWduZWQgZnJvbSBhIHNlcmllcyBvZiBzdWNjZXNzaXZlIFZlY3RvcjMuXG4gICAgICoge0BsaW5rIGh0dHA6Ly9kb2MuYmFieWxvbmpzLmNvbS90dXRvcmlhbHMvSG93X3RvX3VzZV9DdXJ2ZTMjY3VydmUzLW9iamVjdCB8IFR1dG9yaWFsIH1cbiAgICAgKiBAcGFyYW0gcG9pbnRzIC0gcG9pbnRzIHdoaWNoIG1ha2UgdXAgdGhlIGN1cnZlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocG9pbnRzKSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDAuMDtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB0aGlzLl9jb21wdXRlTGVuZ3RoKHBvaW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDdXJ2ZTMgb2JqZWN0IGFsb25nIGEgUXVhZHJhdGljIEJlemllciBjdXJ2ZSA6IGh0dHA6Ly9kb2MuYmFieWxvbmpzLmNvbS90dXRvcmlhbHMvSG93X3RvX3VzZV9DdXJ2ZTMjcXVhZHJhdGljLWJlemllci1jdXJ2ZVxuICAgICAqIEBwYXJhbSB2MCAtIChWZWN0b3IzKSB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSBRdWFkcmF0aWMgQmV6aWVyXG4gICAgICogQHBhcmFtIHYxIC0gKFZlY3RvcjMpIHRoZSBjb250cm9sIHBvaW50XG4gICAgICogQHBhcmFtIHYyIC0gKFZlY3RvcjMpIHRoZSBlbmQgcG9pbnQgb2YgdGhlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAgKiBAcGFyYW0gbmJQb2ludHMgLSAoaW50ZWdlcikgdGhlIHdhbnRlZCBudW1iZXIgb2YgcG9pbnRzIGluIHRoZSBjdXJ2ZVxuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIEN1cnZlM1xuICAgICAqL1xuICAgIHN0YXRpYyBDcmVhdGVRdWFkcmF0aWNCZXppZXIodjAsIHYxLCB2MiwgbmJQb2ludHMpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXBhcmFtZXRlci1yZWFzc2lnbm1lbnRcbiAgICAgICAgbmJQb2ludHMgPSBuYlBvaW50cyA+IDIgPyBuYlBvaW50cyA6IDM7XG4gICAgICAgIGNvbnN0IGJleiA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb25zdCBlcXVhdGlvbiA9ICh0LCB2YWwwLCB2YWwxLCB2YWwyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgKiB2YWwwICsgMi4wICogdCAqICgxLjAgLSB0KSAqIHZhbDEgKyB0ICogdCAqIHZhbDI7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuYlBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBiZXoucHVzaChuZXcgVmVjdG9yM18xLlZlY3RvcjMoZXF1YXRpb24oaSAvIG5iUG9pbnRzLCB2MC54LCB2MS54LCB2Mi54KSwgZXF1YXRpb24oaSAvIG5iUG9pbnRzLCB2MC55LCB2MS55LCB2Mi55KSwgZXF1YXRpb24oaSAvIG5iUG9pbnRzLCB2MC56LCB2MS56LCB2Mi56KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ3VydmUzKGJleik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBDdXJ2ZTMgb2JqZWN0IGFsb25nIGEgQ3ViaWMgQmV6aWVyIGN1cnZlIDogaHR0cDovL2RvYy5iYWJ5bG9uanMuY29tL3R1dG9yaWFscy9Ib3dfdG9fdXNlX0N1cnZlMyNjdWJpYy1iZXppZXItY3VydmVcbiAgICAgKiBAcGFyYW0gdjAgLSAoVmVjdG9yMykgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgQ3ViaWMgQmV6aWVyXG4gICAgICogQHBhcmFtIHYxIC0gKFZlY3RvcjMpIHRoZSBmaXJzdCBjb250cm9sIHBvaW50XG4gICAgICogQHBhcmFtIHYyIC0gKFZlY3RvcjMpIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludFxuICAgICAqIEBwYXJhbSB2MyAtIChWZWN0b3IzKSB0aGUgZW5kIHBvaW50IG9mIHRoZSBDdWJpYyBCZXppZXJcbiAgICAgKiBAcGFyYW0gbmJQb2ludHMgLSAoaW50ZWdlcikgdGhlIHdhbnRlZCBudW1iZXIgb2YgcG9pbnRzIGluIHRoZSBjdXJ2ZVxuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIEN1cnZlM1xuICAgICAqL1xuICAgIHN0YXRpYyBDcmVhdGVDdWJpY0Jlemllcih2MCwgdjEsIHYyLCB2MywgbmJQb2ludHMpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXBhcmFtZXRlci1yZWFzc2lnbm1lbnRcbiAgICAgICAgbmJQb2ludHMgPSBuYlBvaW50cyA+IDMgPyBuYlBvaW50cyA6IDQ7XG4gICAgICAgIGNvbnN0IGJleiA9IG5ldyBBcnJheSgpO1xuICAgICAgICBjb25zdCBlcXVhdGlvbiA9ICh0LCB2YWwwLCB2YWwxLCB2YWwyLCB2YWwzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgKiB2YWwwICtcbiAgICAgICAgICAgICAgICAzLjAgKiB0ICogKDEuMCAtIHQpICogKDEuMCAtIHQpICogdmFsMSArXG4gICAgICAgICAgICAgICAgMy4wICogdCAqIHQgKiAoMS4wIC0gdCkgKiB2YWwyICtcbiAgICAgICAgICAgICAgICB0ICogdCAqIHQgKiB2YWwzO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbmJQb2ludHM7IGkrKykge1xuICAgICAgICAgICAgYmV6LnB1c2gobmV3IFZlY3RvcjNfMS5WZWN0b3IzKGVxdWF0aW9uKGkgLyBuYlBvaW50cywgdjAueCwgdjEueCwgdjIueCwgdjMueCksIGVxdWF0aW9uKGkgLyBuYlBvaW50cywgdjAueSwgdjEueSwgdjIueSwgdjMueSksIGVxdWF0aW9uKGkgLyBuYlBvaW50cywgdjAueiwgdjEueiwgdjIueiwgdjMueikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEN1cnZlMyhiZXopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQ3VydmUzIG9iamVjdCBhbG9uZyBhIEhlcm1pdGUgU3BsaW5lIGN1cnZlIDogaHR0cDovL2RvYy5iYWJ5bG9uanMuY29tL3R1dG9yaWFscy9Ib3dfdG9fdXNlX0N1cnZlMyNoZXJtaXRlLXNwbGluZVxuICAgICAqIEBwYXJhbSBwMSAtIChWZWN0b3IzKSB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSBIZXJtaXRlIFNwbGluZVxuICAgICAqIEBwYXJhbSB0MSAtIChWZWN0b3IzKSB0aGUgdGFuZ2VudCB2ZWN0b3IgYXQgdGhlIG9yaWdpbiBwb2ludFxuICAgICAqIEBwYXJhbSBwMiAtIChWZWN0b3IzKSB0aGUgZW5kIHBvaW50IG9mIHRoZSBIZXJtaXRlIFNwbGluZVxuICAgICAqIEBwYXJhbSB0MiAtIChWZWN0b3IzKSB0aGUgdGFuZ2VudCB2ZWN0b3IgYXQgdGhlIGVuZCBwb2ludFxuICAgICAqIEBwYXJhbSBuYlBvaW50cyAtIChpbnRlZ2VyKSB0aGUgd2FudGVkIG51bWJlciBvZiBwb2ludHMgaW4gdGhlIGN1cnZlXG4gICAgICogQHJldHVybnMgdGhlIGNyZWF0ZWQgQ3VydmUzXG4gICAgICovXG4gICAgc3RhdGljIENyZWF0ZUhlcm1pdGVTcGxpbmUocDEsIHQxLCBwMiwgdDIsIG5iUG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IGhlcm1pdGUgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29uc3Qgc3RlcCA9IDEuMCAvIG5iUG9pbnRzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuYlBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBoZXJtaXRlLnB1c2goVmVjdG9yM18xLlZlY3RvcjMuSGVybWl0ZShwMSwgdDEsIHAyLCB0MiwgaSAqIHN0ZXApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEN1cnZlMyhoZXJtaXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEN1cnZlMyBvYmplY3QgYWxvbmcgYSBDYXRtdWxsUm9tIFNwbGluZSBjdXJ2ZSA6XG4gICAgICogQHBhcmFtIHBvaW50cyAtIChhcnJheSBvZiBWZWN0b3IzKSB0aGUgcG9pbnRzIHRoZSBzcGxpbmUgbXVzdCBwYXNzIHRocm91Z2guIEF0IGxlYXN0LCBmb3VyIHBvaW50cyByZXF1aXJlZFxuICAgICAqIEBwYXJhbSBuYlBvaW50cyAtIChpbnRlZ2VyKSB0aGUgd2FudGVkIG51bWJlciBvZiBwb2ludHMgYmV0d2VlbiBlYWNoIGN1cnZlIGNvbnRyb2wgcG9pbnRzXG4gICAgICogQHBhcmFtIGNsb3NlZCAtIChib29sZWFuKSBvcHRpb25hbCB3aXRoIGRlZmF1bHQgZmFsc2UsIHdoZW4gdHJ1ZSBmb3JtcyBhIGNsb3NlZCBsb29wIGZyb20gdGhlIHBvaW50c1xuICAgICAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIEN1cnZlM1xuICAgICAqL1xuICAgIHN0YXRpYyBDcmVhdGVDYXRtdWxsUm9tU3BsaW5lKHBvaW50cywgbmJQb2ludHMsIGNsb3NlZCkge1xuICAgICAgICBjb25zdCBjYXRtdWxsUm9tID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSAxLjAgLyBuYlBvaW50cztcbiAgICAgICAgbGV0IGFtb3VudCA9IDAuMDtcbiAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzQ291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG5iUG9pbnRzOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0bXVsbFJvbS5wdXNoKFZlY3RvcjNfMS5WZWN0b3IzLkNhdG11bGxSb20ocG9pbnRzW2kgJSBwb2ludHNDb3VudF0sIHBvaW50c1soaSArIDEpICUgcG9pbnRzQ291bnRdLCBwb2ludHNbKGkgKyAyKSAlIHBvaW50c0NvdW50XSwgcG9pbnRzWyhpICsgMykgJSBwb2ludHNDb3VudF0sIGFtb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICBhbW91bnQgKz0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRtdWxsUm9tLnB1c2goY2F0bXVsbFJvbVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbFBvaW50cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgdG90YWxQb2ludHMucHVzaChwb2ludHNbMF0uY2xvbmUoKSk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0b3RhbFBvaW50cywgcG9pbnRzKTtcbiAgICAgICAgICAgIHRvdGFsUG9pbnRzLnB1c2gocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5jbG9uZSgpKTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbFBvaW50cy5sZW5ndGggLSAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbW91bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbmJQb2ludHM7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICBjYXRtdWxsUm9tLnB1c2goVmVjdG9yM18xLlZlY3RvcjMuQ2F0bXVsbFJvbSh0b3RhbFBvaW50c1tpXSwgdG90YWxQb2ludHNbaSArIDFdLCB0b3RhbFBvaW50c1tpICsgMl0sIHRvdGFsUG9pbnRzW2kgKyAzXSwgYW1vdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGFtb3VudCArPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGNhdG11bGxSb20ucHVzaChWZWN0b3IzXzEuVmVjdG9yMy5DYXRtdWxsUm9tKHRvdGFsUG9pbnRzW2ldLCB0b3RhbFBvaW50c1tpICsgMV0sIHRvdGFsUG9pbnRzW2kgKyAyXSwgdG90YWxQb2ludHNbaSArIDNdLCBhbW91bnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEN1cnZlMyhjYXRtdWxsUm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdGhlIEN1cnZlMyBzdG9yZWQgYXJyYXkgb2Ygc3VjY2Vzc2l2ZSBWZWN0b3IzXG4gICAgICovXG4gICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgY29tcHV0ZWQgbGVuZ3RoIChmbG9hdCkgb2YgdGhlIGN1cnZlLlxuICAgICAqL1xuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBDdXJ2ZTMgb2JqZWN0IDogdmFyIGN1cnZlID0gY3VydmVBLmNvbnRpbnVlKGN1cnZlQik7XG4gICAgICogVGhpcyBuZXcgQ3VydmUzIGlzIGJ1aWx0IGJ5IHRyYW5zbGF0aW5nIGFuZCBzdGlja2luZyB0aGUgY3VydmVCIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnZlQS5cbiAgICAgKiBjdXJ2ZUEgYW5kIGN1cnZlQiBrZWVwIHVuY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0gY3VydmUgLSB0aGUgY3VydmUgdG8gY29udGludWUgZnJvbSB0aGlzIGN1cnZlXG4gICAgICogQHJldHVybnMgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIGN1cnZlXG4gICAgICovXG4gICAgY29udGludWUoY3VydmUpIHtcbiAgICAgICAgY29uc3QgbGFzdFBvaW50ID0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgY29udGludWVkUG9pbnRzID0gdGhpcy5fcG9pbnRzLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGN1cnZlUG9pbnRzID0gY3VydmUuZ2V0UG9pbnRzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY3VydmVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRpbnVlZFBvaW50cy5wdXNoKGN1cnZlUG9pbnRzW2ldLnN1YnRyYWN0KGN1cnZlUG9pbnRzWzBdKS5hZGQobGFzdFBvaW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGludWVkQ3VydmUgPSBuZXcgQ3VydmUzKGNvbnRpbnVlZFBvaW50cyk7XG4gICAgICAgIHJldHVybiBjb250aW51ZWRDdXJ2ZTtcbiAgICB9XG4gICAgX2NvbXB1dGVMZW5ndGgocGF0aCkge1xuICAgICAgICBsZXQgbCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbCArPSBwYXRoW2ldLnN1YnRyYWN0KHBhdGhbaSAtIDFdKS5sZW5ndGgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG59XG5leHBvcnRzLkN1cnZlMyA9IEN1cnZlMztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUN1cnZlM2QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBsYW5lID0gdm9pZCAwO1xuY29uc3QgVmVjdG9yM18xID0gcmVxdWlyZShcIi4vVmVjdG9yM1wiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgcHJlYWxsb2NhdGVkVmFyaWFibGVzXzEgPSByZXF1aXJlKFwiLi9wcmVhbGxvY2F0ZWRWYXJpYWJsZXNcIik7XG4vKipcbiAqIFJlcHJlc2VucyBhIHBsYW5lIGJ5IHRoZSBlcXVhdGlvbiBheCArIGJ5ICsgY3ogKyBkID0gMFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBQbGFuZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBsYW5lIG9iamVjdCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGZsb2F0cyBhLCBiLCBjLCBkIGFuZCB0aGUgcGxhbmUgZXF1YXRpb24gOiBheCArIGJ5ICsgY3ogKyBkID0gMFxuICAgICAqIEBwYXJhbSBhIC0gYSBjb21wb25lbnQgb2YgdGhlIHBsYW5lXG4gICAgICogQHBhcmFtIGIgLSBiIGNvbXBvbmVudCBvZiB0aGUgcGxhbmVcbiAgICAgKiBAcGFyYW0gYyAtIGMgY29tcG9uZW50IG9mIHRoZSBwbGFuZVxuICAgICAqIEBwYXJhbSBkIC0gZCBjb21wb25lbnQgb2YgdGhlIHBsYW5lXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYSwgYiwgYywgZCkge1xuICAgICAgICB0aGlzLm5vcm1hbCA9IG5ldyBWZWN0b3IzXzEuVmVjdG9yMyhhLCBiLCBjKTtcbiAgICAgICAgdGhpcy5kID0gZDtcbiAgICB9XG4gICAgLy8gU3RhdGljc1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwbGFuZSBmcm9tIGFuICBhcnJheVxuICAgICAqIEBwYXJhbSBhcnJheSAtIHRoZSBhcnJheSB0byBjcmVhdGUgYSBwbGFuZSBmcm9tXG4gICAgICogQHJldHVybnMgYSBuZXcgUGxhbmUgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgICovXG4gICAgc3RhdGljIEZyb21BcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFBsYW5lKGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0sIGFycmF5WzNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYW5lIGZyb20gdGhyZWUgcG9pbnRzXG4gICAgICogQHBhcmFtIHBvaW50MSAtIHBvaW50IHVzZWQgdG8gY3JlYXRlIHRoZSBwbGFuZVxuICAgICAqIEBwYXJhbSBwb2ludDIgLSBwb2ludCB1c2VkIHRvIGNyZWF0ZSB0aGUgcGxhbmVcbiAgICAgKiBAcGFyYW0gcG9pbnQzIC0gcG9pbnQgdXNlZCB0byBjcmVhdGUgdGhlIHBsYW5lXG4gICAgICogQHJldHVybnMgYSBuZXcgUGxhbmUgZGVmaW5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBGcm9tUG9pbnRzKHBvaW50MSwgcG9pbnQyLCBwb2ludDMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFBsYW5lKDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIHJlc3VsdC5jb3B5RnJvbVBvaW50cyhwb2ludDEsIHBvaW50MiwgcG9pbnQzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYW5lIGZyb20gYW4gb3JpZ2luIHBvaW50IGFuZCBhIG5vcm1hbFxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBvcmlnaW4gb2YgdGhlIHBsYW5lIHRvIGJlIGNvbnN0cnVjdGVkXG4gICAgICogQHBhcmFtIG5vcm1hbCAtIG5vcm1hbCBvZiB0aGUgcGxhbmUgdG8gYmUgY29uc3RydWN0ZWRcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBQbGFuZSB0aGUgbm9ybWFsIHZlY3RvciB0byB0aGlzIHBsYW5lIGF0IHRoZSBnaXZlbiBvcmlnaW4gcG9pbnQuXG4gICAgICogTm90ZSA6IHRoZSB2ZWN0b3IgXCJub3JtYWxcIiBpcyB1cGRhdGVkIGJlY2F1c2Ugbm9ybWFsaXplZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgRnJvbVBvc2l0aW9uQW5kTm9ybWFsKG9yaWdpbiwgbm9ybWFsKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQbGFuZSgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgIHJlc3VsdC5ub3JtYWwgPSBub3JtYWw7XG4gICAgICAgIHJlc3VsdC5kID0gLShub3JtYWwueCAqIG9yaWdpbi54ICtcbiAgICAgICAgICAgIG5vcm1hbC55ICogb3JpZ2luLnkgK1xuICAgICAgICAgICAgbm9ybWFsLnogKiBvcmlnaW4ueik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIGZyb20gYSBwbGFuZSBhbmQgYSBwb2ludFxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBvcmlnaW4gb2YgdGhlIHBsYW5lIHRvIGJlIGNvbnN0cnVjdGVkXG4gICAgICogQHBhcmFtIG5vcm1hbCAtIG5vcm1hbCBvZiB0aGUgcGxhbmUgdG8gYmUgY29uc3RydWN0ZWRcbiAgICAgKiBAcGFyYW0gcG9pbnQgLSBwb2ludCB0byBjYWxjdWxhdGUgZGlzdGFuY2UgdG9cbiAgICAgKiBAcmV0dXJucyB0aGUgc2lnbmVkIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBsYW5lIGRlZmluZWQgYnkgdGhlIG5vcm1hbCB2ZWN0b3IgYXQgdGhlIFwib3JpZ2luXCJcIiBwb2ludCBhbmQgdGhlIGdpdmVuIG90aGVyIHBvaW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBTaWduZWREaXN0YW5jZVRvUGxhbmVGcm9tUG9zaXRpb25BbmROb3JtYWwob3JpZ2luLCBub3JtYWwsIHBvaW50KSB7XG4gICAgICAgIGNvbnN0IGQgPSAtKG5vcm1hbC54ICogb3JpZ2luLnggKyBub3JtYWwueSAqIG9yaWdpbi55ICsgbm9ybWFsLnogKiBvcmlnaW4ueik7XG4gICAgICAgIHJldHVybiBWZWN0b3IzXzEuVmVjdG9yMy5Eb3QocG9pbnQsIG5vcm1hbCkgKyBkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgcGxhbmUgY29vcmRpbmF0ZXMgYXMgYSBuZXcgYXJyYXkgb2YgNCBlbGVtZW50cyBbYSwgYiwgYywgZF0uXG4gICAgICovXG4gICAgYXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLm5vcm1hbC54LCB0aGlzLm5vcm1hbC55LCB0aGlzLm5vcm1hbC56LCB0aGlzLmRdO1xuICAgIH1cbiAgICAvLyBNZXRob2RzXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgYSBuZXcgcGxhbmUgY29waWVkIGZyb20gdGhlIGN1cnJlbnQgUGxhbmUuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGxhbmUodGhpcy5ub3JtYWwueCwgdGhpcy5ub3JtYWwueSwgdGhpcy5ub3JtYWwueiwgdGhpcy5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdGhlIHN0cmluZyBcIlBsYW5lXCIuXG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ1BsYW5lJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdGhlIFBsYW5lIGhhc2ggY29kZS5cbiAgICAgKi9cbiAgICBnZXRIYXNoQ29kZSgpIHtcbiAgICAgICAgbGV0IGhhc2ggPSB0aGlzLm5vcm1hbC5nZXRIYXNoQ29kZSgpO1xuICAgICAgICBoYXNoID0gKGhhc2ggKiAzOTcpIF4gKHRoaXMuZCB8fCAwKTtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0aGUgY3VycmVudCBQbGFuZSBpbiBwbGFjZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBQbGFuZS5cbiAgICAgKi9cbiAgICBub3JtYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IG5vcm0gPSBNYXRoLnNxcnQodGhpcy5ub3JtYWwueCAqIHRoaXMubm9ybWFsLnggK1xuICAgICAgICAgICAgdGhpcy5ub3JtYWwueSAqIHRoaXMubm9ybWFsLnkgK1xuICAgICAgICAgICAgdGhpcy5ub3JtYWwueiAqIHRoaXMubm9ybWFsLnopO1xuICAgICAgICBsZXQgbWFnbml0dWRlID0gMC4wO1xuICAgICAgICBpZiAobm9ybSAhPT0gMCkge1xuICAgICAgICAgICAgbWFnbml0dWRlID0gMS4wIC8gbm9ybTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vcm1hbC54ICo9IG1hZ25pdHVkZTtcbiAgICAgICAgdGhpcy5ub3JtYWwueSAqPSBtYWduaXR1ZGU7XG4gICAgICAgIHRoaXMubm9ybWFsLnogKj0gbWFnbml0dWRlO1xuICAgICAgICB0aGlzLmQgKj0gbWFnbml0dWRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIHRyYW5zZm9ybWF0aW9uIHRoZSBwbGFuZSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWF0aW9uIC0gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBiZSBhcHBsaWVkIHRvIHRoZSBwbGFuZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFBsYW5lIGFzIHRoZSByZXN1bHQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBjdXJyZW50IFBsYW5lIGJ5IHRoZSBnaXZlbiBtYXRyaXguXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zcG9zZWRNYXRyaXggPSBwcmVhbGxvY2F0ZWRWYXJpYWJsZXNfMS5NYXRoVG1wLk1hdHJpeFswXTtcbiAgICAgICAgTWF0cml4XzEuTWF0cml4LlRyYW5zcG9zZVRvUmVmKHRyYW5zZm9ybWF0aW9uLCB0cmFuc3Bvc2VkTWF0cml4KTtcbiAgICAgICAgY29uc3QgbSA9IHRyYW5zcG9zZWRNYXRyaXgubTtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMubm9ybWFsLng7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLm5vcm1hbC55O1xuICAgICAgICBjb25zdCB6ID0gdGhpcy5ub3JtYWwuejtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZDtcbiAgICAgICAgY29uc3Qgbm9ybWFsWCA9IHggKiBtWzBdICsgeSAqIG1bMV0gKyB6ICogbVsyXSArIGQgKiBtWzNdO1xuICAgICAgICBjb25zdCBub3JtYWxZID0geCAqIG1bNF0gKyB5ICogbVs1XSArIHogKiBtWzZdICsgZCAqIG1bN107XG4gICAgICAgIGNvbnN0IG5vcm1hbFogPSB4ICogbVs4XSArIHkgKiBtWzldICsgeiAqIG1bMTBdICsgZCAqIG1bMTFdO1xuICAgICAgICBjb25zdCBmaW5hbEQgPSB4ICogbVsxMl0gKyB5ICogbVsxM10gKyB6ICogbVsxNF0gKyBkICogbVsxNV07XG4gICAgICAgIHJldHVybiBuZXcgUGxhbmUobm9ybWFsWCwgbm9ybWFsWSwgbm9ybWFsWiwgZmluYWxEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VhbHR0ZSB0aGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0aGUgcG9pbnQgYW5kIHRoZSBwbGFuZSBub3JtYWxcbiAgICAgKiBAcGFyYW0gcG9pbnQgLSBwb2ludCB0byBjYWxjdWxhdGUgdGhlIGRvdCBwcm9kdWN0IHdpdGhcbiAgICAgKiBAcmV0dXJucyB0aGUgZG90IHByb2R1Y3QgKGZsb2F0KSBvZiB0aGUgcG9pbnQgY29vcmRpbmF0ZXMgYW5kIHRoZSBwbGFuZSBub3JtYWwuXG4gICAgICovXG4gICAgZG90Q29vcmRpbmF0ZShwb2ludCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubm9ybWFsLnggKiBwb2ludC54ICtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsLnkgKiBwb2ludC55ICtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsLnogKiBwb2ludC56ICtcbiAgICAgICAgICAgIHRoaXMuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgUGxhbmUgZnJvbSB0aGUgcGxhbmUgZGVmaW5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLlxuICAgICAqIEBwYXJhbSBwb2ludDEgLSBvbmUgb2YgdGhlIHBvaW50cyB1c2VkIHRvIGNvbnRydWN0IHRoZSBwbGFuZVxuICAgICAqIEBwYXJhbSBwb2ludDIgLSBvbmUgb2YgdGhlIHBvaW50cyB1c2VkIHRvIGNvbnRydWN0IHRoZSBwbGFuZVxuICAgICAqIEBwYXJhbSBwb2ludDMgLSBvbmUgb2YgdGhlIHBvaW50cyB1c2VkIHRvIGNvbnRydWN0IHRoZSBwbGFuZVxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIFBsYW5lLlxuICAgICAqL1xuICAgIGNvcHlGcm9tUG9pbnRzKHBvaW50MSwgcG9pbnQyLCBwb2ludDMpIHtcbiAgICAgICAgY29uc3QgeDEgPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgICAgICBjb25zdCB5MSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgICAgIGNvbnN0IHoxID0gcG9pbnQyLnogLSBwb2ludDEuejtcbiAgICAgICAgY29uc3QgeDIgPSBwb2ludDMueCAtIHBvaW50MS54O1xuICAgICAgICBjb25zdCB5MiA9IHBvaW50My55IC0gcG9pbnQxLnk7XG4gICAgICAgIGNvbnN0IHoyID0gcG9pbnQzLnogLSBwb2ludDEuejtcbiAgICAgICAgY29uc3QgeXogPSB5MSAqIHoyIC0gejEgKiB5MjtcbiAgICAgICAgY29uc3QgeHogPSB6MSAqIHgyIC0geDEgKiB6MjtcbiAgICAgICAgY29uc3QgeHkgPSB4MSAqIHkyIC0geTEgKiB4MjtcbiAgICAgICAgY29uc3QgcHl0aCA9IE1hdGguc3FydCh5eiAqIHl6ICsgeHogKiB4eiArIHh5ICogeHkpO1xuICAgICAgICBsZXQgaW52UHl0aDtcbiAgICAgICAgaWYgKHB5dGggIT09IDApIHtcbiAgICAgICAgICAgIGludlB5dGggPSAxLjAgLyBweXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW52UHl0aCA9IDAuMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vcm1hbC54ID0geXogKiBpbnZQeXRoO1xuICAgICAgICB0aGlzLm5vcm1hbC55ID0geHogKiBpbnZQeXRoO1xuICAgICAgICB0aGlzLm5vcm1hbC56ID0geHkgKiBpbnZQeXRoO1xuICAgICAgICB0aGlzLmQgPSAtKHRoaXMubm9ybWFsLnggKiBwb2ludDEueCArXG4gICAgICAgICAgICB0aGlzLm5vcm1hbC55ICogcG9pbnQxLnkgK1xuICAgICAgICAgICAgdGhpcy5ub3JtYWwueiAqIHBvaW50MS56KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcGxhbmUgaXMgZmFjaW5nIGEgZ2l2ZW4gZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiAtIHRoZSBkaXJlY3Rpb24gdG8gY2hlY2sgaWYgdGhlIHBsYW5lIGlzIGZhY2luZ1xuICAgICAqIEBwYXJhbSBlcHNpbG9uIC0gdmFsdWUgdGhlIGRvdCBwcm9kdWN0IGlzIGNvbXBhcmVkIGFnYWluc3QgKHJldHVybnMgdHJ1ZSBpZiBkb3QgJmx0Oz0gZXBzaWxvbilcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlzIHRoZSB2ZWN0b3IgXCJkaXJlY3Rpb25cIiAgaXMgdGhlIHNhbWUgc2lkZSB0aGFuIHRoZSBwbGFuZSBub3JtYWwuXG4gICAgICovXG4gICAgaXNGcm9udEZhY2luZ1RvKGRpcmVjdGlvbiwgZXBzaWxvbikge1xuICAgICAgICBjb25zdCBkb3QgPSBWZWN0b3IzXzEuVmVjdG9yMy5Eb3QodGhpcy5ub3JtYWwsIGRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiBkb3QgPD0gZXBzaWxvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgdG8gYSBwb2ludFxuICAgICAqIEBwYXJhbSBwb2ludCAtIHBvaW50IHRvIGNhbGN1bGF0ZSBkaXN0YW5jZSB0b1xuICAgICAqIEByZXR1cm5zIHRoZSBzaWduZWQgZGlzdGFuY2UgKGZsb2F0KSBmcm9tIHRoZSBnaXZlbiBwb2ludCB0byB0aGUgUGxhbmUuXG4gICAgICovXG4gICAgc2lnbmVkRGlzdGFuY2VUbyhwb2ludCkge1xuICAgICAgICByZXR1cm4gVmVjdG9yM18xLlZlY3RvcjMuRG90KHBvaW50LCB0aGlzLm5vcm1hbCkgKyB0aGlzLmQ7XG4gICAgfVxufVxuZXhwb3J0cy5QbGFuZSA9IFBsYW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGxhbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZydXN0dW0gPSB2b2lkIDA7XG5jb25zdCBQbGFuZV8xID0gcmVxdWlyZShcIi4vUGxhbmVcIik7XG4vKipcbiAqIFJlcHJhc2VudHMgYSBjYW1lcmEgZnJ1c3R1bVxuICogQHB1YmxpY1xuICovXG5jbGFzcyBGcnVzdHVtIHtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwbGFuZXMgcmVwcmVzZW50aW5nIHRoZSBmcnVzdHVtXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybSAtIG1hdHJpeCB0byBiZSBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCBwbGFuZXNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBhcnJheSBvZiA2IEZydXN0dW0gcGxhbmVzIGNvbXB1dGVkIGJ5IHRoZSBnaXZlbiB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAgICovXG4gICAgc3RhdGljIEdldFBsYW5lcyh0cmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgZnJ1c3R1bVBsYW5lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXgrKykge1xuICAgICAgICAgICAgZnJ1c3R1bVBsYW5lcy5wdXNoKG5ldyBQbGFuZV8xLlBsYW5lKDAuMCwgMC4wLCAwLjAsIDAuMCkpO1xuICAgICAgICB9XG4gICAgICAgIEZydXN0dW0uR2V0UGxhbmVzVG9SZWYodHJhbnNmb3JtLCBmcnVzdHVtUGxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGZydXN0dW1QbGFuZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5lYXIgZnJ1c3R1bSBwbGFuZSB0cmFuc2Zvcm1lZCBieSB0aGUgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gYmUgYXBwbGllZCB0byB0aGUgcmVzdWx0aW5nIGZydXN0dW0gcGxhbmVcbiAgICAgKiBAcGFyYW0gZnJ1c3R1bVBsYW5lIC0gdGhlIHJlc3VsaW5nIGZydXN0dW0gcGxhbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgR2V0TmVhclBsYW5lVG9SZWYodHJhbnNmb3JtLCBmcnVzdHVtUGxhbmUpIHtcbiAgICAgICAgY29uc3QgbSA9IHRyYW5zZm9ybS5tO1xuICAgICAgICBmcnVzdHVtUGxhbmUubm9ybWFsLnggPSBtWzNdICsgbVsyXTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLm5vcm1hbC55ID0gbVs3XSArIG1bNl07XG4gICAgICAgIGZydXN0dW1QbGFuZS5ub3JtYWwueiA9IG1bMTFdICsgbVsxMF07XG4gICAgICAgIGZydXN0dW1QbGFuZS5kID0gbVsxNV0gKyBtWzE0XTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmYXIgZnJ1c3R1bSBwbGFuZSB0cmFuc2Zvcm1lZCBieSB0aGUgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gYmUgYXBwbGllZCB0byB0aGUgcmVzdWx0aW5nIGZydXN0dW0gcGxhbmVcbiAgICAgKiBAcGFyYW0gZnJ1c3R1bVBsYW5lIC0gdGhlIHJlc3VsaW5nIGZydXN0dW0gcGxhbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgR2V0RmFyUGxhbmVUb1JlZih0cmFuc2Zvcm0sIGZydXN0dW1QbGFuZSkge1xuICAgICAgICBjb25zdCBtID0gdHJhbnNmb3JtLm07XG4gICAgICAgIGZydXN0dW1QbGFuZS5ub3JtYWwueCA9IG1bM10gLSBtWzJdO1xuICAgICAgICBmcnVzdHVtUGxhbmUubm9ybWFsLnkgPSBtWzddIC0gbVs2XTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLm5vcm1hbC56ID0gbVsxMV0gLSBtWzEwXTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLmQgPSBtWzE1XSAtIG1bMTRdO1xuICAgICAgICBmcnVzdHVtUGxhbmUubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxlZnQgZnJ1c3R1bSBwbGFuZSB0cmFuc2Zvcm1lZCBieSB0aGUgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdG8gYmUgYXBwbGllZCB0byB0aGUgcmVzdWx0aW5nIGZydXN0dW0gcGxhbmVcbiAgICAgKiBAcGFyYW0gZnJ1c3R1bVBsYW5lIC0gdGhlIHJlc3VsaW5nIGZydXN0dW0gcGxhbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgR2V0TGVmdFBsYW5lVG9SZWYodHJhbnNmb3JtLCBmcnVzdHVtUGxhbmUpIHtcbiAgICAgICAgY29uc3QgbSA9IHRyYW5zZm9ybS5tO1xuICAgICAgICBmcnVzdHVtUGxhbmUubm9ybWFsLnggPSBtWzNdICsgbVswXTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLm5vcm1hbC55ID0gbVs3XSArIG1bNF07XG4gICAgICAgIGZydXN0dW1QbGFuZS5ub3JtYWwueiA9IG1bMTFdICsgbVs4XTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLmQgPSBtWzE1XSArIG1bMTJdO1xuICAgICAgICBmcnVzdHVtUGxhbmUubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJpZ2h0IGZydXN0dW0gcGxhbmUgdHJhbnNmb3JtZWQgYnkgdGhlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJlc3VsdGluZyBmcnVzdHVtIHBsYW5lXG4gICAgICogQHBhcmFtIGZydXN0dW1QbGFuZSAtIHRoZSByZXN1bGluZyBmcnVzdHVtIHBsYW5lXG4gICAgICovXG4gICAgc3RhdGljIEdldFJpZ2h0UGxhbmVUb1JlZih0cmFuc2Zvcm0sIGZydXN0dW1QbGFuZSkge1xuICAgICAgICBjb25zdCBtID0gdHJhbnNmb3JtLm07XG4gICAgICAgIGZydXN0dW1QbGFuZS5ub3JtYWwueCA9IG1bM10gLSBtWzBdO1xuICAgICAgICBmcnVzdHVtUGxhbmUubm9ybWFsLnkgPSBtWzddIC0gbVs0XTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLm5vcm1hbC56ID0gbVsxMV0gLSBtWzhdO1xuICAgICAgICBmcnVzdHVtUGxhbmUuZCA9IG1bMTVdIC0gbVsxMl07XG4gICAgICAgIGZydXN0dW1QbGFuZS5ub3JtYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdG9wIGZydXN0dW0gcGxhbmUgdHJhbnNmb3JtZWQgYnkgdGhlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtIC0gdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIGJlIGFwcGxpZWQgdG8gdGhlIHJlc3VsdGluZyBmcnVzdHVtIHBsYW5lXG4gICAgICogQHBhcmFtIGZydXN0dW1QbGFuZSAtIHRoZSByZXN1bGluZyBmcnVzdHVtIHBsYW5lXG4gICAgICovXG4gICAgc3RhdGljIEdldFRvcFBsYW5lVG9SZWYodHJhbnNmb3JtLCBmcnVzdHVtUGxhbmUpIHtcbiAgICAgICAgY29uc3QgbSA9IHRyYW5zZm9ybS5tO1xuICAgICAgICBmcnVzdHVtUGxhbmUubm9ybWFsLnggPSBtWzNdIC0gbVsxXTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLm5vcm1hbC55ID0gbVs3XSAtIG1bNV07XG4gICAgICAgIGZydXN0dW1QbGFuZS5ub3JtYWwueiA9IG1bMTFdIC0gbVs5XTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLmQgPSBtWzE1XSAtIG1bMTNdO1xuICAgICAgICBmcnVzdHVtUGxhbmUubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJvdHRvbSBmcnVzdHVtIHBsYW5lIHRyYW5zZm9ybWVkIGJ5IHRoZSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICogQHBhcmFtIHRyYW5zZm9ybSAtIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBiZSBhcHBsaWVkIHRvIHRoZSByZXN1bHRpbmcgZnJ1c3R1bSBwbGFuZVxuICAgICAqIEBwYXJhbSBmcnVzdHVtUGxhbmUgLSB0aGUgcmVzdWxpbmcgZnJ1c3R1bSBwbGFuZVxuICAgICAqL1xuICAgIHN0YXRpYyBHZXRCb3R0b21QbGFuZVRvUmVmKHRyYW5zZm9ybSwgZnJ1c3R1bVBsYW5lKSB7XG4gICAgICAgIGNvbnN0IG0gPSB0cmFuc2Zvcm0ubTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLm5vcm1hbC54ID0gbVszXSArIG1bMV07XG4gICAgICAgIGZydXN0dW1QbGFuZS5ub3JtYWwueSA9IG1bN10gKyBtWzVdO1xuICAgICAgICBmcnVzdHVtUGxhbmUubm9ybWFsLnogPSBtWzExXSArIG1bOV07XG4gICAgICAgIGZydXN0dW1QbGFuZS5kID0gbVsxNV0gKyBtWzEzXTtcbiAgICAgICAgZnJ1c3R1bVBsYW5lLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiBhcnJheSBcImZydXN0dW1QbGFuZXNcIiB3aXRoIHRoZSA2IEZydXN0dW0gcGxhbmVzIGNvbXB1dGVkIGJ5IHRoZSBnaXZlbiB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybSAtIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBiZSBhcHBsaWVkIHRvIHRoZSByZXN1bHRpbmcgZnJ1c3R1bSBwbGFuZXNcbiAgICAgKiBAcGFyYW0gZnJ1c3R1bVBsYW5lcyAtIHRoZSByZXN1bGluZyBmcnVzdHVtIHBsYW5lc1xuICAgICAqL1xuICAgIHN0YXRpYyBHZXRQbGFuZXNUb1JlZih0cmFuc2Zvcm0sIGZydXN0dW1QbGFuZXMpIHtcbiAgICAgICAgLy8gTmVhclxuICAgICAgICBGcnVzdHVtLkdldE5lYXJQbGFuZVRvUmVmKHRyYW5zZm9ybSwgZnJ1c3R1bVBsYW5lc1swXSk7XG4gICAgICAgIC8vIEZhclxuICAgICAgICBGcnVzdHVtLkdldEZhclBsYW5lVG9SZWYodHJhbnNmb3JtLCBmcnVzdHVtUGxhbmVzWzFdKTtcbiAgICAgICAgLy8gTGVmdFxuICAgICAgICBGcnVzdHVtLkdldExlZnRQbGFuZVRvUmVmKHRyYW5zZm9ybSwgZnJ1c3R1bVBsYW5lc1syXSk7XG4gICAgICAgIC8vIFJpZ2h0XG4gICAgICAgIEZydXN0dW0uR2V0UmlnaHRQbGFuZVRvUmVmKHRyYW5zZm9ybSwgZnJ1c3R1bVBsYW5lc1szXSk7XG4gICAgICAgIC8vIFRvcFxuICAgICAgICBGcnVzdHVtLkdldFRvcFBsYW5lVG9SZWYodHJhbnNmb3JtLCBmcnVzdHVtUGxhbmVzWzRdKTtcbiAgICAgICAgLy8gQm90dG9tXG4gICAgICAgIEZydXN0dW0uR2V0Qm90dG9tUGxhbmVUb1JlZih0cmFuc2Zvcm0sIGZydXN0dW1QbGFuZXNbNV0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJ1c3R1bSA9IEZydXN0dW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GdXJzdHVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRoMiA9IHZvaWQgMDtcbmNvbnN0IFZlY3RvcjJfMSA9IHJlcXVpcmUoXCIuL1ZlY3RvcjJcIik7XG5jb25zdCBBcmMyXzEgPSByZXF1aXJlKFwiLi9BcmMyXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgMkQgcGF0aCBtYWRlIHVwIG9mIG11bHRpcGxlIDJEIHBvaW50c1xuICogQHB1YmxpY1xuICovXG5jbGFzcyBQYXRoMiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBhdGgyIG9iamVjdCBmcm9tIHRoZSBzdGFydGluZyAyRCBjb29yZGluYXRlcyB4IGFuZCB5LlxuICAgICAqIEBwYXJhbSB4IC0gdGhlIHN0YXJ0aW5nIHBvaW50cyB4IHZhbHVlXG4gICAgICogQHBhcmFtIHkgLSB0aGUgc3RhcnRpbmcgcG9pbnRzIHkgdmFsdWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcGF0aCBzdGFydCBhbmQgZW5kIHBvaW50IGFyZSB0aGUgc2FtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDAuMDtcbiAgICAgICAgdGhpcy5fcG9pbnRzLnB1c2gobmV3IFZlY3RvcjJfMS5WZWN0b3IyKHgsIHkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXRoIHN0YXJ0aW5nIGZyb20gYW4geCBhbmQgeSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB4IC0gc3RhcnRpbmcgeCB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IC0gc3RhcnRpbmcgeSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFBhdGgyIHN0YXJ0aW5nIGF0IHRoZSBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgc3RhdGljIFN0YXJ0aW5nQXQoeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGgyKHgsIHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHNlZ21lbnQgdW50aWwgdGhlIGdpdmVuIGNvb3JkaW5hdGVzICh4LCB5KSB0byB0aGUgY3VycmVudCBQYXRoMi5cbiAgICAgKiBAcGFyYW0geCAtIHRoZSBhZGRlZCBwb2ludHMgeCB2YWx1ZVxuICAgICAqIEBwYXJhbSB5IC0gdGhlIGFkZGVkIHBvaW50cyB5IHZhbHVlXG4gICAgICogQHJldHVybnMgdGhlIHVwZGF0ZWQgUGF0aDIuXG4gICAgICovXG4gICAgYWRkTGluZVRvKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdQb2ludCA9IG5ldyBWZWN0b3IyXzEuVmVjdG9yMih4LCB5KTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNQb2ludCA9IHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuX3BvaW50cy5wdXNoKG5ld1BvaW50KTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoICs9IG5ld1BvaW50LnN1YnRyYWN0KHByZXZpb3VzUG9pbnQpLmxlbmd0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBfbnVtYmVyT2ZTZWdtZW50c18gc2VnbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBhcmMgZGVmaW5pdGlvbiAobWlkZGxlIHBvaW50IGNvb3JkaW5hdGVzLCBlbmQgcG9pbnQgY29vcmRpbmF0ZXMsIHRoZSBhcmMgc3RhcnQgcG9pbnQgYmVpbmcgdGhlIGN1cnJlbnQgUGF0aDIgbGFzdCBwb2ludCkgdG8gdGhlIGN1cnJlbnQgUGF0aDIuXG4gICAgICogQHBhcmFtIG1pZFggLSBtaWRkbGUgcG9pbnQgeCB2YWx1ZVxuICAgICAqIEBwYXJhbSBtaWRZIC0gbWlkZGxlIHBvaW50IHkgdmFsdWVcbiAgICAgKiBAcGFyYW0gZW5kWCAtIGVuZCBwb2ludCB4IHZhbHVlXG4gICAgICogQHBhcmFtIGVuZFkgLSBlbmQgcG9pbnQgeSB2YWx1ZVxuICAgICAqIEBwYXJhbSBudW1iZXJPZlNlZ21lbnRzIC0gKGRlZmF1bHQ6IDM2KVxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIFBhdGgyLlxuICAgICAqL1xuICAgIGFkZEFyY1RvKG1pZFgsIG1pZFksIGVuZFgsIGVuZFksIG51bWJlck9mU2VnbWVudHMgPSAzNikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSB0aGlzLl9wb2ludHNbdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBtaWRQb2ludCA9IG5ldyBWZWN0b3IyXzEuVmVjdG9yMihtaWRYLCBtaWRZKTtcbiAgICAgICAgY29uc3QgZW5kUG9pbnQgPSBuZXcgVmVjdG9yMl8xLlZlY3RvcjIoZW5kWCwgZW5kWSk7XG4gICAgICAgIGNvbnN0IGFyYyA9IG5ldyBBcmMyXzEuQXJjMihzdGFydFBvaW50LCBtaWRQb2ludCwgZW5kUG9pbnQpO1xuICAgICAgICBsZXQgaW5jcmVtZW50ID0gYXJjLmFuZ2xlLnJhZGlhbnMoKSAvIG51bWJlck9mU2VnbWVudHM7XG4gICAgICAgIGlmIChhcmMub3JpZW50YXRpb24gPT09IHR5cGVzXzEuT3JpZW50YXRpb24uQ1cpIHtcbiAgICAgICAgICAgIGluY3JlbWVudCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudEFuZ2xlID0gYXJjLnN0YXJ0QW5nbGUucmFkaWFucygpICsgaW5jcmVtZW50O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGguY29zKGN1cnJlbnRBbmdsZSkgKiBhcmMucmFkaXVzICsgYXJjLmNlbnRlclBvaW50Lng7XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5zaW4oY3VycmVudEFuZ2xlKSAqIGFyYy5yYWRpdXMgKyBhcmMuY2VudGVyUG9pbnQueTtcbiAgICAgICAgICAgIHRoaXMuYWRkTGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgY3VycmVudEFuZ2xlICs9IGluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBQYXRoMi5cbiAgICAgKiBAcmV0dXJucyB0aGUgUGF0aDIuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN1bSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBlYWNoIHNlcXVlbnRpYWwgcG9pbnQgaW4gdGhlIHBhdGhcbiAgICAgKiBAcmV0dXJucyB0aGUgUGF0aDIgdG90YWwgbGVuZ3RoIChmbG9hdCkuXG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fbGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLl9wb2ludHNbdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHRoaXMuX3BvaW50c1swXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBmaXJzdFBvaW50LnN1YnRyYWN0KGxhc3RQb2ludCkubGVuZ3RoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcG9pbnRzIHdoaWNoIGNvbnN0cnVjdCB0aGUgcGF0aFxuICAgICAqIEByZXR1cm5zIHRoZSBQYXRoMiBpbnRlcm5hbCBhcnJheSBvZiBwb2ludHMuXG4gICAgICovXG4gICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyZWl2ZXMgdGhlIHBvaW50IGF0IHRoZSBkaXN0YW5jZSBhd2F5cyBmcm9tIHRoZSBzdGFydGluZyBwb2ludFxuICAgICAqIEBwYXJhbSBub3JtYWxpemVkTGVuZ3RoUG9zaXRpb24gLSB0aGUgbGVuZ3RoIGFsb25nIHRoZSBwYXRoIHRvIHJldHJlaXZlIHRoZSBwb2ludCBmcm9tXG4gICAgICogQHJldHVybnMgYSBuZXcgVmVjdG9yMiBsb2NhdGVkIGF0IGEgcGVyY2VudGFnZSBvZiB0aGUgUGF0aDIgdG90YWwgbGVuZ3RoIG9uIHRoaXMgcGF0aC5cbiAgICAgKi9cbiAgICBnZXRQb2ludEF0TGVuZ3RoUG9zaXRpb24obm9ybWFsaXplZExlbmd0aFBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChub3JtYWxpemVkTGVuZ3RoUG9zaXRpb24gPCAwIHx8IG5vcm1hbGl6ZWRMZW5ndGhQb3NpdGlvbiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IyXzEuVmVjdG9yMi5aZXJvKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoUG9zaXRpb24gPSBub3JtYWxpemVkTGVuZ3RoUG9zaXRpb24gKiB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBsZXQgcHJldmlvdXNPZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaiA9IChpICsgMSkgJSB0aGlzLl9wb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLl9wb2ludHNbal07XG4gICAgICAgICAgICBjb25zdCBiVG9BID0gYi5zdWJ0cmFjdChhKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSBiVG9BLmxlbmd0aCgpICsgcHJldmlvdXNPZmZzZXQ7XG4gICAgICAgICAgICBpZiAobGVuZ3RoUG9zaXRpb24gPj0gcHJldmlvdXNPZmZzZXQgJiYgbGVuZ3RoUG9zaXRpb24gPD0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpciA9IGJUb0Eubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxPZmZzZXQgPSBsZW5ndGhQb3NpdGlvbiAtIHByZXZpb3VzT2Zmc2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMl8xLlZlY3RvcjIoYS54ICsgZGlyLnggKiBsb2NhbE9mZnNldCwgYS55ICsgZGlyLnkgKiBsb2NhbE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c09mZnNldCA9IG5leHRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFZlY3RvcjJfMS5WZWN0b3IyLlplcm8oKTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGgyID0gUGF0aDI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXRoMmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhdGgzRCA9IHZvaWQgMDtcbmNvbnN0IFZlY3RvcjNfMSA9IHJlcXVpcmUoXCIuL1ZlY3RvcjNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBTY2FsYXJfMSA9IHJlcXVpcmUoXCIuL1NjYWxhclwiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIDNEIHBhdGggbWFkZSB1cCBvZiBtdWx0aXBsZSAzRCBwb2ludHNcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUGF0aDNEIHtcbiAgICAvKipcbiAgICAgKiBuZXcgUGF0aDNEKHBhdGgsIG5vcm1hbCwgcmF3KVxuICAgICAqIENyZWF0ZXMgYSBQYXRoM0QuIEEgUGF0aDNEIGlzIGEgbG9naWNhbCBtYXRoIG9iamVjdCwgc28gbm90IGEgbWVzaC5cbiAgICAgKiBwbGVhc2UgcmVhZCB0aGUgZGVzY3JpcHRpb24gaW4gdGhlIHR1dG9yaWFsIDogIGh0dHA6Ly9kb2MuYmFieWxvbmpzLmNvbS90dXRvcmlhbHMvSG93X3RvX3VzZV9QYXRoM0RcbiAgICAgKiBAcGFyYW0gcGF0aCAtIGFuIGFycmF5IG9mIFZlY3RvcjMsIHRoZSBjdXJ2ZSBheGlzIG9mIHRoZSBQYXRoM0RcbiAgICAgKiBAcGFyYW0gbm9ybWFsIC0gKG9wdGlvbnMpIFZlY3RvcjMsIHRoZSBmaXJzdCB3YW50ZWQgbm9ybWFsIHRvIHRoZSBjdXJ2ZS4gRXggKDAsIDEsIDApIGZvciBhIHZlcnRpY2FsIG5vcm1hbC5cbiAgICAgKiBAcGFyYW0gcmF3IC0gKG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlKSA6IGJvb2xlYW4sIGlmIHRydWUgdGhlIHJldHVybmVkIFBhdGgzRCBpc24ndCBub3JtYWxpemVkLiBVc2VmdWwgdG8gZGVwaWN0IHBhdGggYWNjZWxlcmF0aW9uIG9yIHNwZWVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIGFuIGFycmF5IG9mIFZlY3RvcjMsIHRoZSBjdXJ2ZSBheGlzIG9mIHRoZSBQYXRoM0RcbiAgICAgKi9cbiAgICBwYXRoLCBmaXJzdE5vcm1hbCA9IG51bGwsIHJhdykge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9jdXJ2ZSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5fdGFuZ2VudHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5fbm9ybWFscyA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLl9iaW5vcm1hbHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXRoLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZVtwXSA9IHBhdGhbcF0uY2xvbmUoKTsgLy8gaGFyZCBjb3B5XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmF3ID0gcmF3IHx8IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb21wdXRlKGZpcnN0Tm9ybWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUGF0aDNEIGFycmF5IG9mIHN1Y2Nlc3NpdmUgVmVjdG9yMyBkZXNpZ25pbmcgaXRzIGN1cnZlLlxuICAgICAqIEByZXR1cm5zIHRoZSBQYXRoM0QgYXJyYXkgb2Ygc3VjY2Vzc2l2ZSBWZWN0b3IzIGRlc2lnbmluZyBpdHMgY3VydmUuXG4gICAgICovXG4gICAgZ2V0Q3VydmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJ2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCB0YW5nZW50IHZlY3RvcnMgb24gZWFjaCBQYXRoM0QgY3VydmUgcG9pbnQuXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggdGFuZ2VudCB2ZWN0b3JzIG9uIGVhY2ggUGF0aDNEIGN1cnZlIHBvaW50LlxuICAgICAqL1xuICAgIGdldFRhbmdlbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFuZ2VudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggbm9ybWFsIHZlY3RvcnMgb24gZWFjaCBQYXRoM0QgY3VydmUgcG9pbnQuXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggbm9ybWFsIHZlY3RvcnMgb24gZWFjaCBQYXRoM0QgY3VydmUgcG9pbnQuXG4gICAgICovXG4gICAgZ2V0Tm9ybWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgcG9wdWxhdGVkIHdpdGggYmlub3JtYWwgdmVjdG9ycyBvbiBlYWNoIFBhdGgzRCBjdXJ2ZSBwb2ludC5cbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCBiaW5vcm1hbCB2ZWN0b3JzIG9uIGVhY2ggUGF0aDNEIGN1cnZlIHBvaW50LlxuICAgICAqL1xuICAgIGdldEJpbm9ybWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jpbm9ybWFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCBkaXN0YW5jZXMgKGZsb2F0KSBvZiB0aGUgaS10aCBwb2ludCBmcm9tIHRoZSBmaXJzdCBjdXJ2ZSBwb2ludC5cbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBwb3B1bGF0ZWQgd2l0aCBkaXN0YW5jZXMgKGZsb2F0KSBvZiB0aGUgaS10aCBwb2ludCBmcm9tIHRoZSBmaXJzdCBjdXJ2ZSBwb2ludC5cbiAgICAgKi9cbiAgICBnZXREaXN0YW5jZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgUGF0aDNEIHRhbmdlbnQsIG5vcm1hbCwgYmlub3JtYWwgYW5kIGRpc3RhbmNlIHJlY29tcHV0YXRpb24uXG4gICAgICogQHBhcmFtIHBhdGggLSBwYXRoIHdoaWNoIGFsbCB2YWx1ZXMgYXJlIGNvcGllZCBpbnRvIHRoZSBjdXJ2ZXMgcG9pbnRzXG4gICAgICogQHBhcmFtIGZpcnN0Tm9ybWFsIC0gd2hpY2ggc2hvdWxkIGJlIHByb2plY3RlZCBvbnRvIHRoZSBjdXJ2ZVxuICAgICAqIEByZXR1cm5zIHRoZSBzYW1lIG9iamVjdCB1cGRhdGVkLlxuICAgICAqL1xuICAgIHVwZGF0ZShwYXRoLCBmaXJzdE5vcm1hbCA9IG51bGwpIHtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBwYXRoLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZVtwXS54ID0gcGF0aFtwXS54O1xuICAgICAgICAgICAgdGhpcy5fY3VydmVbcF0ueSA9IHBhdGhbcF0ueTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlW3BdLnogPSBwYXRoW3BdLno7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29tcHV0ZShmaXJzdE5vcm1hbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBwcml2YXRlIGZ1bmN0aW9uIGNvbXB1dGUoKSA6IGNvbXB1dGVzIHRhbmdlbnRzLCBub3JtYWxzIGFuZCBiaW5vcm1hbHNcbiAgICBfY29tcHV0ZShmaXJzdE5vcm1hbCkge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5fY3VydmUubGVuZ3RoO1xuICAgICAgICAvLyBmaXJzdCBhbmQgbGFzdCB0YW5nZW50c1xuICAgICAgICB0aGlzLl90YW5nZW50c1swXSA9IHRoaXMuX2dldEZpcnN0Tm9uTnVsbFZlY3RvcigwKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yYXcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhbmdlbnRzWzBdLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhbmdlbnRzW2wgLSAxXSA9IHRoaXMuX2N1cnZlW2wgLSAxXS5zdWJ0cmFjdCh0aGlzLl9jdXJ2ZVtsIC0gMl0pO1xuICAgICAgICBpZiAoIXRoaXMuX3Jhdykge1xuICAgICAgICAgICAgdGhpcy5fdGFuZ2VudHNbbCAtIDFdLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vcm1hbHMgYW5kIGJpbm9ybWFscyBhdCBmaXJzdCBwb2ludCA6IGFyYml0cmFyeSB2ZWN0b3Igd2l0aCBfbm9ybWFsVmVjdG9yKClcbiAgICAgICAgY29uc3QgdGcwID0gdGhpcy5fdGFuZ2VudHNbMF07XG4gICAgICAgIGNvbnN0IHBwMCA9IHRoaXMuX25vcm1hbFZlY3Rvcih0aGlzLl9jdXJ2ZVswXSwgdGcwLCBmaXJzdE5vcm1hbCk7XG4gICAgICAgIHRoaXMuX25vcm1hbHNbMF0gPSBwcDA7XG4gICAgICAgIGlmICghdGhpcy5fcmF3KSB7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxzWzBdLm5vcm1hbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Jpbm9ybWFsc1swXSA9IFZlY3RvcjNfMS5WZWN0b3IzLkNyb3NzKHRnMCwgdGhpcy5fbm9ybWFsc1swXSk7XG4gICAgICAgIGlmICghdGhpcy5fcmF3KSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5vcm1hbHNbMF0ubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzdGFuY2VzWzBdID0gMC4wO1xuICAgICAgICAvLyBub3JtYWxzIGFuZCBiaW5vcm1hbHMgOiBuZXh0IHBvaW50c1xuICAgICAgICBsZXQgcHJldjsgLy8gcHJldmlvdXMgdmVjdG9yIChzZWdtZW50KVxuICAgICAgICBsZXQgY3VyOyAvLyBjdXJyZW50IHZlY3RvciAoc2VnbWVudClcbiAgICAgICAgbGV0IGN1clRhbmc7IC8vIGN1cnJlbnQgdGFuZ2VudFxuICAgICAgICAvLyBwcmV2aW91cyBub3JtYWxcbiAgICAgICAgbGV0IHByZXZCaW5vcjsgLy8gcHJldmlvdXMgYmlub3JtYWxcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHRhbmdlbnRzXG4gICAgICAgICAgICBwcmV2ID0gdGhpcy5fZ2V0TGFzdE5vbk51bGxWZWN0b3IoaSk7XG4gICAgICAgICAgICBpZiAoaSA8IGwgLSAxKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gdGhpcy5fZ2V0Rmlyc3ROb25OdWxsVmVjdG9yKGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhbmdlbnRzW2ldID0gcHJldi5hZGQoY3VyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90YW5nZW50c1tpXS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlc1tpXSA9IHRoaXMuX2Rpc3RhbmNlc1tpIC0gMV0gKyBwcmV2Lmxlbmd0aCgpO1xuICAgICAgICAgICAgLy8gbm9ybWFscyBhbmQgYmlub3JtYWxzXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LmNzLmNtdS5lZHUvYWZzL2FuZHJldy9zY3MvY3MvMTUtNDYyL3dlYi9vbGQvYXNzdDJjYW1lcmEuaHRtbFxuICAgICAgICAgICAgY3VyVGFuZyA9IHRoaXMuX3RhbmdlbnRzW2ldO1xuICAgICAgICAgICAgcHJldkJpbm9yID0gdGhpcy5fYmlub3JtYWxzW2kgLSAxXTtcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbHNbaV0gPSBWZWN0b3IzXzEuVmVjdG9yMy5Dcm9zcyhwcmV2Qmlub3IsIGN1clRhbmcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxzW2ldLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYmlub3JtYWxzW2ldID0gVmVjdG9yM18xLlZlY3RvcjMuQ3Jvc3MoY3VyVGFuZywgdGhpcy5fbm9ybWFsc1tpXSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Jhdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jpbm9ybWFsc1tpXS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSBmaXJzdCBub24gbnVsbCB2ZWN0b3IgZnJvbSBpbmRleCA6IGN1cnZlW2luZGV4ICsgTl0uc3VidHJhY3QoY3VydmVbaW5kZXhdKVxuICAgIF9nZXRGaXJzdE5vbk51bGxWZWN0b3IoaW5kZXgpIHtcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBsZXQgbk5WZWN0b3IgPSB0aGlzLl9jdXJ2ZVtpbmRleCArIGldLnN1YnRyYWN0KHRoaXMuX2N1cnZlW2luZGV4XSk7XG4gICAgICAgIHdoaWxlIChuTlZlY3Rvci5sZW5ndGgoKSA9PT0gMCAmJiBpbmRleCArIGkgKyAxIDwgdGhpcy5fY3VydmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBuTlZlY3RvciA9IHRoaXMuX2N1cnZlW2luZGV4ICsgaV0uc3VidHJhY3QodGhpcy5fY3VydmVbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbk5WZWN0b3I7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdGhlIGxhc3Qgbm9uIG51bGwgdmVjdG9yIGZyb20gaW5kZXggOiBjdXJ2ZVtpbmRleF0uc3VidHJhY3QoY3VydmVbaW5kZXggLSBOXSlcbiAgICBfZ2V0TGFzdE5vbk51bGxWZWN0b3IoaW5kZXgpIHtcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBsZXQgbkxWZWN0b3IgPSB0aGlzLl9jdXJ2ZVtpbmRleF0uc3VidHJhY3QodGhpcy5fY3VydmVbaW5kZXggLSBpXSk7XG4gICAgICAgIHdoaWxlIChuTFZlY3Rvci5sZW5ndGgoKSA9PT0gMCAmJiBpbmRleCA+IGkgKyAxKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBuTFZlY3RvciA9IHRoaXMuX2N1cnZlW2luZGV4XS5zdWJ0cmFjdCh0aGlzLl9jdXJ2ZVtpbmRleCAtIGldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbkxWZWN0b3I7XG4gICAgfVxuICAgIC8vIHByaXZhdGUgZnVuY3Rpb24gbm9ybWFsVmVjdG9yKHYwLCB2dCwgdmEpIDpcbiAgICAvLyByZXR1cm5zIGFuIGFyYml0cmFyeSBwb2ludCBpbiB0aGUgcGxhbmUgZGVmaW5lZCBieSB0aGUgcG9pbnQgdjAgYW5kIHRoZSB2ZWN0b3IgdnQgb3J0aG9nb25hbCB0byB0aGlzIHBsYW5lXG4gICAgLy8gaWYgdmEgaXMgcGFzc2VkLCBpdCByZXR1cm5zIHRoZSB2YSBwcm9qZWN0aW9uIG9uIHRoZSBwbGFuZSBvcnRob2dvbmFsIHRvIHZ0IGF0IHRoZSBwb2ludCB2MFxuICAgIF9ub3JtYWxWZWN0b3IodjAsIHZ0LCB2YSkge1xuICAgICAgICBsZXQgbm9ybWFsMDtcbiAgICAgICAgbGV0IHRnbCA9IHZ0Lmxlbmd0aCgpO1xuICAgICAgICBpZiAodGdsID09PSAwLjApIHtcbiAgICAgICAgICAgIHRnbCA9IDEuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmEgPT09IHVuZGVmaW5lZCB8fCB2YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHBvaW50O1xuICAgICAgICAgICAgaWYgKCFTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbihNYXRoLmFicyh2dC55KSAvIHRnbCwgMS4wLCB0eXBlc18xLkVwc2lsb24pKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIGZvciBhIHBvaW50IGluIHRoZSBwbGFuZVxuICAgICAgICAgICAgICAgIHBvaW50ID0gbmV3IFZlY3RvcjNfMS5WZWN0b3IzKDAuMCwgLTEuMCwgMC4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFTY2FsYXJfMS5TY2FsYXIuV2l0aGluRXBzaWxvbihNYXRoLmFicyh2dC54KSAvIHRnbCwgMS4wLCB0eXBlc18xLkVwc2lsb24pKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgVmVjdG9yM18xLlZlY3RvcjMoMS4wLCAwLjAsIDAuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghU2NhbGFyXzEuU2NhbGFyLldpdGhpbkVwc2lsb24oTWF0aC5hYnModnQueikgLyB0Z2wsIDEuMCwgdHlwZXNfMS5FcHNpbG9uKSkge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gbmV3IFZlY3RvcjNfMS5WZWN0b3IzKDAuMCwgMC4wLCAxLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBWZWN0b3IzXzEuVmVjdG9yMy5aZXJvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWwwID0gVmVjdG9yM18xLlZlY3RvcjMuQ3Jvc3ModnQsIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbDAgPSBWZWN0b3IzXzEuVmVjdG9yMy5Dcm9zcyh2dCwgdmEpO1xuICAgICAgICAgICAgVmVjdG9yM18xLlZlY3RvcjMuQ3Jvc3NUb1JlZihub3JtYWwwLCB2dCwgbm9ybWFsMCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsMC5ub3JtYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbDA7XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoM0QgPSBQYXRoM0Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXRoM2QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpemUgPSB2b2lkIDA7XG4vKipcbiAqIFNpemUgY29udGFpbmluZyB3aWRodCBhbmQgaGVpZ2h0XG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFNpemUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBTaXplIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0IChmbG9hdHMpLlxuICAgICAqIEBwYXJhbSB3aWR0aCAtIHdpZHRoIG9mIHRoZSBuZXcgc2l6ZVxuICAgICAqIEBwYXJhbSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIG5ldyBzaXplXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc3VyZmFjZSBvZiB0aGUgU2l6ZSA6IHdpZHRoICogaGVpZ2h0IChmbG9hdCkuXG4gICAgICovXG4gICAgZ2V0IHN1cmZhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzaXplIG9mIHplcm9cbiAgICAgKiBAcmV0dXJucyBhIG5ldyBTaXplIHNldCB0byAoMC4wLCAwLjApXG4gICAgICovXG4gICAgc3RhdGljIFplcm8oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSgwLjAsIDAuMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2l6ZSBzZXQgYXQgdGhlIGxpbmVhciBpbnRlcnBvbGF0aW9uIFwiYW1vdW50XCIgYmV0d2VlbiBcInN0YXJ0XCIgYW5kIFwiZW5kXCJcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBzdGFydGluZyBzaXplIHRvIGxlcnAgYmV0d2VlblxuICAgICAqIEBwYXJhbSBlbmQgLSBlbmQgc2l6ZSB0byBsZXJwIGJldHdlZW5cbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gYW1vdW50IHRvIGxlcnAgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBTaXplIHNldCBhdCB0aGUgbGluZWFyIGludGVycG9sYXRpb24gXCJhbW91bnRcIiBiZXR3ZWVuIFwic3RhcnRcIiBhbmQgXCJlbmRcIlxuICAgICAqL1xuICAgIHN0YXRpYyBMZXJwKHN0YXJ0LCBlbmQsIGFtb3VudCkge1xuICAgICAgICBjb25zdCB3ID0gc3RhcnQud2lkdGggKyAoZW5kLndpZHRoIC0gc3RhcnQud2lkdGgpICogYW1vdW50O1xuICAgICAgICBjb25zdCBoID0gc3RhcnQuaGVpZ2h0ICsgKGVuZC5oZWlnaHQgLSBzdGFydC5oZWlnaHQpICogYW1vdW50O1xuICAgICAgICByZXR1cm4gbmV3IFNpemUodywgaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgU2l6ZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICogQHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgU2l6ZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBge1c6ICR7dGhpcy53aWR0aH0sIEg6ICR7dGhpcy5oZWlnaHR9fWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFwiU2l6ZVwiXG4gICAgICogQHJldHVybnMgdGhlIHN0cmluZyBcIlNpemVcIlxuICAgICAqL1xuICAgIGdldENsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdTaXplJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU2l6ZSBoYXNoIGNvZGUuXG4gICAgICogQHJldHVybnMgYSBoYXNoIGNvZGUgZm9yIGEgdW5pcXVlIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXRIYXNoQ29kZSgpIHtcbiAgICAgICAgbGV0IGhhc2ggPSB0aGlzLndpZHRoIHx8IDA7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIDM5NykgXiAodGhpcy5oZWlnaHQgfHwgMCk7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHNpemUgZnJvbSB0aGUgZ2l2ZW4gb25lLlxuICAgICAqIEBwYXJhbSBzcmMgLSB0aGUgZ2l2ZW4gc2l6ZVxuICAgICAqL1xuICAgIGNvcHlGcm9tKHNyYykge1xuICAgICAgICB0aGlzLndpZHRoID0gc3JjLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNyYy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgaW4gcGxhY2UgdGhlIGN1cnJlbnQgU2l6ZSBmcm9tIHRoZSBnaXZlbiBmbG9hdHMuXG4gICAgICogQHBhcmFtIHdpZHRoIC0gd2lkdGggb2YgdGhlIG5ldyBzaXplXG4gICAgICogQHBhcmFtIGhlaWdodCAtIGhlaWdodCBvZiB0aGUgbmV3IHNpemVcbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBTaXplLlxuICAgICAqL1xuICAgIGNvcHlGcm9tRmxvYXRzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgaW4gcGxhY2UgdGhlIGN1cnJlbnQgU2l6ZSBmcm9tIHRoZSBnaXZlbiBmbG9hdHMuXG4gICAgICogQHBhcmFtIHdpZHRoIC0gd2lkdGggdG8gc2V0XG4gICAgICogQHBhcmFtIGhlaWdodCAtIGhlaWdodCB0byBzZXRcbiAgICAgKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBTaXplLlxuICAgICAqL1xuICAgIHNldCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHlGcm9tRmxvYXRzKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGJ5IG51bWJlcnNcbiAgICAgKiBAcGFyYW0gdyAtIGZhY3RvciB0byBtdWx0aXBsZSB0aGUgd2lkdGggYnlcbiAgICAgKiBAcGFyYW0gaCAtIGZhY3RvciB0byBtdWx0aXBsZSB0aGUgaGVpZ2h0IGJ5XG4gICAgICogQHJldHVybnMgYSBuZXcgU2l6ZSBzZXQgd2l0aCB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0IG9mIHRoZSBjdXJyZW50IFNpemUgYW5kIHRoZSBnaXZlbiBmbG9hdHMuXG4gICAgICovXG4gICAgbXVsdGlwbHlCeUZsb2F0cyh3LCBoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICogdywgdGhpcy5oZWlnaHQgKiBoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBzaXplXG4gICAgICogQHJldHVybnMgYSBuZXcgU2l6ZSBjb3BpZWQgZnJvbSB0aGUgZ2l2ZW4gb25lLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBjdXJyZW50IFNpemUgYW5kIHRoZSBnaXZlbiBvbmUgd2lkdGggYW5kIGhlaWdodCBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gICAgICogQHBhcmFtIG90aGVyIC0gdGhlIG90aGVyIHNpemUgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY3VycmVudCBTaXplIGFuZCB0aGUgZ2l2ZW4gb25lIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHN0cmljdGx5IGVxdWFsLlxuICAgICAqL1xuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IG90aGVyLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBvdGhlci5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1bXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdHdvIHNpemVzXG4gICAgICogQHBhcmFtIG90aGVyU2l6ZSAtIHNpemUgdG8gYWRkIHRvIHRoaXMgc2l6ZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFNpemUgc2V0IGFzIHRoZSBhZGRpdGlvbiByZXN1bHQgb2YgdGhlIGN1cnJlbnQgU2l6ZSBhbmQgdGhlIGdpdmVuIG9uZS5cbiAgICAgKi9cbiAgICBhZGQob3RoZXJTaXplKSB7XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgU2l6ZSh0aGlzLndpZHRoICsgb3RoZXJTaXplLndpZHRoLCB0aGlzLmhlaWdodCArIG90aGVyU2l6ZS5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHR3b1xuICAgICAqIEBwYXJhbSBvdGhlclNpemUgLSBzaXplIHRvIHN1YnRyYWN0IHRvIHRoaXMgc2l6ZVxuICAgICAqIEByZXR1cm5zIGEgbmV3IFNpemUgc2V0IGFzIHRoZSBzdWJ0cmFjdGlvbiByZXN1bHQgb2YgIHRoZSBnaXZlbiBvbmUgZnJvbSB0aGUgY3VycmVudCBTaXplLlxuICAgICAqL1xuICAgIHN1YnRyYWN0KG90aGVyU2l6ZSkge1xuICAgICAgICBjb25zdCByID0gbmV3IFNpemUodGhpcy53aWR0aCAtIG90aGVyU2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLSBvdGhlclNpemUuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxufVxuZXhwb3J0cy5TaXplID0gU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpemUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJlYWxsb2NhdGVkVmFyaWFibGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9BbmdsZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQXJjMlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQXhpc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQmV6aWVyQ3VydmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbG9yM1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29sb3I0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9DdXJ2ZTNkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9GdXJzdHVtXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9NYXRyaXhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1BhdGgyZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGF0aDNkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QbGFuZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUXVhdGVybmlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vU2NhbGFyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TaXplXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9WZWN0b3IyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9WZWN0b3IzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9WZWN0b3I0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbmRleFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBPYnNlcnZhYmxlQ29tcG9uZW50IH0gZnJvbSAnLi4vZWNzL0NvbXBvbmVudCdcbmltcG9ydCB7IG5ld0lkIH0gZnJvbSAnLi4vZWNzL2hlbHBlcnMnXG5pbXBvcnQgeyBBbmltYXRvciB9IGZyb20gJy4vQ29tcG9uZW50cydcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIEFuaW1hdGlvblBhcmFtcyA9IHtcbiAgbG9vcGluZz86IGJvb2xlYW5cbiAgc3BlZWQ/OiBudW1iZXJcbiAgd2VpZ2h0PzogbnVtYmVyXG4gIGxheWVyPzogbnVtYmVyXG59XG5cbmNvbnN0IGRlZmF1bHRQYXJhbXM6IFJlcXVpcmVkPFxuICBQaWNrPEFuaW1hdGlvblBhcmFtcywgJ2xvb3BpbmcnIHwgJ3NwZWVkJyB8ICd3ZWlnaHQnIHwgJ2xheWVyJz5cbj4gPSB7XG4gIGxvb3Bpbmc6IHRydWUsXG4gIHNwZWVkOiAxLjAsXG4gIHdlaWdodDogMS4wLFxuICBsYXllcjogMFxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIEFuaW1hdGlvblN0YXRlIGV4dGVuZHMgT2JzZXJ2YWJsZUNvbXBvbmVudCB7XG4gIC8vIEBpbnRlcm5hbFxuICBwdWJsaWMgaXNBbmltYXRpb25DbGlwOiBib29sZWFuID0gdHJ1ZVxuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBhbmltYXRpb24gaW4gdGhlIG1vZGVsXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICBwdWJsaWMgcmVhZG9ubHkgY2xpcDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIERvZXMgdGhlIGFuaW1hdGlvbiBsb29wPywgZGVmYXVsdDogdHJ1ZVxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcHVibGljIGxvb3Bpbmc6IGJvb2xlYW4gPSBkZWZhdWx0UGFyYW1zLmxvb3BpbmdcblxuICAvKipcbiAgICogV2VpZ2h0IG9mIHRoZSBhbmltYXRpb24sIHZhbHVlcyBmcm9tIDAgdG8gMSwgdXNlZCB0byBibGVuZCBzZXZlcmFsIGFuaW1hdGlvbnMuIGRlZmF1bHQ6IDFcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHB1YmxpYyB3ZWlnaHQ6IG51bWJlciA9IGRlZmF1bHRQYXJhbXMud2VpZ2h0XG5cbiAgLyoqXG4gICAqIElzIHRoZSBhbmltYXRpb24gcGxheWluZz8gZGVmYXVsdDogdHJ1ZVxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcHVibGljIHBsYXlpbmc6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBEb2VzIGFueSBhbnlvbmUgYXNrZWQgdG8gcmVzZXQgdGhlIGFuaW1hdGlvbj8gZGVmYXVsdDogZmFsc2VcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHB1YmxpYyBzaG91bGRSZXNldDogYm9vbGVhbiA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIFRoZSBhbmltYXRpb24gc3BlZWRcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHB1YmxpYyBzcGVlZDogbnVtYmVyID0gZGVmYXVsdFBhcmFtcy5zcGVlZFxuXG4gIC8vIEBpbnRlcm5hbFxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSBuYW1lOiBzdHJpbmcgPSBuZXdJZCgnQW5pbUNsaXAnKVxuXG4gIC8qKlxuICAgKiBMYXllcmluZyBhbGxvd3MgeW91IHRvIGhhdmUgdHdvIG9yIG1vcmUgbGV2ZWxzIG9mIGFuaW1hdGlvbiBvbiBhbiBvYmplY3QncyBwYXJhbWV0ZXJzIGF0IHRoZSBzYW1lIHRpbWVcbiAgICovXG4gIHB1YmxpYyBsYXllcjogbnVtYmVyID0gZGVmYXVsdFBhcmFtcy5sYXllclxuXG4gIC8vIEBpbnRlcm5hbFxuICBwdWJsaWMgb3duZXI/OiBBbmltYXRvclxuXG4gIGNvbnN0cnVjdG9yKGNsaXA6IHN0cmluZywgcGFyYW1zOiBBbmltYXRpb25QYXJhbXMgPSBkZWZhdWx0UGFyYW1zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuY2xpcCA9IGNsaXBcbiAgICB0aGlzLnNldFBhcmFtcyh7IC4uLnBhcmFtcyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNsaXAgcGFyYW1ldGVyc1xuICAgKi9cbiAgc2V0UGFyYW1zKHBhcmFtczogQW5pbWF0aW9uUGFyYW1zKSB7XG4gICAgdGhpcy5sb29waW5nID0gcGFyYW1zLmxvb3BpbmcgIT09IHVuZGVmaW5lZCA/IHBhcmFtcy5sb29waW5nIDogdGhpcy5sb29waW5nXG4gICAgdGhpcy5zcGVlZCA9IHBhcmFtcy5zcGVlZCB8fCB0aGlzLnNwZWVkXG4gICAgdGhpcy53ZWlnaHQgPSBwYXJhbXMud2VpZ2h0IHx8IHRoaXMud2VpZ2h0XG4gICAgdGhpcy5sYXllciA9IHBhcmFtcy5sYXllciB8fCB0aGlzLmxheWVyXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCByZXQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN1cGVyLnRvSlNPTigpKSlcbiAgICBpZiAodGhpcy5zaG91bGRSZXNldCkge1xuICAgICAgdGhpcy5zaG91bGRSZXNldCA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGFuaW1hdGlvblxuICAgKi9cbiAgcGxheShyZXNldDogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgdGhpcy5vd25lcj8ucGxheSh0aGlzLCByZXNldClcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZXMgdGhlIGFuaW1hdGlvblxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5vd25lcj8ucGF1c2UodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGFuaW1hdGlvbiBzdGF0ZSB0byB0aGUgZnJhbWUgMFxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zaG91bGRSZXNldCA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgYW5kIHBhdXNlcyB0aGUgYW5pbWF0aW9uXG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMub3duZXI/LnN0b3AodGhpcylcbiAgfVxufVxuIiwiaW1wb3J0IHsgUmVhZE9ubHlDb2xvcjQgfSBmcm9tICdAZGNsL2Vjcy1tYXRoJ1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGVudW0gSW5wdXRFdmVudFR5cGUge1xuICBET1dOLFxuICBVUFxufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGVudW0gQ2FtZXJhTW9kZSB7XG4gIEZpcnN0UGVyc29uID0gMCxcbiAgVGhpcmRQZXJzb24gPSAxLFxuICAvLyBAaW50ZXJuYWxcbiAgQnVpbGRpbmdUb29sR29kTW9kZSA9IDJcbn1cblxuLy8gQGludGVybmFsXG5leHBvcnQgY29uc3QgQVZBVEFSX09CU0VSVkFCTEUgPSAnQVZBVEFSX09CU0VSVkFCTEUnXG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBXZWFyYWJsZUlkID0gc3RyaW5nXG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBBdmF0YXJGb3JSZW5kZXJlciA9IHtcbiAgYm9keVNoYXBlOiBXZWFyYWJsZUlkXG4gIHNraW5Db2xvcjogUmVhZE9ubHlDb2xvcjRcbiAgaGFpckNvbG9yOiBSZWFkT25seUNvbG9yNFxuICBleWVDb2xvcjogUmVhZE9ubHlDb2xvcjRcbiAgd2VhcmFibGVzOiBXZWFyYWJsZUlkW11cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFdlYXJhYmxlID0ge1xuICBpZDogV2VhcmFibGVJZFxuICB0eXBlOiAnd2VhcmFibGUnXG4gIGNhdGVnb3J5OiBzdHJpbmdcbiAgYmFzZVVybDogc3RyaW5nXG4gIHRhZ3M6IHN0cmluZ1tdXG4gIHJlcHJlc2VudGF0aW9uczogQm9keVNoYXBlUmVzcHJlc2VudGF0aW9uW11cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIEJvZHlTaGFwZVJlc3ByZXNlbnRhdGlvbiA9IHtcbiAgYm9keVNoYXBlczogc3RyaW5nW11cbiAgbWFpbkZpbGU6IHN0cmluZ1xuICBjb250ZW50czogRmlsZUFuZEhhc2hbXVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRmlsZUFuZEhhc2ggPSB7XG4gIGZpbGU6IHN0cmluZ1xuICBoYXNoOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIFByb2ZpbGVGb3JSZW5kZXJlciA9IHtcbiAgdXNlcklkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICBhdmF0YXI6IEF2YXRhckZvclJlbmRlcmVyXG4gIHNuYXBzaG90czoge1xuICAgIGZhY2U6IHN0cmluZ1xuICAgIGJvZHk6IHN0cmluZ1xuICB9XG4gIHZlcnNpb246IG51bWJlclxuICBoYXNDb25uZWN0ZWRXZWIzOiBib29sZWFuXG4gIHVwZGF0ZWRBdD86IG51bWJlclxuICBjcmVhdGVkQXQ/OiBudW1iZXJcbiAgcGFyY2Vsc1dpdGhBY2Nlc3M/OiBQYXJjZWxzV2l0aEFjY2Vzc1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgUGFyY2Vsc1dpdGhBY2Nlc3MgPSBBcnJheTx7XG4gIHg6IG51bWJlclxuICB5OiBudW1iZXJcbiAgcm9sZTogTGFuZFJvbGVcbn0+XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgZW51bSBMYW5kUm9sZSB7XG4gIE9XTkVSID0gJ293bmVyJyxcbiAgT1BFUkFUT1IgPSAnb3BlcmF0b3InXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBNaW5pbWFwU2NlbmVJbmZvID0ge1xuICBuYW1lOiBzdHJpbmdcbiAgb3duZXI6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHByZXZpZXdJbWFnZVVybDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIHR5cGU6IG51bWJlclxuICBwYXJjZWxzOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1bXVxuICBpc1BPSTogYm9vbGVhblxufVxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0BkY2wvZWNzLW1hdGgnXG5cbmltcG9ydCB7IElucHV0RXZlbnRUeXBlIH0gZnJvbSAnLi9UeXBlcydcbmltcG9ydCB7IENvbXBvbmVudCwgRGlzcG9zYWJsZUNvbXBvbmVudCB9IGZyb20gJy4uL2Vjcy9Db21wb25lbnQnXG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBJbnB1dEV2ZW50S2luZCA9ICdCVVRUT05fRE9XTicgfCAnQlVUVE9OX1VQJ1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGVudW0gQWN0aW9uQnV0dG9uIHtcbiAgUE9JTlRFUiA9ICdQT0lOVEVSJyxcbiAgUFJJTUFSWSA9ICdQUklNQVJZJyxcbiAgU0VDT05EQVJZID0gJ1NFQ09OREFSWScsXG4gIEFOWSA9ICdBTlknLFxuICBGT1JXQVJEID0gJ0ZPUldBUkQnLFxuICBCQUNLV0FSRCA9ICdCQUNLV0FSRCcsXG4gIFJJR0hUID0gJ1JJR0hUJyxcbiAgTEVGVCA9ICdMRUZUJyxcbiAgSlVNUCA9ICdKVU1QJyxcbiAgV0FMSyA9ICdXQUxLJyxcbiAgQUNUSU9OXzMgPSAnQUNUSU9OXzMnLFxuICBBQ1RJT05fNCA9ICdBQ1RJT05fNCcsXG4gIEFDVElPTl81ID0gJ0FDVElPTl81JyxcbiAgQUNUSU9OXzYgPSAnQUNUSU9OXzYnXG59XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBJbnB1dFN0YXRlID0gUmVjb3JkPFxuICBBY3Rpb25CdXR0b24sXG4gIHtcbiAgICBCVVRUT05fRE9XTjogYm9vbGVhblxuICB9XG4+XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBMb2NhbEFjdGlvbkJ1dHRvbkV2ZW50ID0gR2xvYmFsSW5wdXRFdmVudFJlc3VsdCAmIHtcbiAgb3JpZ2luOiBWZWN0b3IzXG4gIGRpcmVjdGlvbjogVmVjdG9yM1xuICBidXR0b246IEFjdGlvbkJ1dHRvblxuICBoaXQ/OiBHbG9iYWxJbnB1dEV2ZW50UmVzdWx0WydoaXQnXSAmIHtcbiAgICBoaXRQb2ludDogVmVjdG9yM1xuICAgIG5vcm1hbDogVmVjdG9yM1xuICAgIHdvcmxkTm9ybWFsOiBWZWN0b3IzXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2ludGVyRXZlbnRDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2FsbGJhY2s6IChldmVudDogTG9jYWxBY3Rpb25CdXR0b25FdmVudCkgPT4gdm9pZFxuICApIHtcbiAgICBpZiAoIWNhbGxiYWNrIHx8ICEoJ2FwcGx5JyBpbiBjYWxsYmFjaykgfHwgISgnY2FsbCcgaW4gY2FsbGJhY2spKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uJylcbiAgICB9XG4gICAgSW5wdXQuZW5zdXJlSW5zdGFuY2UoKVxuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5AQ29tcG9uZW50KCdwb2ludGVyRG93bicpXG5leHBvcnQgY2xhc3MgR2xvYmFsUG9pbnRlckRvd24gZXh0ZW5kcyBQb2ludGVyRXZlbnRDb21wb25lbnQge31cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ3BvaW50ZXJVcCcpXG5leHBvcnQgY2xhc3MgR2xvYmFsUG9pbnRlclVwIGV4dGVuZHMgUG9pbnRlckV2ZW50Q29tcG9uZW50IHt9XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgU3Vic2NyaXB0aW9uIHtcbiAgcHVibGljIGZuOiAoZTogTG9jYWxBY3Rpb25CdXR0b25FdmVudCkgPT4gdm9pZFxuICBwdWJsaWMgdXNlUmF5Y2FzdDogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKGZuOiAoZTogTG9jYWxBY3Rpb25CdXR0b25FdmVudCkgPT4gdm9pZCwgdXNlUmF5Y2FzdDogYm9vbGVhbikge1xuICAgIHRoaXMuZm4gPSBmblxuICAgIHRoaXMudXNlUmF5Y2FzdCA9IHVzZVJheWNhc3RcbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIElucHV0IHtcbiAgcHJpdmF0ZSBzdGF0aWMgX2luc3RhbmNlOiBJbnB1dFxuXG4gIC8vIEBpbnRlcm5hbFxuICBwcml2YXRlIGJ1dHRvbklkTWFwcGluZzogQWN0aW9uQnV0dG9uW10gPSBbXG4gICAgQWN0aW9uQnV0dG9uLlBPSU5URVIsXG4gICAgQWN0aW9uQnV0dG9uLlBSSU1BUlksXG4gICAgQWN0aW9uQnV0dG9uLlNFQ09OREFSWSxcbiAgICBBY3Rpb25CdXR0b24uQU5ZLFxuICAgIEFjdGlvbkJ1dHRvbi5GT1JXQVJELFxuICAgIEFjdGlvbkJ1dHRvbi5CQUNLV0FSRCxcbiAgICBBY3Rpb25CdXR0b24uUklHSFQsXG4gICAgQWN0aW9uQnV0dG9uLkxFRlQsXG4gICAgQWN0aW9uQnV0dG9uLkpVTVAsXG4gICAgQWN0aW9uQnV0dG9uLldBTEssXG4gICAgQWN0aW9uQnV0dG9uLkFDVElPTl8zLFxuICAgIEFjdGlvbkJ1dHRvbi5BQ1RJT05fNCxcbiAgICBBY3Rpb25CdXR0b24uQUNUSU9OXzUsXG4gICAgQWN0aW9uQnV0dG9uLkFDVElPTl82XG4gIF1cblxuICBzdGF0aWMgZ2V0IGluc3RhbmNlKCk6IElucHV0IHtcbiAgICBJbnB1dC5lbnN1cmVJbnN0YW5jZSgpXG4gICAgcmV0dXJuIElucHV0Ll9pbnN0YW5jZVxuICB9XG5cbiAgLy8gQGludGVybmFsXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogUmVjb3JkPFxuICAgIEFjdGlvbkJ1dHRvbixcbiAgICBSZWNvcmQ8SW5wdXRFdmVudEtpbmQsIEFycmF5PFN1YnNjcmlwdGlvbj4+XG4gID4gPSB0aGlzLmJ1dHRvbklkTWFwcGluZy5yZWR1Y2UoXG4gICAgKGFjYywgaykgPT4gKHsgLi4uYWNjLCBba106IHsgQlVUVE9OX0RPV046IFtdLCBCVVRUT05fVVA6IFtdIH0gfSksXG4gICAge30gYXMgUmVjb3JkPEFjdGlvbkJ1dHRvbiwgUmVjb3JkPElucHV0RXZlbnRLaW5kLCBBcnJheTxTdWJzY3JpcHRpb24+Pj5cbiAgKVxuXG4gIHByaXZhdGUgaW50ZXJuYWxTdGF0ZTogSW5wdXRTdGF0ZSA9IHRoaXMuYnV0dG9uSWRNYXBwaW5nLnJlZHVjZShcbiAgICAoYWNjLCBrKSA9PiAoeyAuLi5hY2MsIFtrXTogeyBCVVRUT05fRE9XTjogZmFsc2UgfSB9KSxcbiAgICB7fSBhcyBJbnB1dFN0YXRlXG4gIClcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cblxuICBzdGF0aWMgZW5zdXJlSW5zdGFuY2UoKTogYW55IHtcbiAgICBpZiAoIUlucHV0Ll9pbnN0YW5jZSkge1xuICAgICAgSW5wdXQuX2luc3RhbmNlID0gbmV3IElucHV0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHRvIGtub3cgaWYgYSBidXR0b24gaXMgcHJlc3NlZFxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJ1dHRvbiBpcyBwcmVzc2VkXG4gICAqIEBwYXJhbSBidXR0b25JZCAtIFRoZSBpZCBvZiB0aGUgYnV0dG9uLlxuICAgKi9cbiAgcHVibGljIGlzQnV0dG9uUHJlc3NlZChidXR0b25JZDogQWN0aW9uQnV0dG9uKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZVtidXR0b25JZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIHRvIGFuIGlucHV0IGV2ZW50IGFuZCB0cmlnZ2VycyB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gICAqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgdG8gcmVtb3ZlIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKHNlZSBJbnB1dEV2ZW50S2luZCkuXG4gICAqIEBwYXJhbSBidXR0b25JZCAtIFRoZSBpZCBvZiB0aGUgYnV0dG9uLlxuICAgKiBAcGFyYW0gdXNlUmF5Y2FzdCAtIEVuYWJsZXMgZ2V0dGluZyByYXljYXN0IGluZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0gZm4gLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuICBwdWJsaWMgc3Vic2NyaWJlKFxuICAgIGV2ZW50TmFtZTogSW5wdXRFdmVudEtpbmQsXG4gICAgYnV0dG9uSWQ6IEFjdGlvbkJ1dHRvbixcbiAgICB1c2VSYXljYXN0OiBib29sZWFuLFxuICAgIGZuOiAoZTogTG9jYWxBY3Rpb25CdXR0b25FdmVudCkgPT4gdm9pZFxuICApOiAoKSA9PiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnNbYnV0dG9uSWRdW2V2ZW50TmFtZV0ucHVzaChcbiAgICAgIG5ldyBTdWJzY3JpcHRpb24oZm4sIHVzZVJheWNhc3QpXG4gICAgKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKGV2ZW50TmFtZSwgYnV0dG9uSWQsIGZuKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIGlucHV0IGV2ZW50IHN1YnNjcmlwdGlvbi5cbiAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoc2VlIElucHV0RXZlbnRLaW5kKS5cbiAgICogQHBhcmFtIGJ1dHRvbklkIC0gVGhlIGlkIG9mIHRoZSBidXR0b24uXG4gICAqIEBwYXJhbSBmbiAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB1c2VkIHdoZW4gc3Vic2NyaWJpbmcgdG8gdGhlIGV2ZW50LlxuICAgKi9cbiAgcHVibGljIHVuc3Vic2NyaWJlKFxuICAgIGV2ZW50TmFtZTogSW5wdXRFdmVudEtpbmQsXG4gICAgYnV0dG9uSWQ6IEFjdGlvbkJ1dHRvbixcbiAgICBmbjogKGU6IExvY2FsQWN0aW9uQnV0dG9uRXZlbnQpID0+IHZvaWRcbiAgKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldFN1YnNjcmlwdGlvbklkKGV2ZW50TmFtZSwgYnV0dG9uSWQsIGZuKVxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zW2J1dHRvbklkXVtldmVudE5hbWVdLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBwdWJsaWMgaGFuZGxlUG9pbnRlckV2ZW50KGRhdGE6IEdsb2JhbElucHV0RXZlbnRSZXN1bHQpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLmdldFBvaW50ZXJCeUlkKGRhdGEuYnV0dG9uSWQpXG5cbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRSZXN1bHQ6IExvY2FsQWN0aW9uQnV0dG9uRXZlbnQgPSB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgYnV0dG9uLFxuICAgICAgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLmNvcHlGcm9tKGRhdGEuZGlyZWN0aW9uKSxcbiAgICAgIG9yaWdpbjogbmV3IFZlY3RvcjMoKS5jb3B5RnJvbShkYXRhLm9yaWdpbiksXG4gICAgICBoaXQ6IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGNvbnN0IGhpdCA9IGRhdGEuaGl0XG4gICAgICA/IHtcbiAgICAgICAgICAuLi5kYXRhLmhpdCxcbiAgICAgICAgICBoaXRQb2ludDogbmV3IFZlY3RvcjMoKS5jb3B5RnJvbShkYXRhLmhpdC5oaXRQb2ludCksXG4gICAgICAgICAgbm9ybWFsOiBuZXcgVmVjdG9yMygpLmNvcHlGcm9tKGRhdGEuaGl0Lm5vcm1hbCksXG4gICAgICAgICAgd29ybGROb3JtYWw6IG5ldyBWZWN0b3IzKCkuY29weUZyb20oZGF0YS5oaXQud29ybGROb3JtYWwpXG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICBpZiAoZGF0YS50eXBlID09PSBJbnB1dEV2ZW50VHlwZS5ET1dOKSB7XG4gICAgICB0aGlzLmludGVybmFsU3RhdGVbYnV0dG9uXS5CVVRUT05fRE9XTiA9IHRydWVcblxuICAgICAgZm9yIChcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBpIDwgdGhpcy5zdWJzY3JpcHRpb25zW2J1dHRvbl1bJ0JVVFRPTl9ET1dOJ10ubGVuZ3RoO1xuICAgICAgICBpKytcbiAgICAgICkge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmlwdGlvbnNbYnV0dG9uXVsnQlVUVE9OX0RPV04nXVtpXVxuXG4gICAgICAgIC8vIHJlbW92ZSBoaXQgaW5mb3JtYXRpb24gd2hlbiByYXljYXN0IGlzIGRpc2FibGVkXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24udXNlUmF5Y2FzdCkge1xuICAgICAgICAgIGV2ZW50UmVzdWx0LmhpdCA9IGhpdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50UmVzdWx0LmhpdCA9IHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgc3Vic2NyaXB0aW9uLmZuKGV2ZW50UmVzdWx0KVxuICAgICAgfVxuXG4gICAgICBpZiAoaGl0ICYmIGhpdC5lbnRpdHlJZCAmJiBEaXNwb3NhYmxlQ29tcG9uZW50LmVuZ2luZSkge1xuICAgICAgICBjb25zdCBlbnRpdHkgPSBEaXNwb3NhYmxlQ29tcG9uZW50LmVuZ2luZS5lbnRpdGllc1toaXQuZW50aXR5SWRdXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBlbnRpdHkgJiYgZW50aXR5LmdldENvbXBvbmVudE9yTnVsbChHbG9iYWxQb2ludGVyRG93bilcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBldmVudFJlc3VsdC5oaXQgPSBoaXRcbiAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKGV2ZW50UmVzdWx0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZVtidXR0b25dLkJVVFRPTl9ET1dOID0gZmFsc2VcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1YnNjcmlwdGlvbnNbYnV0dG9uXVsnQlVUVE9OX1VQJ10ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpcHRpb25zW2J1dHRvbl1bJ0JVVFRPTl9VUCddW2ldXG5cbiAgICAgICAgLy8gcmVtb3ZlIGhpdCBpbmZvcm1hdGlvbiB3aGVuIHJheWNhc3QgaXMgZGlzYWJsZWRcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi51c2VSYXljYXN0KSB7XG4gICAgICAgICAgZXZlbnRSZXN1bHQuaGl0ID0gaGl0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRSZXN1bHQuaGl0ID0gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICBzdWJzY3JpcHRpb24uZm4oZXZlbnRSZXN1bHQpXG4gICAgICB9XG5cbiAgICAgIGlmIChoaXQgJiYgaGl0LmVudGl0eUlkICYmIERpc3Bvc2FibGVDb21wb25lbnQuZW5naW5lKSB7XG4gICAgICAgIGNvbnN0IGVudGl0eSA9IERpc3Bvc2FibGVDb21wb25lbnQuZW5naW5lLmVudGl0aWVzW2hpdC5lbnRpdHlJZF1cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGVudGl0eSAmJiBlbnRpdHkuZ2V0Q29tcG9uZW50T3JOdWxsKEdsb2JhbFBvaW50ZXJVcClcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBldmVudFJlc3VsdC5oaXQgPSBoaXRcbiAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKGV2ZW50UmVzdWx0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRTdWJzY3JpcHRpb25JZChcbiAgICBldmVudE5hbWU6IElucHV0RXZlbnRLaW5kLFxuICAgIGJ1dHRvbklkOiBBY3Rpb25CdXR0b24sXG4gICAgZm46IChlOiBMb2NhbEFjdGlvbkJ1dHRvbkV2ZW50KSA9PiB2b2lkXG4gICk6IG51bWJlciB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1YnNjcmlwdGlvbnNbYnV0dG9uSWRdW2V2ZW50TmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnNbYnV0dG9uSWRdW2V2ZW50TmFtZV1baV0uZm4gPT09IGZuKSB7XG4gICAgICAgIHJldHVybiBpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICBwcml2YXRlIGdldFBvaW50ZXJCeUlkKGlkOiBudW1iZXIpOiBBY3Rpb25CdXR0b24gfCBudWxsIHtcbiAgICBpZiAoaWQgPCAwIHx8IGlkID49IHRoaXMuYnV0dG9uSWRNYXBwaW5nLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpb25CdXR0b24gPSB0aGlzLmJ1dHRvbklkTWFwcGluZ1tpZF1cblxuICAgIGlmIChhY3Rpb25CdXR0b24gPT09IEFjdGlvbkJ1dHRvbi5BTlkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbkJ1dHRvblxuICB9XG59XG4iLCJpbXBvcnQge1xuICBWZWN0b3IzLFxuICBRdWF0ZXJuaW9uLFxuICBNYXRyaXgsXG4gIE1hdGhUbXAsXG4gIENvbG9yMyxcbiAgQ29sb3I0XG59IGZyb20gJ0BkY2wvZWNzLW1hdGgnXG5cbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgT2JzZXJ2YWJsZUNvbXBvbmVudCxcbiAgRGlzcG9zYWJsZUNvbXBvbmVudCxcbiAgZ2V0Q29tcG9uZW50SWRcbn0gZnJvbSAnLi4vZWNzL0NvbXBvbmVudCdcbmltcG9ydCB7IEFuaW1hdGlvblN0YXRlIH0gZnJvbSAnLi9BbmltYXRpb25TdGF0ZSdcbmltcG9ydCB7IGxvZywgbmV3SWQgfSBmcm9tICcuLi9lY3MvaGVscGVycydcbmltcG9ydCB7IEFjdGlvbkJ1dHRvbiB9IGZyb20gJy4vSW5wdXQnXG5pbXBvcnQgeyBDYW1lcmFNb2RlIH0gZnJvbSAnLi9UeXBlcydcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIFRyYW5mb3JtQ29uc3RydWN0b3JBcmdzID0gVHJhbnNmb3JtQ29uc3RydWN0b3JBcmdzXG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBUcmFuc2Zvcm1Db25zdHJ1Y3RvckFyZ3MgPSB7XG4gIHBvc2l0aW9uPzogVmVjdG9yM1xuICByb3RhdGlvbj86IFF1YXRlcm5pb25cbiAgc2NhbGU/OiBWZWN0b3IzXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZW51bSBDTEFTU19JRCB7XG4gIFRSQU5TRk9STSA9IDEsXG4gIFVVSURfQ0FMTEJBQ0sgPSA4LFxuICBCT1hfU0hBUEUgPSAxNixcbiAgU1BIRVJFX1NIQVBFID0gMTcsXG4gIFBMQU5FX1NIQVBFID0gMTgsXG4gIENPTkVfU0hBUEUgPSAxOSxcbiAgQ1lMSU5ERVJfU0hBUEUgPSAyMCxcbiAgVEVYVF9TSEFQRSA9IDIxLFxuXG4gIE5GVF9TSEFQRSA9IDIyLFxuICBVSV9XT1JMRF9TUEFDRV9TSEFQRSA9IDIzLFxuICBVSV9TQ1JFRU5fU1BBQ0VfU0hBUEUgPSAyNCxcbiAgVUlfQ09OVEFJTkVSX1JFQ1QgPSAyNSxcbiAgVUlfQ09OVEFJTkVSX1NUQUNLID0gMjYsXG4gIFVJX1RFWFRfU0hBUEUgPSAyNyxcbiAgVUlfSU5QVVRfVEVYVF9TSEFQRSA9IDI4LFxuICBVSV9JTUFHRV9TSEFQRSA9IDI5LFxuICBVSV9TTElERVJfU0hBUEUgPSAzMCxcbiAgQ0lSQ0xFX1NIQVBFID0gMzEsXG4gIEJJTExCT0FSRCA9IDMyLFxuXG4gIEFOSU1BVElPTiA9IDMzLFxuICBGT05UID0gMzQsXG5cbiAgVUlfRlVMTFNDUkVFTl9TSEFQRSA9IDQwLCAvLyBpbnRlcm5hbCBmdWxsc2NyZWVuIHNjZW5lc1xuICBVSV9CVVRUT05fU0hBUEUgPSA0MSxcblxuICBHTFRGX1NIQVBFID0gNTQsXG4gIE9CSl9TSEFQRSA9IDU1LFxuICBBVkFUQVJfU0hBUEUgPSA1NixcblxuICBCQVNJQ19NQVRFUklBTCA9IDY0LFxuICBQQlJfTUFURVJJQUwgPSA2NSxcblxuICBISUdITElHSFRfRU5USVRZID0gNjYsXG5cbiAgLyoqIEBkZXByZWNhdGVkIFNvdW5kIGhhcyBiZWVuIGRlcHJlY2F0YWVkICovXG4gIFNPVU5EID0gNjcsXG4gIFRFWFRVUkUgPSA2OCxcblxuICBWSURFT19DTElQID0gNzAsXG4gIFZJREVPX1RFWFRVUkUgPSA3MSxcblxuICBBVkFUQVJfVEVYVFVSRSA9IDcyLFxuXG4gIEFVRElPX0NMSVAgPSAyMDAsXG4gIEFVRElPX1NPVVJDRSA9IDIwMSxcbiAgQVVESU9fU1RSRUFNID0gMjAyLFxuICBHSVpNT1MgPSAyMDMsXG4gIFNNQVJUX0lURU0gPSAyMDQsXG4gIEFWQVRBUl9NT0RJRklFUl9BUkVBID0gMjA1LFxuICBBVkFUQVJfQVRUQUNIID0gMjA2LFxuICBDQU1FUkFfTU9ERV9BUkVBID0gMjA3LFxuXG4gIC8vIEZvciBzdGF0ZSBzeW5jIG9ubHlcbiAgTkFNRSA9IDMwMCxcbiAgTE9DS0VEX09OX0VESVQgPSAzMDEsXG4gIFZJU0lCTEVfT05fRURJVCA9IDMwMlxufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGVudW0gQXZhdGFyTW9kaWZpZXJzIHtcbiAgSElERV9BVkFUQVJTID0gJ0hJREVfQVZBVEFSUycsXG4gIERJU0FCTEVfUEFTU1BPUlRTID0gJ0RJU0FCTEVfUEFTU1BPUlRTJ1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgQXJlYSA9IHsgYm94OiBWZWN0b3IzIH1cblxuLyoqXG4gKiBEZWZpbmUgYW4gYXJlYSB3aGVyZSBhdmF0YXJzIGNhbiBiZSBtb2RpZmllZCBpbiBzb21lIHdheVxuICogQHB1YmxpY1xuICovXG5AQ29tcG9uZW50KCdlbmdpbmUuYXZhdGFyTW9kaWZpZXJBcmVhJywgQ0xBU1NfSUQuQVZBVEFSX01PRElGSUVSX0FSRUEpXG5leHBvcnQgY2xhc3MgQXZhdGFyTW9kaWZpZXJBcmVhIGV4dGVuZHMgT2JzZXJ2YWJsZUNvbXBvbmVudCB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGFyZWEhOiBBcmVhXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgbW9kaWZpZXJzITogQXZhdGFyTW9kaWZpZXJzW11cblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBleGNsdWRlSWRzPzogc3RyaW5nW11cblxuICBjb25zdHJ1Y3RvcihhcmdzOiB7XG4gICAgYXJlYTogQXJlYVxuICAgIG1vZGlmaWVyczogQXZhdGFyTW9kaWZpZXJzW11cbiAgICBleGNsdWRlSWRzPzogc3RyaW5nW11cbiAgfSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmFyZWEgPSBhcmdzLmFyZWFcbiAgICB0aGlzLm1vZGlmaWVycyA9IGFyZ3MubW9kaWZpZXJzXG4gICAgdGhpcy5leGNsdWRlSWRzID0gYXJncy5leGNsdWRlSWRzXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS50cmFuc2Zvcm0nLCBDTEFTU19JRC5UUkFOU0ZPUk0pXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIGV4dGVuZHMgT2JzZXJ2YWJsZUNvbXBvbmVudCB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBvc2l0aW9uITogVmVjdG9yM1xuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHJvdGF0aW9uITogUXVhdGVybmlvblxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNjYWxlITogVmVjdG9yM1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFRyYW5zZm9ybUNvbnN0cnVjdG9yQXJncyA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMucG9zaXRpb24gPSBhcmdzLnBvc2l0aW9uIHx8IFZlY3RvcjMuWmVybygpXG4gICAgdGhpcy5yb3RhdGlvbiA9IGFyZ3Mucm90YXRpb24gfHwgUXVhdGVybmlvbi5JZGVudGl0eVxuICAgIHRoaXMuc2NhbGUgPSBhcmdzLnNjYWxlIHx8IG5ldyBWZWN0b3IzKDEsIDEsIDEpXG4gIH1cblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBUaGUgcm90YXRpb24gYXMgRXVsZXIgYW5nbGVzIGluIGRlZ3JlZXMuXG4gICAqL1xuICBnZXQgZXVsZXJBbmdsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRpb24uZXVsZXJBbmdsZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIFJvdGF0ZXMgdGhlIHRyYW5zZm9ybSBzbyB0aGUgZm9yd2FyZCB2ZWN0b3IgcG9pbnRzIGF0IHRhcmdldCdzIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqL1xuICBsb29rQXQodGFyZ2V0OiBWZWN0b3IzLCB3b3JsZFVwOiBWZWN0b3IzID0gTWF0aFRtcC5zdGF0aWNVcCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXRyaXgoKVxuICAgIE1hdHJpeC5Mb29rQXRMSFRvUmVmKHRoaXMucG9zaXRpb24sIHRhcmdldCwgd29ybGRVcCwgcmVzdWx0KVxuICAgIHJlc3VsdC5pbnZlcnQoKVxuICAgIFF1YXRlcm5pb24uRnJvbVJvdGF0aW9uTWF0cml4VG9SZWYocmVzdWx0LCB0aGlzLnJvdGF0aW9uKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQHB1YmxpY1xuICAgKiBBcHBsaWVzIGEgcm90YXRpb24gb2YgZXVsZXIgYW5nbGVzIGFyb3VuZCB0aGUgeCwgeSBhbmQgeiBheGlzLlxuICAgKi9cbiAgcm90YXRlKGF4aXM6IFZlY3RvcjMsIGFuZ2xlOiBudW1iZXIpIHtcbiAgICB0aGlzLnJvdGF0aW9uLm11bHRpcGx5SW5QbGFjZSh0aGlzLnJvdGF0aW9uLmFuZ2xlQXhpcyhhbmdsZSwgYXhpcykpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHVibGljXG4gICAqIE1vdmVzIHRoZSB0cmFuc2Zvcm0gaW4gdGhlIGRpcmVjdGlvbiBhbmQgZGlzdGFuY2Ugb2YgdHJhbnNsYXRpb24uXG4gICAqL1xuICB0cmFuc2xhdGUodmVjOiBWZWN0b3IzKSB7XG4gICAgdGhpcy5wb3NpdGlvbi5hZGRJblBsYWNlKHZlYylcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgZW51bSBBdHRhY2hUb0F2YXRhckFuY2hvclBvaW50SWQge1xuICBQb3NpdGlvbiA9IDAsXG4gIE5hbWVUYWcgPSAxLFxuICAvKiogQGludGVybmFsICovXG4gIExlZnRIYW5kID0gMixcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBSaWdodEhhbmQgPSAzXG59XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBBdHRhY2hUb0F2YXRhckNvbnN0cnVjdG9yQXJncyA9IHtcbiAgYXZhdGFySWQ/OiBzdHJpbmdcbiAgYW5jaG9yUG9pbnRJZD86IEF0dGFjaFRvQXZhdGFyQW5jaG9yUG9pbnRJZFxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQENvbXBvbmVudCgnZW5naW5lLnRyYW5zZm9ybScsIENMQVNTX0lELkFWQVRBUl9BVFRBQ0gpXG5leHBvcnQgY2xhc3MgQXR0YWNoVG9BdmF0YXIgZXh0ZW5kcyBPYnNlcnZhYmxlQ29tcG9uZW50IHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgYXZhdGFySWQhOiBzdHJpbmdcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBhbmNob3JQb2ludElkITogQXR0YWNoVG9BdmF0YXJBbmNob3JQb2ludElkXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgYXZhdGFyU2NlbmVJZCE6ICdkY2wtZ3MtYXZhdGFycydcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBBdHRhY2hUb0F2YXRhckNvbnN0cnVjdG9yQXJncyA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuYXZhdGFySWQgPSBhcmdzLmF2YXRhcklkIHx8ICcnXG4gICAgdGhpcy5hbmNob3JQb2ludElkID1cbiAgICAgIGFyZ3MuYW5jaG9yUG9pbnRJZCB8fCBBdHRhY2hUb0F2YXRhckFuY2hvclBvaW50SWQuUG9zaXRpb25cbiAgfVxufVxuXG4vKipcbiAqIEJpbGxib2FyZCBkZWZpbmVzIGEgYmVoYXZpb3IgdGhhdCBtYWtlcyB0aGUgZW50aXR5IGZhY2UgdGhlIGNhbWVyYSBpbiBhbnkgbW9tZW50LlxuICogQHB1YmxpY1xuICovXG5AQ29tcG9uZW50KCdlbmdpbmUuYmlsbGJvYXJkJywgQ0xBU1NfSUQuQklMTEJPQVJEKVxuZXhwb3J0IGNsYXNzIEJpbGxib2FyZCBleHRlbmRzIE9ic2VydmFibGVDb21wb25lbnQge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB4OiBib29sZWFuID0gdHJ1ZVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHk6IGJvb2xlYW4gPSB0cnVlXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgejogYm9vbGVhbiA9IHRydWVcblxuICBjb25zdHJ1Y3Rvcih4OiBib29sZWFuID0gdHJ1ZSwgeTogYm9vbGVhbiA9IHRydWUsIHo6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMueCA9IHhcbiAgICB0aGlzLnkgPSB5XG4gICAgdGhpcy56ID0gelxuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgU2hhcGUgZXh0ZW5kcyBPYnNlcnZhYmxlQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIHRvIHR1cm4gb24gdGhlIGNvbGxpZGVyIGZvciB0aGUgZW50aXR5LlxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgd2l0aENvbGxpc2lvbnM6IGJvb2xlYW4gPSB0cnVlXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIHRvIHR1cm4gb24gdGhlIFBvaW50ZXJFdmVudHMgYmxvY2tpbmcgZm9yIHRoZSBlbnRpdHkuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBpc1BvaW50ZXJCbG9ja2VyOiBib29sZWFuID0gdHJ1ZVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGlmIHRoZSBlbnRpdHkgYW5kIGl0cyBjaGlsZHJlbiBzaG91bGQgYmUgcmVuZGVyZWRcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHZpc2libGU6IGJvb2xlYW4gPSB0cnVlXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnNoYXBlJywgQ0xBU1NfSUQuQk9YX1NIQVBFKVxuZXhwb3J0IGNsYXNzIEJveFNoYXBlIGV4dGVuZHMgU2hhcGUge1xuICAvKipcbiAgICogU2V0cyB0aGUgVVYgY29vcmRpbmF0ZXMgZm9yIHRoZSBib3guXG4gICAqIFVzZWQgdG8gbWFwIHNwZWNpZmljIHBpZWNlcyBvZiBhIE1hdGVyaWFsJ3MgdGV4dHVyZSBpbnRvIHRoZSBib3gncyBnZW9tZXRyeS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHV2cz86IG51bWJlcltdXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnNoYXBlJywgQ0xBU1NfSUQuU1BIRVJFX1NIQVBFKVxuZXhwb3J0IGNsYXNzIFNwaGVyZVNoYXBlIGV4dGVuZHMgU2hhcGUge31cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUuc2hhcGUnLCBDTEFTU19JRC5DSVJDTEVfU0hBUEUpXG5leHBvcnQgY2xhc3MgQ2lyY2xlU2hhcGUgZXh0ZW5kcyBTaGFwZSB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNlZ21lbnRzPzogbnVtYmVyXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgYXJjPzogbnVtYmVyXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnNoYXBlJywgQ0xBU1NfSUQuUExBTkVfU0hBUEUpXG5leHBvcnQgY2xhc3MgUGxhbmVTaGFwZSBleHRlbmRzIFNoYXBlIHtcbiAgLyoqXG4gICAqIFNldHMgdGhlIGhvcml6b250YWwgbGVuZ3RoIG9mIHRoZSBwbGFuZS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHdpZHRoOiBudW1iZXIgPSAxXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZlcnRpY2FsIGxlbmd0aCBvZiB0aGUgcGxhbmUuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBoZWlnaHQ6IG51bWJlciA9IDFcblxuICAvKipcbiAgICogU2V0cyB0aGUgVVYgY29vcmRpbmF0ZXMgZm9yIHRoZSBwbGFuZS5cbiAgICogVXNlZCB0byBtYXAgc3BlY2lmaWMgcGllY2VzIG9mIGEgTWF0ZXJpYWwncyB0ZXh0dXJlIGludG8gdGhlIHBsYW5lJ3MgZ2VvbWV0cnkuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB1dnM/OiBudW1iZXJbXVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQERpc3Bvc2FibGVDb21wb25lbnQoJ2VuZ2luZS5zaGFwZScsIENMQVNTX0lELkNPTkVfU0hBUEUpXG5leHBvcnQgY2xhc3MgQ29uZVNoYXBlIGV4dGVuZHMgU2hhcGUge1xuICAvKipcbiAgICogVGhlIHJhZGl1cyBvZiB0aGUgdG9wIG9mIGEgdHJ1bmNhdGVkIGNvbmUuIERlZmF1bHRzIHRvIDAuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICByYWRpdXNUb3A6IG51bWJlciA9IDBcblxuICAvKipcbiAgICogVGhlIHJhZGl1cyBvZiB0aGUgYmFzZSBvZiB0aGUgY29uZS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHJhZGl1c0JvdHRvbTogbnVtYmVyID0gMVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcmluZ3MgYWxvbmcgdGhlIGNvbmUgaGVpZ2h0IChwb3NpdGl2ZSBpbnRlZ2VyKS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNlZ21lbnRzSGVpZ2h0OiBudW1iZXIgPSAxXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG51bWJlciBvZiBjb25lIHNpZGVzIChwb3NpdGl2ZSBpbnRlZ2VyKS4gRGVmYXVsdHMgdG8gMzYuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzZWdtZW50c1JhZGlhbDogbnVtYmVyID0gMzZcblxuICAvKipcbiAgICogQWRkcyB0d28gZXh0cmEgZmFjZXMgcGVyIHN1YmRpdmlzaW9uIHRvIGVuY2xvc2UgdGhlIGNvbmUgYXJvdW5kIGl0cyBoZWlnaHQgYXhpcy5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBvcGVuRW5kZWQ6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByYWRpdXMgb2YgdGhlIHRvcCBhbmQgYm90dG9tIGNhcHMgYXQgb25jZS5cbiAgICpcbiAgICogUHJvcGVydGllcyBgcmFkaXVzVG9wYCBhbmQgYHJhZGl1c0JvdHRvbWAgYXJlIHByaW9yaXRpemVkIG92ZXIgdGhpcyBvbmUuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICByYWRpdXM6IG51bWJlciB8IG51bGwgPSBudWxsXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJhdGlvIChtYXggMSkgdG8gYXBwbHkgdG8gdGhlIGNpcmN1bWZlcmVuY2UgdG8gc2xpY2UgdGhlIGNvbmUuIERlZmF1bHRzIHRvIDM2MC5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGFyYzogbnVtYmVyID0gMzYwXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnNoYXBlJywgQ0xBU1NfSUQuQ1lMSU5ERVJfU0hBUEUpXG5leHBvcnQgY2xhc3MgQ3lsaW5kZXJTaGFwZSBleHRlbmRzIFNoYXBlIHtcbiAgLyoqXG4gICAqIFRoZSByYWRpdXMgb2YgdGhlIHRvcCBvZiB0aGUgY3lsaW5kZXIuIERlZmF1bHRzIHRvIDAuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICByYWRpdXNUb3A6IG51bWJlciA9IDFcblxuICAvKipcbiAgICogVGhlIHJhZGl1cyBvZiB0aGUgYmFzZSBvZiB0aGUgY3lsaW5kZXIuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICByYWRpdXNCb3R0b206IG51bWJlciA9IDFcblxuICAvKipcbiAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHJpbmdzIGFsb25nIHRoZSBjeWxpbmRlciBoZWlnaHQgKHBvc2l0aXZlIGludGVnZXIpLiBEZWZhdWx0cyB0byAxLlxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2VnbWVudHNIZWlnaHQ6IG51bWJlciA9IDFcblxuICAvKipcbiAgICogU2V0cyB0aGUgbnVtYmVyIG9mIGN5bGluZGVyIHNpZGVzIChwb3NpdGl2ZSBpbnRlZ2VyKS4gRGVmYXVsdHMgdG8gMzYuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzZWdtZW50c1JhZGlhbDogbnVtYmVyID0gMzZcblxuICAvKipcbiAgICogQWRkcyB0d28gZXh0cmEgZmFjZXMgcGVyIHN1YmRpdmlzaW9uIHRvIGVuY2xvc2UgdGhlIGN5bGluZGVyIGFyb3VuZCBpdHMgaGVpZ2h0IGF4aXMuXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgb3BlbkVuZGVkOiBib29sZWFuID0gZmFsc2VcblxuICAvKipcbiAgICogU2V0cyB0aGUgcmFkaXVzIG9mIHRoZSB0b3AgYW5kIGJvdHRvbSBjYXBzIGF0IG9uY2UuXG4gICAqXG4gICAqIFByb3BlcnRpZXMgYHJhZGl1c1RvcGAgYW5kIGByYWRpdXNCb3R0b21gIGFyZSBwcmlvcml0aXplZCBvdmVyIHRoaXMgb25lLlxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcmFkaXVzOiBudW1iZXIgfCBudWxsID0gbnVsbFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByYXRpbyAobWF4IDEpIHRvIGFwcGx5IHRvIHRoZSBjaXJjdW1mZXJlbmNlIHRvIHNsaWNlIHRoZSBjeWxpbmRlci4gRGVmYXVsdHMgdG8gMzYwLlxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgYXJjOiBudW1iZXIgPSAzNjBcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUuc2hhcGUnLCBDTEFTU19JRC5HTFRGX1NIQVBFKVxuZXhwb3J0IGNsYXNzIEdMVEZTaGFwZSBleHRlbmRzIFNoYXBlIHtcbiAgQFNoYXBlLnJlYWRvbmx5XG4gIHJlYWRvbmx5IHNyYyE6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHNyYzogc3RyaW5nKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuc3JjID0gc3JjXG4gIH1cbn1cblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBlbnVtIFBpY3R1cmVGcmFtZVN0eWxlIHtcbiAgQ2xhc3NpYyA9IDAsXG4gIEJhcm9xdWVfT3JuYW1lbnQgPSAxLFxuICBEaWFtb25kX09ybmFtZW50ID0gMixcbiAgTWluaW1hbF9XaWRlID0gMyxcbiAgTWluaW1hbF9HcmV5ID0gNCxcbiAgQmxvY2t5ID0gNSxcbiAgR29sZF9FZGdlcyA9IDYsXG4gIEdvbGRfQ2FydmVkID0gNyxcbiAgR29sZF9XaWRlID0gOCxcbiAgR29sZF9Sb3VuZGVkID0gOSxcbiAgTWV0YWxfTWVkaXVtID0gMTAsXG4gIE1ldGFsX1dpZGUgPSAxMSxcbiAgTWV0YWxfU2xpbSA9IDEyLFxuICBNZXRhbF9Sb3VuZGVkID0gMTMsXG4gIFBpbnMgPSAxNCxcbiAgTWluaW1hbF9CbGFjayA9IDE1LFxuICBNaW5pbWFsX1doaXRlID0gMTYsXG4gIFRhcGUgPSAxNyxcbiAgV29vZF9TbGltID0gMTgsXG4gIFdvb2RfV2lkZSA9IDE5LFxuICBXb29kX1R3aWdzID0gMjAsXG4gIENhbnZhcyA9IDIxLFxuICBOb25lID0gMjJcbn1cblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIE5GVFNoYXBlQ29uc3RydWN0b3JBcmdzID0ge1xuICBjb2xvcj86IENvbG9yM1xuICBzdHlsZT86IFBpY3R1cmVGcmFtZVN0eWxlXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnNoYXBlJywgQ0xBU1NfSUQuTkZUX1NIQVBFKVxuZXhwb3J0IGNsYXNzIE5GVFNoYXBlIGV4dGVuZHMgU2hhcGUge1xuICBAU2hhcGUucmVhZG9ubHlcbiAgcmVhZG9ubHkgc3JjITogc3RyaW5nXG5cbiAgQFNoYXBlLnJlYWRvbmx5XG4gIHJlYWRvbmx5IHN0eWxlITogUGljdHVyZUZyYW1lU3R5bGVcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBjb2xvcjogQ29sb3IzXG5cbiAgY29uc3RydWN0b3Ioc3JjOiBzdHJpbmcpXG4gIGNvbnN0cnVjdG9yKHNyYzogc3RyaW5nLCBjb2xvcjogQ29sb3IzKSAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgY29uc3RydWN0b3Ioc3JjOiBzdHJpbmcsIGFyZ3M6IE5GVFNoYXBlQ29uc3RydWN0b3JBcmdzKVxuICBjb25zdHJ1Y3RvcihzcmM6IHN0cmluZywgYXJnczogYW55ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zcmMgPSBzcmNcblxuICAgIGxldCBjb2xvciA9IG5ldyBDb2xvcjMoMC42NDA0OTE4LCAwLjYxMTQ3MiwgMC44NTg0OTA2KVxuICAgIGxldCBzdHlsZSA9IFBpY3R1cmVGcmFtZVN0eWxlLkNsYXNzaWNcblxuICAgIC8vIGNoZWNrIGlmIGFyZ3MgaXMgY29sb3IgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgIGlmICgncicgaW4gYXJncykge1xuICAgICAgY29sb3IgPSBhcmdzXG4gICAgfSBlbHNlIGlmIChhcmdzICE9PSBudWxsKSB7XG4gICAgICBpZiAoYXJncy5jb2xvcikgY29sb3IgPSBhcmdzLmNvbG9yXG4gICAgICBpZiAoYXJncy5zdHlsZSkgc3R5bGUgPSBhcmdzLnN0eWxlXG4gICAgfVxuXG4gICAgdGhpcy5jb2xvciA9IGNvbG9yXG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUudGV4dHVyZScsIENMQVNTX0lELlRFWFRVUkUpXG5leHBvcnQgY2xhc3MgVGV4dHVyZSBleHRlbmRzIE9ic2VydmFibGVDb21wb25lbnQge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSBzcmMhOiBzdHJpbmdcblxuICAvKipcbiAgICogRW5hYmxlcyBjcmlzcGVyIGltYWdlcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc2FtcGxpbmcgbW9kZS5cbiAgICogfCBWYWx1ZSB8IFR5cGUgICAgICB8XG4gICAqIHwtLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgKiB8ICAgICAwIHwgTkVBUkVTVCAgIHxcbiAgICogfCAgICAgMSB8IEJJTElORUFSICB8XG4gICAqIHwgICAgIDIgfCBUUklMSU5FQVIgfFxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcmVhZG9ubHkgc2FtcGxpbmdNb2RlITogbnVtYmVyXG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGV4dHVyZSB3cmFwcGluZyBmb3IgdGhpcyBtYXRlcmlhbC5cbiAgICogfCBWYWx1ZSB8IFR5cGUgICAgICB8XG4gICAqIHwtLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgKiB8ICAgICAwIHwgQ0xBTVAgICAgIHxcbiAgICogfCAgICAgMSB8IFdSQVAgICAgICB8XG4gICAqIHwgICAgIDIgfCBNSVJST1IgICAgfFxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcmVhZG9ubHkgd3JhcCE6IG51bWJlclxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGlmIHRoaXMgdGV4dHVyZSBoYXMgYW4gYWxwaGEgY2hhbm5lbFxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcmVhZG9ubHkgaGFzQWxwaGEhOiBib29sZWFuXG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3JjOiBzdHJpbmcsXG4gICAgb3B0cz86IFBhcnRpYWw8UGljazxUZXh0dXJlLCAnc2FtcGxpbmdNb2RlJyB8ICd3cmFwJyB8ICdoYXNBbHBoYSc+PlxuICApIHtcbiAgICBzdXBlcigpXG5cbiAgICBjb25zdCBiYXNlNjRUZXN0ID0gbmV3IFJlZ0V4cCgnZGF0YTpbYS16LV0rL1thLXotXSs7YmFzZTY0JylcbiAgICBpZiAoc3JjLmxlbmd0aCA+IDIwNDggfHwgYmFzZTY0VGVzdC50ZXN0KHNyYykpIHtcbiAgICAgIGxvZyhcbiAgICAgICAgJ+KaoO+4j/CfmqggQmFzZTY0IHRleHR1cmVzIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB2ZXJzaW9uIDcgb2YgZGVjZW50cmFsYW5kLWVjcydcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnNyYyA9IHNyY1xuXG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGZvciAoY29uc3QgaSBpbiBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzIGFzIGFueVxuICAgICAgICB0aGF0W2kgYXMgJ3NhbXBsaW5nTW9kZScgfCAnd3JhcCcgfCAnaGFzQWxwaGEnXSA9IChvcHRzIGFzIGFueSlbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS5hbmltYXRvcicsIENMQVNTX0lELkFOSU1BVElPTilcbmV4cG9ydCBjbGFzcyBBbmltYXRvciBleHRlbmRzIFNoYXBlIHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcHJpdmF0ZSBzdGF0ZXM6IEFuaW1hdGlvblN0YXRlW10gPSBbXVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIEFuaW1hdGlvblN0YXRlIHRvIHRoZSBhbmltYXRpb24gbGlzdHMuXG4gICAqL1xuICBhZGRDbGlwKGNsaXA6IEFuaW1hdGlvblN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZXMucHVzaChjbGlwKVxuICAgIGNsaXAub25DaGFuZ2UoKCkgPT4ge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWVcbiAgICB9KVxuXG4gICAgY2xpcC5vd25lciA9IHRoaXNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGFuaW1hdGlvbiBjbGlwIGluc3RhbmNlIGZvciB0aGUgc3BlY2lmaWVkIGNsaXAgbmFtZS5cbiAgICogSWYgdGhlIGNsaXAgZG9lc24ndCBleGlzdCBhIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgZ2V0Q2xpcChjbGlwTmFtZTogc3RyaW5nKTogQW5pbWF0aW9uU3RhdGUge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNsaXAgPSB0aGlzLnN0YXRlc1tpXVxuICAgICAgaWYgKGNsaXAuY2xpcCA9PT0gY2xpcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNsaXBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXdDbGlwID0gbmV3IEFuaW1hdGlvblN0YXRlKGNsaXBOYW1lKVxuICAgIHRoaXMuYWRkQ2xpcChuZXdDbGlwKVxuICAgIHJldHVybiBuZXdDbGlwXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIGFuZCBwYXVzZXMgdGhlIGFuaW1hdGlvbiBzdGF0ZSwgaWYgdGhlIGNsaXAgaXMgbnVsbCBpdCB3aWxsIHN0b3AgYWxsIGFuaW1hdGlvbnMgb24gdGhpcyBhbmltYXRvclxuICAgKi9cbiAgc3RvcChjbGlwPzogQW5pbWF0aW9uU3RhdGUpIHtcbiAgICBpZiAoY2xpcCkge1xuICAgICAgY2xpcC5wbGF5aW5nID0gZmFsc2VcbiAgICAgIGNsaXAuc2hvdWxkUmVzZXQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uU3RhdGUgPSB0aGlzLnN0YXRlc1tpXVxuICAgICAgICB0aGlzLnN0b3AoYW5pbWF0aW9uU3RhdGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgYW5pbWF0aW9uXG4gICAqL1xuICBwbGF5KGNsaXA6IEFuaW1hdGlvblN0YXRlLCByZXNldDogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYW5pbWF0aW9uU3RhdGUgPSB0aGlzLnN0YXRlc1tpXVxuICAgICAgaWYgKGFuaW1hdGlvblN0YXRlLmxheWVyID09PSBjbGlwLmxheWVyICYmIGNsaXAgIT09IGFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgIHRoaXMucGF1c2UoYW5pbWF0aW9uU3RhdGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc2V0KSBjbGlwLnNob3VsZFJlc2V0ID0gdHJ1ZVxuICAgIGNsaXAucGxheWluZyA9IHRydWVcbiAgICBjbGlwLmRpcnR5ID0gdHJ1ZVxuICAgIGNsaXAuZGF0YS5ub25jZSA9IE1hdGgucmFuZG9tKClcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZXMgdGhlIGFuaW1hdGlvbiBzdGF0ZSwgaWYgdGhlIGNsaXAgaXMgbnVsbCBpdCB3aWxsIHBhdXNlIGFsbCBhbmltYXRpb25zIG9uIHRoaXMgYW5pbWF0b3JcbiAgICovXG4gIHBhdXNlKGNsaXA/OiBBbmltYXRpb25TdGF0ZSkge1xuICAgIGlmIChjbGlwKSB7XG4gICAgICBjbGlwLnBsYXlpbmcgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvblN0YXRlID0gdGhpcy5zdGF0ZXNbaV1cbiAgICAgICAgdGhpcy5wYXVzZShhbmltYXRpb25TdGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUuc2hhcGUnLCBDTEFTU19JRC5PQkpfU0hBUEUpXG5leHBvcnQgY2xhc3MgT0JKU2hhcGUgZXh0ZW5kcyBTaGFwZSB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHNyYyE6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHNyYzogc3RyaW5nKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuc3JjID0gc3JjXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUuZm9udCcsIENMQVNTX0lELkZPTlQpXG5leHBvcnQgY2xhc3MgRm9udCBleHRlbmRzIE9ic2VydmFibGVDb21wb25lbnQge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSBzcmMhOiBzdHJpbmdcblxuICBwdWJsaWMgY29uc3RydWN0b3Ioc3JjOiBzdHJpbmcgPSAnJykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnNyYyA9IHNyY1xuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZW51bSBGb250cyB7XG4gIC8qKiBAZGVwcmVjYXRlZCBTYW5GcmFuY2lzY28gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFNhbnNTZXJpZiBpbnN0ZWFkLiovXG4gIFNhbkZyYW5jaXNjbyA9ICdidWlsdGluOlNGLVVJLVRleHQtUmVndWxhciBTREYnLFxuICAvKiogQGRlcHJlY2F0ZWQgU2FuRnJhbmNpc2NvX0hlYXZ5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBTYW5zU2VyaWZfSGVhdnkgaW5zdGVhZC4qL1xuICBTYW5GcmFuY2lzY29fSGVhdnkgPSAnYnVpbHRpbjpTRi1VSS1UZXh0LUhlYXZ5IFNERicsXG4gIC8qKiBAZGVwcmVjYXRlZCBTYW5GcmFuY2lzY29fU2VtaWJvbGQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFNhbnNTZXJpZl9TZW1pQm9sZCBpbnN0ZWFkLiovXG4gIFNhbkZyYW5jaXNjb19TZW1pYm9sZCA9ICdidWlsdGluOlNGLVVJLVRleHQtU2VtaWJvbGQgU0RGJyxcbiAgTGliZXJhdGlvblNhbnMgPSAnYnVpbHRpbjpMaWJlcmF0aW9uU2FucyBTREYnLFxuICBTYW5zU2VyaWYgPSAnU2Fuc1NlcmlmJyxcbiAgU2Fuc1NlcmlmX0hlYXZ5ID0gJ1NhbnNTZXJpZl9IZWF2eScsXG4gIFNhbnNTZXJpZl9Cb2xkID0gJ1NhbnNTZXJpZl9Cb2xkJyxcbiAgU2Fuc1NlcmlmX1NlbWlCb2xkID0gJ1NhbnNTZXJpZl9TZW1pQm9sZCdcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS50ZXh0JywgQ0xBU1NfSUQuVEVYVF9TSEFQRSlcbmV4cG9ydCBjbGFzcyBUZXh0U2hhcGUgZXh0ZW5kcyBPYnNlcnZhYmxlQ29tcG9uZW50IHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgb3V0bGluZVdpZHRoOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgb3V0bGluZUNvbG9yOiBDb2xvcjMgPSBuZXcgQ29sb3IzKDEsIDEsIDEpXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgY29sb3I6IENvbG9yMyA9IG5ldyBDb2xvcjMoMSwgMSwgMSlcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBmb250U2l6ZTogbnVtYmVyID0gMTBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5jb21wb25lbnRcbiAgZm9udD86IEZvbnRcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBvcGFjaXR5OiBudW1iZXIgPSAxLjBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB2YWx1ZTogc3RyaW5nID0gJydcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBsaW5lU3BhY2luZzogc3RyaW5nID0gJzBweCdcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBsaW5lQ291bnQ6IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB0ZXh0V3JhcHBpbmc6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNoYWRvd0JsdXI6IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzaGFkb3dPZmZzZXRYOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2hhZG93T2Zmc2V0WTogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNoYWRvd0NvbG9yOiBDb2xvcjMgPSBuZXcgQ29sb3IzKDEsIDEsIDEpXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgaFRleHRBbGlnbjogc3RyaW5nID0gJ2NlbnRlcidcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB2VGV4dEFsaWduOiBzdHJpbmcgPSAnY2VudGVyJ1xuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHdpZHRoOiBudW1iZXIgPSAxXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgaGVpZ2h0OiBudW1iZXIgPSAxXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcGFkZGluZ1RvcDogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBhZGRpbmdSaWdodDogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBhZGRpbmdCb3R0b206IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwYWRkaW5nTGVmdDogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGJpbGxib2FyZDogYm9vbGVhbiA9IGZhbHNlXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgdmlzaWJsZTogYm9vbGVhbiA9IHRydWVcblxuICBjb25zdHJ1Y3Rvcih2YWx1ZT86IHN0cmluZykge1xuICAgIHN1cGVyKClcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZW51bSBUcmFuc3BhcmVuY3lNb2RlIHtcbiAgT1BBUVVFID0gMCxcbiAgQUxQSEFfVEVTVCA9IDEsXG4gIEFMUEhBX0JMRU5EID0gMixcbiAgQUxQSEFfVEVTVF9BTkRfQkxFTkQgPSAzLFxuICBBVVRPID0gNFxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQERpc3Bvc2FibGVDb21wb25lbnQoJ2VuZ2luZS5tYXRlcmlhbCcsIENMQVNTX0lELlBCUl9NQVRFUklBTClcbmV4cG9ydCBjbGFzcyBNYXRlcmlhbCBleHRlbmRzIE9ic2VydmFibGVDb21wb25lbnQge1xuICAvKipcbiAgICogQ3V0b2ZmIGxldmVsIGZvciBBTFBIQVRFU1QgbW9kZS4gUmFuZ2UgaXMgYmV0d2VlbiAwIGFuZCAxLlxuICAgKiBEZWZhdWx0cyB0byAwLjVcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGFscGhhVGVzdD86IG51bWJlciA9IDAuNVxuXG4gIC8qKlxuICAgKiBBS0EgRGlmZnVzZSBDb2xvciBpbiBvdGhlciBub21lbmNsYXR1cmUuXG4gICAqIERlZmF1bHRzIHRvICNDQ0NDQ0MuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBhbGJlZG9Db2xvcj86IENvbG9yNCB8IENvbG9yM1xuXG4gIC8qKlxuICAgKiBUaGUgY29sb3IgZW1pdHRlZCBmcm9tIHRoZSBtYXRlcmlhbC5cbiAgICogRGVmYXVsdHMgdG8gYmxhY2suXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBlbWlzc2l2ZUNvbG9yPzogQ29sb3IzXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgbWV0YWxsaWMgc2NhbGFyIG9mIHRoZSBtZXRhbGxpYy9yb3VnaG5lc3Mgd29ya2Zsb3cuXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgdG8gc2NhbGUgdGhlIG1ldGFsbmVzcyB2YWx1ZXMgb2YgdGhlIG1ldGFsbGljIHRleHR1cmUuXG4gICAqIERlZmF1bHRzIHRvICAwLjUuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBtZXRhbGxpYz86IG51bWJlclxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHJvdWdobmVzcyBzY2FsYXIgb2YgdGhlIG1ldGFsbGljL3JvdWdobmVzcyB3b3JrZmxvdy5cbiAgICogQ2FuIGFsc28gYmUgdXNlZCB0byBzY2FsZSB0aGUgcm91Z2huZXNzIHZhbHVlcyBvZiB0aGUgbWV0YWxsaWMgdGV4dHVyZS5cbiAgICogRGVmYXVsdHMgdG8gIDAuNS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHJvdWdobmVzcz86IG51bWJlclxuXG4gIC8qKlxuICAgKiBBS0EgU3BlY3VsYXIgQ29sb3IgaW4gb3RoZXIgbm9tZW5jbGF0dXJlLlxuICAgKiBEZWZhdWx0cyB0byB3aGl0ZS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHJlZmxlY3Rpdml0eUNvbG9yPzogQ29sb3IzXG5cbiAgLyoqXG4gICAqIEludGVuc2l0eSBvZiB0aGUgZGlyZWN0IGxpZ2h0cyBlLmcuIHRoZSBmb3VyIGxpZ2h0cyBhdmFpbGFibGUgaW4gc2NlbmUuXG4gICAqIFRoaXMgaW1wYWN0cyBib3RoIHRoZSBkaXJlY3QgZGlmZnVzZSBhbmQgc3BlY3VsYXIgaGlnaGxpZ2h0cy5cbiAgICogRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGRpcmVjdEludGVuc2l0eT86IG51bWJlclxuXG4gIC8qKlxuICAgKiBBS0EgR2xvc3NpbmVzcyBpbiBvdGhlciBub21lbmNsYXR1cmUuXG4gICAqIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBtaWNyb1N1cmZhY2U/OiBudW1iZXJcblxuICAvKipcbiAgICogSW50ZW5zaXR5IG9mIHRoZSBlbWlzc2l2ZSBwYXJ0IG9mIHRoZSBtYXRlcmlhbC5cbiAgICogVGhpcyBoZWxwcyBjb250cm9sbGluZyB0aGUgZW1pc3NpdmUgZWZmZWN0IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBlbWlzc2l2ZSBjb2xvci5cbiAgICogRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGVtaXNzaXZlSW50ZW5zaXR5PzogbnVtYmVyXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBzcGVjaWFsIGNvbnRyb2wgYWxsb3dpbmcgdGhlIHJlZHVjdGlvbiBvZiB0aGUgc3BlY3VsYXIgaGlnaGxpZ2h0cyBjb21pbmcgZnJvbSB0aGVcbiAgICogZm91ciBsaWdodHMgb2YgdGhlIHNjZW5lLiBUaG9zZSBoaWdobGlnaHRzIG1heSBub3QgYmUgbmVlZGVkIGluIGZ1bGwgZW52aXJvbm1lbnQgbGlnaHRpbmcuXG4gICAqIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzcGVjdWxhckludGVuc2l0eT86IG51bWJlclxuXG4gIC8qKlxuICAgKiBUZXh0dXJlIGFwcGxpZWQgYXMgbWF0ZXJpYWwuXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5jb21wb25lbnRcbiAgYWxiZWRvVGV4dHVyZT86IFRleHR1cmUgfCBWaWRlb1RleHR1cmUgfCBBdmF0YXJUZXh0dXJlXG5cbiAgLyoqXG4gICAqIFRleHR1cmUgYXBwbGllZCBhcyBvcGFjaXR5LiBEZWZhdWx0OiB0aGUgc2FtZSB0ZXh0dXJlIHVzZWQgaW4gYWxiZWRvVGV4dHVyZS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmNvbXBvbmVudFxuICBhbHBoYVRleHR1cmU/OiBUZXh0dXJlIHwgVmlkZW9UZXh0dXJlIHwgQXZhdGFyVGV4dHVyZVxuXG4gIC8qKlxuICAgKiBFbWlzc2l2ZSB0ZXh0dXJlLlxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuY29tcG9uZW50XG4gIGVtaXNzaXZlVGV4dHVyZT86IFRleHR1cmUgfCBWaWRlb1RleHR1cmUgfCBBdmF0YXJUZXh0dXJlXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBzdXJmYWNlIG5vcm1hbCBkYXRhIHVzZWQgdG8gZGlzcGxhY2UgYSBtZXNoIGluIGEgdGV4dHVyZS5cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmNvbXBvbmVudFxuICBidW1wVGV4dHVyZT86IFRleHR1cmUgfCBBdmF0YXJUZXh0dXJlXG5cbiAgLyoqXG4gICAqIEFsbG93IHRoZSBtYXRlcmlhbCB0byBjYXN0IHNoYWRvd3Mgb3ZlciBvdGhlciBvYmplY3RzXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBjYXN0U2hhZG93cz86IGJvb2xlYW4gPSB0cnVlXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRyYW5zcGFyZW5jeSBtb2RlIG9mIHRoZSBtYXRlcmlhbC5cbiAgICogRGVmYXVsdHMgdG8gLTEuXG4gICAqXG4gICAqIHwgVmFsdWUgfCBUeXBlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAtLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICAgKiB8IDAgICAgIHwgT1BBUVVFICAoZGVmYXVsdCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgMSAgICAgfCBBTFBIQVRFU1QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogfCAyICAgICB8IEFMUEhBQkxFTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgKiB8IDMgICAgIHwgQUxQSEFURVNUQU5EQkxFTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIHwgNCAgICAgfCBBVVRPIChBTFBIQUJMRU5EIGlmIGFscGhhIE9QQVFVRSBvdGhlcndpc2UgICAgIHxcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHRyYW5zcGFyZW5jeU1vZGU6IFRyYW5zcGFyZW5jeU1vZGUgPSBUcmFuc3BhcmVuY3lNb2RlLkFVVE9cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUubWF0ZXJpYWwnLCBDTEFTU19JRC5CQVNJQ19NQVRFUklBTClcbmV4cG9ydCBjbGFzcyBCYXNpY01hdGVyaWFsIGV4dGVuZHMgT2JzZXJ2YWJsZUNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBUaGUgc291cmNlIG9mIHRoZSB0ZXh0dXJlIGltYWdlLlxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuY29tcG9uZW50XG4gIHRleHR1cmU/OiBUZXh0dXJlIHwgVmlkZW9UZXh0dXJlIHwgQXZhdGFyVGV4dHVyZVxuXG4gIC8qKlxuICAgKiBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAqIEFueSBwaXhlbCB3aXRoIGFuIGFscGhhIGxvd2VyIHRoYW4gdGhpcyB2YWx1ZSB3aWxsIGJlIHNob3duIGFzIHRyYW5zcGFyZW50LlxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgYWxwaGFUZXN0OiBudW1iZXIgPSAwLjVcblxuICAvKipcbiAgICogQWxsb3cgdGhlIG1hdGVyaWFsIHRvIGNhc3Qgc2hhZG93cyBvdmVyIG90aGVyIG9iamVjdHNcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGNhc3RTaGFkb3dzPzogYm9vbGVhbiA9IHRydWVcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBPblVVSURFdmVudDxUIGV4dGVuZHMga2V5b2YgSUV2ZW50cz4gZXh0ZW5kcyBPYnNlcnZhYmxlQ29tcG9uZW50IHtcbiAgLy8gQGludGVybmFsXG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIC8vIEBpbnRlcm5hbFxuICByZWFkb25seSB1dWlkOiBzdHJpbmcgPSBuZXdJZCgnVVVJRCcpXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgY2FsbGJhY2shOiAoZXZlbnQ6IGFueSkgPT4gdm9pZFxuXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrOiAoZXZlbnQ6IElFdmVudHNbVF0pID0+IHZvaWQpIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoIWNhbGxiYWNrIHx8ICEoJ2FwcGx5JyBpbiBjYWxsYmFjaykgfHwgISgnY2FsbCcgaW4gY2FsbGJhY2spKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxuXG4gIHN0YXRpYyB1dWlkRXZlbnQodGFyZ2V0OiBPYnNlcnZhYmxlQ29tcG9uZW50LCBwcm9wZXJ0eUtleTogc3RyaW5nKSB7XG4gICAgaWYgKGRlbGV0ZSAodGFyZ2V0IGFzIGFueSlbcHJvcGVydHlLZXldKSB7XG4gICAgICBjb25zdCBjb21wb25lbnRTeW1ib2wgPSBwcm9wZXJ0eUtleSArICdfJyArIE1hdGgucmFuZG9tKClcbiAgICAgIDsodGFyZ2V0IGFzIGFueSlbY29tcG9uZW50U3ltYm9sXSA9IHVuZGVmaW5lZFxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnRTeW1ib2wsIHtcbiAgICAgICAgLi4uT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbXBvbmVudFN5bWJvbCksXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleS50b1N0cmluZygpLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzW2NvbXBvbmVudFN5bWJvbF1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXNbY29tcG9uZW50U3ltYm9sXVxuXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPblVVSURFdmVudCkge1xuICAgICAgICAgICAgICB0aGlzLmRhdGFbcHJvcGVydHlLZXldID0gdmFsdWUudXVpZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBpcyBub3QgYW4gT25VVUlERXZlbnQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcHJvcGVydHlLZXldID0gbnVsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXNbY29tcG9uZW50U3ltYm9sXSA9IHZhbHVlXG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaV0ocHJvcGVydHlLZXksIHZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IHV1aWQ6IHRoaXMudXVpZCwgdHlwZTogdGhpcy50eXBlIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE9uUG9pbnRlclVVSURFdmVudDxcbiAgVCBleHRlbmRzIGtleW9mIElFdmVudHNcbj4gZXh0ZW5kcyBPblVVSURFdmVudDxUPiB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGJ1dHRvbjogQWN0aW9uQnV0dG9uID0gQWN0aW9uQnV0dG9uLkFOWVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGhvdmVyVGV4dDogc3RyaW5nID0gJ0ludGVyYWN0J1xuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGRpc3RhbmNlOiBudW1iZXIgPSAxMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNob3dGZWVkYmFjazogYm9vbGVhbiA9IHRydWVcblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHV1aWQ6IHRoaXMudXVpZCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGJ1dHRvbjogdGhpcy5idXR0b24sXG4gICAgICBob3ZlclRleHQ6IHRoaXMuaG92ZXJUZXh0LFxuICAgICAgZGlzdGFuY2U6IHRoaXMuZGlzdGFuY2UsXG4gICAgICBzaG93RmVlZGJhY2s6IHRoaXMuc2hvd0ZlZWRiYWNrXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS5vblBvaW50ZXJMb2NrJywgQ0xBU1NfSUQuVVVJRF9DQUxMQkFDSylcbmV4cG9ydCBjbGFzcyBPblBvaW50ZXJMb2NrIGV4dGVuZHMgT25VVUlERXZlbnQ8J29uUG9pbnRlckxvY2snPiB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZyA9ICdvblBvaW50ZXJMb2NrJ1xufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQENvbXBvbmVudCgnZW5naW5lLm9uQW5pbWF0aW9uRW5kJywgQ0xBU1NfSUQuVVVJRF9DQUxMQkFDSylcbmV4cG9ydCBjbGFzcyBPbkFuaW1hdGlvbkVuZCBleHRlbmRzIE9uVVVJREV2ZW50PCdvbkFuaW1hdGlvbkVuZCc+IHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nID0gJ29uQW5pbWF0aW9uRW5kJ1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5AQ29tcG9uZW50KCdlbmdpbmUuc21hcnRJdGVtJywgQ0xBU1NfSUQuU01BUlRfSVRFTSlcbmV4cG9ydCBjbGFzcyBTbWFydEl0ZW0gZXh0ZW5kcyBPYnNlcnZhYmxlQ29tcG9uZW50IHt9XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLlZpZGVvQ2xpcCcsIENMQVNTX0lELlZJREVPX0NMSVApXG5leHBvcnQgY2xhc3MgVmlkZW9DbGlwIGV4dGVuZHMgT2JzZXJ2YWJsZUNvbXBvbmVudCB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHVybDogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy51cmwgPSB1cmxcbiAgfVxufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGVudW0gVmlkZW9TdGF0dXMge1xuICBOT05FID0gMCxcbiAgRVJST1IgPSAxLFxuICBMT0FESU5HID0gMixcbiAgUkVBRFkgPSAzLFxuICBQTEFZSU5HID0gNCxcbiAgQlVGRkVSSU5HID0gNVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQERpc3Bvc2FibGVDb21wb25lbnQoJ2VuZ2luZS5WaWRlb1RleHR1cmUnLCBDTEFTU19JRC5WSURFT19URVhUVVJFKVxuZXhwb3J0IGNsYXNzIFZpZGVvVGV4dHVyZSBleHRlbmRzIE9ic2VydmFibGVDb21wb25lbnQge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSB2aWRlb0NsaXBJZDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgY3Jpc3BlciBpbWFnZXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHNhbXBsaW5nIG1vZGUuXG4gICAqIHwgVmFsdWUgfCBUeXBlICAgICAgfFxuICAgKiB8LS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCAgICAgMSB8IE5FQVJFU1QgICB8XG4gICAqIHwgICAgIDIgfCBCSUxJTkVBUiAgfFxuICAgKiB8ICAgICAzIHwgVFJJTElORUFSIHxcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHNhbXBsaW5nTW9kZSE6IG51bWJlclxuXG4gIC8qKlxuICAgKiBFbmFibGVzIHRleHR1cmUgd3JhcHBpbmcgZm9yIHRoaXMgbWF0ZXJpYWwuXG4gICAqIHwgVmFsdWUgfCBUeXBlICAgICAgfFxuICAgKiB8LS0tLS0tLXwtLS0tLS0tLS0tLXxcbiAgICogfCAgICAgMSB8IENMQU1QICAgICB8XG4gICAqIHwgICAgIDIgfCBXUkFQICAgICAgfFxuICAgKiB8ICAgICAzIHwgTUlSUk9SICAgIHxcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHdyYXAhOiBudW1iZXJcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB2b2x1bWU6IG51bWJlciA9IDFcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwbGF5YmFja1JhdGU6IG51bWJlciA9IDFcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBsb29wOiBib29sZWFuID0gZmFsc2VcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzZWVrOiBudW1iZXIgPSAtMVxuXG4gIHByaXZhdGUgX3Bvc2l0aW9uOiBudW1iZXIgPSAtMVxuICBwcml2YXRlIF92aWRlb0xlbmd0aDogbnVtYmVyID0gLTFcbiAgcHJpdmF0ZSBfc3RhdHVzOiBWaWRlb1N0YXR1cyA9IFZpZGVvU3RhdHVzLk5PTkVcblxuICAvKipcbiAgICogSXMgdGhpcyBWaWRlb1RleHR1cmUgcGxheWluZz9cbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBsYXlpbmc6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHZpZGVvQ2xpcDogVmlkZW9DbGlwLFxuICAgIG9wdHM/OiBQYXJ0aWFsPFBpY2s8VmlkZW9UZXh0dXJlLCAnc2FtcGxpbmdNb2RlJyB8ICd3cmFwJz4+XG4gICkge1xuICAgIHN1cGVyKClcblxuICAgIGlmICghKHZpZGVvQ2xpcCBpbnN0YW5jZW9mIFZpZGVvQ2xpcCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRyeWluZyB0byBjcmVhdGUgVmlkZW9UZXh0dXJlKFZpZGVvQ2xpcCkgd2l0aCBhbiBpbnZhbGlkIFZpZGVvQ2xpcGBcbiAgICAgIClcbiAgICB9XG4gICAgdGhpcy52aWRlb0NsaXBJZCA9IGdldENvbXBvbmVudElkKHZpZGVvQ2xpcCBhcyBhbnkpXG5cbiAgICBpZiAob3B0cykge1xuICAgICAgZm9yIChjb25zdCBpIGluIG9wdHMpIHtcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXMgYXMgYW55XG4gICAgICAgIHRoYXRbaSBhcyAnc2FtcGxpbmdNb2RlJyB8ICd3cmFwJ10gPSAob3B0cyBhcyBhbnkpW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGxheSgpIHtcbiAgICB0aGlzLnBsYXlpbmcgPSB0cnVlXG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZVxuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zZWVrVGltZSgwKVxuICAgIHRoaXMucGF1c2UoKVxuICB9XG5cbiAgc2Vla1RpbWUoc2Vjb25kczogbnVtYmVyKSB7XG4gICAgdGhpcy5zZWVrID0gc2Vjb25kc1xuICAgIHRoaXMuZGlydHkgPSB0cnVlXG4gICAgdGhpcy5kYXRhLm5vbmNlID0gTWF0aC5yYW5kb20oKVxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGlmICh0aGlzLnNlZWsgPj0gMCkge1xuICAgICAgLy8gdGhlIHNlZWsgdmFsdWUgd2FzIGNoYW5nZWQvdXNlZFxuICAgICAgY29uc3QgcmV0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdXBlci50b0pTT04oKSkpXG4gICAgICB0aGlzLnNlZWsgPSAtMVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci50b0pTT04oKVxuICB9XG5cbiAgdXBkYXRlKHZpZGVvRXZlbnQ6IElFdmVudHNbJ3ZpZGVvRXZlbnQnXSkge1xuICAgIGlmICh2aWRlb0V2ZW50LnZpZGVvQ2xpcElkID09PSB0aGlzLnZpZGVvQ2xpcElkKSB7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAodmlkZW9FdmVudC52aWRlb1N0YXR1cyBhcyBWaWRlb1N0YXR1cykgfHwgVmlkZW9TdGF0dXMuTk9ORVxuICAgICAgdGhpcy5fdmlkZW9MZW5ndGggPSB2aWRlb0V2ZW50LnRvdGFsVmlkZW9MZW5ndGhcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmlkZW9FdmVudC5jdXJyZW50T2Zmc2V0XG4gICAgfVxuICB9XG5cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblxuICB9XG5cbiAgZ2V0IHZpZGVvTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl92aWRlb0xlbmd0aFxuICB9XG5cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS5jYW1lcmFNb2RlQXJlYScsIENMQVNTX0lELkNBTUVSQV9NT0RFX0FSRUEpXG5leHBvcnQgY2xhc3MgQ2FtZXJhTW9kZUFyZWEgZXh0ZW5kcyBPYnNlcnZhYmxlQ29tcG9uZW50IHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgYXJlYSE6IEFyZWFcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBjYW1lcmFNb2RlITogQ2FtZXJhTW9kZVxuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IHsgYXJlYTogQXJlYTsgY2FtZXJhTW9kZTogQ2FtZXJhTW9kZSB9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuYXJlYSA9IGFyZ3MuYXJlYVxuICAgIHRoaXMuY2FtZXJhTW9kZSA9IGFyZ3MuY2FtZXJhTW9kZVxuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnRleHR1cmUnLCBDTEFTU19JRC5BVkFUQVJfVEVYVFVSRSlcbmV4cG9ydCBjbGFzcyBBdmF0YXJUZXh0dXJlIGV4dGVuZHMgT2JzZXJ2YWJsZUNvbXBvbmVudCB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHVzZXJJZCE6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBFbmFibGVzIGNyaXNwZXIgaW1hZ2VzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBzYW1wbGluZyBtb2RlLlxuICAgKiB8IFZhbHVlIHwgVHlwZSAgICAgIHxcbiAgICogfC0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAqIHwgICAgIDAgfCBORUFSRVNUICAgfFxuICAgKiB8ICAgICAxIHwgQklMSU5FQVIgIHxcbiAgICogfCAgICAgMiB8IFRSSUxJTkVBUiB8XG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSBzYW1wbGluZ01vZGUhOiBudW1iZXJcblxuICAvKipcbiAgICogRW5hYmxlcyB0ZXh0dXJlIHdyYXBwaW5nIGZvciB0aGlzIG1hdGVyaWFsLlxuICAgKiB8IFZhbHVlIHwgVHlwZSAgICAgIHxcbiAgICogfC0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAqIHwgICAgIDAgfCBDTEFNUCAgICAgfFxuICAgKiB8ICAgICAxIHwgV1JBUCAgICAgIHxcbiAgICogfCAgICAgMiB8IE1JUlJPUiAgICB8XG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSB3cmFwITogbnVtYmVyXG5cbiAgLyoqXG4gICAqIERlZmluZXMgaWYgdGhpcyB0ZXh0dXJlIGhhcyBhbiBhbHBoYSBjaGFubmVsXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSBoYXNBbHBoYSE6IGJvb2xlYW5cblxuICBjb25zdHJ1Y3RvcihcbiAgICB1c2VySWQ6IHN0cmluZyxcbiAgICBvcHRzPzogUGFydGlhbDxQaWNrPEF2YXRhclRleHR1cmUsICdzYW1wbGluZ01vZGUnIHwgJ3dyYXAnIHwgJ2hhc0FscGhhJz4+XG4gICkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMudXNlcklkID0gdXNlcklkXG5cbiAgICBpZiAob3B0cykge1xuICAgICAgZm9yIChjb25zdCBpIGluIG9wdHMpIHtcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXMgYXMgYW55XG4gICAgICAgIHRoYXRbaSBhcyAnc2FtcGxpbmdNb2RlJyB8ICd3cmFwJyB8ICdoYXNBbHBoYSddID0gKG9wdHMgYXMgYW55KVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgVmVjdG9yMywgUXVhdGVybmlvbiB9IGZyb20gJ0BkY2wvZWNzLW1hdGgnXG5cbmltcG9ydCB7IENhbWVyYU1vZGUgfSBmcm9tICcuL1R5cGVzJ1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIENhbWVyYSB7XG4gIC8vIEBpbnRlcm5hbFxuICBwcml2YXRlIHN0YXRpYyBfaW5zdGFuY2U6IENhbWVyYVxuXG4gIHN0YXRpYyBnZXQgaW5zdGFuY2UoKTogQ2FtZXJhIHtcbiAgICBpZiAoIUNhbWVyYS5faW5zdGFuY2UpIHtcbiAgICAgIENhbWVyYS5faW5zdGFuY2UgPSBuZXcgQ2FtZXJhKClcbiAgICB9XG4gICAgcmV0dXJuIENhbWVyYS5faW5zdGFuY2VcbiAgfVxuXG4gIC8qKiBDYW1lcmEgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSBwYXJjZWwuICovXG4gIHB1YmxpYyByZWFkb25seSBwb3NpdGlvbjogVmVjdG9yMyA9IG5ldyBWZWN0b3IzKClcbiAgLyoqIENhbWVyYSByb3RhdGlvbiAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcm90YXRpb246IFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpXG5cbiAgLyoqIEZlZXQgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSBwYXJjZWwuICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZmVldFBvc2l0aW9uOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoKVxuICAvKiogQ2FtZXJhIHBvc2l0aW9uLCBhYnNvbHV0ZS4gKi9cbiAgcHVibGljIHJlYWRvbmx5IHdvcmxkUG9zaXRpb246IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpXG5cbiAgLyoqIFBsYXllciBoZWlnaHQuICovXG4gIGdldCBwbGF5ZXJIZWlnaHQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcGxheWVySGVpZ2h0XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgVXNlIG9uQ2FtZXJhTW9kZUNoYW5nZWRPYnNlcnZhYmxlIE9ic2VydmFibGUgaW5zdGVhZC4gKi9cbiAgZ2V0IGNhbWVyYU1vZGUoKTogQ2FtZXJhTW9kZSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbWVyYU1vZGVcbiAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICBwcml2YXRlIGxhc3RFdmVudFBvc2l0aW9uOiBSZWFkT25seVZlY3RvcjMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfVxuICAvLyBAaW50ZXJuYWxcbiAgcHJpdmF0ZSBsYXN0RXZlbnRXb3JsZFBvc2l0aW9uOiBSZWFkT25seVZlY3RvcjMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICBwcml2YXRlIGxhc3RFdmVudFJvdGF0aW9uOiBSZWFkT25seVF1YXRlcm5pb24gPSB7IHg6IDAsIHk6IDAsIHo6IDAsIHc6IDEuMCB9XG5cbiAgLy8gQGludGVybmFsXG4gIHByaXZhdGUgX3BsYXllckhlaWdodDogbnVtYmVyID0gMS42XG4gIC8vIEBpbnRlcm5hbFxuICBwcml2YXRlIF9jYW1lcmFNb2RlOiBDYW1lcmFNb2RlID0gQ2FtZXJhTW9kZS5UaGlyZFBlcnNvblxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0eXBlb2YgZGNsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGNsLnN1YnNjcmliZSgncG9zaXRpb25DaGFuZ2VkJylcbiAgICAgIGRjbC5zdWJzY3JpYmUoJ3JvdGF0aW9uQ2hhbmdlZCcpXG4gICAgICBkY2wuc3Vic2NyaWJlKCdjYW1lcmFNb2RlQ2hhbmdlZCcpXG5cbiAgICAgIGRjbC5vbkV2ZW50KChldmVudCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdwb3NpdGlvbkNoYW5nZWQnOlxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZWQoZXZlbnQuZGF0YSBhcyBhbnkpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3JvdGF0aW9uQ2hhbmdlZCc6XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uQ2hhbmdlZChldmVudC5kYXRhIGFzIGFueSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnY2FtZXJhTW9kZUNoYW5nZWQnOlxuICAgICAgICAgICAgdGhpcy5jYW1lcmFNb2RlQ2hhbmdlZChldmVudC5kYXRhIGFzIGFueSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucG9zaXRpb24sICd4Jywge1xuICAgICAgZ2V0OiAoKSA9PiB0aGlzLmxhc3RFdmVudFBvc2l0aW9uLnhcbiAgICB9KVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucG9zaXRpb24sICd5Jywge1xuICAgICAgZ2V0OiAoKSA9PiB0aGlzLmxhc3RFdmVudFBvc2l0aW9uLnlcbiAgICB9KVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucG9zaXRpb24sICd6Jywge1xuICAgICAgZ2V0OiAoKSA9PiB0aGlzLmxhc3RFdmVudFBvc2l0aW9uLnpcbiAgICB9KVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMud29ybGRQb3NpdGlvbiwgJ3gnLCB7XG4gICAgICBnZXQ6ICgpID0+IHRoaXMubGFzdEV2ZW50V29ybGRQb3NpdGlvbi54XG4gICAgfSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLndvcmxkUG9zaXRpb24sICd5Jywge1xuICAgICAgZ2V0OiAoKSA9PiB0aGlzLmxhc3RFdmVudFdvcmxkUG9zaXRpb24ueVxuICAgIH0pXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy53b3JsZFBvc2l0aW9uLCAneicsIHtcbiAgICAgIGdldDogKCkgPT4gdGhpcy5sYXN0RXZlbnRXb3JsZFBvc2l0aW9uLnpcbiAgICB9KVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZmVldFBvc2l0aW9uLCAneCcsIHtcbiAgICAgIGdldDogKCkgPT4gdGhpcy5sYXN0RXZlbnRQb3NpdGlvbi54XG4gICAgfSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmZlZXRQb3NpdGlvbiwgJ3knLCB7XG4gICAgICBnZXQ6ICgpID0+IHRoaXMubGFzdEV2ZW50UG9zaXRpb24ueSAtIHRoaXMucGxheWVySGVpZ2h0XG4gICAgfSlcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmZlZXRQb3NpdGlvbiwgJ3onLCB7XG4gICAgICBnZXQ6ICgpID0+IHRoaXMubGFzdEV2ZW50UG9zaXRpb24uelxuICAgIH0pXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yb3RhdGlvbiwgJ3gnLCB7XG4gICAgICBnZXQ6ICgpID0+IHRoaXMubGFzdEV2ZW50Um90YXRpb24ueFxuICAgIH0pXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yb3RhdGlvbiwgJ3knLCB7XG4gICAgICBnZXQ6ICgpID0+IHRoaXMubGFzdEV2ZW50Um90YXRpb24ueVxuICAgIH0pXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yb3RhdGlvbiwgJ3onLCB7XG4gICAgICBnZXQ6ICgpID0+IHRoaXMubGFzdEV2ZW50Um90YXRpb24uelxuICAgIH0pXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yb3RhdGlvbiwgJ3cnLCB7XG4gICAgICBnZXQ6ICgpID0+IHRoaXMubGFzdEV2ZW50Um90YXRpb24ud1xuICAgIH0pXG4gIH1cblxuICAvLyBAaW50ZXJuYWxcbiAgcHJpdmF0ZSBwb3NpdGlvbkNoYW5nZWQoZTogSUV2ZW50c1sncG9zaXRpb25DaGFuZ2VkJ10pIHtcbiAgICB0aGlzLmxhc3RFdmVudFBvc2l0aW9uID0gZS5wb3NpdGlvblxuICAgIHRoaXMubGFzdEV2ZW50V29ybGRQb3NpdGlvbiA9IGUuY2FtZXJhUG9zaXRpb25cbiAgICB0aGlzLl9wbGF5ZXJIZWlnaHQgPSBlLnBsYXllckhlaWdodFxuICB9XG5cbiAgLy8gQGludGVybmFsXG4gIHByaXZhdGUgcm90YXRpb25DaGFuZ2VkKGU6IElFdmVudHNbJ3JvdGF0aW9uQ2hhbmdlZCddKSB7XG4gICAgdGhpcy5sYXN0RXZlbnRSb3RhdGlvbiA9IGUucXVhdGVybmlvblxuICB9XG5cbiAgLy8gQGludGVybmFsXG4gIHByaXZhdGUgY2FtZXJhTW9kZUNoYW5nZWQoZTogSUV2ZW50c1snY2FtZXJhTW9kZUNoYW5nZWQnXSkge1xuICAgIHRoaXMuX2NhbWVyYU1vZGUgPSBlLmNhbWVyYU1vZGVcbiAgfVxufVxuIiwiaW1wb3J0IHsgVmVjdG9yMywgTWF0cml4IH0gZnJvbSAnQGRjbC9lY3MtbWF0aCdcblxuaW1wb3J0IHsgUmF5Y2FzdFJlc3BvbnNlIH0gZnJvbSAnLi9FdmVudHMnXG5pbXBvcnQgeyB1dWlkLCBsb2cgfSBmcm9tICcuLi9lY3MvaGVscGVycydcblxuaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSAnLi9DYW1lcmEnXG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBRdWVyeVR5cGUgPVxuICB8ICdIaXRGaXJzdCdcbiAgfCAnSGl0QWxsJ1xuICB8ICdIaXRGaXJzdEF2YXRhcidcbiAgfCAnSGl0QWxsQXZhdGFycydcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZW51bSBRdWVyeVByZWZpeCB7XG4gIEhpdEZpcnN0ID0gJ3JxaGYnLFxuICBIaXRBbGwgPSAncnFoYSdcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSYXljYXN0UXVlcnkge1xuICBxdWVyeUlkOiBzdHJpbmdcbiAgcXVlcnlUeXBlOiBRdWVyeVR5cGVcbiAgcmF5OiBSYXlcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmF5Y2FzdEhpdCB7XG4gIGRpZEhpdDogYm9vbGVhblxuICByYXk6IFJheVxuICBoaXRQb2ludDogUmVhZE9ubHlWZWN0b3IzXG4gIGhpdE5vcm1hbDogUmVhZE9ubHlWZWN0b3IzXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJheSB7XG4gIG9yaWdpbjogUmVhZE9ubHlWZWN0b3IzXG4gIGRpcmVjdGlvbjogUmVhZE9ubHlWZWN0b3IzXG4gIGRpc3RhbmNlOiBudW1iZXJcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGl0RW50aXR5SW5mbyB7XG4gIGlzVmFsaWQ6IGJvb2xlYW5cbiAgZW50aXR5SWQ6IHN0cmluZ1xuICBtZXNoTmFtZTogc3RyaW5nXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJheWNhc3RIaXRFbnRpdHkgZXh0ZW5kcyBSYXljYXN0SGl0IHtcbiAgZW50aXR5OiBIaXRFbnRpdHlJbmZvXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJheWNhc3RIaXRFbnRpdGllcyBleHRlbmRzIFJheWNhc3RIaXQge1xuICBlbnRpdGllczogUmF5Y2FzdEhpdEVudGl0eVtdXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEJhc2ljQXZhdGFySW5mbyB7XG4gIHVzZXJJZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSYXljYXN0SGl0QXZhdGFyIGV4dGVuZHMgUmF5Y2FzdEhpdCB7XG4gIGF2YXRhcjogQmFzaWNBdmF0YXJJbmZvXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJheWNhc3RIaXRBdmF0YXJzIGV4dGVuZHMgUmF5Y2FzdEhpdCB7XG4gIGF2YXRhcnM6IEJhc2ljQXZhdGFySW5mb1tdXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgaW50ZXJmYWNlIElQaHlzaWNzQ2FzdCB7XG4gIGhpdEZpcnN0KFxuICAgIHJheTogUmF5LFxuICAgIGhpdENhbGxiYWNrOiAoZXZlbnQ6IFJheWNhc3RIaXRFbnRpdHkpID0+IHZvaWQsXG4gICAgaWQ/OiBudW1iZXJcbiAgKTogdm9pZFxuICBoaXRBbGwoXG4gICAgcmF5OiBSYXksXG4gICAgaGl0Q2FsbGJhY2s6IChldmVudDogUmF5Y2FzdEhpdEVudGl0aWVzKSA9PiB2b2lkLFxuICAgIGlkPzogbnVtYmVyXG4gICk6IHZvaWRcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBoaXRGaXJzdEF2YXRhcihyYXk6IFJheSwgaGl0Q2FsbGJhY2s6IChldmVudDogUmF5Y2FzdEhpdEF2YXRhcikgPT4gdm9pZCk6IHZvaWRcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBoaXRBbGxBdmF0YXJzKHJheTogUmF5LCBoaXRDYWxsYmFjazogKGV2ZW50OiBSYXljYXN0SGl0QXZhdGFycykgPT4gdm9pZCk6IHZvaWRcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBQaHlzaWNzQ2FzdCBpbXBsZW1lbnRzIElQaHlzaWNzQ2FzdCB7XG4gIHByaXZhdGUgc3RhdGljIF9pbnN0YW5jZTogUGh5c2ljc0Nhc3RcbiAgcHJpdmF0ZSBxdWVyaWVzOiBSZWNvcmQ8c3RyaW5nLCAoZXZlbnQ6IFJheWNhc3RIaXQpID0+IHZvaWQ+ID0ge31cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cblxuICBwdWJsaWMgc3RhdGljIGdldCBpbnN0YW5jZSgpOiBQaHlzaWNzQ2FzdCB7XG4gICAgUGh5c2ljc0Nhc3QuZW5zdXJlSW5zdGFuY2UoKVxuICAgIHJldHVybiBQaHlzaWNzQ2FzdC5faW5zdGFuY2VcbiAgfVxuXG4gIHN0YXRpYyBlbnN1cmVJbnN0YW5jZSgpOiBhbnkge1xuICAgIGlmICghUGh5c2ljc0Nhc3QuX2luc3RhbmNlKSB7XG4gICAgICBQaHlzaWNzQ2FzdC5faW5zdGFuY2UgPSBuZXcgUGh5c2ljc0Nhc3QoKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRSYXlGcm9tQ2FtZXJhKGRpc3RhbmNlOiBudW1iZXIpIHtcbiAgICBjb25zdCByb3RhdGlvbiA9IENhbWVyYS5pbnN0YW5jZS5yb3RhdGlvblxuICAgIGNvbnN0IHJvdGF0aW9uTWF0OiBNYXRyaXggPSBNYXRyaXguSWRlbnRpdHkoKVxuICAgIHJvdGF0aW9uLnRvUm90YXRpb25NYXRyaXgocm90YXRpb25NYXQpXG4gICAgY29uc3QgZGlyZWN0aW9uID0gVmVjdG9yMy5UcmFuc2Zvcm1Db29yZGluYXRlcyhcbiAgICAgIFZlY3RvcjMuRm9yd2FyZCgpLFxuICAgICAgcm90YXRpb25NYXRcbiAgICApXG5cbiAgICBjb25zdCByYXk6IFJheSA9IHtcbiAgICAgIG9yaWdpbjogQ2FtZXJhLmluc3RhbmNlLnBvc2l0aW9uLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2VcbiAgICB9XG5cbiAgICByZXR1cm4gcmF5XG4gIH1cblxuICBwdWJsaWMgZ2V0UmF5RnJvbVBvc2l0aW9ucyhmcm9tOiBWZWN0b3IzLCB0bzogVmVjdG9yMykge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRvLnN1YnRyYWN0KGZyb20pXG4gICAgY29uc3QgbGVuZ3RoID0gZGlyZWN0aW9uLmxlbmd0aCgpXG5cbiAgICBjb25zdCByYXk6IFJheSA9IHtcbiAgICAgIG9yaWdpbjogZnJvbSxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLm5vcm1hbGl6ZSgpLFxuICAgICAgZGlzdGFuY2U6IGxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiByYXlcbiAgfVxuXG4gIHB1YmxpYyBoaXRGaXJzdChcbiAgICByYXk6IFJheSxcbiAgICBoaXRDYWxsYmFjazogKGV2ZW50OiBSYXljYXN0SGl0RW50aXR5KSA9PiB2b2lkLFxuICAgIGlkPzogbnVtYmVyXG4gICkge1xuICAgIGNvbnN0IHF1ZXJ5SWQgPSB0eXBlb2YgaWQgPT09ICdudW1iZXInID8gUXVlcnlQcmVmaXguSGl0Rmlyc3QgKyBpZCA6IHV1aWQoKVxuXG4gICAgdGhpcy5xdWVyaWVzW3F1ZXJ5SWRdID0gaGl0Q2FsbGJhY2sgYXMgKGV2ZW50OiBSYXljYXN0SGl0KSA9PiB2b2lkXG5cbiAgICBpZiAodHlwZW9mIGRjbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRjbC5xdWVyeSgncmF5Y2FzdCcsIHsgcXVlcnlJZCwgcXVlcnlUeXBlOiAnSGl0Rmlyc3QnLCByYXkgfSlcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaGl0QWxsKFxuICAgIHJheTogUmF5LFxuICAgIGhpdENhbGxiYWNrOiAoZXZlbnQ6IFJheWNhc3RIaXRFbnRpdGllcykgPT4gdm9pZCxcbiAgICBpZD86IG51bWJlclxuICApIHtcbiAgICBjb25zdCBxdWVyeUlkID0gdHlwZW9mIGlkID09PSAnbnVtYmVyJyA/IFF1ZXJ5UHJlZml4LkhpdEFsbCArIGlkIDogdXVpZCgpXG5cbiAgICB0aGlzLnF1ZXJpZXNbcXVlcnlJZF0gPSBoaXRDYWxsYmFjayBhcyAoZXZlbnQ6IFJheWNhc3RIaXQpID0+IHZvaWRcblxuICAgIGlmICh0eXBlb2YgZGNsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGNsLnF1ZXJ5KCdyYXljYXN0JywgeyBxdWVyeUlkLCBxdWVyeVR5cGU6ICdIaXRBbGwnLCByYXkgfSlcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaGl0Rmlyc3RBdmF0YXIoXG4gICAgX3JheTogUmF5LFxuICAgIF9oaXRDYWxsYmFjazogKGV2ZW50OiBSYXljYXN0SGl0QXZhdGFyKSA9PiB2b2lkXG4gICkge1xuICAgIGxvZygnbm90IGltcGxlbWVudGVkIHlldCcpXG4gIH1cblxuICBwdWJsaWMgaGl0QWxsQXZhdGFycyhcbiAgICBfcmF5OiBSYXksXG4gICAgX2hpdENhbGxiYWNrOiAoZXZlbnQ6IFJheWNhc3RIaXRBdmF0YXJzKSA9PiB2b2lkXG4gICkge1xuICAgIGxvZygnbm90IGltcGxlbWVudGVkIHlldCcpXG4gIH1cblxuICBwdWJsaWMgaGFuZGxlUmF5Y2FzdEhpdEZpcnN0UmVzcG9uc2UoXG4gICAgcmVzcG9uc2U6IFJheWNhc3RSZXNwb25zZTxSYXljYXN0SGl0RW50aXR5PlxuICApIHtcbiAgICB0aGlzLnF1ZXJpZXNbcmVzcG9uc2UucGF5bG9hZC5xdWVyeUlkXShyZXNwb25zZS5wYXlsb2FkLnBheWxvYWQpXG4gICAgZGVsZXRlIHRoaXMucXVlcmllc1tyZXNwb25zZS5wYXlsb2FkLnF1ZXJ5SWRdXG4gIH1cblxuICBwdWJsaWMgaGFuZGxlUmF5Y2FzdEhpdEFsbFJlc3BvbnNlKFxuICAgIHJlc3BvbnNlOiBSYXljYXN0UmVzcG9uc2U8UmF5Y2FzdEhpdEVudGl0aWVzPlxuICApIHtcbiAgICB0aGlzLnF1ZXJpZXNbcmVzcG9uc2UucGF5bG9hZC5xdWVyeUlkXShyZXNwb25zZS5wYXlsb2FkLnBheWxvYWQpXG4gICAgZGVsZXRlIHRoaXMucXVlcmllc1tyZXNwb25zZS5wYXlsb2FkLnF1ZXJ5SWRdXG4gIH1cbn1cbiIsImltcG9ydCB7IEVuZ2luZSB9IGZyb20gJy4uL2Vjcy9FbmdpbmUnXG5pbXBvcnQgeyBVVUlERXZlbnQsIFBvaW50ZXJFdmVudCwgUmF5Y2FzdFJlc3BvbnNlIH0gZnJvbSAnLi9FdmVudHMnXG5pbXBvcnQgeyBPblVVSURFdmVudCB9IGZyb20gJy4vQ29tcG9uZW50cydcbmltcG9ydCB7XG4gIElTeXN0ZW0sXG4gIENvbXBvbmVudEFkZGVkLFxuICBDb21wb25lbnRSZW1vdmVkLFxuICBJRW50aXR5XG59IGZyb20gJy4uL2Vjcy9JRW50aXR5J1xuaW1wb3J0IHsgSW5wdXQgfSBmcm9tICcuL0lucHV0J1xuaW1wb3J0IHtcbiAgUGh5c2ljc0Nhc3QsXG4gIFJheWNhc3RIaXRFbnRpdHksXG4gIFJheWNhc3RIaXRFbnRpdGllc1xufSBmcm9tICcuL1BoeXNpY3NDYXN0J1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFJheWNhc3RFdmVudFN5c3RlbSBpbXBsZW1lbnRzIElTeXN0ZW0ge1xuICBhY3RpdmF0ZShlbmdpbmU6IEVuZ2luZSkge1xuICAgIGVuZ2luZS5ldmVudE1hbmFnZXIuYWRkTGlzdGVuZXIoUmF5Y2FzdFJlc3BvbnNlLCB0aGlzLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5wYXlsb2FkLnF1ZXJ5VHlwZSA9PT0gJ0hpdEZpcnN0Jykge1xuICAgICAgICBQaHlzaWNzQ2FzdC5pbnN0YW5jZS5oYW5kbGVSYXljYXN0SGl0Rmlyc3RSZXNwb25zZShcbiAgICAgICAgICBldmVudCBhcyBSYXljYXN0UmVzcG9uc2U8UmF5Y2FzdEhpdEVudGl0eT5cbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmIChldmVudC5wYXlsb2FkLnF1ZXJ5VHlwZSA9PT0gJ0hpdEFsbCcpIHtcbiAgICAgICAgUGh5c2ljc0Nhc3QuaW5zdGFuY2UuaGFuZGxlUmF5Y2FzdEhpdEFsbFJlc3BvbnNlKFxuICAgICAgICAgIGV2ZW50IGFzIFJheWNhc3RSZXNwb25zZTxSYXljYXN0SGl0RW50aXRpZXM+XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkY2wuc3Vic2NyaWJlKCdyYXljYXN0UmVzcG9uc2UnKVxuICAgIH1cbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkY2wudW5zdWJzY3JpYmUoJ3JheWNhc3RSZXNwb25zZScpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY2xhc3MgUG9pbnRlckV2ZW50U3lzdGVtIGltcGxlbWVudHMgSVN5c3RlbSB7XG4gIGFjdGl2YXRlKGVuZ2luZTogRW5naW5lKSB7XG4gICAgZW5naW5lLmV2ZW50TWFuYWdlci5hZGRMaXN0ZW5lcihQb2ludGVyRXZlbnQsIHRoaXMsIChldmVudCkgPT4ge1xuICAgICAgSW5wdXQuaW5zdGFuY2UuaGFuZGxlUG9pbnRlckV2ZW50KGV2ZW50LnBheWxvYWQgYXMgR2xvYmFsSW5wdXRFdmVudFJlc3VsdClcbiAgICB9KVxuXG4gICAgaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkY2wuc3Vic2NyaWJlKCdwb2ludGVyVXAnKVxuICAgICAgZGNsLnN1YnNjcmliZSgncG9pbnRlckRvd24nKVxuICAgICAgZGNsLnN1YnNjcmliZSgnYWN0aW9uQnV0dG9uRXZlbnQnKVxuICAgIH1cbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkY2wudW5zdWJzY3JpYmUoJ3BvaW50ZXJVcCcpXG4gICAgICBkY2wudW5zdWJzY3JpYmUoJ3BvaW50ZXJEb3duJylcbiAgICAgIGRjbC51bnN1YnNjcmliZSgnYWN0aW9uQnV0dG9uRXZlbnQnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFVVSURFdmVudFN5c3RlbSBpbXBsZW1lbnRzIElTeXN0ZW0ge1xuICBoYW5kbGVyTWFwOiB7IFt1dWlkOiBzdHJpbmddOiBPblVVSURFdmVudDxhbnk+IH0gPSB7fVxuXG4gIGFjdGl2YXRlKGVuZ2luZTogRW5naW5lKSB7XG4gICAgZW5naW5lLmV2ZW50TWFuYWdlci5hZGRMaXN0ZW5lcihVVUlERXZlbnQsIHRoaXMsIHRoaXMuaGFuZGxlRXZlbnQpXG4gICAgZW5naW5lLmV2ZW50TWFuYWdlci5hZGRMaXN0ZW5lcihDb21wb25lbnRBZGRlZCwgdGhpcywgdGhpcy5jb21wb25lbnRBZGRlZClcbiAgICBlbmdpbmUuZXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgQ29tcG9uZW50UmVtb3ZlZCxcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLmNvbXBvbmVudFJlbW92ZWRcbiAgICApXG5cbiAgICBpZiAodHlwZW9mIGRjbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRjbC5zdWJzY3JpYmUoJ3V1aWRFdmVudCcpXG4gICAgfVxuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICBpZiAodHlwZW9mIGRjbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRjbC51bnN1YnNjcmliZSgndXVpZEV2ZW50JylcbiAgICB9XG4gIH1cblxuICBvbkFkZEVudGl0eShlbnRpdHk6IElFbnRpdHkpIHtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudE5hbWUgaW4gZW50aXR5LmNvbXBvbmVudHMpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGVudGl0eS5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdXG5cbiAgICAgIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBPblVVSURFdmVudCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJNYXBbY29tcG9uZW50LnV1aWRdID0gY29tcG9uZW50XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25SZW1vdmVFbnRpdHkoZW50aXR5OiBJRW50aXR5KSB7XG4gICAgZm9yIChjb25zdCBjb21wb25lbnROYW1lIGluIGVudGl0eS5jb21wb25lbnRzKSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBlbnRpdHkuY29tcG9uZW50c1tjb21wb25lbnROYW1lXVxuXG4gICAgICBpZiAoY29tcG9uZW50IGluc3RhbmNlb2YgT25VVUlERXZlbnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGFuZGxlck1hcFtjb21wb25lbnQudXVpZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbXBvbmVudEFkZGVkKGV2ZW50OiBDb21wb25lbnRBZGRlZCkge1xuICAgIGlmIChldmVudC5lbnRpdHkuaXNBZGRlZFRvRW5naW5lKCkpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGV2ZW50LmVudGl0eS5jb21wb25lbnRzW2V2ZW50LmNvbXBvbmVudE5hbWVdXG5cbiAgICAgIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBPblVVSURFdmVudCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJNYXBbY29tcG9uZW50LnV1aWRdID0gY29tcG9uZW50XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb21wb25lbnRSZW1vdmVkKGV2ZW50OiBDb21wb25lbnRSZW1vdmVkKSB7XG4gICAgaWYgKGV2ZW50LmVudGl0eS5pc0FkZGVkVG9FbmdpbmUoKSkge1xuICAgICAgaWYgKGV2ZW50LmNvbXBvbmVudCBpbnN0YW5jZW9mIE9uVVVJREV2ZW50KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmhhbmRsZXJNYXBbZXZlbnQuY29tcG9uZW50LnV1aWRdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFdmVudChldmVudDogVVVJREV2ZW50KTogdm9pZCB7XG4gICAgaWYgKGV2ZW50LnV1aWQgaW4gdGhpcy5oYW5kbGVyTWFwKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVyTWFwW2V2ZW50LnV1aWRdXG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBpZiAoaGFuZGxlci5jYWxsYmFjayAmJiAnY2FsbCcgaW4gaGFuZGxlci5jYWxsYmFjaykge1xuICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2soZXZlbnQucGF5bG9hZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgcmF5Y2FzdEV2ZW50U3lzdGVtID0gbmV3IFJheWNhc3RFdmVudFN5c3RlbSgpXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwb2ludGVyRXZlbnRTeXN0ZW0gPSBuZXcgUG9pbnRlckV2ZW50U3lzdGVtKClcblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHV1aWRFdmVudFN5c3RlbSA9IG5ldyBVVUlERXZlbnRTeXN0ZW0oKVxuIiwiaW1wb3J0IHtcbiAgRGlzcG9zYWJsZUNvbXBvbmVudCxcbiAgT2JzZXJ2YWJsZUNvbXBvbmVudCxcbiAgQ29tcG9uZW50LFxuICBnZXRDb21wb25lbnRJZFxufSBmcm9tICcuLi9lY3MvQ29tcG9uZW50J1xuaW1wb3J0IHsgQ0xBU1NfSUQgfSBmcm9tICcuL0NvbXBvbmVudHMnXG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLkF1ZGlvQ2xpcCcsIENMQVNTX0lELkFVRElPX0NMSVApXG5leHBvcnQgY2xhc3MgQXVkaW9DbGlwIGV4dGVuZHMgT2JzZXJ2YWJsZUNvbXBvbmVudCB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHVybDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIElzIHRoaXMgY2xpcCBsb29waW5nIGJ5IGRlZmF1bHQ/XG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBsb29wOiBib29sZWFuID0gZmFsc2VcblxuICAvLyBAaW50ZXJuYWxcbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgbG9hZGluZ0NvbXBsZXRlRXZlbnRJZD86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBDbGlwJ3MgbWFzdGVyIHZvbHVtZS4gVGhpcyB2b2x1bWUgYWZmZWN0cyBhbGwgdGhlIEF1ZGlvU291cmNlcy5cbiAgICogVmFsaWQgcmFuZ2VzIGZyb20gMCB0byAxXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB2b2x1bWU6IG51bWJlciA9IDFcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnVybCA9IHVybFxuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5AQ29tcG9uZW50KCdlbmdpbmUuQXVkaW9Tb3VyY2UnLCBDTEFTU19JRC5BVURJT19TT1VSQ0UpXG5leHBvcnQgY2xhc3MgQXVkaW9Tb3VyY2UgZXh0ZW5kcyBPYnNlcnZhYmxlQ29tcG9uZW50IHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcmVhZG9ubHkgYXVkaW9DbGlwSWQ6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBJcyB0aGlzIGNsaXAgbG9vcGluZyBieSBkZWZhdWx0P1xuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgbG9vcDogYm9vbGVhbiA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIENsaXAncyBtYXN0ZXIgdm9sdW1lLiBUaGlzIHZvbHVtZSBhZmZlY3RzIGFsbCB0aGUgQXVkaW9Tb3VyY2VzLlxuICAgKiBWYWxpZCByYW5nZXMgZnJvbSAwIHRvIDFcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHZvbHVtZTogbnVtYmVyID0gMVxuXG4gIC8qKlxuICAgKiBJcyB0aGlzIEF1ZGlvU291cmNlIHBsYXlpbmc/XG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwbGF5aW5nOiBib29sZWFuID0gZmFsc2VcblxuICAvKipcbiAgICogUGl0Y2gsIGRlZmF1bHQ6IDEuMCwgcmFuZ2UgZnJvbSAwLjAgdG8gTWF4RmxvYXRcbiAgICovXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBpdGNoOiBudW1iZXIgPSAxLjBcblxuICAvKipcbiAgICogVGltZXN0YW1wIG9mIHdoZW4gdGhlIHBsYXlPbmNlIHdhcyBleGVjdXRlZCB0byBzZWUgaWYgd2UgbmVlZCB0byBzdGFydCBvdmVyIHRoZSBhdWRpb1xuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcGxheWVkQXRUaW1lc3RhbXA6IG51bWJlciA9IERhdGUubm93KClcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYXVkaW9DbGlwOiBBdWRpb0NsaXApIHtcbiAgICBzdXBlcigpXG4gICAgaWYgKCEoYXVkaW9DbGlwIGluc3RhbmNlb2YgQXVkaW9DbGlwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVHJ5aW5nIHRvIGNyZWF0ZSBBdWRpb1NvdXJjZShBdWRpb0NsaXApIHdpdGggYW4gaW52YWxpZCBBdWRpb0NsaXBgXG4gICAgICApXG4gICAgfVxuICAgIHRoaXMuYXVkaW9DbGlwSWQgPSBnZXRDb21wb25lbnRJZChhdWRpb0NsaXAgYXMgYW55KVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBsb29waW5nIGFuZCBwbGF5cyB0aGUgY3VycmVudCBzb3VyY2Ugb25jZS5cbiAgICogSWYgdGhlIHNvdW5kIHdhcyBwbGF5aW5nLCBpdCBzdG9wcyBhbmQgc3RhcnRzIG92ZXIuXG4gICAqL1xuICBwbGF5T25jZSgpIHtcbiAgICB0aGlzLnBsYXlpbmcgPSB0cnVlXG4gICAgdGhpcy5kaXJ0eSA9IHRydWVcbiAgICB0aGlzLnBsYXllZEF0VGltZXN0YW1wID0gRGF0ZS5ub3coKVxuICAgIHRoaXMuZGF0YS5ub25jZSA9IE1hdGgucmFuZG9tKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5AQ29tcG9uZW50KCdlbmdpbmUuQXVkaW9TdHJlYW0nLCBDTEFTU19JRC5BVURJT19TVFJFQU0pXG5leHBvcnQgY2xhc3MgQXVkaW9TdHJlYW0gZXh0ZW5kcyBPYnNlcnZhYmxlQ29tcG9uZW50IHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcmVhZG9ubHkgdXJsOiBzdHJpbmdcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwbGF5aW5nOiBib29sZWFuID0gZmFsc2VcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB2b2x1bWU6IG51bWJlciA9IDFcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMucGxheWluZyA9IHRydWVcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPYnNlcnZhYmxlQ29tcG9uZW50IH0gZnJvbSAnLi4vZWNzL0NvbXBvbmVudCdcbmltcG9ydCB7IENMQVNTX0lELCBPblVVSURFdmVudCB9IGZyb20gJy4vQ29tcG9uZW50cydcblxuLyoqXG4gKiBHaXptbyBpZGVudGlmaWVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZW51bSBHaXptbyB7XG4gIE1PVkUgPSAnTU9WRScsXG4gIFJPVEFURSA9ICdST1RBVEUnLFxuICBTQ0FMRSA9ICdTQ0FMRScsXG4gIE5PTkUgPSAnTk9ORSdcbn1cblxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIHRyaWdnZXJlZCBhZnRlciB0aGUgdXNlciBmaW5hbGl6ZXMgZHJhZ2dpbmcgYSBnaXptby5cbiAqIEBwdWJsaWNcbiAqL1xuQENvbXBvbmVudCgnZW5naW5lLmdpem1vRXZlbnQnLCBDTEFTU19JRC5VVUlEX0NBTExCQUNLKVxuZXhwb3J0IGNsYXNzIE9uR2l6bW9FdmVudCBleHRlbmRzIE9uVVVJREV2ZW50PCdnaXptb0V2ZW50Jz4ge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSB0eXBlOiBzdHJpbmcgPSAnZ2l6bW9FdmVudCdcbn1cblxuLyoqXG4gKiBFbmFibGVzIGdpem1vcyBpbiB0aGUgZW50aXR5LiBHaXptb3Mgb25seSB3b3JrIGluIEVESVRPUiwgUFJFVklFVyBvciBERUJVRyBtb2Rlcy5cbiAqIEBwdWJsaWNcbiAqL1xuQENvbXBvbmVudCgnZW5naW5lLmdpem1vcycsIENMQVNTX0lELkdJWk1PUylcbmV4cG9ydCBjbGFzcyBHaXptb3MgZXh0ZW5kcyBPYnNlcnZhYmxlQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEVuYWJsZSBwb3NpdGlvbiBnaXptb1xuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcG9zaXRpb246IGJvb2xlYW4gPSB0cnVlXG5cbiAgLyoqXG4gICAqIEVuYWJsZSByb3RhdGlvbiBnaXptb1xuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcm90YXRpb246IGJvb2xlYW4gPSB0cnVlXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBzY2FsZSBnaXptb1xuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2NhbGU6IGJvb2xlYW4gPSB0cnVlXG5cbiAgLyoqXG4gICAqIEN5Y2xlIHRocm91Z2ggZ2l6bW9zIHVzaW5nIGNsaWNrLlxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgY3ljbGU6IGJvb2xlYW4gPSB0cnVlXG5cbiAgLyoqXG4gICAqIElmIGN5Y2xlIGlzIGZhbHNlLCB0aGlzIHdpbGwgYmUgdGhlIHNlbGVjdGVkIGdpem1vXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzZWxlY3RlZEdpem1vPzogR2l6bW9cblxuICAvKipcbiAgICogQWxpZ24gdGhlIGdpem1vcyB0byBtYXRjaCB0aGUgbG9jYWwgcmVmZXJlbmNlIHN5c3RlbVxuICAgKi9cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgbG9jYWxSZWZlcmVuY2U6IGJvb2xlYW4gPSBmYWxzZVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPYnNlcnZhYmxlQ29tcG9uZW50IH0gZnJvbSAnLi4vZWNzL0NvbXBvbmVudCdcbmltcG9ydCB7IHV1aWRFdmVudFN5c3RlbSB9IGZyb20gJy4vU3lzdGVtcydcbmltcG9ydCB7IENMQVNTX0lELCBPblVVSURFdmVudCwgT25Qb2ludGVyVVVJREV2ZW50IH0gZnJvbSAnLi9Db21wb25lbnRzJ1xuaW1wb3J0IHsgQWN0aW9uQnV0dG9uIH0gZnJvbSAnLi9JbnB1dCdcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS5vbkZvY3VzJywgQ0xBU1NfSUQuVVVJRF9DQUxMQkFDSylcbmV4cG9ydCBjbGFzcyBPbkZvY3VzIGV4dGVuZHMgT25VVUlERXZlbnQ8J29uRm9jdXMnPiB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZyA9ICdvbkZvY3VzJ1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjazogKGV2ZW50OiBJRXZlbnRzWydvbkZvY3VzJ10pID0+IHZvaWQpIHtcbiAgICBzdXBlcihjYWxsYmFjaylcbiAgICAvLyBUaGlzIGluamVjdGlvbiBpcyBuZWNlc3NhcnkgT05MWSBpbiBldmVudHMgdGhhdCBhcmUgQUxXQVlTIHR1cm5lZCBvbiBhbmQgYXJlXG4gICAgLy8gbm90IGFzc2lnbmFibGUgdG8gZW50aXRpZXMuIExpa2UgZXZlbnRzIGZvciB0aGUgVUkgZWxlbWVudHNcblxuICAgIC8vIFRPRE8oQnJpYW4pOiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCB3aGVuIFVJIGdldHMgYmFjayB0byB0aGUgZW50aXR5IHBhcmVudGluZy5cbiAgICB1dWlkRXZlbnRTeXN0ZW0uaGFuZGxlck1hcFt0aGlzLnV1aWRdID0gdGhpc1xuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5AQ29tcG9uZW50KCdlbmdpbmUub25UZXh0U3VibWl0JywgQ0xBU1NfSUQuVVVJRF9DQUxMQkFDSylcbmV4cG9ydCBjbGFzcyBPblRleHRTdWJtaXQgZXh0ZW5kcyBPblVVSURFdmVudDwnb25UZXh0U3VibWl0Jz4ge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSB0eXBlOiBzdHJpbmcgPSAnb25UZXh0U3VibWl0J1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjazogKGV2ZW50OiBJRXZlbnRzWydvblRleHRTdWJtaXQnXSkgPT4gdm9pZCkge1xuICAgIHN1cGVyKGNhbGxiYWNrKVxuICAgIC8vIFRoaXMgaW5qZWN0aW9uIGlzIG5lY2Vzc2FyeSBPTkxZIGluIGV2ZW50cyB0aGF0IGFyZSBBTFdBWVMgdHVybmVkIG9uIGFuZCBhcmVcbiAgICAvLyBub3QgYXNzaWduYWJsZSB0byBlbnRpdGllcy4gTGlrZSBldmVudHMgZm9yIHRoZSBVSSBlbGVtZW50c1xuXG4gICAgLy8gVE9ETyhCcmlhbik6IFRoaXMgd2lsbCBiZSByZW1vdmVkIHdoZW4gVUkgZ2V0cyBiYWNrIHRvIHRoZSBlbnRpdHkgcGFyZW50aW5nLlxuICAgIHV1aWRFdmVudFN5c3RlbS5oYW5kbGVyTWFwW3RoaXMudXVpZF0gPSB0aGlzXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS5vbkJsdXInLCBDTEFTU19JRC5VVUlEX0NBTExCQUNLKVxuZXhwb3J0IGNsYXNzIE9uQmx1ciBleHRlbmRzIE9uVVVJREV2ZW50PCdvbkJsdXInPiB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZyA9ICdvbkJsdXInXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrOiAoZXZlbnQ6IElFdmVudHNbJ29uQmx1ciddKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoY2FsbGJhY2spXG4gICAgLy8gVGhpcyBpbmplY3Rpb24gaXMgbmVjZXNzYXJ5IE9OTFkgaW4gZXZlbnRzIHRoYXQgYXJlIEFMV0FZUyB0dXJuZWQgb24gYW5kIGFyZVxuICAgIC8vIG5vdCBhc3NpZ25hYmxlIHRvIGVudGl0aWVzLiBMaWtlIGV2ZW50cyBmb3IgdGhlIFVJIGVsZW1lbnRzXG5cbiAgICAvLyBUT0RPKEJyaWFuKTogVGhpcyB3aWxsIGJlIHJlbW92ZWQgd2hlbiBVSSBnZXRzIGJhY2sgdG8gdGhlIGVudGl0eSBwYXJlbnRpbmcuXG4gICAgdXVpZEV2ZW50U3lzdGVtLmhhbmRsZXJNYXBbdGhpcy51dWlkXSA9IHRoaXNcbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQENvbXBvbmVudCgnZW5naW5lLm9uRW50ZXInLCBDTEFTU19JRC5VVUlEX0NBTExCQUNLKVxuZXhwb3J0IGNsYXNzIE9uRW50ZXIgZXh0ZW5kcyBPblVVSURFdmVudDwnb25FbnRlcic+IHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nID0gJ29uRW50ZXInXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrOiAoZXZlbnQ6IElFdmVudHNbJ29uRW50ZXInXSkgPT4gdm9pZCkge1xuICAgIHN1cGVyKGNhbGxiYWNrKVxuICAgIC8vIFRoaXMgaW5qZWN0aW9uIGlzIG5lY2Vzc2FyeSBPTkxZIGluIGV2ZW50cyB0aGF0IGFyZSBBTFdBWVMgdHVybmVkIG9uIGFuZCBhcmVcbiAgICAvLyBub3QgYXNzaWduYWJsZSB0byBlbnRpdGllcy4gTGlrZSBldmVudHMgZm9yIHRoZSBVSSBlbGVtZW50c1xuXG4gICAgLy8gVE9ETyhCcmlhbik6IFRoaXMgd2lsbCBiZSByZW1vdmVkIHdoZW4gVUkgZ2V0cyBiYWNrIHRvIHRoZSBlbnRpdHkgcGFyZW50aW5nLlxuICAgIHV1aWRFdmVudFN5c3RlbS5oYW5kbGVyTWFwW3RoaXMudXVpZF0gPSB0aGlzXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS5vbkNoYW5nZScsIENMQVNTX0lELlVVSURfQ0FMTEJBQ0spXG5leHBvcnQgY2xhc3MgT25DaGFuZ2VkIGV4dGVuZHMgT25VVUlERXZlbnQ8J29uQ2hhbmdlJz4ge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSB0eXBlOiBzdHJpbmcgPSAnb25DaGFuZ2UnXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrOiAoZXZlbnQ6IElFdmVudHNbJ29uQ2hhbmdlJ10pID0+IHZvaWQpIHtcbiAgICBzdXBlcihjYWxsYmFjaylcbiAgICAvLyBUaGlzIGluamVjdGlvbiBpcyBuZWNlc3NhcnkgT05MWSBpbiBldmVudHMgdGhhdCBhcmUgQUxXQVlTIHR1cm5lZCBvbiBhbmQgYXJlXG4gICAgLy8gbm90IGFzc2lnbmFibGUgdG8gZW50aXRpZXMuIExpa2UgZXZlbnRzIGZvciB0aGUgVUkgZWxlbWVudHNcblxuICAgIC8vIFRPRE8oQnJpYW4pOiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCB3aGVuIFVJIGdldHMgYmFjayB0byB0aGUgZW50aXR5IHBhcmVudGluZy5cbiAgICB1dWlkRXZlbnRTeXN0ZW0uaGFuZGxlck1hcFt0aGlzLnV1aWRdID0gdGhpc1xuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBPblBvaW50ZXJVVUlERXZlbnRPcHRpb25zID0ge1xuICBidXR0b24/OiBBY3Rpb25CdXR0b25cbiAgaG92ZXJUZXh0Pzogc3RyaW5nXG4gIHNob3dGZWVkYmFjaz86IGJvb2xlYW5cbiAgZGlzdGFuY2U/OiBudW1iZXJcbn1cblxuLyoqXG4gKiBAcHVibGljIEBkZXByZWNhdGVkIHVzZSBgT25Qb2ludGVyRG93bmAgaW5zdGVhZFxuICovXG5AQ29tcG9uZW50KCdlbmdpbmUub25DbGljaycsIENMQVNTX0lELlVVSURfQ0FMTEJBQ0spXG5leHBvcnQgY2xhc3MgT25DbGljayBleHRlbmRzIE9uUG9pbnRlclVVSURFdmVudDwnb25DbGljayc+IHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nID0gJ29uQ2xpY2snXG5cbiAgY29uc3RydWN0b3IoY2FsbGJhY2s6IChldmVudDogSUV2ZW50c1snb25DbGljayddKSA9PiB2b2lkKVxuICBjb25zdHJ1Y3RvcihcbiAgICBjYWxsYmFjazogKGV2ZW50OiBJRXZlbnRzWydvbkNsaWNrJ10pID0+IHZvaWQsXG4gICAgb3B0aW9uczogT25Qb2ludGVyVVVJREV2ZW50T3B0aW9uc1xuICApXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrOiAoZXZlbnQ6IElFdmVudHNbJ29uQ2xpY2snXSkgPT4gdm9pZCwgb3B0aW9ucz86IGFueSkge1xuICAgIHN1cGVyKGNhbGxiYWNrKVxuICAgIC8vIFRoaXMgaW5qZWN0aW9uIGlzIG5lY2Vzc2FyeSBPTkxZIGluIGV2ZW50cyB0aGF0IGFyZSBBTFdBWVMgdHVybmVkIG9uIGFuZCBhcmVcbiAgICAvLyBub3QgYXNzaWduYWJsZSB0byBlbnRpdGllcy4gTGlrZSBldmVudHMgZm9yIHRoZSBVSSBlbGVtZW50c1xuXG4gICAgLy8gVE9ETyhCcmlhbik6IFRoaXMgd2lsbCBiZSByZW1vdmVkIHdoZW4gVUkgZ2V0cyBiYWNrIHRvIHRoZSBlbnRpdHkgcGFyZW50aW5nLlxuICAgIHV1aWRFdmVudFN5c3RlbS5oYW5kbGVyTWFwW3RoaXMudXVpZF0gPSB0aGlzXG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zaG93RmVlZGJhY2sgPSAhKG9wdGlvbnMuc2hvd0ZlZWRiYWNrID09PSBmYWxzZSlcblxuICAgICAgaWYgKG9wdGlvbnMuYnV0dG9uKSB7XG4gICAgICAgIHRoaXMuYnV0dG9uID0gb3B0aW9ucy5idXR0b25cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaG92ZXJUZXh0KSB7XG4gICAgICAgIHRoaXMuaG92ZXJUZXh0ID0gb3B0aW9ucy5ob3ZlclRleHRcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS5wb2ludGVyRG93bicsIENMQVNTX0lELlVVSURfQ0FMTEJBQ0spXG5leHBvcnQgY2xhc3MgT25Qb2ludGVyRG93biBleHRlbmRzIE9uUG9pbnRlclVVSURFdmVudDwncG9pbnRlckRvd24nPiB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnJlYWRvbmx5XG4gIHJlYWRvbmx5IHR5cGU6IHN0cmluZyA9ICdwb2ludGVyRG93bidcblxuICBjb25zdHJ1Y3RvcihjYWxsYmFjazogKGV2ZW50OiBJRXZlbnRzWydwb2ludGVyRG93biddKSA9PiB2b2lkKVxuICBjb25zdHJ1Y3RvcihcbiAgICBjYWxsYmFjazogKGV2ZW50OiBJRXZlbnRzWydwb2ludGVyRG93biddKSA9PiB2b2lkLFxuICAgIG9wdGlvbnM6IE9uUG9pbnRlclVVSURFdmVudE9wdGlvbnNcbiAgKVxuICBjb25zdHJ1Y3RvcihcbiAgICBjYWxsYmFjazogKGV2ZW50OiBJRXZlbnRzWydwb2ludGVyRG93biddKSA9PiB2b2lkLFxuICAgIG9wdGlvbnM/OiBhbnlcbiAgKSB7XG4gICAgc3VwZXIoY2FsbGJhY2spXG4gICAgLy8gVGhpcyBpbmplY3Rpb24gaXMgbmVjZXNzYXJ5IE9OTFkgaW4gZXZlbnRzIHRoYXQgYXJlIEFMV0FZUyB0dXJuZWQgb24gYW5kIGFyZVxuICAgIC8vIG5vdCBhc3NpZ25hYmxlIHRvIGVudGl0aWVzLiBMaWtlIGV2ZW50cyBmb3IgdGhlIFVJIGVsZW1lbnRzXG5cbiAgICAvLyBUT0RPKEJyaWFuKTogVGhpcyB3aWxsIGJlIHJlbW92ZWQgd2hlbiBVSSBnZXRzIGJhY2sgdG8gdGhlIGVudGl0eSBwYXJlbnRpbmcuXG4gICAgdXVpZEV2ZW50U3lzdGVtLmhhbmRsZXJNYXBbdGhpcy51dWlkXSA9IHRoaXNcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNob3dGZWVkYmFjayA9ICEob3B0aW9ucy5zaG93RmVlZGJhY2sgPT09IGZhbHNlKVxuXG4gICAgICBpZiAob3B0aW9ucy5idXR0b24pIHtcbiAgICAgICAgdGhpcy5idXR0b24gPSBvcHRpb25zLmJ1dHRvblxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5ob3ZlclRleHQpIHtcbiAgICAgICAgdGhpcy5ob3ZlclRleHQgPSBvcHRpb25zLmhvdmVyVGV4dFxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kaXN0YW5jZSkge1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQENvbXBvbmVudCgnZW5naW5lLnBvaW50ZXJVcCcsIENMQVNTX0lELlVVSURfQ0FMTEJBQ0spXG5leHBvcnQgY2xhc3MgT25Qb2ludGVyVXAgZXh0ZW5kcyBPblBvaW50ZXJVVUlERXZlbnQ8J3BvaW50ZXJVcCc+IHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQucmVhZG9ubHlcbiAgcmVhZG9ubHkgdHlwZTogc3RyaW5nID0gJ3BvaW50ZXJVcCdcblxuICBjb25zdHJ1Y3RvcihjYWxsYmFjazogKGV2ZW50OiBJRXZlbnRzWydwb2ludGVyVXAnXSkgPT4gdm9pZClcbiAgY29uc3RydWN0b3IoXG4gICAgY2FsbGJhY2s6IChldmVudDogSUV2ZW50c1sncG9pbnRlclVwJ10pID0+IHZvaWQsXG4gICAgb3B0aW9uczogT25Qb2ludGVyVVVJREV2ZW50T3B0aW9uc1xuICApXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrOiAoZXZlbnQ6IElFdmVudHNbJ3BvaW50ZXJVcCddKSA9PiB2b2lkLCBvcHRpb25zPzogYW55KSB7XG4gICAgc3VwZXIoY2FsbGJhY2spXG4gICAgLy8gVGhpcyBpbmplY3Rpb24gaXMgbmVjZXNzYXJ5IE9OTFkgaW4gZXZlbnRzIHRoYXQgYXJlIEFMV0FZUyB0dXJuZWQgb24gYW5kIGFyZVxuICAgIC8vIG5vdCBhc3NpZ25hYmxlIHRvIGVudGl0aWVzLiBMaWtlIGV2ZW50cyBmb3IgdGhlIFVJIGVsZW1lbnRzXG5cbiAgICAvLyBUT0RPKEJyaWFuKTogVGhpcyB3aWxsIGJlIHJlbW92ZWQgd2hlbiBVSSBnZXRzIGJhY2sgdG8gdGhlIGVudGl0eSBwYXJlbnRpbmcuXG4gICAgdXVpZEV2ZW50U3lzdGVtLmhhbmRsZXJNYXBbdGhpcy51dWlkXSA9IHRoaXNcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNob3dGZWVkYmFjayA9ICEob3B0aW9ucy5zaG93RmVlZGJhY2sgPT09IGZhbHNlKVxuXG4gICAgICBpZiAob3B0aW9ucy5idXR0b24pIHtcbiAgICAgICAgdGhpcy5idXR0b24gPSBvcHRpb25zLmJ1dHRvblxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5ob3ZlclRleHQpIHtcbiAgICAgICAgdGhpcy5ob3ZlclRleHQgPSBvcHRpb25zLmhvdmVyVGV4dFxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kaXN0YW5jZSkge1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgT25Qb2ludGVySG92ZXJFbnRlclVVSURFdmVudE9wdGlvbnMgPSB7XG4gIGRpc3RhbmNlPzogbnVtYmVyXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5AQ29tcG9uZW50KCdlbmdpbmUucG9pbnRlckhvdmVyRW50ZXInLCBDTEFTU19JRC5VVUlEX0NBTExCQUNLKVxuZXhwb3J0IGNsYXNzIE9uUG9pbnRlckhvdmVyRW50ZXIgZXh0ZW5kcyBPblBvaW50ZXJVVUlERXZlbnQ8J3BvaW50ZXJIb3ZlckVudGVyJz4ge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSB0eXBlOiBzdHJpbmcgPSAncG9pbnRlckhvdmVyRW50ZXInXG5cbiAgY29uc3RydWN0b3IoY2FsbGJhY2s6IChldmVudDogSUV2ZW50c1sncG9pbnRlckhvdmVyRW50ZXInXSkgPT4gdm9pZClcbiAgY29uc3RydWN0b3IoXG4gICAgY2FsbGJhY2s6IChldmVudDogSUV2ZW50c1sncG9pbnRlckhvdmVyRW50ZXInXSkgPT4gdm9pZCxcbiAgICBvcHRpb25zOiBPblBvaW50ZXJIb3ZlckVudGVyVVVJREV2ZW50T3B0aW9uc1xuICApXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNhbGxiYWNrOiAoZXZlbnQ6IElFdmVudHNbJ3BvaW50ZXJIb3ZlckVudGVyJ10pID0+IHZvaWQsXG4gICAgb3B0aW9ucz86IGFueVxuICApIHtcbiAgICBzdXBlcihjYWxsYmFjaylcbiAgICAvLyBUaGlzIGluamVjdGlvbiBpcyBuZWNlc3NhcnkgT05MWSBpbiBldmVudHMgdGhhdCBhcmUgQUxXQVlTIHR1cm5lZCBvbiBhbmQgYXJlXG4gICAgLy8gbm90IGFzc2lnbmFibGUgdG8gZW50aXRpZXMuIExpa2UgZXZlbnRzIGZvciB0aGUgVUkgZWxlbWVudHNcblxuICAgIC8vIFRPRE8oQnJpYW4pOiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCB3aGVuIFVJIGdldHMgYmFjayB0byB0aGUgZW50aXR5IHBhcmVudGluZy5cbiAgICB1dWlkRXZlbnRTeXN0ZW0uaGFuZGxlck1hcFt0aGlzLnV1aWRdID0gdGhpc1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5AQ29tcG9uZW50KCdlbmdpbmUucG9pbnRlckhvdmVyRXhpdCcsIENMQVNTX0lELlVVSURfQ0FMTEJBQ0spXG5leHBvcnQgY2xhc3MgT25Qb2ludGVySG92ZXJFeGl0IGV4dGVuZHMgT25Qb2ludGVyVVVJREV2ZW50PCdwb2ludGVySG92ZXJFeGl0Jz4ge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5yZWFkb25seVxuICByZWFkb25seSB0eXBlOiBzdHJpbmcgPSAncG9pbnRlckhvdmVyRXhpdCdcblxuICBjb25zdHJ1Y3RvcihjYWxsYmFjazogKGV2ZW50OiBJRXZlbnRzWydwb2ludGVySG92ZXJFeGl0J10pID0+IHZvaWQpIHtcbiAgICBzdXBlcihjYWxsYmFjaylcbiAgICAvLyBUaGlzIGluamVjdGlvbiBpcyBuZWNlc3NhcnkgT05MWSBpbiBldmVudHMgdGhhdCBhcmUgQUxXQVlTIHR1cm5lZCBvbiBhbmQgYXJlXG4gICAgLy8gbm90IGFzc2lnbmFibGUgdG8gZW50aXRpZXMuIExpa2UgZXZlbnRzIGZvciB0aGUgVUkgZWxlbWVudHNcblxuICAgIC8vIFRPRE8oQnJpYW4pOiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCB3aGVuIFVJIGdldHMgYmFjayB0byB0aGUgZW50aXR5IHBhcmVudGluZy5cbiAgICB1dWlkRXZlbnRTeXN0ZW0uaGFuZGxlck1hcFt0aGlzLnV1aWRdID0gdGhpc1xuXG4gICAgLy8gQ2hhbmdlZCBkZWZhdWx0IGRpc3RhbmNlIHZhbHVlIGZvciB0aGlzIGNvbXBvbmVudCBiZWNhdXNlIGluIG1vc3QgY2FzZXMgd2UgcHJvYmFibHlcbiAgICAvLyBkb24ndCB3YW50IGZvciB0aGUgaG92ZXIgZXhpdCBldmVudCB0byBiZSBsaW1pdGVkIGJ5IGEgZGlzdGFuY2UsIGFuZCBpdCBkZWZhdWx0IHZhbHVlIHdhcyB0b28gc21hbGwuXG4gICAgdGhpcy5kaXN0YW5jZSA9IDE2MFxuICB9XG59XG4iLCJpbXBvcnQgeyBDb2xvcjQgfSBmcm9tICdAZGNsL2Vjcy1tYXRoJ1xuaW1wb3J0IHtcbiAgT2JzZXJ2YWJsZUNvbXBvbmVudCxcbiAgRGlzcG9zYWJsZUNvbXBvbmVudCxcbiAgZ2V0Q29tcG9uZW50SWRcbn0gZnJvbSAnLi4vZWNzL0NvbXBvbmVudCdcbmltcG9ydCB7XG4gIENMQVNTX0lELFxuICBPblVVSURFdmVudCxcbiAgVGV4dHVyZSxcbiAgQXZhdGFyVGV4dHVyZSxcbiAgRm9udFxufSBmcm9tICcuL0NvbXBvbmVudHMnXG5pbXBvcnQgeyBPblRleHRTdWJtaXQsIE9uQmx1ciwgT25DaGFuZ2VkLCBPbkNsaWNrLCBPbkZvY3VzIH0gZnJvbSAnLi9VSUV2ZW50cydcbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVUlTaGFwZSBleHRlbmRzIE9ic2VydmFibGVDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmaW5lcyBpZiB0aGUgZW50aXR5IGFuZCBpdHMgY2hpbGRyZW4gc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAqL1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBuYW1lOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHZpc2libGU6IGJvb2xlYW4gPSB0cnVlXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgb3BhY2l0eTogbnVtYmVyID0gMVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGhBbGlnbjogc3RyaW5nID0gJ2NlbnRlcidcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB2QWxpZ246IHN0cmluZyA9ICdjZW50ZXInXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQudWlWYWx1ZVxuICB3aWR0aDogc3RyaW5nIHwgbnVtYmVyID0gJzEwMHB4J1xuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LnVpVmFsdWVcbiAgaGVpZ2h0OiBzdHJpbmcgfCBudW1iZXIgPSAnNTBweCdcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC51aVZhbHVlXG4gIHBvc2l0aW9uWDogc3RyaW5nIHwgbnVtYmVyID0gJzBweCdcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC51aVZhbHVlXG4gIHBvc2l0aW9uWTogc3RyaW5nIHwgbnVtYmVyID0gJzBweCdcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBpc1BvaW50ZXJCbG9ja2VyOiBib29sZWFuID0gdHJ1ZVxuXG4gIHByaXZhdGUgX3BhcmVudD86IFVJU2hhcGVcblxuICBjb25zdHJ1Y3RvcihwYXJlbnQ6IFVJU2hhcGUgfCBudWxsKSB7XG4gICAgc3VwZXIoKVxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgICAgdGhpcy5kYXRhLnBhcmVudENvbXBvbmVudCA9IGdldENvbXBvbmVudElkKHBhcmVudCBhcyBhbnkpXG4gICAgfVxuICB9XG5cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50XG4gIH1cblxuICAvLyBAaW50ZXJuYWxcbiAgZ2V0IHBhcmVudENvbXBvbmVudCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmRhdGEucGFyZW50Q29tcG9uZW50XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIE5PVEUoQnJpYW4pOiB0aGlzIHNob3VsZCBiZSBkZXByZWNhdGVkXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUuc2hhcGUnLCBDTEFTU19JRC5VSV9GVUxMU0NSRUVOX1NIQVBFKVxuZXhwb3J0IGNsYXNzIFVJRnVsbFNjcmVlbiBleHRlbmRzIFVJU2hhcGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihudWxsKVxuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBOT1RFKEJyaWFuKTogdGhpcyBzaG91bGQgYmUgZGVwcmVjYXRlZFxuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnNoYXBlJywgQ0xBU1NfSUQuVUlfV09STERfU1BBQ0VfU0hBUEUpXG5leHBvcnQgY2xhc3MgVUlXb3JsZFNwYWNlIGV4dGVuZHMgVUlTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG51bGwpXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUuc2hhcGUnLCBDTEFTU19JRC5VSV9TQ1JFRU5fU1BBQ0VfU0hBUEUpXG5leHBvcnQgY2xhc3MgVUlDYW52YXMgZXh0ZW5kcyBVSVNoYXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIobnVsbClcbiAgfVxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQERpc3Bvc2FibGVDb21wb25lbnQoJ2VuZ2luZS5zaGFwZScsIENMQVNTX0lELlVJX0NPTlRBSU5FUl9SRUNUKVxuZXhwb3J0IGNsYXNzIFVJQ29udGFpbmVyUmVjdCBleHRlbmRzIFVJU2hhcGUge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB0aGlja25lc3M6IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBjb2xvcjogQ29sb3I0ID0gQ29sb3I0LkNsZWFyKClcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBhbGlnbm1lbnRVc2VzU2l6ZTogYm9vbGVhbiA9IHRydWVcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBlbnVtIFVJU3RhY2tPcmllbnRhdGlvbiB7XG4gIFZFUlRJQ0FMLFxuICBIT1JJWk9OVEFMXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnNoYXBlJywgQ0xBU1NfSUQuVUlfQ09OVEFJTkVSX1NUQUNLKVxuZXhwb3J0IGNsYXNzIFVJQ29udGFpbmVyU3RhY2sgZXh0ZW5kcyBVSVNoYXBlIHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgYWRhcHRXaWR0aDogYm9vbGVhbiA9IHRydWVcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBhZGFwdEhlaWdodDogYm9vbGVhbiA9IHRydWVcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBjb2xvcjogQ29sb3I0ID0gQ29sb3I0LkNsZWFyKClcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzdGFja09yaWVudGF0aW9uOiBVSVN0YWNrT3JpZW50YXRpb24gPSBVSVN0YWNrT3JpZW50YXRpb24uVkVSVElDQUxcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzcGFjaW5nOiBudW1iZXIgPSAwXG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnNoYXBlJywgQ0xBU1NfSUQuVUlfQlVUVE9OX1NIQVBFKVxuZXhwb3J0IGNsYXNzIFVJQnV0dG9uIGV4dGVuZHMgVUlTaGFwZSB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGZvbnRTaXplOiBudW1iZXIgPSAxMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGZvbnRXZWlnaHQ6IHN0cmluZyA9ICdub3JtYWwnXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgdGhpY2tuZXNzOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgY29ybmVyUmFkaXVzOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgY29sb3I6IENvbG9yNCA9IENvbG9yNC5XaGl0ZSgpXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgYmFja2dyb3VuZDogQ29sb3I0ID0gQ29sb3I0LldoaXRlKClcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwYWRkaW5nVG9wOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcGFkZGluZ1JpZ2h0OiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcGFkZGluZ0JvdHRvbTogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBhZGRpbmdMZWZ0OiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2hhZG93Qmx1cjogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNoYWRvd09mZnNldFg6IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzaGFkb3dPZmZzZXRZOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2hhZG93Q29sb3I6IENvbG9yNCA9IENvbG9yNC5CbGFjaygpXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgdGV4dDogc3RyaW5nID0gJ2J1dHRvbidcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUuc2hhcGUnLCBDTEFTU19JRC5VSV9URVhUX1NIQVBFKVxuZXhwb3J0IGNsYXNzIFVJVGV4dCBleHRlbmRzIFVJU2hhcGUge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBvdXRsaW5lV2lkdGg6IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBvdXRsaW5lQ29sb3I6IENvbG9yNCA9IENvbG9yNC5XaGl0ZSgpXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgY29sb3I6IENvbG9yNCA9IENvbG9yNC5XaGl0ZSgpXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgZm9udFNpemU6IG51bWJlciA9IDEwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgZm9udEF1dG9TaXplOiBib29sZWFuID0gZmFsc2VcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5jb21wb25lbnRcbiAgZm9udD86IEZvbnRcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB2YWx1ZTogc3RyaW5nID0gJydcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBsaW5lU3BhY2luZzogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGxpbmVDb3VudDogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGFkYXB0V2lkdGg6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGFkYXB0SGVpZ2h0OiBib29sZWFuID0gZmFsc2VcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB0ZXh0V3JhcHBpbmc6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNoYWRvd0JsdXI6IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzaGFkb3dPZmZzZXRYOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2hhZG93T2Zmc2V0WTogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNoYWRvd0NvbG9yOiBDb2xvcjQgPSBDb2xvcjQuQmxhY2soKVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGhUZXh0QWxpZ246IHN0cmluZyA9ICdsZWZ0J1xuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHZUZXh0QWxpZ246IHN0cmluZyA9ICdib3R0b20nXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcGFkZGluZ1RvcDogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBhZGRpbmdSaWdodDogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBhZGRpbmdCb3R0b206IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwYWRkaW5nTGVmdDogbnVtYmVyID0gMFxufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuQERpc3Bvc2FibGVDb21wb25lbnQoJ2VuZ2luZS5zaGFwZScsIENMQVNTX0lELlVJX0lOUFVUX1RFWFRfU0hBUEUpXG5leHBvcnQgY2xhc3MgVUlJbnB1dFRleHQgZXh0ZW5kcyBVSVNoYXBlIHtcbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgb3V0bGluZVdpZHRoOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgb3V0bGluZUNvbG9yOiBDb2xvcjQgPSBDb2xvcjQuQmxhY2soKVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGNvbG9yOiBDb2xvcjQgPSBDb2xvcjQuQ2xlYXIoKVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGZvbnRTaXplOiBudW1iZXIgPSAxMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmNvbXBvbmVudFxuICBmb250PzogRm9udFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHZhbHVlOiBzdHJpbmcgPSAnJ1xuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBsYWNlaG9sZGVyOiBzdHJpbmcgPSAnJ1xuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIG1hcmdpbjogbnVtYmVyID0gMTBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBoVGV4dEFsaWduOiBzdHJpbmcgPSAnbGVmdCdcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB2VGV4dEFsaWduOiBzdHJpbmcgPSAnYm90dG9tJ1xuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGZvY3VzZWRCYWNrZ3JvdW5kOiBDb2xvcjQgPSBDb2xvcjQuQmxhY2soKVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHRleHRXcmFwcGluZzogYm9vbGVhbiA9IGZhbHNlXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2hhZG93Qmx1cjogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHNoYWRvd09mZnNldFg6IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzaGFkb3dPZmZzZXRZOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2hhZG93Q29sb3I6IENvbG9yNCA9IENvbG9yNC5XaGl0ZSgpXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcGFkZGluZ1RvcDogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBhZGRpbmdSaWdodDogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBhZGRpbmdCb3R0b206IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwYWRkaW5nTGVmdDogbnVtYmVyID0gMFxuXG4gIG9uVGV4dFN1Ym1pdDogT25UZXh0U3VibWl0IHwgbnVsbCA9IG51bGxcblxuICBvbkNoYW5nZWQ6IE9uQ2hhbmdlZCB8IG51bGwgPSBudWxsXG5cbiAgLy8gQGludGVybmFsXG4gIEBPblVVSURFdmVudC51dWlkRXZlbnRcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IG9uVGV4dENoYW5nZWQ6IE9uQ2hhbmdlZFxuXG4gIEBPblVVSURFdmVudC51dWlkRXZlbnRcbiAgb25Gb2N1czogT25Gb2N1cyB8IG51bGwgPSBudWxsXG5cbiAgQE9uVVVJREV2ZW50LnV1aWRFdmVudFxuICBvbkJsdXI6IE9uQmx1ciB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IocGFyZW50OiBVSVNoYXBlIHwgbnVsbCkge1xuICAgIHN1cGVyKHBhcmVudClcbiAgICB0aGlzLm9uVGV4dENoYW5nZWQgPSBuZXcgT25DaGFuZ2VkKChlKSA9PiB7XG4gICAgICBjb25zdCB7IHZhbHVlLCBpc1N1Ym1pdCB9ID0gZS52YWx1ZVxuXG4gICAgICAvLyBOT1RFOiBoZXJlIHdlIHdhbnQgdG8ga2VlcCB0aGUgc2FtZSBgZGlydHlgIHN0YXRlIGFzIGJlZm9yZSBjaGFuZ2luZyBgdGhpcy52YWx1ZWBcbiAgICAgIC8vIGJlY2F1c2UgY2hhbmdpbmcgYHRoaXMudmFsdWVgIHdpbGwgc2V0IHRoZSBjb21wb25lbnQgYXMgYGRpcnR5YCBhbmQgc2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHJlbmRlcmVyIHdpdGggaXQgdmFsdWVcbiAgICAgIC8vIGFuZCB0aGF0IG1lc3NhZ2UgaXMgdW5uZWNlc2FyeSAoaWYgdGhlIG9ubHkgdGhpbmcgdGhhdCBoYXZlIGNoYW5nZWQgaXMgYHRoaXMudmFsdWVgKSBzaW5jZSB0aGF0IG5ldyB2YWx1ZSBoYXMgY29tZSBmcm9tIHRoZSByZW5kZXJlciBpdHNlbGZcbiAgICAgIGNvbnN0IGlzRGlydHkgPSB0aGlzLmRpcnR5XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXMuZGlydHkgPSBpc0RpcnR5XG5cbiAgICAgIGlmIChpc1N1Ym1pdCAmJiB0aGlzLm9uVGV4dFN1Ym1pdCkge1xuICAgICAgICBjb25zdCBvblN1Ym1pdFZhbHVlOiBJRXZlbnRzWydvblRleHRTdWJtaXQnXSA9IHsgdGV4dDogdmFsdWUgfVxuICAgICAgICB0aGlzLm9uVGV4dFN1Ym1pdC5jYWxsYmFjayhvblN1Ym1pdFZhbHVlKVxuICAgICAgfSBlbHNlIGlmICghaXNTdWJtaXQgJiYgdGhpcy5vbkNoYW5nZWQpIHtcbiAgICAgICAgY29uc3Qgb25DaGFuZ2VWYWx1ZTogSUV2ZW50c1snb25DaGFuZ2UnXSA9IHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBwb2ludGVySWQ6IGUucG9pbnRlcklkXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNoYW5nZWQuY2FsbGJhY2sob25DaGFuZ2VWYWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5ARGlzcG9zYWJsZUNvbXBvbmVudCgnZW5naW5lLnNoYXBlJywgQ0xBU1NfSUQuVUlfSU1BR0VfU0hBUEUpXG5leHBvcnQgY2xhc3MgVUlJbWFnZSBleHRlbmRzIFVJU2hhcGUge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzb3VyY2VMZWZ0OiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc291cmNlVG9wOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc291cmNlV2lkdGg6IG51bWJlciA9IDFcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBzb3VyY2VIZWlnaHQ6IG51bWJlciA9IDFcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5jb21wb25lbnRcbiAgc291cmNlPzogVGV4dHVyZSB8IEF2YXRhclRleHR1cmVcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwYWRkaW5nVG9wOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcGFkZGluZ1JpZ2h0OiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcGFkZGluZ0JvdHRvbTogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBhZGRpbmdMZWZ0OiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2l6ZUluUGl4ZWxzOiBib29sZWFuID0gdHJ1ZVxuXG4gIEBPblVVSURFdmVudC51dWlkRXZlbnRcbiAgb25DbGljazogT25DbGljayB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IocGFyZW50OiBVSVNoYXBlLCBzb3VyY2U6IFRleHR1cmUgfCBBdmF0YXJUZXh0dXJlKSB7XG4gICAgc3VwZXIocGFyZW50KVxuICAgIHRoaXMuc291cmNlID0gc291cmNlXG4gIH1cbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBEaXNwb3NhYmxlQ29tcG9uZW50KCdlbmdpbmUuc2hhcGUnLCBDTEFTU19JRC5VSV9TTElERVJfU0hBUEUpXG5leHBvcnQgY2xhc3MgVUlTY3JvbGxSZWN0IGV4dGVuZHMgVUlTaGFwZSB7XG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHZhbHVlWDogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHZhbHVlWTogbnVtYmVyID0gMFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGJhY2tncm91bmRDb2xvcjogQ29sb3I0ID0gQ29sb3I0LkNsZWFyKClcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBpc0hvcml6b250YWw6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGlzVmVydGljYWw6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIHBhZGRpbmdUb3A6IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwYWRkaW5nUmlnaHQ6IG51bWJlciA9IDBcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBwYWRkaW5nQm90dG9tOiBudW1iZXIgPSAwXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgcGFkZGluZ0xlZnQ6IG51bWJlciA9IDBcblxuICBAT25VVUlERXZlbnQudXVpZEV2ZW50XG4gIG9uQ2hhbmdlZDogT25DaGFuZ2VkIHwgbnVsbCA9IG51bGxcbn1cbiIsImltcG9ydCB7IFJlYWRPbmx5Q29sb3I0IH0gZnJvbSAnQGRjbC9lY3MtbWF0aCdcblxuaW1wb3J0IHsgV2VhcmFibGVJZCB9IGZyb20gJy4uL2RlY2VudHJhbGFuZC9UeXBlcydcbmltcG9ydCB7IENvbXBvbmVudCwgT2JzZXJ2YWJsZUNvbXBvbmVudCB9IGZyb20gJy4uL2Vjcy9Db21wb25lbnQnXG5pbXBvcnQgeyBDTEFTU19JRCB9IGZyb20gJy4vQ29tcG9uZW50cydcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbkBDb21wb25lbnQoJ2VuZ2luZS5hdmF0YXJTaGFwZScsIENMQVNTX0lELkFWQVRBUl9TSEFQRSlcbmV4cG9ydCBjbGFzcyBBdmF0YXJTaGFwZSBleHRlbmRzIE9ic2VydmFibGVDb21wb25lbnQge1xuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBpZCE6IHN0cmluZ1xuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIG5hbWUhOiBzdHJpbmdcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBleHByZXNzaW9uVHJpZ2dlcklkITogc3RyaW5nXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgZXhwcmVzc2lvblRyaWdnZXJUaW1lc3RhbXAhOiBudW1iZXJcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBib2R5U2hhcGUhOiBXZWFyYWJsZUlkXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgd2VhcmFibGVzITogV2VhcmFibGVJZFtdXG5cbiAgQE9ic2VydmFibGVDb21wb25lbnQuZmllbGRcbiAgc2tpbkNvbG9yITogUmVhZE9ubHlDb2xvcjRcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICBoYWlyQ29sb3IhOiBSZWFkT25seUNvbG9yNFxuXG4gIEBPYnNlcnZhYmxlQ29tcG9uZW50LmZpZWxkXG4gIGV5ZUNvbG9yITogUmVhZE9ubHlDb2xvcjRcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB1c2VEdW1teU1vZGVsOiBib29sZWFuID0gZmFsc2VcblxuICBAT2JzZXJ2YWJsZUNvbXBvbmVudC5maWVsZFxuICB0YWxraW5nOiBib29sZWFuID0gZmFsc2VcblxuICBwdWJsaWMgc3RhdGljIER1bW15KCk6IEF2YXRhclNoYXBlIHtcbiAgICBjb25zdCBhdmF0YXJTaGFwZSA9IG5ldyBBdmF0YXJTaGFwZSgpXG4gICAgYXZhdGFyU2hhcGUudXNlRHVtbXlNb2RlbCA9IHRydWVcbiAgICByZXR1cm4gYXZhdGFyU2hhcGVcbiAgfVxufVxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICcuLi9lY3MvT2JzZXJ2YWJsZSdcbmltcG9ydCB7IGVycm9yIH0gZnJvbSAnLi4vZWNzL2hlbHBlcnMnXG5cbmxldCBjb21tdW5pY2F0aW9uc0NvbnRyb2xsZXI6IE1vZHVsZURlc2NyaXB0b3IgfCBudWxsID0gbnVsbFxubGV0IGNvbW11bmljYXRpb25zQ29udHJvbGxlclByb21pc2U6IFByb21pc2VMaWtlPE1vZHVsZURlc2NyaXB0b3I+IHwgbnVsbCA9IG51bGxcblxubGV0IF9tZXNzYWdlT2JzZXJ2ZXI6IG51bGwgfCBPYnNlcnZhYmxlPElFdmVudHNbJ2NvbW1zJ10+ID0gbnVsbFxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZU9ic2VydmVyKCkge1xuICBpZiAoIV9tZXNzYWdlT2JzZXJ2ZXIpIHtcbiAgICBfbWVzc2FnZU9ic2VydmVyID0gbmV3IE9ic2VydmFibGU8SUV2ZW50c1snY29tbXMnXT4oKVxuICB9XG4gIHJldHVybiBfbWVzc2FnZU9ic2VydmVyXG59XG5cbmZ1bmN0aW9uIGVuc3VyZUNvbW11bmljYXRpb25zQ29udHJvbGxlcigpIHtcbiAgaWYgKCFjb21tdW5pY2F0aW9uc0NvbnRyb2xsZXJQcm9taXNlKSB7XG4gICAgY29tbXVuaWNhdGlvbnNDb250cm9sbGVyUHJvbWlzZSA9IGRjbC5sb2FkTW9kdWxlKFxuICAgICAgJ0BkZWNlbnRyYWxhbmQvQ29tbXVuaWNhdGlvbnNDb250cm9sbGVyJyxcbiAgICAgIHt9XG4gICAgKVxuXG4gICAgdm9pZCBjb21tdW5pY2F0aW9uc0NvbnRyb2xsZXJQcm9taXNlLnRoZW4oKCQpID0+IHtcbiAgICAgIGNvbW11bmljYXRpb25zQ29udHJvbGxlciA9ICRcbiAgICB9KVxuXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBnZXRNZXNzYWdlT2JzZXJ2ZXIoKVxuXG4gICAgZGNsLnN1YnNjcmliZSgnY29tbXMnKVxuICAgIGRjbC5vbkV2ZW50KChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjb21tcycpIHtcbiAgICAgICAgb2JzZXJ2ZXIubm90aWZ5T2JzZXJ2ZXJzKGV2ZW50LmRhdGEgYXMgYW55KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGNvbW11bmljYXRpb25zQ29udHJvbGxlclByb21pc2Vcbn1cblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlQnVzIHtcbiAgcHJpdmF0ZSBtZXNzYWdlUXVldWU6IHN0cmluZ1tdID0gW11cbiAgcHJpdmF0ZSBjb25uZWN0ZWQgPSBmYWxzZVxuICBwcml2YXRlIGZsdXNoaW5nID0gZmFsc2VcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2b2lkIGVuc3VyZUNvbW11bmljYXRpb25zQ29udHJvbGxlcigpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlXG4gICAgICB0aGlzLmZsdXNoKClcbiAgICB9KVxuICB9XG5cbiAgb24oXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAodmFsdWU6IGFueSwgc2VuZGVyOiBzdHJpbmcpID0+IHZvaWRcbiAgKTogT2JzZXJ2ZXI8SUV2ZW50c1snY29tbXMnXT4ge1xuICAgIHJldHVybiBnZXRNZXNzYWdlT2JzZXJ2ZXIoKS5hZGQoKGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG0gPSBKU09OLnBhcnNlKGUubWVzc2FnZSlcblxuICAgICAgICBpZiAobS5tZXNzYWdlID09PSBtZXNzYWdlKSB7XG4gICAgICAgICAgY2FsbGJhY2sobS5wYXlsb2FkLCBlLnNlbmRlcilcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkY2wuZXJyb3IoXG4gICAgICAgICAgJ0Vycm9yIHBhcnNpbmcgY29tbXMgbWVzc2FnZSAnICsgKChlIGFzIEVycm9yKS5tZXNzYWdlIHx8ICcnKSxcbiAgICAgICAgICBlXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9KSFcbiAgfVxuXG4gIC8vIEBpbnRlcm5hbFxuICBzZW5kUmF3KG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gobWVzc2FnZSlcblxuICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgdGhpcy5mbHVzaCgpXG4gICAgfVxuICB9XG5cbiAgZW1pdChtZXNzYWdlOiBzdHJpbmcsIHBheWxvYWQ6IFJlY29yZDxhbnksIGFueT4pIHtcbiAgICBjb25zdCBtZXNzYWdlVG9TZW5kID0gSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlLCBwYXlsb2FkIH0pXG4gICAgdGhpcy5zZW5kUmF3KG1lc3NhZ2VUb1NlbmQpXG4gICAgZ2V0TWVzc2FnZU9ic2VydmVyKCkubm90aWZ5T2JzZXJ2ZXJzKHtcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VUb1NlbmQsXG4gICAgICBzZW5kZXI6ICdzZWxmJ1xuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLm1lc3NhZ2VRdWV1ZS5sZW5ndGggPT09IDApIHJldHVyblxuICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHJldHVyblxuICAgIGlmICghY29tbXVuaWNhdGlvbnNDb250cm9sbGVyKSByZXR1cm5cbiAgICBpZiAodGhpcy5mbHVzaGluZykgcmV0dXJuXG5cbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlUXVldWUuc2hpZnQoKVxuXG4gICAgdGhpcy5mbHVzaGluZyA9IHRydWVcblxuICAgIGRjbC5jYWxsUnBjKGNvbW11bmljYXRpb25zQ29udHJvbGxlci5ycGNIYW5kbGUsICdzZW5kJywgW21lc3NhZ2VdKS50aGVuKFxuICAgICAgKF8pID0+IHtcbiAgICAgICAgdGhpcy5mbHVzaGluZyA9IGZhbHNlXG4gICAgICAgIHRoaXMuZmx1c2goKVxuICAgICAgfSxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIHRoaXMuZmx1c2hpbmcgPSBmYWxzZVxuICAgICAgICBlcnJvcignRXJyb3IgZmx1c2hpbmcgTWVzc2FnZUJ1cycsIGUpXG4gICAgICB9XG4gICAgKVxuICB9XG59XG4iLCIvLyBDT1JFIERFUEVOREVOQ0lFU1xuZXhwb3J0ICogZnJvbSAnLi9lY3MvQXR0YWNoYWJsZSdcbmV4cG9ydCAqIGZyb20gJy4vZWNzL0VuZ2luZSdcbmV4cG9ydCAqIGZyb20gJy4vZWNzL0NvbXBvbmVudCdcbmV4cG9ydCAqIGZyb20gJy4vZWNzL0NvbXBvbmVudEdyb3VwJ1xuZXhwb3J0ICogZnJvbSAnLi9lY3MvRW50aXR5J1xuZXhwb3J0ICogZnJvbSAnLi9lY3MvSUVudGl0eSdcbmV4cG9ydCAqIGZyb20gJy4vZWNzL1Rhc2snXG5leHBvcnQgKiBmcm9tICcuL2Vjcy9oZWxwZXJzJ1xuZXhwb3J0ICogZnJvbSAnLi9lY3MvT2JzZXJ2YWJsZSdcbmV4cG9ydCAqIGZyb20gJy4vZWNzL1VJVmFsdWUnXG5leHBvcnQgKiBmcm9tICcuL2Vjcy9FdmVudE1hbmFnZXInXG5leHBvcnQgKiBmcm9tICcuL2Vjcy9Vc2VyQWN0aW9ucydcblxuaW1wb3J0IHsgX2luaXRFdmVudE9ic2VydmFibGVzIH0gZnJvbSAnLi9kZWNlbnRyYWxhbmQvRXZlbnRzJ1xuaW1wb3J0IHsgRGVjZW50cmFsYW5kU3luY2hyb25pemF0aW9uU3lzdGVtIH0gZnJvbSAnLi9kZWNlbnRyYWxhbmQvSW1wbGVtZW50YXRpb24nXG5cbi8vIEVDUyBJTklUSUFMSVpBVElPTlxuaW1wb3J0IHsgRW5naW5lIH0gZnJvbSAnLi9lY3MvRW5naW5lJ1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnLi9lY3MvRW50aXR5J1xuXG5jb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5KCdzY2VuZScpXG47KGVudGl0eSBhcyBhbnkpLnV1aWQgPSAnMCdcblxuLy8gSW5pdGlhbGl6ZSBlbmdpbmVcbi8qKiBAcHVibGljICovXG5jb25zdCBlbmdpbmUgPSBuZXcgRW5naW5lKGVudGl0eSlcblxuaW1wb3J0IHsgRGlzcG9zYWJsZUNvbXBvbmVudCB9IGZyb20gJy4vZWNzL0NvbXBvbmVudCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmVcbkRpc3Bvc2FibGVDb21wb25lbnQuZW5naW5lID0gZW5naW5lXG5cbi8vIEluaXRpYWxpemUgRGVjZW50cmFsYW5kIGludGVyZmFjZVxuaWYgKHR5cGVvZiBkY2wgIT09ICd1bmRlZmluZWQnKSB7XG4gIGVuZ2luZS5hZGRTeXN0ZW0obmV3IERlY2VudHJhbGFuZFN5bmNocm9uaXphdGlvblN5c3RlbShkY2wpLCBJbmZpbml0eSlcbiAgX2luaXRFdmVudE9ic2VydmFibGVzKGRjbClcbn1cblxuaW1wb3J0IHtcbiAgdXVpZEV2ZW50U3lzdGVtLFxuICBwb2ludGVyRXZlbnRTeXN0ZW0sXG4gIHJheWNhc3RFdmVudFN5c3RlbVxufSBmcm9tICcuL2RlY2VudHJhbGFuZC9TeXN0ZW1zJ1xuXG4vLyBJbml0aWFsaXplIFVVSUQgRXZlbnRzIHN5c3RlbVxuZW5naW5lLmFkZFN5c3RlbSh1dWlkRXZlbnRTeXN0ZW0pXG4vLyBJbml0aWFsaXplIFBvaW50ZXIgRXZlbnRzIFN5c3RlbVxuZW5naW5lLmFkZFN5c3RlbShwb2ludGVyRXZlbnRTeXN0ZW0pXG4vLyBJbml0aWFsaXplIFJheWNhc3QgRXZlbnRzIFN5c3RlbVxuZW5naW5lLmFkZFN5c3RlbShyYXljYXN0RXZlbnRTeXN0ZW0pXG5cbi8vIERFQ0VOVFJBTEFORCBERVBFTkRFTkNJRVNcbmV4cG9ydCAqIGZyb20gJy4vZGVjZW50cmFsYW5kL01hdGgnXG5leHBvcnQgKiBmcm9tICcuL2RlY2VudHJhbGFuZC9UeXBlcydcbmV4cG9ydCAqIGZyb20gJy4vZGVjZW50cmFsYW5kL0NvbXBvbmVudHMnXG5leHBvcnQgKiBmcm9tICcuL2RlY2VudHJhbGFuZC9TeXN0ZW1zJ1xuZXhwb3J0ICogZnJvbSAnLi9kZWNlbnRyYWxhbmQvRXZlbnRzJ1xuZXhwb3J0ICogZnJvbSAnLi9kZWNlbnRyYWxhbmQvQ2FtZXJhJ1xuZXhwb3J0ICogZnJvbSAnLi9kZWNlbnRyYWxhbmQvQW5pbWF0aW9uU3RhdGUnXG5leHBvcnQgKiBmcm9tICcuL2RlY2VudHJhbGFuZC9JbnB1dCdcbmV4cG9ydCAqIGZyb20gJy4vZGVjZW50cmFsYW5kL0F1ZGlvJ1xuZXhwb3J0ICogZnJvbSAnLi9kZWNlbnRyYWxhbmQvR2l6bW9zJ1xuZXhwb3J0ICogZnJvbSAnLi9kZWNlbnRyYWxhbmQvVUlTaGFwZXMnXG5leHBvcnQgKiBmcm9tICcuL2RlY2VudHJhbGFuZC9BdmF0YXJTaGFwZSdcbmV4cG9ydCAqIGZyb20gJy4vZGVjZW50cmFsYW5kL1VJRXZlbnRzJ1xuZXhwb3J0ICogZnJvbSAnLi9kZWNlbnRyYWxhbmQvTWVzc2FnZUJ1cydcbmV4cG9ydCAqIGZyb20gJy4vZGVjZW50cmFsYW5kL1BoeXNpY3NDYXN0J1xuXG5leHBvcnQgeyBlbmdpbmUgfVxuIl0sIm5hbWVzIjpbImJ1aWxkQXJyYXkiLCJVSVZhbHVlVHlwZSIsIlNjYWxhcl8xIiwiVmVjdG9yNF8xIiwidHlwZXNfMSIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQxIiwiVmVjdG9yM18xIiwicmVxdWlyZSQkMiIsIk1hdHJpeF8xIiwiUXVhdGVybmlvbl8xIiwicHJlYWxsb2NhdGVkVmFyaWFibGVzXzEiLCJyZXF1aXJlJCQzIiwicmVxdWlyZSQkNCIsIkFuZ2xlXzEiLCJWZWN0b3IyXzEiLCJBcmMyXzEiLCJBeGlzXzEiLCJCZXppZXJDdXJ2ZV8xIiwiQ29sb3I0XzEiLCJDb2xvcjNfMSIsIlBsYW5lXzEiLCJTaXplXzEiLCJ0aGlzIiwicmVxdWlyZSQkNSIsInJlcXVpcmUkJDYiLCJyZXF1aXJlJCQ3IiwicmVxdWlyZSQkOCIsInJlcXVpcmUkJDkiLCJyZXF1aXJlJCQxMCIsInJlcXVpcmUkJDExIiwicmVxdWlyZSQkMTIiLCJyZXF1aXJlJCQxMyIsInJlcXVpcmUkJDE0IiwicmVxdWlyZSQkMTUiLCJyZXF1aXJlJCQxNiIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxOSIsInJlcXVpcmUkJDIwIiwiSW5wdXRFdmVudFR5cGUiLCJDYW1lcmFNb2RlIiwiTGFuZFJvbGUiLCJBY3Rpb25CdXR0b24iLCJWZWN0b3IzIiwiQ0xBU1NfSUQiLCJBdmF0YXJNb2RpZmllcnMiLCJRdWF0ZXJuaW9uIiwiTWF0aFRtcCIsIk1hdHJpeCIsIkF0dGFjaFRvQXZhdGFyQW5jaG9yUG9pbnRJZCIsIlBpY3R1cmVGcmFtZVN0eWxlIiwiQ29sb3IzIiwiRm9udHMiLCJUcmFuc3BhcmVuY3lNb2RlIiwiVmlkZW9TdGF0dXMiLCJHaXptbyIsIkNvbG9yNCIsIlVJU3RhY2tPcmllbnRhdGlvbiJdLCJtYXBw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QUcsR0FBRyxFQUFFLFdBQVcsRUFBRSxDQUFDO0VBQzdDLFNBQVM7RUFDVCxRQUFRLE9BQU8sR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO0VBQ2pDLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUU7RUFDdkIsUUFBUSxNQUFNLE1BQU0sR0FBRyxDQUFDLEtBQUssQ0FBQztFQUM5QixRQUFRLElBQUksTUFBTSxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7RUFDM0MsWUFBWSxPQUFPLE1BQU0sQ0FBQztFQUMxQixTQUFTO0VBQ1QsUUFBUSxPQUFPLE1BQU0sR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0VBQ25DLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sS0FBSyxDQUFDLEtBQUssRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQUU7RUFDMUMsUUFBUSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDbkQsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssRUFBRTtFQUN2QixRQUFRLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO0VBQzVDLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFO0VBQ2pDLFFBQVEsT0FBTyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEdBQUcs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O0VBQ0E7RUFDQTtFQUNBLElBQUksZUFBZSxDQUFDLFdBQVcsRUFBRTtFQUNqQyxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQztFQUNoQyxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQztFQUNoQyxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQztFQUNoQyxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQztFQUNoQyxRQUFRLE9BQU8sSUFBSSxDQUFDO0VBQ3BCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxRQUFRLENBQUMsV0FBVyxFQUFFO0VBQzFCLFFBQVEsT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMzSCxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxhQUFhLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRTtFQUN2QyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO0VBQzFDLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUM7RUFDMUMsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQztFQUMxQyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO0VBQzFDLFFBQVEsT0FBTyxJQUFJLENBQUM7RUFDcEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLGdCQUFnQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtFQUNqQyxRQUFRLE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztFQUMzRSxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksTUFBTSxDQUFDLFdBQVcsRUFBRTtFQUN4QixRQUFRLE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDM0gsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksV0FBVyxDQUFDLFdBQVcsRUFBRSxNQUFNLEVBQUU7RUFDckMsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQztFQUMxQyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO0VBQzFDLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUM7RUFDMUMsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQztFQUMxQyxRQUFRLE9BQU8sSUFBSSxDQUFDO0VBQ3BCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxhQUFhLENBQUMsV0FBVyxFQUFFO0VBQy9CLFFBQVEsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQztFQUNuRCxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksZUFBZSxDQUFDLEtBQUssRUFBRTtFQUMzQixRQUFRLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFO0VBQzlCLFlBQVksSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQzdCLFNBQVM7RUFDVCxRQUFRLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFO0VBQzlCLFlBQVksSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQzdCLFNBQVM7RUFDVCxRQUFRLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFO0VBQzlCLFlBQVksSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQzdCLFNBQVM7RUFDVCxRQUFRLElBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFO0VBQzlCLFlBQVksSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQzdCLFNBQVM7RUFDVCxRQUFRLE9BQU8sSUFBSSxDQUFDO0VBQ3BCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxlQUFlLENBQUMsS0FBSyxFQUFFO0VBQzNCLFFBQVEsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUU7RUFDOUIsWUFBWSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDN0IsU0FBUztFQUNULFFBQVEsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUU7RUFDOUIsWUFBWSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDN0IsU0FBUztFQUNULFFBQVEsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUU7RUFDOUIsWUFBWSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDN0IsU0FBUztFQUNULFFBQVEsSUFBSSxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUU7RUFDOUIsWUFBWSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDN0IsU0FBUztFQUNULFFBQVEsT0FBTyxJQUFJLENBQUM7RUFDcEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxLQUFLLEdBQUc7RUFDWixRQUFRLE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMzRyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLEtBQUssR0FBRztFQUNaLFFBQVEsT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMs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QixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7RUFDMUIsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzFCLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztFQUMxQixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7RUFDMUIsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzFCLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztFQUMxQixRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUM7RUFDM0IsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzNCLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQztFQUMzQixRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUM7RUFDM0IsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzNCLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQztFQUMzQixRQUFRLE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQztFQUNoQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxVQUFVLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0VBQ3ROLFFBQVEsTUFBTSxNQUFNLEdBQUcsSUFBSSxNQUFNLEVBQUUsQ0FBQztFQUNwQyxRQUFRLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUM7RUFDNUIsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzFCLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztFQUMxQixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7RUFDMUIsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzFCLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztFQUMxQixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7RUFDMUIsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzFCLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztFQUMxQixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUM7RUFDMUIsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzFCLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQztFQUMzQixRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUM7RUFDM0IsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzNCLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQztFQUMzQixRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUM7RUFDM0IsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDO0VBQzNCLFFBQVEsTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO0VBQ2hDLFFBQVEsT0FBTyxNQUFNLENBQUM7RUFDdEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNB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QztFQUMxQixTQUFTO0VBQ1QsYUFBYTtFQUNiLFlBQVksS0FBSyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztFQUNoRSxTQUFTO0VBQ1Q7RUFDQSxRQUFRQSxXQUFTLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0VBQzFELFFBQVEsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO0VBQzFCO0VBQ0EsUUFBUSxNQUFNLEVBQUUsR0FBRyxDQUFDQSxXQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFDdEQsUUFBUSxNQUFNLEVBQUUsR0FBRyxDQUFDQSxXQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFDdEQsUUFBUSxNQUFNLEVBQUUsR0FBRyxDQUFDQSxXQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFDdEQsUUFBUSxNQUFNLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztFQUN4SixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFF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RTtFQUN6RCxRQUFRLE1BQU0sQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0VBQzNKLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLG1CQUFtQixDQUFDLElBQUksRUFBRSxNQUFNLEVBQUU7RUFDN0MsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbkMsUUFBUSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0VBQzdDLFFBQVEsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0VBQ3ZDLFFBQVEsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0VBQ3ZDLFFBQVEsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7RUFDM0IsUUFBUSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7RUFDdkMsUUFBUSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0VBQzdDLFFBQVEsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0VBQ3ZDLFFBQVEsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7RUFDM0IsUUFBUSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7RUFDdkMsUUFBUSxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7RUFDdkMsUUFBUSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFH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QUFHLElBQUksQ0FBQztFQUMzQyxhQUFhO0VBQ2IsU0FBUztFQUNULFFBQVEsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0VBQ25DLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksV0FBVyxHQUFHO0VBQ2xCLFFBQVEsSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLElBQUksRUFBRTtFQUN2QyxZQUFZLE9BQU8sQ0FBQyxDQUFDO0VBQ3JCLFNBQVM7RUFDVCxRQUFRLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7RUFDMUI7RUFDQSxRQUFRLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUM3RDtFQUNBLFFBQVEsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzdEO0VBQ0EsUUFBUSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDL0Q7RUFDQSxRQUFRLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUNqRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxRQUFRLE1BQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUNoRCxRQUFRLE1BQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUNoRCxRQUFRLE1BQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUNoRCxRQUFRLE1BQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUNoRCxRQUFRLE1BQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUNoRCxRQUFRLE1BQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUNoRCxRQUFRLE1BQU0sU0FBUyxHQUFHLEVBQUUsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLENBQUMsQ0FBQztFQUNqRixRQUFRLE1BQU0sU0FBUyxHQUFHLEVBQUUsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLENBQUMsQ0FBQztFQUNqRixRQUFRLE1BQU0sU0FBUyxHQUFHLEVBQUUsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLENBQUMsQ0FBQztFQUNqRixRQUFRLE1BQU0sU0FBUyxHQUFHLEVBQUUsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLENBQUMsQ0FBQztFQUNqRjtFQUNBLFFBQVEsT0FBTyxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxH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RyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDN0QsUUFBUSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDN0QsUUFBUSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDL0QsUUFBUSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDakU7RUFDQTtFQUNBLFFBQVEsTUFBTSxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0VBQ2hELFFBQVEsTUFBTSxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0VBQ2hELFFBQVEsTUFBTSxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0VBQ2hELFFBQVEsTUFBTSxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0VBQ2hELFFBQVEsTUFBTSxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0VBQ2hELFFBQVEsTUFBTSxTQUFTLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0VBQ2hELFFBQVEsTUFBTSxTQUFTLEdBQUcsRUFBRSxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0VBQ2pGLFFBQVEsTUFBTSxTQUFTLEdBQUcsRUFBRSxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0VBQ2pGLFFBQVEsTUFBTSxTQUFTLEdBQUcsRUFBRSxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0VBQ2pGLFFBQVEsTUFBTSxTQUFTLEdBQUcsRUFBRSxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsQ0FBQyxDQUFDO0VBQ2pGLFFBQVEsTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxHQUFHLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsQ0FBQztFQUMxRixRQUFRLElBQUksR0FBRyxLQUFLLENBQUMsRUFBRTtFQUN2QjtFQUNBLFlBQVksS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztFQUNqQyxZQUFZLE9BQU8sSUFBSSxDQUFDO0VBQ3hCLFNBQVM7RUFDVCxRQUFRLE1BQU0sTUFBTSxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7RUFDL0IsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7RUFDaEQsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxTQUFTLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUM7RUFDakYsUUFBUSxNQUFNLENBQUMs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QSxJQUFJLHdCQUF3QixHQUFHO0VBQy9CLFFBQVEsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUN6QixRQUFRLE1BQU0sQ0FBQyxlQUFlLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0VBQzdILFFBQVEsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUM3RixRQUFRLE9BQU8sSUFBSSxDQUFDO0VBQ3BCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFO0VBQ3BCLFFBQVEsTUFBTSxNQUFNLEdBQUcsSUFBSSxNQUFNLEVBQUUsQ0FBQztFQUNwQyxRQUFRLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0VBQzFDLFFBQVEsT0FBTyxNQUFNLENBQUM7RUFDdEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUU7RUFDcEIsUUFBUSxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUNuQyxRQUFRLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQztFQUN4QixRQUFRLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0VBQy9HLFFBQVEsT0FBTyxJQUFJLENBQUM7RUFDcEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksV0FBVyxDQUFDLEtBQUssRUFBRSxNQUFNLEdBQUcsQ0FBQyxFQUFFO0VBQ25DLFFBQVEsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRTtFQUNqRCxZQUFZLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztFQUNuRCxTQUFTO0VBQ1QsUUFBUSxPQUFPLElBQUksQ0FBQztFQUNwQixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxhQUFhLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRTtFQUNqQyxRQUFRLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtFQUM5QixZQUFZLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7RUFDbkMsWUFBWSxPQUFPLElBQUksQ0FBQztFQUN4QixTQUFTO0VBQ1QsUUFBUSxJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUU7RUFDL0IsWUFBWSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0VBQ2xDLFlBQVksT0FBTyxJQUFJLENBQUM7RUFDeEIsU0FBUztFQUNULFFBQVEsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUNsRCxRQUFRLE1BQU0sQ0FBQyxjQUFjLEVBQUUsQ0FBQztFQUNoQyxRQUFRLE9BQU8sSUFBSSxDQUFDO0VBQ3BCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksZUFBZSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0VBQzNDLFFBQVEsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztFQUMxQixRQUFRLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDL0I7RUFDQSxRQUFRLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUM3RCxRQUFRLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUM3RCxRQUFRLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUNqRSxRQUFRLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUNyRSxRQUFRLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUNqRixRQUFRLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUNqRixRQUFRLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUNyRixRQUFRLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUN6RjtFQUNBLFFBQVEsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7RUFDeEUsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7RUFDNUUsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7RUFDN0UsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7RUFDN0UsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7RUFDNUUsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7RUFDNUUsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7RUFDN0UsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7RUFDN0UsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7RUFDOUUsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7RUFDOUUsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7RUFDaEYsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7RUFDaEYsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7RUFDakYsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7RUFDakYsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7RUFDbEYsUUFBUSxNQUFNLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7RUFDbEYsUUFBUSxPQUFPLElBQUksQ0FBQztFQUNwQixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtFQUNsQixRQUFRLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQztFQUM1QixRQUFRLElBQUksQ0FBQyxLQUFLLEVBQUU7RUFDcEIsWUFBWSxPQUFP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QUksQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMxRCxRQUFRLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDM0Q7RUFDQSxRQUFRLE1BQU0sS0FBSyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0VBQ3RDLFFBQVEsSUFBSSxDQUFDLENBQUM7RUFDZCxRQUFRLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtFQUN2QixZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7RUFDN0MsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7RUFDaEMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDdkMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDdkMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDdkMsU0FBUztFQUNULGFBQWEsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLEVBQUU7RUFDekMsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7RUFDdkQsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDdkMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7RUFDaEMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDdkMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDdkMsU0FBUztFQUNULGFBQWEsSUFBSSxHQUFHLEdBQUcsR0FBRyxFQUFFO0VBQzVCLFlBQVksQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0VBQ3ZELFlBQVksTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO0VBQ3ZDLFlBQVksTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO0VBQ3ZDLFlBQVksTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0VBQ2hDLFlBQVksTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO0VBQ3ZDLFNBQVM7RUFDVCxhQUFhO0VBQ2IsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7RUFDdkQsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDdkMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDdkMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDdkMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7RUFDaEMsU0FBUztFQUNULEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUU7RUFDNUIsUUFBUSxRQUFRLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRTtFQUMzRixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFFBQVEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFO0VBQ2xDLFFBQVEsTUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7RUFDakQsUUFBUSxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUM7RUFDeEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLElBQUksR0FBRztFQUNsQixRQUFRLE9BQU8sSUFBSSxVQUFVLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFDbEQsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sT0FBTyxDQUFDLENBQUMsRUFBRTtFQUN0QixRQUFRLE9BQU8sSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ3JELEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFVBQVUsQ0FBQyxVQUFVLEVBQUU7RUFDbEMsUUFBUSxRQUFRLFVBQVU7RUFDMUIsWUFBWSxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUM7RUFDOUIsWUFBWSxVQUFV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UUFBUSxNQUFNLE9BQU8sR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0VBQ2xDLFFBQVEsTUFBTSxRQUFRLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQztFQUNwQyxRQUFRLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7RUFDdkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0VBQ3JDLFFBQVEsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztFQUN0QyxRQUFRLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7RUFDdkMsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0VBQ3JDLFFBQVEsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztFQUN0QyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7RUFDL0MsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO0VBQy9DLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztFQUMvQyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7RUFDL0MsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLHNCQUFzQixDQUFDLEtBQUssRUFBRSxJ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QUFHQSxXQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUM7RUFDakUsUUFBUSxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQzVCLFFBQVEsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUM1QixRQUFRLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDNUIsUUFBUSxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQzVCLFFBQVEsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUM1QixRQUFRLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDNUIsUUFBUSxNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDO0VBQ2pDLFFBQVEsTUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQztFQUNqQyxRQUFRLE1BQU0sR0FBRyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUM7RUFDakMsUUFBUSxNQUFNLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUNyQyxRQUFRLE1BQU0sVUFBVSxHQUFHLElBQUksVUFBVSxFQUFFLENBQUM7RUFDNUMsUUFBUSxJQUFJLElBQUksR0FBRyxDQUFDLEVBQUU7RUFDdEIsWUFBWSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztFQUMxQyxZQUFZLFVBQVUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztFQUNyQyxZQUFZLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0VBQzVCLFlBQVksVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDO0VBQzdDLFlBQVksVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksR0FB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QU8sQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7RUFDbEgsUUFBUSxPQUFPLElBQUksQ0FBQztFQUNwQixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFO0VBQ2YsUUFBUSxPQUFPLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ3RHLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUU7RUFDdEIsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDMUIsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDMUIsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDMUIsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDMUIsUUFBUSxPQUFPLElBQUksQ0FBQztFQUNwQixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksUUFBUSxDQUFDLEtBQUssRUFBRTtFQUNwQixRQUFRLE9BQU8sSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDdEcsS0FBSztF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Z0IsQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztFQUM1RSxvQkFBb0IsT0FBTztFQUMzQixnQkFBZ0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQztFQUNsRixRQUFRLE1BQU0sQ0FBQyxHQUFHLEdBQUc7RUFDckIsYUFBYSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUM7RUFDM0IsZ0JBQWdCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLElBQUksTUFBTTtFQUMvQyxnQkFBZ0IsQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztFQUM1RSxvQkFBb0IsT0FBTztFQUMzQixnQkFBZ0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQztFQUNsRixRQUFRLE1BQU0sQ0FBQyxHQUFHLEdBQUc7RUFDckIsYUFBYSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUM7RUFDM0IsZ0JBQWdCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLElBQUksTUFBTTtFQUMvQyxnQkFBZ0IsQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztFQUM1RSxvQkFBb0IsT0FBTztFQUMzQixnQkFBZ0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQztFQUNsRixRQUFRLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUNwQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRTtFQUNsQyxRQUFRLE1BQU0sQ0FBQyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7RUFDaEMsUUFBUSxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQy9DLFFBQVEsT0FBTyxDQUFDLENBQUM7RUFDakIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxVQUFVLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFO0VBQy9DLFFBQVEsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUN4QixRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztFQUNsQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztFQUNsQyxRQUFRLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDeEIsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7RUFDbEMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7RUFDbEMsUUFBUSxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQ3hCLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQ2xDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQ2xDLFFBQVEsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQ3ZDLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sT0FBTyxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUU7RUFDL0QsUUFBUSxNQUFNLE9BQU8sR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDO0VBQ3hDLFFBQVEsTUFBTSxLQUFLLEdBQUcsTUFBTSxHQUFHLE9BQU8sQ0FBQztFQUN2QyxRQUFRLE1BQU0sS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLE9BQU8sR0FBRyxHQUFHLENBQUM7RUFDeEQsUUFBUSxNQUFNLEtBQUssR0FBRyxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLE9BQU8sQ0FBQztFQUNuRCxRQUFRLE1BQU0sS0FBSyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsT0FBTyxHQUFHLE1BQU0sQ0FBQztFQUNyRCxRQUFRLE1BQU0sS0FBSyxHQUFHLEtBQUssR0FBRyxPQUFPLENBQUM7RUFDdEMsUUFBUSxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLEtBQUs7RUFDbEMsWUFBWSxNQUFNLENBQUMsQ0FBQyxHQUFHLEtBQUs7RUFDNUIsWUFBWSxRQUFRLENBQUMsQ0FBQyxHQUFHLEtBQUs7RUFDOUIsWUFBWSxRQUFRLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztFQUMvQixRQUFRLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsS0FBSztFQUNsQyxZQUFZLE1BQU0sQ0FBQyxDQUFDLEdBQUcsS0FBSztFQUM1QixZQUFZLFFBQVEsQ0FBQyxDQUFDLEdBQUcsS0FBSztFQUM5QixZQUFZLFFBQVEsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0VBQy9CLFFBQVEsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxLQUFLO0VBQ2xDLFlBQVksTUFBTSxDQUFDLENBQUMsR0FBRyxLQUFLO0VBQzVCLFlBQVksUUFBUSxDQUFDLENBQUMsR0FBRyxLQUFLO0VBQzlCLFlBQVksUUFBUSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7RUFDL0IsUUFBUSxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDcEMsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRTtFQUNwQyxRQUFRLE1BQU0sTUFBTSxHQUFHLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDNUMsUUFBUSxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0VBQ3RELFFBQVEsT0FBTyxNQUFNLENBQUM7RUFDdEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFNBQVMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7RUFDakQsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO0VBQ3hELFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztFQUN4RCxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7RUFDeEQsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRTtFQUM1QixRQUFRLE9BQU8sSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDdEUsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFO0VBQzlCLFFBQVEsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO0VBQ3RDLFFBQVEsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0VBQ2hELFFBQVEsT0FBTyxNQUFNLENBQUM7RUFDdEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtFQUMzQyxRQUFRLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDdEQsUUFBUSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQ3RELFFBQVEsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUN0RCxRQUFRLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUN2QyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxTQUFTLENBQUMsTUFBTSxFQUFFO0VBQzdCLFFBQVEsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO0VBQ3RDLFFBQVEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7RUFDL0MsUUFBUSxPQUFPLE1BQU0sQ0FBQztFQUN0QixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxjQUFjLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRTtFQUMxQyxRQUFRLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7RUFDdEMsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRTtFQUNqQyxRQUFRLE1BQU0sR0FBRyxHQUFHLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDeEQsUUFBUSxHQUFHLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO0VBQ25DLFFBQVEsT0FBTyxHQUFHLENBQUM7RUFDbkIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRTtFQUNqQyxRQUFRLE1BQU0sR0FBRyxHQUFHLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDeEQsUUFBUSxHQUFHLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO0VBQ25DLFFBQVEsT0FBTyxHQUFHLENBQUM7RUFDbkIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxRQUFRLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRTtFQUNwQyxRQUFRLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO0VBQ2xFLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sZUFBZSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUU7RUFDM0MsUUFBUSxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7RUFDdEMsUUFBUSxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7RUFDdEMsUUFBUSxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7RUFDdEMsUUFBUSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdB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Q0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQ2hFLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7RUFDaEUsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztFQUNoRSxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0VBQ2pFLFFBQVEsT0FBTyxNQUFNLENBQUM7RUFDdEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUU7RUFDZCxRQUFRLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7RUFDekMsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksV0FBVyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUU7RUFDM0IsUUFBUSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUM7RUFDakMsUUFBUSxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztFQUNqRDtFQUNBLFFBQVEsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFDNUMsUUFBUSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztFQUM1QyxRQUFRLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0VBQzVDLFFBQVEsTUFBTSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztFQUM3QztFQUNBLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDO0VBQzVELFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDO0VBQzVELFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDO0VBQzVELFFBQVEsT0FBTyxNQUFNLENBQUM7RUFDdEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxNQUFNLEdBQUc7RUFD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SUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUN2RixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLEtBQUssR0FBRztFQUNaLFFBQVEsT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ2xILEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxNQUFNLEdBQUc7RUFDYixRQUFRLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzlFLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksYUFBYSxHQUFHO0VBQ3BCLFFBQVEsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztFQUNuRSxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksU0FBUyxHQUFHO0VBQ2hCLFFBQVEsT0FBTyxJQUFJ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UUFBUSxPQUFPLFNBQVMsQ0FBQztFQUN6QixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFO0VBQ2pDLFFBQVEsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUN0RCxRQUFRLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDdEQsUUFBUSxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUNqQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFO0VBQ2pDLFFBQVEsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUN0RCxRQUFRLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDdEQsUUFBUSxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUNqQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFNBQVMsQ0FBQyxNQUFNLEVBQUUsY0FBYyxFQUFFO0VBQzdDLFFBQVEsTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO0VBQ2pDLFFBQVEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxNQUFN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QUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMzRSxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxRQUFRLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRTtFQUNsQyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDO0VBQzFDLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUM7RUFDMUMsUUFBUSxPQUFPLElBQUksQ0FBQztFQUNwQixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksVUFBVSxDQUFDLFdBQVcsRUFBRTtFQUM1QixRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQztFQUNoQyxRQUFRLElBQUksQ0FBQyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQztFQUNoQyxRQUFRLE9BQU8sSUFBSSxDQUFDO0VBQ3BCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxVQUFVLENBQUMsV0FBVyxFQUFFO0VBQzVCLFFBQVEsT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDM0UsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLFFBQVEsQ0FBQyxXQUFXLEVBQUU7RUFDMUIsUUFBUSxPQUFPLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMzRSxLQUFL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QUUsRUFBRSxDQUFDLENBQUM7RUFDcEQsUUFBUSxNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7RUFDcEQsUUFBUSxNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7RUFDcEQsUUFBUSxNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7RUFDcEQsUUFBUSxPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDM0MsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtFQUNyQyxRQUFRLE1BQU0sTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0VBQ3RELFFBQVEsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztFQUN0RCxRQUFRLE9BQU8sTUFBTSxDQUFDO0VBQ3RCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxTQUFTLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0VBQ2xELFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztFQUN4RCxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUM7RUFDeEQsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO0VBQ3hELFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztFQUN4RCxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sR0FBRyxHQUFHO0VBQ2pCLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztFQUMxQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sS0FBSyxHQUFHO0VBQ25CLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztFQUMxQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sSUFBSSxHQUFHO0VBQ2xCLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztFQUMxQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sS0FBSyxHQUFHO0VBQ25CLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUN0QyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sS0FBSyxHQUFHO0VBQ25CLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUN0QyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sTUFBTSxHQUFHO0VBQ3BCLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUMxQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sT0FBTyxHQUFHO0VBQ3JCLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUN0QyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sTUFBTSxHQUFHO0VBQ3BCLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUN0QyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sSUFBSSxHQUFHO0VBQ2xCLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztFQUM5QyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sSUFBSSxHQUFHO0VBQ2xCLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztFQUM1QyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sS0FBSyxHQUFHO0VBQ25CLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUN0QyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFVBQVUsQ0FBQyxNQUFNLEVBQUUsS0FBSyxHQUFHLEdBQUcsRUFBRTtFQUMzQyxRQUFRLE9BQU8sSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7RUFDL0QsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxTQUFTLENBQUMsS0FBSyxFQUFFLE1BQU0sR0FBRyxDQUFDLEVBQUU7RUFDeEMsUUFBUSxPQUFPLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ2xHLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7RUFDaEMsUUFBUSxPQUFPLElBQUksTUFBTSxDQUFDLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztFQUN0RSxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sWUFBWSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUU7RUFDdkM7RUFDQSxRQUFRLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxLQUFLLEdBQUcsQ0FBQyxFQUFFO0VBQ3pDLFlBQVksTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO0VBQy9CLFlBQVksS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsS0FBSyxJQUFJLENBQUMsRUFBRTtFQUNuRSxnQkFBZ0IsTUFBTSxRQUFRLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztFQUNqRCxnQkFBZ0IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztFQUNsRCxnQkFBZ0IsT0FBTyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO0VBQzFELGdCQUFnQixPQUFPLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7RUFDMUQsZ0JBQWdCLE9BQU8sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0VBQzVDLGFBQWE7RUFDYixZQUFZLE9BQU8sT0FBTyxDQUFDO0VBQzNCLFNBQVM7RUFDVCxRQUFRLE9BQU8sTUFBTSxDQUFDO0VBQ3RCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUU7RUFDdEIsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDMUIsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDMUIsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDMUIsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDMUIsUUFBUSxPQUFPLElBQUksQ0FBQztFQUNwQixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLE9BQU8sR0FBRztFQUNkLFFBQVEsTUFBTSxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztFQUNuQyxRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQ2hDLFFBQVEsT0FBTyxNQUFNLENBQUM7RUFDdEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFO0VBQzlCLFFBQVEsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDOUIsUUFBUSxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbEMsUUFBUSxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbEMsUUFBUSxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7RUFDbEMsUUFBUSxPQUFPLElBQUksQ0FBQztFQUNwQixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRTtFQUNmLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUNsRyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksUUFBUSxDQUFDLEtBQUssRUFBRTtFQUNwQixRQUFRLE9BQU8sSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDbEcsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksYUFBYSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7RUFDakMsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUNwQyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQ3BDLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDcEMsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUNwQyxRQUFRLE9BQU8sSUFBSSxDQUFDO0VBQ3BCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFO0VBQ2pCLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0VBQzFGLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFO0VBQzlCLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztFQUNsQyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7RUFDbEMsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0VBQ2xDLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztFQUNsQyxRQUFRLE9BQU8sSUFBSSxDQUFDO0VBQ3BCLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLGdCQUFnQixDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7RUFDcEMsUUFBUSxNQUFNLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0VBQ25DLFFBQVEsTUFBTSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztFQUNuQyxRQUFRLE1BQU0sQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7RUFDbkMsUUFBUSxNQUFNLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0VBQ25DLFFBQVEsT0FBTyxJQUFJLENBQUM7RUFDcEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxFQUFFLE1BQU0sRUFBRTtFQUN6QyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUdKLFVBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0VBQzNELFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBR0EsVUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFDM0QsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHQSxVQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztFQUMzRCxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUdBLFVBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0VBQzNELFFBQVEsT0FBTyxJQUFJLENBQUM7RUFDcEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUU7RUFDcEIsUUFBUSxPQUFPLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ2xHLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLGFBQWEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFO0VBQ2pDLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDcEMsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztFQUNwQyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0VBQ3BDLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDcEMsUUFBUSxPQUFPLE1BQU0sQ0FBQztFQUN0QixLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLFFBQVEsR0FBRztFQUNmLFFBQVEsUUFBUSxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxL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SSxPQUFPLFNBQVMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxHQUFHLENBQUMsRUFBRTtFQUN4QyxRQUFRLE9BQU8sSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQy9FLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksT0FBTyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7RUFDN0IsUUFBUSxPQUFPLElBQUksTUFBTSxDQUFDLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7RUFDM0QsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRTtFQUNwQyxRQUFRLE1BQU0sTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFDakQsUUFBUSxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0VBQ3JELFFBQVEsT0FBTyxNQUFNLENBQUM7RUFDdEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7RUFDbEQsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDO0VBQ3hELFFBQVEsTUFBTSxDQUFDLENBQUMsR0FB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S0FBSyxVQUFVLENBQUMsQ0FBQztFQUNuQyxZQUFZLElBQUksQ0FBQyxDQUFDLEtBQUssVUFBVSxDQUFDLENBQUM7RUFDbkMsWUFBWSxJQUFJLENBQUMsQ0FBQyxLQUFLLFVBQVUsQ0FBQyxDQUFDLEVBQUU7RUFDckMsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7RUFDMUIsUUFBUSxPQUFPLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0VBQzVELEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFO0VBQ2pCLFFBQVEsT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0VBQzFFLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFO0VBQzlCLFFBQVEsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztFQUNsQyxRQUFRLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7RUFDbEMsUUFBUSxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0VBQ2xDLFFBQVEsT0FBTyxJQUFJLENBQUM7RUFDcEIsS0FBSztFQUNMO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUksZ0JBQWdCLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRTtFQUNwQyxRQUFRLE1BQU0s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ckQsUUFBUSxNQUFNLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO0VBQzlCLFFBQVEsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUM1QyxRQUFRLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDNUMsUUFBUSxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQzlDLFFBQVEsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQ3ZDLFFBQVEsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDO0VBQ2pDLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLGlCQUFpQixDQUFDLFNBQVMsRUFBRSxZQUFZLEVBQUU7RUFDdEQsUUFBUSxNQUFNLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO0VBQzlCLFFBQVEsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUM1QyxRQUFRLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDNUMsUUFBUSxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzdDLFFBQVEsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQ3ZDLFFBQVEsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDO0VBQ2pDLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxZQUFZLEVBQUU7RUFDdkQsUUFBUSxNQUFNLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO0VBQzlCLFFBQVEsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUM1QyxRQUFRLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDNUMsUUFBUSxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzdDLFFBQVEsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQ3ZDLFFBQVEsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDO0VBQ2pDLEtBQUs7RUFDTDtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsSUFBSSxPQUFPLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxZQUFZLEVBQUU7RUFDckQsUUFBUSxNQUFNLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO0VBQzlCLFFBQVEsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUM1QyxRQUFRLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDNUMsUUFBUSxZQUFZLENB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QUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUN6QyxTQUFTO0VBQ1QsUUFBUSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0VBQ25DLFFBQVEsT0FBTyxJQUFJLENBQUM7RUFDcEIsS0FBSztFQUNMO0VBQ0EsSUFBSSxRQUFRLENBQUMsV0FBVyxFQUFFO0VBQzFCLFFBQVEsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7RUFDckM7RUFDQSxRQUFRLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzNELFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7RUFDeEIsWUFBWSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO0VBQzFDLFNBQVM7RUFDVCxRQUFRLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ2hGLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7RUFDeEIsWUFBWSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztFQUM5QyxTQUFTO0VBQ1Q7RUFDQSxRQUFRLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDdEMsUUFBUSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLFdB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QSxLQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxHQUFBO1dBQ3BDLENBQUMsQ0FBQTtVQUVGLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUU7Y0FDeEMsR0FBRyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxHQUFBO1dBQ3BDLENBQUMsQ0FBQTtVQUVGLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUU7Y0FDN0MsR0FBRyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxHQUFBO1dBQ3pDLENBQUMsQ0FBQTtVQUVGLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUU7Y0FDN0MsR0FBRyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxHQUFBO1dBQ3pDLENBQUMsQ0FBQTtVQUVGLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUU7Y0FDN0MsR0FBRyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxHQUFBO1dBQ3pDLENBQUMsQ0FBQTtVQUVGLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUU7Y0FDNUMsR0FBRyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxHQUFBO1dBQ3BDLENBQUMsQ0FBQTtVQUVGLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUU7Y0FDNUMsR0FBRyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxHQUFHLEtBQUksQ0FBQyxZQUFZLEdBQUE7V0FDeEQsQ0FBQyxDQUFBO1VBRUYsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRTtj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QW1CLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQTtFQUVuQztFQUNBLElBQUksT0FBTyxHQUFHLEtBQUssV0FBVyxFQUFFO01BQzlCLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxpQ0FBaUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQTtNQUN0RSxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQTtHQUMzQjtFQVFEO0VBQ0EsTUFBTSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsQ0FBQTtFQUNqQztFQUNBLE1BQU0sQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsQ0FBQTtFQUNwQztFQUNBLE1BQU0sQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=\n",
    "sha256": "ecadb93b614c75d4adcaef27387e0ffe83fc264add2e55fde915fd78f27472f5"
  },
  {
    "path": "node_modules/colyseus.js/dist/colyseus.js",
    "content": "// colyseus.js@0.14.13 (@colyseus/schema 1.0.25)\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define('colyseus.js', ['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Colyseus = {}));\n}(this, (function (exports) { 'use strict';\n\n    //\n    // Polyfills for legacy environments\n    //\n    /*\n     * Support Android 4.4.x\n     */\n    if (!ArrayBuffer.isView) {\n        ArrayBuffer.isView = function (a) {\n            return a !== null && typeof (a) === 'object' && a.buffer instanceof ArrayBuffer;\n        };\n    }\n    // Define globalThis if not available.\n    // https://github.com/colyseus/colyseus.js/issues/86\n    if (typeof (globalThis) === \"undefined\" &&\n        typeof (window) !== \"undefined\") {\n        // @ts-ignore\n        window['globalThis'] = window;\n    }\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\n\n    function apply(src, tar) {\n    \ttar.headers = src.headers || {};\n    \ttar.statusMessage = src.statusText;\n    \ttar.statusCode = src.status;\n    \ttar.data = src.response;\n    }\n\n    function send(method, uri, opts) {\n    \treturn new Promise(function (res, rej) {\n    \t\topts = opts || {};\n    \t\tvar req = new XMLHttpRequest;\n    \t\tvar k, tmp, arr, str=opts.body;\n    \t\tvar headers = opts.headers || {};\n\n    \t\t// IE compatible\n    \t\tif (opts.timeout) req.timeout = opts.timeout;\n    \t\treq.ontimeout = req.onerror = function (err) {\n    \t\t\terr.timeout = err.type == 'timeout';\n    \t\t\trej(err);\n    \t\t};\n\n    \t\treq.open(method, uri.href || uri);\n\n    \t\treq.onload = function () {\n    \t\t\tarr = req.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n    \t\t\tapply(req, req); //=> req.headers\n\n    \t\t\twhile (tmp = arr.shift()) {\n    \t\t\t\ttmp = tmp.split(': ');\n    \t\t\t\treq.headers[tmp.shift().toLowerCase()] = tmp.join(': ');\n    \t\t\t}\n\n    \t\t\ttmp = req.headers['content-type'];\n    \t\t\tif (tmp && !!~tmp.indexOf('application/json')) {\n    \t\t\t\ttry {\n    \t\t\t\t\treq.data = JSON.parse(req.data, opts.reviver);\n    \t\t\t\t} catch (err) {\n    \t\t\t\t\tapply(req, err);\n    \t\t\t\t\treturn rej(err);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t\t(req.status >= 400 ? rej : res)(req);\n    \t\t};\n\n    \t\tif (typeof FormData < 'u' && str instanceof FormData) ; else if (str && typeof str == 'object') {\n    \t\t\theaders['content-type'] = 'application/json';\n    \t\t\tstr = JSON.stringify(str);\n    \t\t}\n\n    \t\treq.withCredentials = !!opts.withCredentials;\n\n    \t\tfor (k in headers) {\n    \t\t\treq.setRequestHeader(k, headers[k]);\n    \t\t}\n\n    \t\treq.send(str);\n    \t});\n    }\n\n    var get = /*#__PURE__*/ send.bind(send, 'GET');\n    var post = /*#__PURE__*/ send.bind(send, 'POST');\n    var patch = /*#__PURE__*/ send.bind(send, 'PATCH');\n    var del = /*#__PURE__*/ send.bind(send, 'DELETE');\n    var put = /*#__PURE__*/ send.bind(send, 'PUT');\n\n    var del_1 = del;\n    var get_1 = get;\n    var patch_1 = patch;\n    var post_1 = post;\n    var put_1 = put;\n    var send_1 = send;\n\n    var xhr = {\n    \tdel: del_1,\n    \tget: get_1,\n    \tpatch: patch_1,\n    \tpost: post_1,\n    \tput: put_1,\n    \tsend: send_1\n    };\n\n    var http = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), xhr, {\n        'default': xhr,\n        del: del_1,\n        get: get_1,\n        patch: patch_1,\n        post: post_1,\n        put: put_1,\n        send: send_1\n    }));\n\n    var ServerError = /** @class */ (function (_super) {\n        __extends(ServerError, _super);\n        function ServerError(code, message) {\n            var _this = _super.call(this, message) || this;\n            _this.name = \"ServerError\";\n            _this.code = code;\n            return _this;\n        }\n        return ServerError;\n    }(Error));\n\n    /**\n     * Copyright (c) 2014 Ion Drive Software Ltd.\n     * https://github.com/darrachequesne/notepack/\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * Patch for Colyseus:\n     * -------------------\n     *\n     * added `offset` on Decoder constructor, for messages arriving with a code\n     * before actual msgpack data\n     */\n    // \n    // DECODER\n    // \n    function Decoder(buffer, offset) {\n        this._offset = offset;\n        if (buffer instanceof ArrayBuffer) {\n            this._buffer = buffer;\n            this._view = new DataView(this._buffer);\n        }\n        else if (ArrayBuffer.isView(buffer)) {\n            this._buffer = buffer.buffer;\n            this._view = new DataView(this._buffer, buffer.byteOffset, buffer.byteLength);\n        }\n        else {\n            throw new Error('Invalid argument');\n        }\n    }\n    function utf8Read$1(view, offset, length) {\n        var string = '', chr = 0;\n        for (var i = offset, end = offset + length; i < end; i++) {\n            var byte = view.getUint8(i);\n            if ((byte & 0x80) === 0x00) {\n                string += String.fromCharCode(byte);\n                continue;\n            }\n            if ((byte & 0xe0) === 0xc0) {\n                string += String.fromCharCode(((byte & 0x1f) << 6) |\n                    (view.getUint8(++i) & 0x3f));\n                continue;\n            }\n            if ((byte & 0xf0) === 0xe0) {\n                string += String.fromCharCode(((byte & 0x0f) << 12) |\n                    ((view.getUint8(++i) & 0x3f) << 6) |\n                    ((view.getUint8(++i) & 0x3f) << 0));\n                continue;\n            }\n            if ((byte & 0xf8) === 0xf0) {\n                chr = ((byte & 0x07) << 18) |\n                    ((view.getUint8(++i) & 0x3f) << 12) |\n                    ((view.getUint8(++i) & 0x3f) << 6) |\n                    ((view.getUint8(++i) & 0x3f) << 0);\n                if (chr >= 0x010000) { // surrogate pair\n                    chr -= 0x010000;\n                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n                }\n                else {\n                    string += String.fromCharCode(chr);\n                }\n                continue;\n            }\n            throw new Error('Invalid byte ' + byte.toString(16));\n        }\n        return string;\n    }\n    Decoder.prototype._array = function (length) {\n        var value = new Array(length);\n        for (var i = 0; i < length; i++) {\n            value[i] = this._parse();\n        }\n        return value;\n    };\n    Decoder.prototype._map = function (length) {\n        var key = '', value = {};\n        for (var i = 0; i < length; i++) {\n            key = this._parse();\n            value[key] = this._parse();\n        }\n        return value;\n    };\n    Decoder.prototype._str = function (length) {\n        var value = utf8Read$1(this._view, this._offset, length);\n        this._offset += length;\n        return value;\n    };\n    Decoder.prototype._bin = function (length) {\n        var value = this._buffer.slice(this._offset, this._offset + length);\n        this._offset += length;\n        return value;\n    };\n    Decoder.prototype._parse = function () {\n        var prefix = this._view.getUint8(this._offset++);\n        var value, length = 0, type = 0, hi = 0, lo = 0;\n        if (prefix < 0xc0) {\n            // positive fixint\n            if (prefix < 0x80) {\n                return prefix;\n            }\n            // fixmap\n            if (prefix < 0x90) {\n                return this._map(prefix & 0x0f);\n            }\n            // fixarray\n            if (prefix < 0xa0) {\n                return this._array(prefix & 0x0f);\n            }\n            // fixstr\n            return this._str(prefix & 0x1f);\n        }\n        // negative fixint\n        if (prefix > 0xdf) {\n            return (0xff - prefix + 1) * -1;\n        }\n        switch (prefix) {\n            // nil\n            case 0xc0:\n                return null;\n            // false\n            case 0xc2:\n                return false;\n            // true\n            case 0xc3:\n                return true;\n            // bin\n            case 0xc4:\n                length = this._view.getUint8(this._offset);\n                this._offset += 1;\n                return this._bin(length);\n            case 0xc5:\n                length = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return this._bin(length);\n            case 0xc6:\n                length = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return this._bin(length);\n            // ext\n            case 0xc7:\n                length = this._view.getUint8(this._offset);\n                type = this._view.getInt8(this._offset + 1);\n                this._offset += 2;\n                return [type, this._bin(length)];\n            case 0xc8:\n                length = this._view.getUint16(this._offset);\n                type = this._view.getInt8(this._offset + 2);\n                this._offset += 3;\n                return [type, this._bin(length)];\n            case 0xc9:\n                length = this._view.getUint32(this._offset);\n                type = this._view.getInt8(this._offset + 4);\n                this._offset += 5;\n                return [type, this._bin(length)];\n            // float\n            case 0xca:\n                value = this._view.getFloat32(this._offset);\n                this._offset += 4;\n                return value;\n            case 0xcb:\n                value = this._view.getFloat64(this._offset);\n                this._offset += 8;\n                return value;\n            // uint\n            case 0xcc:\n                value = this._view.getUint8(this._offset);\n                this._offset += 1;\n                return value;\n            case 0xcd:\n                value = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return value;\n            case 0xce:\n                value = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return value;\n            case 0xcf:\n                hi = this._view.getUint32(this._offset) * Math.pow(2, 32);\n                lo = this._view.getUint32(this._offset + 4);\n                this._offset += 8;\n                return hi + lo;\n            // int\n            case 0xd0:\n                value = this._view.getInt8(this._offset);\n                this._offset += 1;\n                return value;\n            case 0xd1:\n                value = this._view.getInt16(this._offset);\n                this._offset += 2;\n                return value;\n            case 0xd2:\n                value = this._view.getInt32(this._offset);\n                this._offset += 4;\n                return value;\n            case 0xd3:\n                hi = this._view.getInt32(this._offset) * Math.pow(2, 32);\n                lo = this._view.getUint32(this._offset + 4);\n                this._offset += 8;\n                return hi + lo;\n            // fixext\n            case 0xd4:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                if (type === 0x00) {\n                    this._offset += 1;\n                    return void 0;\n                }\n                return [type, this._bin(1)];\n            case 0xd5:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                return [type, this._bin(2)];\n            case 0xd6:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                return [type, this._bin(4)];\n            case 0xd7:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                if (type === 0x00) {\n                    hi = this._view.getInt32(this._offset) * Math.pow(2, 32);\n                    lo = this._view.getUint32(this._offset + 4);\n                    this._offset += 8;\n                    return new Date(hi + lo);\n                }\n                return [type, this._bin(8)];\n            case 0xd8:\n                type = this._view.getInt8(this._offset);\n                this._offset += 1;\n                return [type, this._bin(16)];\n            // str\n            case 0xd9:\n                length = this._view.getUint8(this._offset);\n                this._offset += 1;\n                return this._str(length);\n            case 0xda:\n                length = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return this._str(length);\n            case 0xdb:\n                length = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return this._str(length);\n            // array\n            case 0xdc:\n                length = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return this._array(length);\n            case 0xdd:\n                length = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return this._array(length);\n            // map\n            case 0xde:\n                length = this._view.getUint16(this._offset);\n                this._offset += 2;\n                return this._map(length);\n            case 0xdf:\n                length = this._view.getUint32(this._offset);\n                this._offset += 4;\n                return this._map(length);\n        }\n        throw new Error('Could not parse');\n    };\n    function decode(buffer, offset) {\n        if (offset === void 0) { offset = 0; }\n        var decoder = new Decoder(buffer, offset);\n        var value = decoder._parse();\n        if (decoder._offset !== buffer.byteLength) {\n            throw new Error((buffer.byteLength - decoder._offset) + ' trailing bytes');\n        }\n        return value;\n    }\n    // \n    // ENCODER\n    // \n    function utf8Write(view, offset, str) {\n        var c = 0;\n        for (var i = 0, l = str.length; i < l; i++) {\n            c = str.charCodeAt(i);\n            if (c < 0x80) {\n                view.setUint8(offset++, c);\n            }\n            else if (c < 0x800) {\n                view.setUint8(offset++, 0xc0 | (c >> 6));\n                view.setUint8(offset++, 0x80 | (c & 0x3f));\n            }\n            else if (c < 0xd800 || c >= 0xe000) {\n                view.setUint8(offset++, 0xe0 | (c >> 12));\n                view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);\n                view.setUint8(offset++, 0x80 | (c & 0x3f));\n            }\n            else {\n                i++;\n                c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n                view.setUint8(offset++, 0xf0 | (c >> 18));\n                view.setUint8(offset++, 0x80 | (c >> 12) & 0x3f);\n                view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);\n                view.setUint8(offset++, 0x80 | (c & 0x3f));\n            }\n        }\n    }\n    function utf8Length$1(str) {\n        var c = 0, length = 0;\n        for (var i = 0, l = str.length; i < l; i++) {\n            c = str.charCodeAt(i);\n            if (c < 0x80) {\n                length += 1;\n            }\n            else if (c < 0x800) {\n                length += 2;\n            }\n            else if (c < 0xd800 || c >= 0xe000) {\n                length += 3;\n            }\n            else {\n                i++;\n                length += 4;\n            }\n        }\n        return length;\n    }\n    function _encode(bytes, defers, value) {\n        var type = typeof value, i = 0, l = 0, hi = 0, lo = 0, length = 0, size = 0;\n        if (type === 'string') {\n            length = utf8Length$1(value);\n            // fixstr\n            if (length < 0x20) {\n                bytes.push(length | 0xa0);\n                size = 1;\n            }\n            // str 8\n            else if (length < 0x100) {\n                bytes.push(0xd9, length);\n                size = 2;\n            }\n            // str 16\n            else if (length < 0x10000) {\n                bytes.push(0xda, length >> 8, length);\n                size = 3;\n            }\n            // str 32\n            else if (length < 0x100000000) {\n                bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);\n                size = 5;\n            }\n            else {\n                throw new Error('String too long');\n            }\n            defers.push({ _str: value, _length: length, _offset: bytes.length });\n            return size + length;\n        }\n        if (type === 'number') {\n            // TODO: encode to float 32?\n            // float 64\n            if (Math.floor(value) !== value || !isFinite(value)) {\n                bytes.push(0xcb);\n                defers.push({ _float: value, _length: 8, _offset: bytes.length });\n                return 9;\n            }\n            if (value >= 0) {\n                // positive fixnum\n                if (value < 0x80) {\n                    bytes.push(value);\n                    return 1;\n                }\n                // uint 8\n                if (value < 0x100) {\n                    bytes.push(0xcc, value);\n                    return 2;\n                }\n                // uint 16\n                if (value < 0x10000) {\n                    bytes.push(0xcd, value >> 8, value);\n                    return 3;\n                }\n                // uint 32\n                if (value < 0x100000000) {\n                    bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);\n                    return 5;\n                }\n                // uint 64\n                hi = (value / Math.pow(2, 32)) >> 0;\n                lo = value >>> 0;\n                bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n                return 9;\n            }\n            else {\n                // negative fixnum\n                if (value >= -0x20) {\n                    bytes.push(value);\n                    return 1;\n                }\n                // int 8\n                if (value >= -0x80) {\n                    bytes.push(0xd0, value);\n                    return 2;\n                }\n                // int 16\n                if (value >= -0x8000) {\n                    bytes.push(0xd1, value >> 8, value);\n                    return 3;\n                }\n                // int 32\n                if (value >= -0x80000000) {\n                    bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);\n                    return 5;\n                }\n                // int 64\n                hi = Math.floor(value / Math.pow(2, 32));\n                lo = value >>> 0;\n                bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n                return 9;\n            }\n        }\n        if (type === 'object') {\n            // nil\n            if (value === null) {\n                bytes.push(0xc0);\n                return 1;\n            }\n            if (Array.isArray(value)) {\n                length = value.length;\n                // fixarray\n                if (length < 0x10) {\n                    bytes.push(length | 0x90);\n                    size = 1;\n                }\n                // array 16\n                else if (length < 0x10000) {\n                    bytes.push(0xdc, length >> 8, length);\n                    size = 3;\n                }\n                // array 32\n                else if (length < 0x100000000) {\n                    bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);\n                    size = 5;\n                }\n                else {\n                    throw new Error('Array too large');\n                }\n                for (i = 0; i < length; i++) {\n                    size += _encode(bytes, defers, value[i]);\n                }\n                return size;\n            }\n            // fixext 8 / Date\n            if (value instanceof Date) {\n                var time = value.getTime();\n                hi = Math.floor(time / Math.pow(2, 32));\n                lo = time >>> 0;\n                bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n                return 10;\n            }\n            if (value instanceof ArrayBuffer) {\n                length = value.byteLength;\n                // bin 8\n                if (length < 0x100) {\n                    bytes.push(0xc4, length);\n                    size = 2;\n                }\n                else \n                // bin 16\n                if (length < 0x10000) {\n                    bytes.push(0xc5, length >> 8, length);\n                    size = 3;\n                }\n                else \n                // bin 32\n                if (length < 0x100000000) {\n                    bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);\n                    size = 5;\n                }\n                else {\n                    throw new Error('Buffer too large');\n                }\n                defers.push({ _bin: value, _length: length, _offset: bytes.length });\n                return size + length;\n            }\n            if (typeof value.toJSON === 'function') {\n                return _encode(bytes, defers, value.toJSON());\n            }\n            var keys = [], key = '';\n            var allKeys = Object.keys(value);\n            for (i = 0, l = allKeys.length; i < l; i++) {\n                key = allKeys[i];\n                if (typeof value[key] !== 'function') {\n                    keys.push(key);\n                }\n            }\n            length = keys.length;\n            // fixmap\n            if (length < 0x10) {\n                bytes.push(length | 0x80);\n                size = 1;\n            }\n            // map 16\n            else if (length < 0x10000) {\n                bytes.push(0xde, length >> 8, length);\n                size = 3;\n            }\n            // map 32\n            else if (length < 0x100000000) {\n                bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);\n                size = 5;\n            }\n            else {\n                throw new Error('Object too large');\n            }\n            for (i = 0; i < length; i++) {\n                key = keys[i];\n                size += _encode(bytes, defers, key);\n                size += _encode(bytes, defers, value[key]);\n            }\n            return size;\n        }\n        // false/true\n        if (type === 'boolean') {\n            bytes.push(value ? 0xc3 : 0xc2);\n            return 1;\n        }\n        // fixext 1 / undefined\n        if (type === 'undefined') {\n            bytes.push(0xd4, 0, 0);\n            return 3;\n        }\n        throw new Error('Could not encode');\n    }\n    function encode(value) {\n        var bytes = [];\n        var defers = [];\n        var size = _encode(bytes, defers, value);\n        var buf = new ArrayBuffer(size);\n        var view = new DataView(buf);\n        var deferIndex = 0;\n        var deferWritten = 0;\n        var nextOffset = -1;\n        if (defers.length > 0) {\n            nextOffset = defers[0]._offset;\n        }\n        var defer, deferLength = 0, offset = 0;\n        for (var i = 0, l = bytes.length; i < l; i++) {\n            view.setUint8(deferWritten + i, bytes[i]);\n            if (i + 1 !== nextOffset) {\n                continue;\n            }\n            defer = defers[deferIndex];\n            deferLength = defer._length;\n            offset = deferWritten + nextOffset;\n            if (defer._bin) {\n                var bin = new Uint8Array(defer._bin);\n                for (var j = 0; j < deferLength; j++) {\n                    view.setUint8(offset + j, bin[j]);\n                }\n            }\n            else if (defer._str) {\n                utf8Write(view, offset, defer._str);\n            }\n            else if (defer._float !== undefined) {\n                view.setFloat64(offset, defer._float);\n            }\n            deferIndex++;\n            deferWritten += deferLength;\n            if (defers[deferIndex]) {\n                nextOffset = defers[deferIndex]._offset;\n            }\n        }\n        return buf;\n    }\n\n    var browser = function () {\n      throw new Error(\n        'ws does not work in the browser. Browser clients must use the native ' +\n          'WebSocket object'\n      );\n    };\n\n    var WebSocket = globalThis.WebSocket || browser;\n    var WebSocketTransport = /** @class */ (function () {\n        function WebSocketTransport(events) {\n            this.events = events;\n        }\n        WebSocketTransport.prototype.send = function (data) {\n            if (data instanceof ArrayBuffer) {\n                this.ws.send(data);\n            }\n            else if (Array.isArray(data)) {\n                this.ws.send((new Uint8Array(data)).buffer);\n            }\n        };\n        WebSocketTransport.prototype.connect = function (url) {\n            this.ws = new WebSocket(url, this.protocols);\n            this.ws.binaryType = 'arraybuffer';\n            this.ws.onopen = this.events.onopen;\n            this.ws.onmessage = this.events.onmessage;\n            this.ws.onclose = this.events.onclose;\n            this.ws.onerror = this.events.onerror;\n        };\n        WebSocketTransport.prototype.close = function (code, reason) {\n            this.ws.close(code, reason);\n        };\n        return WebSocketTransport;\n    }());\n\n    var Connection = /** @class */ (function () {\n        function Connection() {\n            this.events = {};\n            this.transport = new WebSocketTransport(this.events);\n        }\n        Connection.prototype.send = function (data) {\n            this.transport.send(data);\n        };\n        Connection.prototype.connect = function (url) {\n            this.transport.connect(url);\n        };\n        Connection.prototype.close = function (code, reason) {\n            this.transport.close(code, reason);\n        };\n        return Connection;\n    }());\n\n    var serializers = {};\n    function registerSerializer(id, serializer) {\n        serializers[id] = serializer;\n    }\n    function getSerializer(id) {\n        var serializer = serializers[id];\n        if (!serializer) {\n            throw new Error(\"missing serializer: \" + id);\n        }\n        return serializer;\n    }\n\n    // Use codes between 0~127 for lesser throughput (1 byte)\n    exports.Protocol = void 0;\n    (function (Protocol) {\n        // Room-related (10~19)\n        Protocol[Protocol[\"HANDSHAKE\"] = 9] = \"HANDSHAKE\";\n        Protocol[Protocol[\"JOIN_ROOM\"] = 10] = \"JOIN_ROOM\";\n        Protocol[Protocol[\"ERROR\"] = 11] = \"ERROR\";\n        Protocol[Protocol[\"LEAVE_ROOM\"] = 12] = \"LEAVE_ROOM\";\n        Protocol[Protocol[\"ROOM_DATA\"] = 13] = \"ROOM_DATA\";\n        Protocol[Protocol[\"ROOM_STATE\"] = 14] = \"ROOM_STATE\";\n        Protocol[Protocol[\"ROOM_STATE_PATCH\"] = 15] = \"ROOM_STATE_PATCH\";\n        Protocol[Protocol[\"ROOM_DATA_SCHEMA\"] = 16] = \"ROOM_DATA_SCHEMA\";\n    })(exports.Protocol || (exports.Protocol = {}));\n    exports.ErrorCode = void 0;\n    (function (ErrorCode) {\n        ErrorCode[ErrorCode[\"MATCHMAKE_NO_HANDLER\"] = 4210] = \"MATCHMAKE_NO_HANDLER\";\n        ErrorCode[ErrorCode[\"MATCHMAKE_INVALID_CRITERIA\"] = 4211] = \"MATCHMAKE_INVALID_CRITERIA\";\n        ErrorCode[ErrorCode[\"MATCHMAKE_INVALID_ROOM_ID\"] = 4212] = \"MATCHMAKE_INVALID_ROOM_ID\";\n        ErrorCode[ErrorCode[\"MATCHMAKE_UNHANDLED\"] = 4213] = \"MATCHMAKE_UNHANDLED\";\n        ErrorCode[ErrorCode[\"MATCHMAKE_EXPIRED\"] = 4214] = \"MATCHMAKE_EXPIRED\";\n        ErrorCode[ErrorCode[\"AUTH_FAILED\"] = 4215] = \"AUTH_FAILED\";\n        ErrorCode[ErrorCode[\"APPLICATION_ERROR\"] = 4216] = \"APPLICATION_ERROR\";\n    })(exports.ErrorCode || (exports.ErrorCode = {}));\n    function utf8Read(view, offset) {\n        var length = view[offset++];\n        var string = '', chr = 0;\n        for (var i = offset, end = offset + length; i < end; i++) {\n            var byte = view[i];\n            if ((byte & 0x80) === 0x00) {\n                string += String.fromCharCode(byte);\n                continue;\n            }\n            if ((byte & 0xe0) === 0xc0) {\n                string += String.fromCharCode(((byte & 0x1f) << 6) |\n                    (view[++i] & 0x3f));\n                continue;\n            }\n            if ((byte & 0xf0) === 0xe0) {\n                string += String.fromCharCode(((byte & 0x0f) << 12) |\n                    ((view[++i] & 0x3f) << 6) |\n                    ((view[++i] & 0x3f) << 0));\n                continue;\n            }\n            if ((byte & 0xf8) === 0xf0) {\n                chr = ((byte & 0x07) << 18) |\n                    ((view[++i] & 0x3f) << 12) |\n                    ((view[++i] & 0x3f) << 6) |\n                    ((view[++i] & 0x3f) << 0);\n                if (chr >= 0x010000) { // surrogate pair\n                    chr -= 0x010000;\n                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n                }\n                else {\n                    string += String.fromCharCode(chr);\n                }\n                continue;\n            }\n            throw new Error('Invalid byte ' + byte.toString(16));\n        }\n        return string;\n    }\n    // Faster for short strings than Buffer.byteLength\n    function utf8Length(str) {\n        if (str === void 0) { str = ''; }\n        var c = 0;\n        var length = 0;\n        for (var i = 0, l = str.length; i < l; i++) {\n            c = str.charCodeAt(i);\n            if (c < 0x80) {\n                length += 1;\n            }\n            else if (c < 0x800) {\n                length += 2;\n            }\n            else if (c < 0xd800 || c >= 0xe000) {\n                length += 3;\n            }\n            else {\n                i++;\n                length += 4;\n            }\n        }\n        return length + 1;\n    }\n\n    let createNanoEvents = () => ({\n      events: {},\n      emit(event, ...args) {\n    (this.events[event] || []).forEach(i => i(...args));\n      },\n      on(event, cb) {\n    (this.events[event] = this.events[event] || []).push(cb);\n        return () =>\n          (this.events[event] = (this.events[event] || []).filter(i => i !== cb))\n      }\n    });\n\n    var EventEmitter = /** @class */ (function () {\n        function EventEmitter() {\n            this.handlers = [];\n        }\n        EventEmitter.prototype.register = function (cb, once) {\n            this.handlers.push(cb);\n            return this;\n        };\n        EventEmitter.prototype.invoke = function () {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            this.handlers.forEach(function (handler) { return handler.apply(_this, args); });\n        };\n        EventEmitter.prototype.invokeAsync = function () {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return Promise.all(this.handlers.map(function (handler) { return handler.apply(_this, args); }));\n        };\n        EventEmitter.prototype.remove = function (cb) {\n            var index = this.handlers.indexOf(cb);\n            this.handlers[index] = this.handlers[this.handlers.length - 1];\n            this.handlers.pop();\n        };\n        EventEmitter.prototype.clear = function () {\n            this.handlers = [];\n        };\n        return EventEmitter;\n    }());\n    function createSignal() {\n        var emitter = new EventEmitter();\n        function register(cb) {\n            return emitter.register(cb, this === null);\n        }\n        register.once = function (cb) {\n            var callback = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                cb.apply(this, args);\n                emitter.remove(callback);\n            };\n            emitter.register(callback);\n        };\n        register.remove = function (cb) { return emitter.remove(cb); };\n        register.invoke = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return emitter.invoke.apply(emitter, args);\n        };\n        register.invokeAsync = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return emitter.invokeAsync.apply(emitter, args);\n        };\n        register.clear = function () { return emitter.clear(); };\n        return register;\n    }\n\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n    function createCommonjsModule(fn) {\n      var module = { exports: {} };\n    \treturn fn(module, module.exports), module.exports;\n    }\n\n    var umd = createCommonjsModule(function (module, exports) {\n    (function (global, factory) {\n        factory(exports) ;\n    }(commonjsGlobal, (function (exports) {\n        /*! *****************************************************************************\r\n        Copyright (c) Microsoft Corporation.\r\n\r\n        Permission to use, copy, modify, and/or distribute this software for any\r\n        purpose with or without fee is hereby granted.\r\n\r\n        THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n        PERFORMANCE OF THIS SOFTWARE.\r\n        ***************************************************************************** */\r\n        /* global Reflect, Promise */\r\n\r\n        var extendStatics = function(d, b) {\r\n            extendStatics = Object.setPrototypeOf ||\r\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n            return extendStatics(d, b);\r\n        };\r\n\r\n        function __extends(d, b) {\r\n            if (typeof b !== \"function\" && b !== null)\r\n                throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n            extendStatics(d, b);\r\n            function __() { this.constructor = d; }\r\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n        }\r\n\r\n        function __decorate(decorators, target, key, desc) {\r\n            var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n            if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n            else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n            return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n        }\r\n\r\n        function __spreadArray(to, from) {\r\n            for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n                to[j] = from[i];\r\n            return to;\r\n        }\n\n        // export const SWITCH_TO_STRUCTURE = 193; (easily collides with DELETE_AND_ADD + fieldIndex = 2)\n        var SWITCH_TO_STRUCTURE = 255; // (decoding collides with DELETE_AND_ADD + fieldIndex = 63)\n        var TYPE_ID = 213;\n        /**\n         * Encoding Schema field operations.\n         */\n        exports.OPERATION = void 0;\n        (function (OPERATION) {\n            // add new structure/primitive\n            OPERATION[OPERATION[\"ADD\"] = 128] = \"ADD\";\n            // replace structure/primitive\n            OPERATION[OPERATION[\"REPLACE\"] = 0] = \"REPLACE\";\n            // delete field\n            OPERATION[OPERATION[\"DELETE\"] = 64] = \"DELETE\";\n            // DELETE field, followed by an ADD\n            OPERATION[OPERATION[\"DELETE_AND_ADD\"] = 192] = \"DELETE_AND_ADD\";\n            // TOUCH is used to determine hierarchy of nested Schema structures during serialization.\n            // touches are NOT encoded.\n            OPERATION[OPERATION[\"TOUCH\"] = 1] = \"TOUCH\";\n            // MapSchema Operations\n            OPERATION[OPERATION[\"CLEAR\"] = 10] = \"CLEAR\";\n        })(exports.OPERATION || (exports.OPERATION = {}));\n        // export enum OPERATION {\n        //     // add new structure/primitive\n        //     // (128)\n        //     ADD = 128, // 10000000,\n        //     // replace structure/primitive\n        //     REPLACE = 1,// 00000001\n        //     // delete field\n        //     DELETE = 192, // 11000000\n        //     // DELETE field, followed by an ADD\n        //     DELETE_AND_ADD = 224, // 11100000\n        //     // TOUCH is used to determine hierarchy of nested Schema structures during serialization.\n        //     // touches are NOT encoded.\n        //     TOUCH = 0, // 00000000\n        //     // MapSchema Operations\n        //     CLEAR = 10,\n        // }\n\n        //\n        // Root holds all schema references by unique id\n        //\n        var Root = /** @class */ (function () {\n            function Root() {\n                //\n                // Relation of refId => Schema structure\n                // For direct access of structures during decoding time.\n                //\n                this.refs = new Map();\n                this.refCounts = {};\n                this.deletedRefs = new Set();\n                this.nextUniqueId = 0;\n            }\n            Root.prototype.getNextUniqueId = function () {\n                return this.nextUniqueId++;\n            };\n            // for decoding\n            Root.prototype.addRef = function (refId, ref, incrementCount) {\n                if (incrementCount === void 0) { incrementCount = true; }\n                this.refs.set(refId, ref);\n                if (incrementCount) {\n                    this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;\n                }\n            };\n            // for decoding\n            Root.prototype.removeRef = function (refId) {\n                this.refCounts[refId] = this.refCounts[refId] - 1;\n                this.deletedRefs.add(refId);\n            };\n            Root.prototype.clearRefs = function () {\n                this.refs.clear();\n                this.deletedRefs.clear();\n                this.refCounts = {};\n            };\n            // for decoding\n            Root.prototype.garbageCollectDeletedRefs = function () {\n                var _this = this;\n                this.deletedRefs.forEach(function (refId) {\n                    if (_this.refCounts[refId] <= 0) {\n                        var ref = _this.refs.get(refId);\n                        //\n                        // Ensure child schema instances have their references removed as well.\n                        //\n                        if (ref instanceof Schema) {\n                            for (var fieldName in ref['_definition'].schema) {\n                                if (typeof (ref['_definition'].schema[fieldName]) !== \"string\" &&\n                                    ref[fieldName] &&\n                                    ref[fieldName]['$changes']) {\n                                    _this.removeRef(ref[fieldName]['$changes'].refId);\n                                }\n                            }\n                        }\n                        else {\n                            var definition = ref['$changes'].parent._definition;\n                            var type = definition.schema[definition.fieldsByIndex[ref['$changes'].parentIndex]];\n                            if (typeof (Object.values(type)[0]) === \"function\") {\n                                Array.from(ref.values())\n                                    .forEach(function (child) { return _this.removeRef(child['$changes'].refId); });\n                            }\n                        }\n                        _this.refs.delete(refId);\n                        delete _this.refCounts[refId];\n                    }\n                });\n                // clear deleted refs.\n                this.deletedRefs.clear();\n            };\n            return Root;\n        }());\n        var ChangeTree = /** @class */ (function () {\n            function ChangeTree(ref, parent, root) {\n                this.changed = false;\n                this.changes = new Map();\n                this.allChanges = new Set();\n                // cached indexes for filtering\n                this.caches = {};\n                this.currentCustomOperation = 0;\n                this.ref = ref;\n                this.setParent(parent, root);\n            }\n            ChangeTree.prototype.setParent = function (parent, root, parentIndex) {\n                var _this = this;\n                if (!this.indexes) {\n                    this.indexes = (this.ref instanceof Schema)\n                        ? this.ref['_definition'].indexes\n                        : {};\n                }\n                this.parent = parent;\n                this.parentIndex = parentIndex;\n                // avoid setting parents with empty `root`\n                if (!root) {\n                    return;\n                }\n                this.root = root;\n                //\n                // assign same parent on child structures\n                //\n                if (this.ref instanceof Schema) {\n                    var definition = this.ref['_definition'];\n                    for (var field in definition.schema) {\n                        var value = this.ref[field];\n                        if (value && value['$changes']) {\n                            var parentIndex_1 = definition.indexes[field];\n                            value['$changes'].setParent(this.ref, root, parentIndex_1);\n                        }\n                    }\n                }\n                else if (typeof (this.ref) === \"object\") {\n                    this.ref.forEach(function (value, key) {\n                        if (value instanceof Schema) {\n                            var changeTreee = value['$changes'];\n                            var parentIndex_2 = _this.ref['$changes'].indexes[key];\n                            changeTreee.setParent(_this.ref, _this.root, parentIndex_2);\n                        }\n                    });\n                }\n            };\n            ChangeTree.prototype.operation = function (op) {\n                this.changes.set(--this.currentCustomOperation, op);\n            };\n            ChangeTree.prototype.change = function (fieldName, operation) {\n                if (operation === void 0) { operation = exports.OPERATION.ADD; }\n                var index = (typeof (fieldName) === \"number\")\n                    ? fieldName\n                    : this.indexes[fieldName];\n                this.assertValidIndex(index, fieldName);\n                var previousChange = this.changes.get(index);\n                if (!previousChange ||\n                    previousChange.op === exports.OPERATION.DELETE ||\n                    previousChange.op === exports.OPERATION.TOUCH // (mazmorra.io's BattleAction issue)\n                ) {\n                    this.changes.set(index, {\n                        op: (!previousChange)\n                            ? operation\n                            : (previousChange.op === exports.OPERATION.DELETE)\n                                ? exports.OPERATION.DELETE_AND_ADD\n                                : operation,\n                        // : OPERATION.REPLACE,\n                        index: index\n                    });\n                }\n                this.allChanges.add(index);\n                this.changed = true;\n                this.touchParents();\n            };\n            ChangeTree.prototype.touch = function (fieldName) {\n                var index = (typeof (fieldName) === \"number\")\n                    ? fieldName\n                    : this.indexes[fieldName];\n                this.assertValidIndex(index, fieldName);\n                if (!this.changes.has(index)) {\n                    this.changes.set(index, { op: exports.OPERATION.TOUCH, index: index });\n                }\n                this.allChanges.add(index);\n                // ensure touch is placed until the $root is found.\n                this.touchParents();\n            };\n            ChangeTree.prototype.touchParents = function () {\n                if (this.parent) {\n                    this.parent['$changes'].touch(this.parentIndex);\n                }\n            };\n            ChangeTree.prototype.getType = function (index) {\n                if (this.ref['_definition']) {\n                    var definition = this.ref['_definition'];\n                    return definition.schema[definition.fieldsByIndex[index]];\n                }\n                else {\n                    var definition = this.parent['_definition'];\n                    var parentType = definition.schema[definition.fieldsByIndex[this.parentIndex]];\n                    //\n                    // Get the child type from parent structure.\n                    // - [\"string\"] => \"string\"\n                    // - { map: \"string\" } => \"string\"\n                    // - { set: \"string\" } => \"string\"\n                    //\n                    return Object.values(parentType)[0];\n                }\n            };\n            ChangeTree.prototype.getChildrenFilter = function () {\n                var childFilters = this.parent['_definition'].childFilters;\n                return childFilters && childFilters[this.parentIndex];\n            };\n            //\n            // used during `.encode()`\n            //\n            ChangeTree.prototype.getValue = function (index) {\n                return this.ref['getByIndex'](index);\n            };\n            ChangeTree.prototype.delete = function (fieldName) {\n                var index = (typeof (fieldName) === \"number\")\n                    ? fieldName\n                    : this.indexes[fieldName];\n                if (index === undefined) {\n                    console.warn(\"@colyseus/schema \" + this.ref.constructor.name + \": trying to delete non-existing index: \" + fieldName + \" (\" + index + \")\");\n                    return;\n                }\n                var previousValue = this.getValue(index);\n                // console.log(\"$changes.delete =>\", { fieldName, index, previousValue });\n                this.changes.set(index, { op: exports.OPERATION.DELETE, index: index });\n                this.allChanges.delete(index);\n                // delete cache\n                delete this.caches[index];\n                // remove `root` reference\n                if (previousValue && previousValue['$changes']) {\n                    previousValue['$changes'].parent = undefined;\n                }\n                this.changed = true;\n                this.touchParents();\n            };\n            ChangeTree.prototype.discard = function (changed, discardAll) {\n                var _this = this;\n                if (changed === void 0) { changed = false; }\n                if (discardAll === void 0) { discardAll = false; }\n                //\n                // Map, Array, etc:\n                // Remove cached key to ensure ADD operations is unsed instead of\n                // REPLACE in case same key is used on next patches.\n                //\n                // TODO: refactor this. this is not relevant for Collection and Set.\n                //\n                if (!(this.ref instanceof Schema)) {\n                    this.changes.forEach(function (change) {\n                        if (change.op === exports.OPERATION.DELETE) {\n                            var index = _this.ref['getIndex'](change.index);\n                            delete _this.indexes[index];\n                        }\n                    });\n                }\n                this.changes.clear();\n                this.changed = changed;\n                if (discardAll) {\n                    this.allChanges.clear();\n                }\n                // re-set `currentCustomOperation`\n                this.currentCustomOperation = 0;\n            };\n            /**\n             * Recursively discard all changes from this, and child structures.\n             */\n            ChangeTree.prototype.discardAll = function () {\n                var _this = this;\n                this.changes.forEach(function (change) {\n                    var value = _this.getValue(change.index);\n                    if (value && value['$changes']) {\n                        value['$changes'].discardAll();\n                    }\n                });\n                this.discard();\n            };\n            // cache(field: number, beginIndex: number, endIndex: number) {\n            ChangeTree.prototype.cache = function (field, cachedBytes) {\n                this.caches[field] = cachedBytes;\n            };\n            ChangeTree.prototype.clone = function () {\n                return new ChangeTree(this.ref, this.parent, this.root);\n            };\n            ChangeTree.prototype.ensureRefId = function () {\n                // skip if refId is already set.\n                if (this.refId !== undefined) {\n                    return;\n                }\n                this.refId = this.root.getNextUniqueId();\n            };\n            ChangeTree.prototype.assertValidIndex = function (index, fieldName) {\n                if (index === undefined) {\n                    throw new Error(\"ChangeTree: missing index for field \\\"\" + fieldName + \"\\\"\");\n                }\n            };\n            return ChangeTree;\n        }());\n\n        //\n        // Notes:\n        // -----\n        //\n        // - The tsconfig.json of @colyseus/schema uses ES2018.\n        // - ES2019 introduces `flatMap` / `flat`, which is not currently relevant, and caused other issues.\n        //\n        var DEFAULT_SORT = function (a, b) {\n            var A = a.toString();\n            var B = b.toString();\n            if (A < B)\n                return -1;\n            else if (A > B)\n                return 1;\n            else\n                return 0;\n        };\n        function getArrayProxy(value) {\n            value['$proxy'] = true;\n            //\n            // compatibility with @colyseus/schema 0.5.x\n            // - allow `map[\"key\"]`\n            // - allow `map[\"key\"] = \"xxx\"`\n            // - allow `delete map[\"key\"]`\n            //\n            value = new Proxy(value, {\n                get: function (obj, prop) {\n                    if (typeof (prop) !== \"symbol\" &&\n                        !isNaN(prop) // https://stackoverflow.com/a/175787/892698\n                    ) {\n                        return obj.at(prop);\n                    }\n                    else {\n                        return obj[prop];\n                    }\n                },\n                set: function (obj, prop, setValue) {\n                    if (typeof (prop) !== \"symbol\" &&\n                        !isNaN(prop)) {\n                        var indexes = Array.from(obj['$items'].keys());\n                        var key = parseInt(indexes[prop] || prop);\n                        if (setValue === undefined || setValue === null) {\n                            obj.deleteAt(key);\n                        }\n                        else {\n                            obj.setAt(key, setValue);\n                        }\n                    }\n                    else {\n                        obj[prop] = setValue;\n                    }\n                    return true;\n                },\n                deleteProperty: function (obj, prop) {\n                    if (typeof (prop) === \"number\") {\n                        obj.deleteAt(prop);\n                    }\n                    else {\n                        delete obj[prop];\n                    }\n                    return true;\n                },\n            });\n            return value;\n        }\n        var ArraySchema = /** @class */ (function () {\n            function ArraySchema() {\n                var items = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    items[_i] = arguments[_i];\n                }\n                this.$changes = new ChangeTree(this);\n                this.$items = new Map();\n                this.$indexes = new Map();\n                this.$refId = 0;\n                this.push.apply(this, items);\n            }\n            ArraySchema.is = function (type) {\n                return (\n                // type format: [\"string\"]\n                Array.isArray(type) ||\n                    // type format: { array: \"string\" }\n                    (type['array'] !== undefined));\n            };\n            Object.defineProperty(ArraySchema.prototype, \"length\", {\n                get: function () {\n                    return this.$items.size;\n                },\n                set: function (value) {\n                    if (value === 0) {\n                        this.clear();\n                    }\n                    else {\n                        this.splice(value, this.length - value);\n                    }\n                },\n                enumerable: false,\n                configurable: true\n            });\n            ArraySchema.prototype.push = function () {\n                var _this = this;\n                var values = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    values[_i] = arguments[_i];\n                }\n                var lastIndex;\n                values.forEach(function (value) {\n                    // set \"index\" for reference.\n                    lastIndex = _this.$refId++;\n                    _this.setAt(lastIndex, value);\n                });\n                return lastIndex;\n            };\n            /**\n             * Removes the last element from an array and returns it.\n             */\n            ArraySchema.prototype.pop = function () {\n                var key = Array.from(this.$indexes.values()).pop();\n                if (key === undefined) {\n                    return undefined;\n                }\n                this.$changes.delete(key);\n                this.$indexes.delete(key);\n                var value = this.$items.get(key);\n                this.$items.delete(key);\n                return value;\n            };\n            ArraySchema.prototype.at = function (index) {\n                //\n                // FIXME: this should be O(1)\n                //\n                var key = Array.from(this.$items.keys())[index];\n                return this.$items.get(key);\n            };\n            ArraySchema.prototype.setAt = function (index, value) {\n                var _a, _b;\n                if (value['$changes'] !== undefined) {\n                    value['$changes'].setParent(this, this.$changes.root, index);\n                }\n                var operation = (_b = (_a = this.$changes.indexes[index]) === null || _a === void 0 ? void 0 : _a.op) !== null && _b !== void 0 ? _b : exports.OPERATION.ADD;\n                this.$changes.indexes[index] = index;\n                this.$indexes.set(index, index);\n                this.$items.set(index, value);\n                this.$changes.change(index, operation);\n            };\n            ArraySchema.prototype.deleteAt = function (index) {\n                var key = Array.from(this.$items.keys())[index];\n                if (key === undefined) {\n                    return false;\n                }\n                return this.$deleteAt(key);\n            };\n            ArraySchema.prototype.$deleteAt = function (index) {\n                // delete at internal index\n                this.$changes.delete(index);\n                this.$indexes.delete(index);\n                return this.$items.delete(index);\n            };\n            ArraySchema.prototype.clear = function (isDecoding) {\n                var _this = this;\n                // discard previous operations.\n                this.$changes.discard(true, true);\n                this.$changes.indexes = {};\n                // clear previous indexes\n                this.$indexes.clear();\n                // flag child items for garbage collection.\n                if (isDecoding && typeof (this.$changes.getType()) !== \"string\") {\n                    this.$items.forEach(function (item) {\n                        _this.$changes.root.removeRef(item['$changes'].refId);\n                    });\n                }\n                // clear items\n                this.$items.clear();\n                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });\n                // touch all structures until reach root\n                this.$changes.touchParents();\n            };\n            /**\n             * Combines two or more arrays.\n             * @param items Additional items to add to the end of array1.\n             */\n            ArraySchema.prototype.concat = function () {\n                var _a;\n                var items = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    items[_i] = arguments[_i];\n                }\n                return new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], (_a = Array.from(this.$items.values())).concat.apply(_a, items))))();\n            };\n            /**\n             * Adds all the elements of an array separated by the specified separator string.\n             * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n             */\n            ArraySchema.prototype.join = function (separator) {\n                return Array.from(this.$items.values()).join(separator);\n            };\n            /**\n             * Reverses the elements in an Array.\n             */\n            ArraySchema.prototype.reverse = function () {\n                var _this = this;\n                var indexes = Array.from(this.$items.keys());\n                var reversedItems = Array.from(this.$items.values()).reverse();\n                reversedItems.forEach(function (item, i) {\n                    _this.setAt(indexes[i], item);\n                });\n                return this;\n            };\n            /**\n             * Removes the first element from an array and returns it.\n             */\n            ArraySchema.prototype.shift = function () {\n                var indexes = Array.from(this.$items.keys());\n                var shiftAt = indexes.shift();\n                if (shiftAt === undefined) {\n                    return undefined;\n                }\n                var value = this.$items.get(shiftAt);\n                this.$deleteAt(shiftAt);\n                return value;\n            };\n            /**\n             * Returns a section of an array.\n             * @param start The beginning of the specified portion of the array.\n             * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\n             */\n            ArraySchema.prototype.slice = function (start, end) {\n                return new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], Array.from(this.$items.values()).slice(start, end))))();\n            };\n            /**\n             * Sorts an array.\n             * @param compareFn Function used to determine the order of the elements. It is expected to return\n             * a negative value if first argument is less than second argument, zero if they're equal and a positive\n             * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.\n             * ```ts\n             * [11,2,22,1].sort((a, b) => a - b)\n             * ```\n             */\n            ArraySchema.prototype.sort = function (compareFn) {\n                var _this = this;\n                if (compareFn === void 0) { compareFn = DEFAULT_SORT; }\n                var indexes = Array.from(this.$items.keys());\n                var sortedItems = Array.from(this.$items.values()).sort(compareFn);\n                sortedItems.forEach(function (item, i) {\n                    _this.setAt(indexes[i], item);\n                });\n                return this;\n            };\n            /**\n             * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n             * @param start The zero-based location in the array from which to start removing elements.\n             * @param deleteCount The number of elements to remove.\n             * @param items Elements to insert into the array in place of the deleted elements.\n             */\n            ArraySchema.prototype.splice = function (start, deleteCount) {\n                if (deleteCount === void 0) { deleteCount = this.length - start; }\n                var items = [];\n                for (var _i = 2; _i < arguments.length; _i++) {\n                    items[_i - 2] = arguments[_i];\n                }\n                var indexes = Array.from(this.$items.keys());\n                var removedItems = [];\n                for (var i = start; i < start + deleteCount; i++) {\n                    removedItems.push(this.$items.get(indexes[i]));\n                    this.$deleteAt(indexes[i]);\n                }\n                return removedItems;\n            };\n            /**\n             * Inserts new elements at the start of an array.\n             * @param items  Elements to insert at the start of the Array.\n             */\n            ArraySchema.prototype.unshift = function () {\n                var _this = this;\n                var items = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    items[_i] = arguments[_i];\n                }\n                var length = this.length;\n                var addedLength = items.length;\n                // const indexes = Array.from(this.$items.keys());\n                var previousValues = Array.from(this.$items.values());\n                items.forEach(function (item, i) {\n                    _this.setAt(i, item);\n                });\n                previousValues.forEach(function (previousValue, i) {\n                    _this.setAt(addedLength + i, previousValue);\n                });\n                return length + addedLength;\n            };\n            /**\n             * Returns the index of the first occurrence of a value in an array.\n             * @param searchElement The value to locate in the array.\n             * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n             */\n            ArraySchema.prototype.indexOf = function (searchElement, fromIndex) {\n                return Array.from(this.$items.values()).indexOf(searchElement, fromIndex);\n            };\n            /**\n             * Returns the index of the last occurrence of a specified value in an array.\n             * @param searchElement The value to locate in the array.\n             * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n             */\n            ArraySchema.prototype.lastIndexOf = function (searchElement, fromIndex) {\n                if (fromIndex === void 0) { fromIndex = this.length - 1; }\n                return Array.from(this.$items.values()).lastIndexOf(searchElement, fromIndex);\n            };\n            /**\n             * Determines whether all the members of an array satisfy the specified test.\n             * @param callbackfn A function that accepts up to three arguments. The every method calls\n             * the callbackfn function for each element in the array until the callbackfn returns a value\n             * which is coercible to the Boolean value false, or until the end of the array.\n             * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n             * If thisArg is omitted, undefined is used as the this value.\n             */\n            ArraySchema.prototype.every = function (callbackfn, thisArg) {\n                return Array.from(this.$items.values()).every(callbackfn, thisArg);\n            };\n            /**\n             * Determines whether the specified callback function returns true for any element of an array.\n             * @param callbackfn A function that accepts up to three arguments. The some method calls\n             * the callbackfn function for each element in the array until the callbackfn returns a value\n             * which is coercible to the Boolean value true, or until the end of the array.\n             * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n             * If thisArg is omitted, undefined is used as the this value.\n             */\n            ArraySchema.prototype.some = function (callbackfn, thisArg) {\n                return Array.from(this.$items.values()).some(callbackfn, thisArg);\n            };\n            /**\n             * Performs the specified action for each element in an array.\n             * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n             * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n             */\n            ArraySchema.prototype.forEach = function (callbackfn, thisArg) {\n                Array.from(this.$items.values()).forEach(callbackfn, thisArg);\n            };\n            /**\n             * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n             * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n             * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n             */\n            ArraySchema.prototype.map = function (callbackfn, thisArg) {\n                return Array.from(this.$items.values()).map(callbackfn, thisArg);\n            };\n            ArraySchema.prototype.filter = function (callbackfn, thisArg) {\n                return Array.from(this.$items.values()).filter(callbackfn, thisArg);\n            };\n            /**\n             * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n             * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n             * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n             */\n            ArraySchema.prototype.reduce = function (callbackfn, initialValue) {\n                return Array.from(this.$items.values()).reduce(callbackfn, initialValue);\n            };\n            /**\n             * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n             * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n             * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n             */\n            ArraySchema.prototype.reduceRight = function (callbackfn, initialValue) {\n                return Array.from(this.$items.values()).reduceRight(callbackfn, initialValue);\n            };\n            /**\n             * Returns the value of the first element in the array where predicate is true, and undefined\n             * otherwise.\n             * @param predicate find calls predicate once for each element of the array, in ascending\n             * order, until it finds one where predicate returns true. If such an element is found, find\n             * immediately returns that element value. Otherwise, find returns undefined.\n             * @param thisArg If provided, it will be used as the this value for each invocation of\n             * predicate. If it is not provided, undefined is used instead.\n             */\n            ArraySchema.prototype.find = function (predicate, thisArg) {\n                return Array.from(this.$items.values()).find(predicate, thisArg);\n            };\n            /**\n             * Returns the index of the first element in the array where predicate is true, and -1\n             * otherwise.\n             * @param predicate find calls predicate once for each element of the array, in ascending\n             * order, until it finds one where predicate returns true. If such an element is found,\n             * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n             * @param thisArg If provided, it will be used as the this value for each invocation of\n             * predicate. If it is not provided, undefined is used instead.\n             */\n            ArraySchema.prototype.findIndex = function (predicate, thisArg) {\n                return Array.from(this.$items.values()).findIndex(predicate, thisArg);\n            };\n            /**\n             * Returns the this object after filling the section identified by start and end with value\n             * @param value value to fill array section with\n             * @param start index to start filling the array at. If start is negative, it is treated as\n             * length+start where length is the length of the array.\n             * @param end index to stop filling the array at. If end is negative, it is treated as\n             * length+end.\n             */\n            ArraySchema.prototype.fill = function (value, start, end) {\n                //\n                // TODO\n                //\n                throw new Error(\"ArraySchema#fill() not implemented\");\n            };\n            /**\n             * Returns the this object after copying a section of the array identified by start and end\n             * to the same array starting at position target\n             * @param target If target is negative, it is treated as length+target where length is the\n             * length of the array.\n             * @param start If start is negative, it is treated as length+start. If end is negative, it\n             * is treated as length+end.\n             * @param end If not specified, length of the this object is used as its default value.\n             */\n            ArraySchema.prototype.copyWithin = function (target, start, end) {\n                //\n                // TODO\n                //\n                throw new Error(\"ArraySchema#copyWithin() not implemented\");\n            };\n            /**\n             * Returns a string representation of an array.\n             */\n            ArraySchema.prototype.toString = function () { return this.$items.toString(); };\n            /**\n             * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n             */\n            ArraySchema.prototype.toLocaleString = function () { return this.$items.toLocaleString(); };\n            /** Iterator */\n            ArraySchema.prototype[Symbol.iterator] = function () {\n                return Array.from(this.$items.values())[Symbol.iterator]();\n            };\n            ArraySchema.prototype[Symbol.unscopables] = function () {\n                return this.$items[Symbol.unscopables]();\n            };\n            /**\n             * Returns an iterable of key, value pairs for every entry in the array\n             */\n            ArraySchema.prototype.entries = function () { return this.$items.entries(); };\n            /**\n             * Returns an iterable of keys in the array\n             */\n            ArraySchema.prototype.keys = function () { return this.$items.keys(); };\n            /**\n             * Returns an iterable of values in the array\n             */\n            ArraySchema.prototype.values = function () { return this.$items.values(); };\n            /**\n             * Determines whether an array includes a certain element, returning true or false as appropriate.\n             * @param searchElement The element to search for.\n             * @param fromIndex The position in this array at which to begin searching for searchElement.\n             */\n            ArraySchema.prototype.includes = function (searchElement, fromIndex) {\n                return Array.from(this.$items.values()).includes(searchElement, fromIndex);\n            };\n            /**\n             * Calls a defined callback function on each element of an array. Then, flattens the result into\n             * a new array.\n             * This is identical to a map followed by flat with depth 1.\n             *\n             * @param callback A function that accepts up to three arguments. The flatMap method calls the\n             * callback function one time for each element in the array.\n             * @param thisArg An object to which the this keyword can refer in the callback function. If\n             * thisArg is omitted, undefined is used as the this value.\n             */\n            // @ts-ignore\n            ArraySchema.prototype.flatMap = function (callback, thisArg) {\n                // @ts-ignore\n                throw new Error(\"ArraySchema#flatMap() is not supported.\");\n            };\n            /**\n             * Returns a new array with all sub-array elements concatenated into it recursively up to the\n             * specified depth.\n             *\n             * @param depth The maximum recursion depth\n             */\n            // @ts-ignore\n            ArraySchema.prototype.flat = function (depth) {\n                // @ts-ignore\n                throw new Error(\"ArraySchema#flat() is not supported.\");\n            };\n            // get size () {\n            //     return this.$items.size;\n            // }\n            ArraySchema.prototype.setIndex = function (index, key) {\n                this.$indexes.set(index, key);\n            };\n            ArraySchema.prototype.getIndex = function (index) {\n                return this.$indexes.get(index);\n            };\n            ArraySchema.prototype.getByIndex = function (index) {\n                return this.$items.get(this.$indexes.get(index));\n            };\n            ArraySchema.prototype.deleteByIndex = function (index) {\n                var key = this.$indexes.get(index);\n                this.$items.delete(key);\n                this.$indexes.delete(index);\n            };\n            ArraySchema.prototype.toArray = function () {\n                return Array.from(this.$items.values());\n            };\n            ArraySchema.prototype.toJSON = function () {\n                return this.toArray().map(function (value) {\n                    return (typeof (value['toJSON']) === \"function\")\n                        ? value['toJSON']()\n                        : value;\n                });\n            };\n            //\n            // Decoding utilities\n            //\n            ArraySchema.prototype.clone = function (isDecoding) {\n                var cloned;\n                if (isDecoding) {\n                    cloned = new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], Array.from(this.$items.values()))))();\n                }\n                else {\n                    cloned = new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], this.map(function (item) { return ((item['$changes'])\n                        ? item.clone()\n                        : item); }))))();\n                }\n                return cloned;\n            };\n            ArraySchema.prototype.triggerAll = function () {\n                Schema.prototype.triggerAll.apply(this);\n            };\n            return ArraySchema;\n        }());\n\n        function getMapProxy(value) {\n            value['$proxy'] = true;\n            value = new Proxy(value, {\n                get: function (obj, prop) {\n                    if (typeof (prop) !== \"symbol\" && // accessing properties\n                        typeof (obj[prop]) === \"undefined\") {\n                        return obj.get(prop);\n                    }\n                    else {\n                        return obj[prop];\n                    }\n                },\n                set: function (obj, prop, setValue) {\n                    if (typeof (prop) !== \"symbol\" &&\n                        (prop.indexOf(\"$\") === -1 &&\n                            prop !== \"onAdd\" &&\n                            prop !== \"onRemove\" &&\n                            prop !== \"onChange\")) {\n                        obj.set(prop, setValue);\n                    }\n                    else {\n                        obj[prop] = setValue;\n                    }\n                    return true;\n                },\n                deleteProperty: function (obj, prop) {\n                    obj.delete(prop);\n                    return true;\n                },\n            });\n            return value;\n        }\n        var MapSchema = /** @class */ (function () {\n            function MapSchema(initialValues) {\n                var _this = this;\n                this.$changes = new ChangeTree(this);\n                this.$items = new Map();\n                this.$indexes = new Map();\n                this.$refId = 0;\n                if (initialValues) {\n                    if (initialValues instanceof Map) {\n                        initialValues.forEach(function (v, k) { return _this.set(k, v); });\n                    }\n                    else {\n                        for (var k in initialValues) {\n                            this.set(k, initialValues[k]);\n                        }\n                    }\n                }\n            }\n            MapSchema.is = function (type) {\n                return type['map'] !== undefined;\n            };\n            /** Iterator */\n            MapSchema.prototype[Symbol.iterator] = function () { return this.$items[Symbol.iterator](); };\n            Object.defineProperty(MapSchema.prototype, Symbol.toStringTag, {\n                get: function () { return this.$items[Symbol.toStringTag]; },\n                enumerable: false,\n                configurable: true\n            });\n            MapSchema.prototype.set = function (key, value) {\n                if (value === undefined || value === null) {\n                    throw new Error(\"MapSchema#set('\" + key + \"', \" + value + \"): trying to set \" + value + \" value on '\" + key + \"'.\");\n                }\n                // get \"index\" for this value.\n                var hasIndex = typeof (this.$changes.indexes[key]) !== \"undefined\";\n                var index = (hasIndex)\n                    ? this.$changes.indexes[key]\n                    : this.$refId++;\n                var operation = (hasIndex)\n                    ? exports.OPERATION.REPLACE\n                    : exports.OPERATION.ADD;\n                var isRef = (value['$changes']) !== undefined;\n                if (isRef) {\n                    value['$changes'].setParent(this, this.$changes.root, index);\n                }\n                //\n                // (encoding)\n                // set a unique id to relate directly with this key/value.\n                //\n                if (!hasIndex) {\n                    this.$changes.indexes[key] = index;\n                    this.$indexes.set(index, key);\n                }\n                else if (isRef && // if is schema, force ADD operation if value differ from previous one.\n                    this.$items.get(key) !== value) {\n                    operation = exports.OPERATION.ADD;\n                }\n                this.$items.set(key, value);\n                this.$changes.change(key, operation);\n                return this;\n            };\n            MapSchema.prototype.get = function (key) {\n                return this.$items.get(key);\n            };\n            MapSchema.prototype.delete = function (key) {\n                //\n                // TODO: add a \"purge\" method after .encode() runs, to cleanup removed `$indexes`\n                //\n                // We don't remove $indexes to allow setting the same key in the same patch\n                // (See \"should allow to remove and set an item in the same place\" test)\n                //\n                // // const index = this.$changes.indexes[key];\n                // // this.$indexes.delete(index);\n                this.$changes.delete(key);\n                return this.$items.delete(key);\n            };\n            MapSchema.prototype.clear = function (isDecoding) {\n                var _this = this;\n                // discard previous operations.\n                this.$changes.discard(true, true);\n                this.$changes.indexes = {};\n                // clear previous indexes\n                this.$indexes.clear();\n                // flag child items for garbage collection.\n                if (isDecoding && typeof (this.$changes.getType()) !== \"string\") {\n                    this.$items.forEach(function (item) {\n                        _this.$changes.root.removeRef(item['$changes'].refId);\n                    });\n                }\n                // clear items\n                this.$items.clear();\n                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });\n                // touch all structures until reach root\n                this.$changes.touchParents();\n            };\n            MapSchema.prototype.has = function (key) {\n                return this.$items.has(key);\n            };\n            MapSchema.prototype.forEach = function (callbackfn) {\n                this.$items.forEach(callbackfn);\n            };\n            MapSchema.prototype.entries = function () {\n                return this.$items.entries();\n            };\n            MapSchema.prototype.keys = function () {\n                return this.$items.keys();\n            };\n            MapSchema.prototype.values = function () {\n                return this.$items.values();\n            };\n            Object.defineProperty(MapSchema.prototype, \"size\", {\n                get: function () {\n                    return this.$items.size;\n                },\n                enumerable: false,\n                configurable: true\n            });\n            MapSchema.prototype.setIndex = function (index, key) {\n                this.$indexes.set(index, key);\n            };\n            MapSchema.prototype.getIndex = function (index) {\n                return this.$indexes.get(index);\n            };\n            MapSchema.prototype.getByIndex = function (index) {\n                return this.$items.get(this.$indexes.get(index));\n            };\n            MapSchema.prototype.deleteByIndex = function (index) {\n                var key = this.$indexes.get(index);\n                this.$items.delete(key);\n                this.$indexes.delete(index);\n            };\n            MapSchema.prototype.toJSON = function () {\n                var map = {};\n                this.forEach(function (value, key) {\n                    map[key] = (typeof (value['toJSON']) === \"function\")\n                        ? value['toJSON']()\n                        : value;\n                });\n                return map;\n            };\n            //\n            // Decoding utilities\n            //\n            MapSchema.prototype.clone = function (isDecoding) {\n                var cloned;\n                if (isDecoding) {\n                    // client-side\n                    cloned = Object.assign(new MapSchema(), this);\n                }\n                else {\n                    // server-side\n                    cloned = new MapSchema();\n                    this.forEach(function (value, key) {\n                        if (value['$changes']) {\n                            cloned.set(key, value['clone']());\n                        }\n                        else {\n                            cloned.set(key, value);\n                        }\n                    });\n                }\n                return cloned;\n            };\n            MapSchema.prototype.triggerAll = function () {\n                Schema.prototype.triggerAll.apply(this);\n            };\n            return MapSchema;\n        }());\n\n        var registeredTypes = {};\n        function registerType(identifier, definition) {\n            registeredTypes[identifier] = definition;\n        }\n        function getType(identifier) {\n            return registeredTypes[identifier];\n        }\n\n        var SchemaDefinition = /** @class */ (function () {\n            function SchemaDefinition() {\n                //\n                // TODO: use a \"field\" structure combining all these properties per-field.\n                //\n                this.indexes = {};\n                this.fieldsByIndex = {};\n                this.deprecated = {};\n                this.descriptors = {};\n            }\n            SchemaDefinition.create = function (parent) {\n                var definition = new SchemaDefinition();\n                // support inheritance\n                definition.schema = Object.assign({}, parent && parent.schema || {});\n                definition.indexes = Object.assign({}, parent && parent.indexes || {});\n                definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});\n                definition.descriptors = Object.assign({}, parent && parent.descriptors || {});\n                definition.deprecated = Object.assign({}, parent && parent.deprecated || {});\n                return definition;\n            };\n            SchemaDefinition.prototype.addField = function (field, type) {\n                var index = this.getNextFieldIndex();\n                this.fieldsByIndex[index] = field;\n                this.indexes[field] = index;\n                this.schema[field] = (Array.isArray(type))\n                    ? { array: type[0] }\n                    : type;\n            };\n            SchemaDefinition.prototype.addFilter = function (field, cb) {\n                if (!this.filters) {\n                    this.filters = {};\n                    this.indexesWithFilters = [];\n                }\n                this.filters[this.indexes[field]] = cb;\n                this.indexesWithFilters.push(this.indexes[field]);\n                return true;\n            };\n            SchemaDefinition.prototype.addChildrenFilter = function (field, cb) {\n                var index = this.indexes[field];\n                var type = this.schema[field];\n                if (getType(Object.keys(type)[0])) {\n                    if (!this.childFilters) {\n                        this.childFilters = {};\n                    }\n                    this.childFilters[index] = cb;\n                    return true;\n                }\n                else {\n                    console.warn(\"@filterChildren: field '\" + field + \"' can't have children. Ignoring filter.\");\n                }\n            };\n            SchemaDefinition.prototype.getChildrenFilter = function (field) {\n                return this.childFilters && this.childFilters[this.indexes[field]];\n            };\n            SchemaDefinition.prototype.getNextFieldIndex = function () {\n                return Object.keys(this.schema || {}).length;\n            };\n            return SchemaDefinition;\n        }());\n        function hasFilter(klass) {\n            return klass._context && klass._context.useFilters;\n        }\n        var Context = /** @class */ (function () {\n            function Context() {\n                this.types = {};\n                this.schemas = new Map();\n                this.useFilters = false;\n            }\n            Context.prototype.has = function (schema) {\n                return this.schemas.has(schema);\n            };\n            Context.prototype.get = function (typeid) {\n                return this.types[typeid];\n            };\n            Context.prototype.add = function (schema, typeid) {\n                if (typeid === void 0) { typeid = this.schemas.size; }\n                // FIXME: move this to somewhere else?\n                // support inheritance\n                schema._definition = SchemaDefinition.create(schema._definition);\n                schema._typeid = typeid;\n                this.types[typeid] = schema;\n                this.schemas.set(schema, typeid);\n            };\n            Context.create = function (context) {\n                if (context === void 0) { context = new Context; }\n                return function (definition) {\n                    return type(definition, context);\n                };\n            };\n            return Context;\n        }());\n        var globalContext = new Context();\n        /**\n         * `@type()` decorator for proxies\n         */\n        function type(type, context) {\n            if (context === void 0) { context = globalContext; }\n            return function (target, field) {\n                var constructor = target.constructor;\n                constructor._context = context;\n                /*\n                 * static schema\n                 */\n                if (!context.has(constructor)) {\n                    context.add(constructor);\n                }\n                var definition = constructor._definition;\n                definition.addField(field, type);\n                /**\n                 * skip if descriptor already exists for this field (`@deprecated()`)\n                 */\n                if (definition.descriptors[field]) {\n                    if (definition.deprecated[field]) {\n                        // do not create accessors for deprecated properties.\n                        return;\n                    }\n                    else {\n                        // trying to define same property multiple times across inheritance.\n                        // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\n                        try {\n                            throw new Error(\"@colyseus/schema: Duplicate '\" + field + \"' definition on '\" + constructor.name + \"'.\\nCheck @type() annotation\");\n                        }\n                        catch (e) {\n                            var definitionAtLine = e.stack.split(\"\\n\")[4].trim();\n                            throw new Error(e.message + \" \" + definitionAtLine);\n                        }\n                    }\n                }\n                var isArray = ArraySchema.is(type);\n                var isMap = !isArray && MapSchema.is(type);\n                // TODO: refactor me.\n                // Allow abstract intermediary classes with no fields to be serialized\n                // (See \"should support an inheritance with a Schema type without fields\" test)\n                if (typeof (type) !== \"string\" && !Schema.is(type)) {\n                    var childType = Object.values(type)[0];\n                    if (typeof (childType) !== \"string\" && !context.has(childType)) {\n                        context.add(childType);\n                    }\n                }\n                var fieldCached = \"_\" + field;\n                definition.descriptors[fieldCached] = {\n                    enumerable: false,\n                    configurable: false,\n                    writable: true,\n                };\n                definition.descriptors[field] = {\n                    get: function () {\n                        return this[fieldCached];\n                    },\n                    set: function (value) {\n                        /**\n                         * Create Proxy for array or map items\n                         */\n                        // skip if value is the same as cached.\n                        if (value === this[fieldCached]) {\n                            return;\n                        }\n                        if (value !== undefined &&\n                            value !== null) {\n                            // automaticallty transform Array into ArraySchema\n                            if (isArray && !(value instanceof ArraySchema)) {\n                                value = new (ArraySchema.bind.apply(ArraySchema, __spreadArray([void 0], value)))();\n                            }\n                            // automaticallty transform Map into MapSchema\n                            if (isMap && !(value instanceof MapSchema)) {\n                                value = new MapSchema(value);\n                            }\n                            // try to turn provided structure into a Proxy\n                            if (value['$proxy'] === undefined) {\n                                if (isMap) {\n                                    value = getMapProxy(value);\n                                }\n                                else if (isArray) {\n                                    value = getArrayProxy(value);\n                                }\n                            }\n                            // flag the change for encoding.\n                            this.$changes.change(field);\n                            //\n                            // call setParent() recursively for this and its child\n                            // structures.\n                            //\n                            if (value['$changes']) {\n                                value['$changes'].setParent(this, this.$changes.root, this._definition.indexes[field]);\n                            }\n                        }\n                        else {\n                            //\n                            // Setting a field to `null` or `undefined` will delete it.\n                            //\n                            this.$changes.delete(field);\n                        }\n                        this[fieldCached] = value;\n                    },\n                    enumerable: true,\n                    configurable: true\n                };\n            };\n        }\n        /**\n         * `@filter()` decorator for defining data filters per client\n         */\n        function filter(cb) {\n            return function (target, field) {\n                var constructor = target.constructor;\n                var definition = constructor._definition;\n                if (definition.addFilter(field, cb)) {\n                    constructor._context.useFilters = true;\n                }\n            };\n        }\n        function filterChildren(cb) {\n            return function (target, field) {\n                var constructor = target.constructor;\n                var definition = constructor._definition;\n                if (definition.addChildrenFilter(field, cb)) {\n                    constructor._context.useFilters = true;\n                }\n            };\n        }\n        /**\n         * `@deprecated()` flag a field as deprecated.\n         * The previous `@type()` annotation should remain along with this one.\n         */\n        function deprecated(throws, context) {\n            if (throws === void 0) { throws = true; }\n            return function (target, field) {\n                var constructor = target.constructor;\n                var definition = constructor._definition;\n                definition.deprecated[field] = true;\n                if (throws) {\n                    definition.descriptors[field] = {\n                        get: function () { throw new Error(field + \" is deprecated.\"); },\n                        set: function (value) { },\n                        enumerable: false,\n                        configurable: true\n                    };\n                }\n            };\n        }\n        function defineTypes(target, fields, context) {\n            if (context === void 0) { context = target._context || globalContext; }\n            for (var field in fields) {\n                type(fields[field], context)(target.prototype, field);\n            }\n            return target;\n        }\n\n        /**\n         * Copyright (c) 2018 Endel Dreyer\n         * Copyright (c) 2014 Ion Drive Software Ltd.\n         *\n         * Permission is hereby granted, free of charge, to any person obtaining a copy\n         * of this software and associated documentation files (the \"Software\"), to deal\n         * in the Software without restriction, including without limitation the rights\n         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n         * copies of the Software, and to permit persons to whom the Software is\n         * furnished to do so, subject to the following conditions:\n         *\n         * The above copyright notice and this permission notice shall be included in all\n         * copies or substantial portions of the Software.\n         *\n         * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n         * SOFTWARE\n         */\n        /**\n         * msgpack implementation highly based on notepack.io\n         * https://github.com/darrachequesne/notepack\n         */\n        function utf8Length(str) {\n            var c = 0, length = 0;\n            for (var i = 0, l = str.length; i < l; i++) {\n                c = str.charCodeAt(i);\n                if (c < 0x80) {\n                    length += 1;\n                }\n                else if (c < 0x800) {\n                    length += 2;\n                }\n                else if (c < 0xd800 || c >= 0xe000) {\n                    length += 3;\n                }\n                else {\n                    i++;\n                    length += 4;\n                }\n            }\n            return length;\n        }\n        function utf8Write(view, offset, str) {\n            var c = 0;\n            for (var i = 0, l = str.length; i < l; i++) {\n                c = str.charCodeAt(i);\n                if (c < 0x80) {\n                    view[offset++] = c;\n                }\n                else if (c < 0x800) {\n                    view[offset++] = 0xc0 | (c >> 6);\n                    view[offset++] = 0x80 | (c & 0x3f);\n                }\n                else if (c < 0xd800 || c >= 0xe000) {\n                    view[offset++] = 0xe0 | (c >> 12);\n                    view[offset++] = 0x80 | (c >> 6 & 0x3f);\n                    view[offset++] = 0x80 | (c & 0x3f);\n                }\n                else {\n                    i++;\n                    c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n                    view[offset++] = 0xf0 | (c >> 18);\n                    view[offset++] = 0x80 | (c >> 12 & 0x3f);\n                    view[offset++] = 0x80 | (c >> 6 & 0x3f);\n                    view[offset++] = 0x80 | (c & 0x3f);\n                }\n            }\n        }\n        function int8$1(bytes, value) {\n            bytes.push(value & 255);\n        }\n        function uint8$1(bytes, value) {\n            bytes.push(value & 255);\n        }\n        function int16$1(bytes, value) {\n            bytes.push(value & 255);\n            bytes.push((value >> 8) & 255);\n        }\n        function uint16$1(bytes, value) {\n            bytes.push(value & 255);\n            bytes.push((value >> 8) & 255);\n        }\n        function int32$1(bytes, value) {\n            bytes.push(value & 255);\n            bytes.push((value >> 8) & 255);\n            bytes.push((value >> 16) & 255);\n            bytes.push((value >> 24) & 255);\n        }\n        function uint32$1(bytes, value) {\n            var b4 = value >> 24;\n            var b3 = value >> 16;\n            var b2 = value >> 8;\n            var b1 = value;\n            bytes.push(b1 & 255);\n            bytes.push(b2 & 255);\n            bytes.push(b3 & 255);\n            bytes.push(b4 & 255);\n        }\n        function int64$1(bytes, value) {\n            var high = Math.floor(value / Math.pow(2, 32));\n            var low = value >>> 0;\n            uint32$1(bytes, low);\n            uint32$1(bytes, high);\n        }\n        function uint64$1(bytes, value) {\n            var high = (value / Math.pow(2, 32)) >> 0;\n            var low = value >>> 0;\n            uint32$1(bytes, low);\n            uint32$1(bytes, high);\n        }\n        function float32$1(bytes, value) {\n            writeFloat32(bytes, value);\n        }\n        function float64$1(bytes, value) {\n            writeFloat64(bytes, value);\n        }\n        var _int32$1 = new Int32Array(2);\n        var _float32$1 = new Float32Array(_int32$1.buffer);\n        var _float64$1 = new Float64Array(_int32$1.buffer);\n        function writeFloat32(bytes, value) {\n            _float32$1[0] = value;\n            int32$1(bytes, _int32$1[0]);\n        }\n        function writeFloat64(bytes, value) {\n            _float64$1[0] = value;\n            int32$1(bytes, _int32$1[0 ]);\n            int32$1(bytes, _int32$1[1 ]);\n        }\n        function boolean$1(bytes, value) {\n            return uint8$1(bytes, value ? 1 : 0);\n        }\n        function string$1(bytes, value) {\n            // encode `null` strings as empty.\n            if (!value) {\n                value = \"\";\n            }\n            var length = utf8Length(value);\n            var size = 0;\n            // fixstr\n            if (length < 0x20) {\n                bytes.push(length | 0xa0);\n                size = 1;\n            }\n            // str 8\n            else if (length < 0x100) {\n                bytes.push(0xd9);\n                uint8$1(bytes, length);\n                size = 2;\n            }\n            // str 16\n            else if (length < 0x10000) {\n                bytes.push(0xda);\n                uint16$1(bytes, length);\n                size = 3;\n            }\n            // str 32\n            else if (length < 0x100000000) {\n                bytes.push(0xdb);\n                uint32$1(bytes, length);\n                size = 5;\n            }\n            else {\n                throw new Error('String too long');\n            }\n            utf8Write(bytes, bytes.length, value);\n            return size + length;\n        }\n        function number$1(bytes, value) {\n            if (isNaN(value)) {\n                return number$1(bytes, 0);\n            }\n            else if (!isFinite(value)) {\n                return number$1(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER);\n            }\n            else if (value !== (value | 0)) {\n                bytes.push(0xcb);\n                writeFloat64(bytes, value);\n                return 9;\n                // TODO: encode float 32?\n                // is it possible to differentiate between float32 / float64 here?\n                // // float 32\n                // bytes.push(0xca);\n                // writeFloat32(bytes, value);\n                // return 5;\n            }\n            if (value >= 0) {\n                // positive fixnum\n                if (value < 0x80) {\n                    uint8$1(bytes, value);\n                    return 1;\n                }\n                // uint 8\n                if (value < 0x100) {\n                    bytes.push(0xcc);\n                    uint8$1(bytes, value);\n                    return 2;\n                }\n                // uint 16\n                if (value < 0x10000) {\n                    bytes.push(0xcd);\n                    uint16$1(bytes, value);\n                    return 3;\n                }\n                // uint 32\n                if (value < 0x100000000) {\n                    bytes.push(0xce);\n                    uint32$1(bytes, value);\n                    return 5;\n                }\n                // uint 64\n                bytes.push(0xcf);\n                uint64$1(bytes, value);\n                return 9;\n            }\n            else {\n                // negative fixnum\n                if (value >= -0x20) {\n                    bytes.push(0xe0 | (value + 0x20));\n                    return 1;\n                }\n                // int 8\n                if (value >= -0x80) {\n                    bytes.push(0xd0);\n                    int8$1(bytes, value);\n                    return 2;\n                }\n                // int 16\n                if (value >= -0x8000) {\n                    bytes.push(0xd1);\n                    int16$1(bytes, value);\n                    return 3;\n                }\n                // int 32\n                if (value >= -0x80000000) {\n                    bytes.push(0xd2);\n                    int32$1(bytes, value);\n                    return 5;\n                }\n                // int 64\n                bytes.push(0xd3);\n                int64$1(bytes, value);\n                return 9;\n            }\n        }\n\n        var encode = /*#__PURE__*/Object.freeze({\n            __proto__: null,\n            utf8Write: utf8Write,\n            int8: int8$1,\n            uint8: uint8$1,\n            int16: int16$1,\n            uint16: uint16$1,\n            int32: int32$1,\n            uint32: uint32$1,\n            int64: int64$1,\n            uint64: uint64$1,\n            float32: float32$1,\n            float64: float64$1,\n            writeFloat32: writeFloat32,\n            writeFloat64: writeFloat64,\n            boolean: boolean$1,\n            string: string$1,\n            number: number$1\n        });\n\n        /**\n         * Copyright (c) 2018 Endel Dreyer\n         * Copyright (c) 2014 Ion Drive Software Ltd.\n         *\n         * Permission is hereby granted, free of charge, to any person obtaining a copy\n         * of this software and associated documentation files (the \"Software\"), to deal\n         * in the Software without restriction, including without limitation the rights\n         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n         * copies of the Software, and to permit persons to whom the Software is\n         * furnished to do so, subject to the following conditions:\n         *\n         * The above copyright notice and this permission notice shall be included in all\n         * copies or substantial portions of the Software.\n         *\n         * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n         * SOFTWARE\n         */\n        function utf8Read(bytes, offset, length) {\n            var string = '', chr = 0;\n            for (var i = offset, end = offset + length; i < end; i++) {\n                var byte = bytes[i];\n                if ((byte & 0x80) === 0x00) {\n                    string += String.fromCharCode(byte);\n                    continue;\n                }\n                if ((byte & 0xe0) === 0xc0) {\n                    string += String.fromCharCode(((byte & 0x1f) << 6) |\n                        (bytes[++i] & 0x3f));\n                    continue;\n                }\n                if ((byte & 0xf0) === 0xe0) {\n                    string += String.fromCharCode(((byte & 0x0f) << 12) |\n                        ((bytes[++i] & 0x3f) << 6) |\n                        ((bytes[++i] & 0x3f) << 0));\n                    continue;\n                }\n                if ((byte & 0xf8) === 0xf0) {\n                    chr = ((byte & 0x07) << 18) |\n                        ((bytes[++i] & 0x3f) << 12) |\n                        ((bytes[++i] & 0x3f) << 6) |\n                        ((bytes[++i] & 0x3f) << 0);\n                    if (chr >= 0x010000) { // surrogate pair\n                        chr -= 0x010000;\n                        string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n                    }\n                    else {\n                        string += String.fromCharCode(chr);\n                    }\n                    continue;\n                }\n                console.error('Invalid byte ' + byte.toString(16));\n                // (do not throw error to avoid server/client from crashing due to hack attemps)\n                // throw new Error('Invalid byte ' + byte.toString(16));\n            }\n            return string;\n        }\n        function int8(bytes, it) {\n            return uint8(bytes, it) << 24 >> 24;\n        }\n        function uint8(bytes, it) {\n            return bytes[it.offset++];\n        }\n        function int16(bytes, it) {\n            return uint16(bytes, it) << 16 >> 16;\n        }\n        function uint16(bytes, it) {\n            return bytes[it.offset++] | bytes[it.offset++] << 8;\n        }\n        function int32(bytes, it) {\n            return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;\n        }\n        function uint32(bytes, it) {\n            return int32(bytes, it) >>> 0;\n        }\n        function float32(bytes, it) {\n            return readFloat32(bytes, it);\n        }\n        function float64(bytes, it) {\n            return readFloat64(bytes, it);\n        }\n        function int64(bytes, it) {\n            var low = uint32(bytes, it);\n            var high = int32(bytes, it) * Math.pow(2, 32);\n            return high + low;\n        }\n        function uint64(bytes, it) {\n            var low = uint32(bytes, it);\n            var high = uint32(bytes, it) * Math.pow(2, 32);\n            return high + low;\n        }\n        var _int32 = new Int32Array(2);\n        var _float32 = new Float32Array(_int32.buffer);\n        var _float64 = new Float64Array(_int32.buffer);\n        function readFloat32(bytes, it) {\n            _int32[0] = int32(bytes, it);\n            return _float32[0];\n        }\n        function readFloat64(bytes, it) {\n            _int32[0 ] = int32(bytes, it);\n            _int32[1 ] = int32(bytes, it);\n            return _float64[0];\n        }\n        function boolean(bytes, it) {\n            return uint8(bytes, it) > 0;\n        }\n        function string(bytes, it) {\n            var prefix = bytes[it.offset++];\n            var length;\n            if (prefix < 0xc0) {\n                // fixstr\n                length = prefix & 0x1f;\n            }\n            else if (prefix === 0xd9) {\n                length = uint8(bytes, it);\n            }\n            else if (prefix === 0xda) {\n                length = uint16(bytes, it);\n            }\n            else if (prefix === 0xdb) {\n                length = uint32(bytes, it);\n            }\n            var value = utf8Read(bytes, it.offset, length);\n            it.offset += length;\n            return value;\n        }\n        function stringCheck(bytes, it) {\n            var prefix = bytes[it.offset];\n            return (\n            // fixstr\n            (prefix < 0xc0 && prefix > 0xa0) ||\n                // str 8\n                prefix === 0xd9 ||\n                // str 16\n                prefix === 0xda ||\n                // str 32\n                prefix === 0xdb);\n        }\n        function number(bytes, it) {\n            var prefix = bytes[it.offset++];\n            if (prefix < 0x80) {\n                // positive fixint\n                return prefix;\n            }\n            else if (prefix === 0xca) {\n                // float 32\n                return readFloat32(bytes, it);\n            }\n            else if (prefix === 0xcb) {\n                // float 64\n                return readFloat64(bytes, it);\n            }\n            else if (prefix === 0xcc) {\n                // uint 8\n                return uint8(bytes, it);\n            }\n            else if (prefix === 0xcd) {\n                // uint 16\n                return uint16(bytes, it);\n            }\n            else if (prefix === 0xce) {\n                // uint 32\n                return uint32(bytes, it);\n            }\n            else if (prefix === 0xcf) {\n                // uint 64\n                return uint64(bytes, it);\n            }\n            else if (prefix === 0xd0) {\n                // int 8\n                return int8(bytes, it);\n            }\n            else if (prefix === 0xd1) {\n                // int 16\n                return int16(bytes, it);\n            }\n            else if (prefix === 0xd2) {\n                // int 32\n                return int32(bytes, it);\n            }\n            else if (prefix === 0xd3) {\n                // int 64\n                return int64(bytes, it);\n            }\n            else if (prefix > 0xdf) {\n                // negative fixint\n                return (0xff - prefix + 1) * -1;\n            }\n        }\n        function numberCheck(bytes, it) {\n            var prefix = bytes[it.offset];\n            // positive fixint - 0x00 - 0x7f\n            // float 32        - 0xca\n            // float 64        - 0xcb\n            // uint 8          - 0xcc\n            // uint 16         - 0xcd\n            // uint 32         - 0xce\n            // uint 64         - 0xcf\n            // int 8           - 0xd0\n            // int 16          - 0xd1\n            // int 32          - 0xd2\n            // int 64          - 0xd3\n            return (prefix < 0x80 ||\n                (prefix >= 0xca && prefix <= 0xd3));\n        }\n        function arrayCheck(bytes, it) {\n            return bytes[it.offset] < 0xa0;\n            // const prefix = bytes[it.offset] ;\n            // if (prefix < 0xa0) {\n            //   return prefix;\n            // // array\n            // } else if (prefix === 0xdc) {\n            //   it.offset += 2;\n            // } else if (0xdd) {\n            //   it.offset += 4;\n            // }\n            // return prefix;\n        }\n        function switchStructureCheck(bytes, it) {\n            return (\n            // previous byte should be `SWITCH_TO_STRUCTURE`\n            bytes[it.offset - 1] === SWITCH_TO_STRUCTURE &&\n                // next byte should be a number\n                (bytes[it.offset] < 0x80 || (bytes[it.offset] >= 0xca && bytes[it.offset] <= 0xd3)));\n        }\n\n        var decode = /*#__PURE__*/Object.freeze({\n            __proto__: null,\n            int8: int8,\n            uint8: uint8,\n            int16: int16,\n            uint16: uint16,\n            int32: int32,\n            uint32: uint32,\n            float32: float32,\n            float64: float64,\n            int64: int64,\n            uint64: uint64,\n            readFloat32: readFloat32,\n            readFloat64: readFloat64,\n            boolean: boolean,\n            string: string,\n            stringCheck: stringCheck,\n            number: number,\n            numberCheck: numberCheck,\n            arrayCheck: arrayCheck,\n            switchStructureCheck: switchStructureCheck\n        });\n\n        var CollectionSchema = /** @class */ (function () {\n            function CollectionSchema(initialValues) {\n                var _this = this;\n                this.$changes = new ChangeTree(this);\n                this.$items = new Map();\n                this.$indexes = new Map();\n                this.$refId = 0;\n                if (initialValues) {\n                    initialValues.forEach(function (v) { return _this.add(v); });\n                }\n            }\n            CollectionSchema.is = function (type) {\n                return type['collection'] !== undefined;\n            };\n            CollectionSchema.prototype.add = function (value) {\n                // set \"index\" for reference.\n                var index = this.$refId++;\n                var isRef = (value['$changes']) !== undefined;\n                if (isRef) {\n                    value['$changes'].setParent(this, this.$changes.root, index);\n                }\n                this.$changes.indexes[index] = index;\n                this.$indexes.set(index, index);\n                this.$items.set(index, value);\n                this.$changes.change(index);\n                return index;\n            };\n            CollectionSchema.prototype.at = function (index) {\n                var key = Array.from(this.$items.keys())[index];\n                return this.$items.get(key);\n            };\n            CollectionSchema.prototype.entries = function () {\n                return this.$items.entries();\n            };\n            CollectionSchema.prototype.delete = function (item) {\n                var entries = this.$items.entries();\n                var index;\n                var entry;\n                while (entry = entries.next()) {\n                    if (entry.done) {\n                        break;\n                    }\n                    if (item === entry.value[1]) {\n                        index = entry.value[0];\n                        break;\n                    }\n                }\n                if (index === undefined) {\n                    return false;\n                }\n                this.$changes.delete(index);\n                this.$indexes.delete(index);\n                return this.$items.delete(index);\n            };\n            CollectionSchema.prototype.clear = function (isDecoding) {\n                var _this = this;\n                // discard previous operations.\n                this.$changes.discard(true, true);\n                this.$changes.indexes = {};\n                // clear previous indexes\n                this.$indexes.clear();\n                // flag child items for garbage collection.\n                if (isDecoding && typeof (this.$changes.getType()) !== \"string\") {\n                    this.$items.forEach(function (item) {\n                        _this.$changes.root.removeRef(item['$changes'].refId);\n                    });\n                }\n                // clear items\n                this.$items.clear();\n                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });\n                // touch all structures until reach root\n                this.$changes.touchParents();\n            };\n            CollectionSchema.prototype.has = function (value) {\n                return Array.from(this.$items.values()).some(function (v) { return v === value; });\n            };\n            CollectionSchema.prototype.forEach = function (callbackfn) {\n                var _this = this;\n                this.$items.forEach(function (value, key, _) { return callbackfn(value, key, _this); });\n            };\n            CollectionSchema.prototype.values = function () {\n                return this.$items.values();\n            };\n            Object.defineProperty(CollectionSchema.prototype, \"size\", {\n                get: function () {\n                    return this.$items.size;\n                },\n                enumerable: false,\n                configurable: true\n            });\n            CollectionSchema.prototype.setIndex = function (index, key) {\n                this.$indexes.set(index, key);\n            };\n            CollectionSchema.prototype.getIndex = function (index) {\n                return this.$indexes.get(index);\n            };\n            CollectionSchema.prototype.getByIndex = function (index) {\n                return this.$items.get(this.$indexes.get(index));\n            };\n            CollectionSchema.prototype.deleteByIndex = function (index) {\n                var key = this.$indexes.get(index);\n                this.$items.delete(key);\n                this.$indexes.delete(index);\n            };\n            CollectionSchema.prototype.toArray = function () {\n                return Array.from(this.$items.values());\n            };\n            CollectionSchema.prototype.toJSON = function () {\n                var values = [];\n                this.forEach(function (value, key) {\n                    values.push((typeof (value['toJSON']) === \"function\")\n                        ? value['toJSON']()\n                        : value);\n                });\n                return values;\n            };\n            //\n            // Decoding utilities\n            //\n            CollectionSchema.prototype.clone = function (isDecoding) {\n                var cloned;\n                if (isDecoding) {\n                    // client-side\n                    cloned = Object.assign(new CollectionSchema(), this);\n                }\n                else {\n                    // server-side\n                    cloned = new CollectionSchema();\n                    this.forEach(function (value) {\n                        if (value['$changes']) {\n                            cloned.add(value['clone']());\n                        }\n                        else {\n                            cloned.add(value);\n                        }\n                    });\n                }\n                return cloned;\n            };\n            CollectionSchema.prototype.triggerAll = function () {\n                Schema.prototype.triggerAll.apply(this);\n            };\n            return CollectionSchema;\n        }());\n\n        var SetSchema = /** @class */ (function () {\n            function SetSchema(initialValues) {\n                var _this = this;\n                this.$changes = new ChangeTree(this);\n                this.$items = new Map();\n                this.$indexes = new Map();\n                this.$refId = 0;\n                if (initialValues) {\n                    initialValues.forEach(function (v) { return _this.add(v); });\n                }\n            }\n            SetSchema.is = function (type) {\n                return type['set'] !== undefined;\n            };\n            SetSchema.prototype.add = function (value) {\n                var _a, _b;\n                // immediatelly return false if value already added.\n                if (this.has(value)) {\n                    return false;\n                }\n                // set \"index\" for reference.\n                var index = this.$refId++;\n                if ((value['$changes']) !== undefined) {\n                    value['$changes'].setParent(this, this.$changes.root, index);\n                }\n                var operation = (_b = (_a = this.$changes.indexes[index]) === null || _a === void 0 ? void 0 : _a.op) !== null && _b !== void 0 ? _b : exports.OPERATION.ADD;\n                this.$changes.indexes[index] = index;\n                this.$indexes.set(index, index);\n                this.$items.set(index, value);\n                this.$changes.change(index, operation);\n                return index;\n            };\n            SetSchema.prototype.entries = function () {\n                return this.$items.entries();\n            };\n            SetSchema.prototype.delete = function (item) {\n                var entries = this.$items.entries();\n                var index;\n                var entry;\n                while (entry = entries.next()) {\n                    if (entry.done) {\n                        break;\n                    }\n                    if (item === entry.value[1]) {\n                        index = entry.value[0];\n                        break;\n                    }\n                }\n                if (index === undefined) {\n                    return false;\n                }\n                this.$changes.delete(index);\n                this.$indexes.delete(index);\n                return this.$items.delete(index);\n            };\n            SetSchema.prototype.clear = function (isDecoding) {\n                var _this = this;\n                // discard previous operations.\n                this.$changes.discard(true, true);\n                this.$changes.indexes = {};\n                // clear previous indexes\n                this.$indexes.clear();\n                // flag child items for garbage collection.\n                if (isDecoding && typeof (this.$changes.getType()) !== \"string\") {\n                    this.$items.forEach(function (item) {\n                        _this.$changes.root.removeRef(item['$changes'].refId);\n                    });\n                }\n                // clear items\n                this.$items.clear();\n                this.$changes.operation({ index: 0, op: exports.OPERATION.CLEAR });\n                // touch all structures until reach root\n                this.$changes.touchParents();\n            };\n            SetSchema.prototype.has = function (value) {\n                var values = this.$items.values();\n                var has = false;\n                var entry;\n                while (entry = values.next()) {\n                    if (entry.done) {\n                        break;\n                    }\n                    if (value === entry.value) {\n                        has = true;\n                        break;\n                    }\n                }\n                return has;\n            };\n            SetSchema.prototype.forEach = function (callbackfn) {\n                var _this = this;\n                this.$items.forEach(function (value, key, _) { return callbackfn(value, key, _this); });\n            };\n            SetSchema.prototype.values = function () {\n                return this.$items.values();\n            };\n            Object.defineProperty(SetSchema.prototype, \"size\", {\n                get: function () {\n                    return this.$items.size;\n                },\n                enumerable: false,\n                configurable: true\n            });\n            SetSchema.prototype.setIndex = function (index, key) {\n                this.$indexes.set(index, key);\n            };\n            SetSchema.prototype.getIndex = function (index) {\n                return this.$indexes.get(index);\n            };\n            SetSchema.prototype.getByIndex = function (index) {\n                return this.$items.get(this.$indexes.get(index));\n            };\n            SetSchema.prototype.deleteByIndex = function (index) {\n                var key = this.$indexes.get(index);\n                this.$items.delete(key);\n                this.$indexes.delete(index);\n            };\n            SetSchema.prototype.toArray = function () {\n                return Array.from(this.$items.values());\n            };\n            SetSchema.prototype.toJSON = function () {\n                var values = [];\n                this.forEach(function (value, key) {\n                    values.push((typeof (value['toJSON']) === \"function\")\n                        ? value['toJSON']()\n                        : value);\n                });\n                return values;\n            };\n            //\n            // Decoding utilities\n            //\n            SetSchema.prototype.clone = function (isDecoding) {\n                var cloned;\n                if (isDecoding) {\n                    // client-side\n                    cloned = Object.assign(new SetSchema(), this);\n                }\n                else {\n                    // server-side\n                    cloned = new SetSchema();\n                    this.forEach(function (value) {\n                        if (value['$changes']) {\n                            cloned.add(value['clone']());\n                        }\n                        else {\n                            cloned.add(value);\n                        }\n                    });\n                }\n                return cloned;\n            };\n            SetSchema.prototype.triggerAll = function () {\n                Schema.prototype.triggerAll.apply(this);\n            };\n            return SetSchema;\n        }());\n\n        /**\n         * Extracted from https://www.npmjs.com/package/strong-events\n         */\n        var EventEmitter_ = /** @class */ (function () {\n            function EventEmitter_() {\n                this.handlers = [];\n            }\n            EventEmitter_.prototype.register = function (cb, once) {\n                this.handlers.push(cb);\n                return this;\n            };\n            EventEmitter_.prototype.invoke = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                this.handlers.forEach(function (handler) { return handler.apply(void 0, args); });\n            };\n            EventEmitter_.prototype.invokeAsync = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return Promise.all(this.handlers.map(function (handler) { return handler.apply(void 0, args); }));\n            };\n            EventEmitter_.prototype.remove = function (cb) {\n                var index = this.handlers.indexOf(cb);\n                this.handlers[index] = this.handlers[this.handlers.length - 1];\n                this.handlers.pop();\n            };\n            EventEmitter_.prototype.clear = function () {\n                this.handlers = [];\n            };\n            return EventEmitter_;\n        }());\n\n        var ClientState = /** @class */ (function () {\n            function ClientState() {\n                this.refIds = new WeakSet();\n                this.containerIndexes = new WeakMap();\n            }\n            // containerIndexes = new Map<ChangeTree, Set<number>>();\n            ClientState.prototype.addRefId = function (changeTree) {\n                if (!this.refIds.has(changeTree)) {\n                    this.refIds.add(changeTree);\n                    this.containerIndexes.set(changeTree, new Set());\n                }\n            };\n            ClientState.get = function (client) {\n                if (client.$filterState === undefined) {\n                    client.$filterState = new ClientState();\n                }\n                return client.$filterState;\n            };\n            return ClientState;\n        }());\n\n        var EncodeSchemaError = /** @class */ (function (_super) {\n            __extends(EncodeSchemaError, _super);\n            function EncodeSchemaError() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            return EncodeSchemaError;\n        }(Error));\n        function assertType(value, type, klass, field) {\n            var typeofTarget;\n            var allowNull = false;\n            switch (type) {\n                case \"number\":\n                case \"int8\":\n                case \"uint8\":\n                case \"int16\":\n                case \"uint16\":\n                case \"int32\":\n                case \"uint32\":\n                case \"int64\":\n                case \"uint64\":\n                case \"float32\":\n                case \"float64\":\n                    typeofTarget = \"number\";\n                    if (isNaN(value)) {\n                        console.log(\"trying to encode \\\"NaN\\\" in \" + klass.constructor.name + \"#\" + field);\n                    }\n                    break;\n                case \"string\":\n                    typeofTarget = \"string\";\n                    allowNull = true;\n                    break;\n                case \"boolean\":\n                    // boolean is always encoded as true/false based on truthiness\n                    return;\n            }\n            if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\n                var foundValue = \"'\" + JSON.stringify(value) + \"'\" + ((value && value.constructor && \" (\" + value.constructor.name + \")\") || '');\n                throw new EncodeSchemaError(\"a '\" + typeofTarget + \"' was expected, but \" + foundValue + \" was provided in \" + klass.constructor.name + \"#\" + field);\n            }\n        }\n        function assertInstanceType(value, type, klass, field) {\n            if (!(value instanceof type)) {\n                throw new EncodeSchemaError(\"a '\" + type.name + \"' was expected, but '\" + value.constructor.name + \"' was provided in \" + klass.constructor.name + \"#\" + field);\n            }\n        }\n        function encodePrimitiveType(type, bytes, value, klass, field) {\n            assertType(value, type, klass, field);\n            var encodeFunc = encode[type];\n            if (encodeFunc) {\n                encodeFunc(bytes, value);\n            }\n            else {\n                throw new EncodeSchemaError(\"a '\" + type + \"' was expected, but \" + value + \" was provided in \" + klass.constructor.name + \"#\" + field);\n            }\n        }\n        function decodePrimitiveType(type, bytes, it) {\n            return decode[type](bytes, it);\n        }\n        /**\n         * Schema encoder / decoder\n         */\n        var Schema = /** @class */ (function () {\n            // allow inherited classes to have a constructor\n            function Schema() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                // fix enumerability of fields for end-user\n                Object.defineProperties(this, {\n                    $changes: {\n                        value: new ChangeTree(this, undefined, new Root()),\n                        enumerable: false,\n                        writable: true\n                    },\n                    $listeners: {\n                        value: {},\n                        enumerable: false,\n                        writable: true\n                    },\n                });\n                var descriptors = this._definition.descriptors;\n                if (descriptors) {\n                    Object.defineProperties(this, descriptors);\n                }\n                //\n                // Assign initial values\n                //\n                if (args[0]) {\n                    this.assign(args[0]);\n                }\n            }\n            Schema.onError = function (e) {\n                console.error(e);\n            };\n            Schema.is = function (type) {\n                return (type['_definition'] &&\n                    type['_definition'].schema !== undefined);\n            };\n            Schema.prototype.assign = function (props) {\n                Object.assign(this, props);\n                return this;\n            };\n            Object.defineProperty(Schema.prototype, \"_definition\", {\n                get: function () { return this.constructor._definition; },\n                enumerable: false,\n                configurable: true\n            });\n            Schema.prototype.listen = function (attr, callback) {\n                var _this = this;\n                if (!this.$listeners[attr]) {\n                    this.$listeners[attr] = new EventEmitter_();\n                }\n                this.$listeners[attr].register(callback);\n                // return un-register callback.\n                return function () {\n                    return _this.$listeners[attr].remove(callback);\n                };\n            };\n            Schema.prototype.decode = function (bytes, it, ref, allChanges) {\n                if (it === void 0) { it = { offset: 0 }; }\n                if (ref === void 0) { ref = this; }\n                if (allChanges === void 0) { allChanges = new Map(); }\n                var $root = this.$changes.root;\n                var totalBytes = bytes.length;\n                var refId = 0;\n                var changes = [];\n                $root.refs.set(refId, this);\n                allChanges.set(refId, changes);\n                while (it.offset < totalBytes) {\n                    var byte = bytes[it.offset++];\n                    if (byte == SWITCH_TO_STRUCTURE) {\n                        refId = number(bytes, it);\n                        var nextRef = $root.refs.get(refId);\n                        //\n                        // Trying to access a reference that haven't been decoded yet.\n                        //\n                        if (!nextRef) {\n                            throw new Error(\"\\\"refId\\\" not found: \" + refId);\n                        }\n                        ref = nextRef;\n                        // create empty list of changes for this refId.\n                        changes = [];\n                        allChanges.set(refId, changes);\n                        continue;\n                    }\n                    var changeTree = ref['$changes'];\n                    var isSchema = (ref['_definition'] !== undefined);\n                    var operation = (isSchema)\n                        ? (byte >> 6) << 6 // \"compressed\" index + operation\n                        : byte; // \"uncompressed\" index + operation (array/map items)\n                    if (operation === exports.OPERATION.CLEAR) {\n                        //\n                        // TODO: refactor me!\n                        // The `.clear()` method is calling `$root.removeRef(refId)` for\n                        // each item inside this collection\n                        //\n                        ref.clear(true);\n                        continue;\n                    }\n                    var fieldIndex = (isSchema)\n                        ? byte % (operation || 255) // if \"REPLACE\" operation (0), use 255\n                        : number(bytes, it);\n                    var fieldName = (isSchema)\n                        ? (ref['_definition'].fieldsByIndex[fieldIndex])\n                        : \"\";\n                    var type = changeTree.getType(fieldIndex);\n                    var value = void 0;\n                    var previousValue = void 0;\n                    var dynamicIndex = void 0;\n                    if (!isSchema) {\n                        previousValue = ref['getByIndex'](fieldIndex);\n                        if ((operation & exports.OPERATION.ADD) === exports.OPERATION.ADD) { // ADD or DELETE_AND_ADD\n                            dynamicIndex = (ref instanceof MapSchema)\n                                ? string(bytes, it)\n                                : fieldIndex;\n                            ref['setIndex'](fieldIndex, dynamicIndex);\n                        }\n                        else {\n                            // here\n                            dynamicIndex = ref['getIndex'](fieldIndex);\n                        }\n                    }\n                    else {\n                        previousValue = ref[\"_\" + fieldName];\n                    }\n                    //\n                    // Delete operations\n                    //\n                    if ((operation & exports.OPERATION.DELETE) === exports.OPERATION.DELETE) {\n                        if (operation !== exports.OPERATION.DELETE_AND_ADD) {\n                            ref['deleteByIndex'](fieldIndex);\n                        }\n                        // Flag `refId` for garbage collection.\n                        if (previousValue && previousValue['$changes']) {\n                            $root.removeRef(previousValue['$changes'].refId);\n                        }\n                        value = null;\n                    }\n                    if (fieldName === undefined) {\n                        console.warn(\"@colyseus/schema: definition mismatch\");\n                        //\n                        // keep skipping next bytes until reaches a known structure\n                        // by local decoder.\n                        //\n                        var nextIterator = { offset: it.offset };\n                        while (it.offset < totalBytes) {\n                            if (switchStructureCheck(bytes, it)) {\n                                nextIterator.offset = it.offset + 1;\n                                if ($root.refs.has(number(bytes, nextIterator))) {\n                                    break;\n                                }\n                            }\n                            it.offset++;\n                        }\n                        continue;\n                    }\n                    else if (operation === exports.OPERATION.DELETE) ;\n                    else if (Schema.is(type)) {\n                        var refId_1 = number(bytes, it);\n                        value = $root.refs.get(refId_1);\n                        if (operation !== exports.OPERATION.REPLACE) {\n                            var childType = this.getSchemaType(bytes, it, type);\n                            if (!value) {\n                                value = this.createTypeInstance(childType);\n                                value.$changes.refId = refId_1;\n                                if (previousValue) {\n                                    value.onChange = previousValue.onChange;\n                                    value.onRemove = previousValue.onRemove;\n                                    value.$listeners = previousValue.$listeners;\n                                    if (previousValue['$changes'].refId &&\n                                        refId_1 !== previousValue['$changes'].refId) {\n                                        $root.removeRef(previousValue['$changes'].refId);\n                                    }\n                                }\n                            }\n                            $root.addRef(refId_1, value, (value !== previousValue));\n                        }\n                    }\n                    else if (typeof (type) === \"string\") {\n                        //\n                        // primitive value (number, string, boolean, etc)\n                        //\n                        value = decodePrimitiveType(type, bytes, it);\n                    }\n                    else {\n                        var typeDef = getType(Object.keys(type)[0]);\n                        var refId_2 = number(bytes, it);\n                        var valueRef = ($root.refs.has(refId_2))\n                            ? previousValue || $root.refs.get(refId_2)\n                            : new typeDef.constructor();\n                        value = valueRef.clone(true);\n                        value.$changes.refId = refId_2;\n                        // preserve schema callbacks\n                        if (previousValue) {\n                            value.onAdd = previousValue.onAdd;\n                            value.onRemove = previousValue.onRemove;\n                            value.onChange = previousValue.onChange;\n                            if (previousValue['$changes'].refId &&\n                                refId_2 !== previousValue['$changes'].refId) {\n                                $root.removeRef(previousValue['$changes'].refId);\n                                //\n                                // Trigger onRemove if structure has been replaced.\n                                //\n                                var deletes = [];\n                                var entries = previousValue.entries();\n                                var iter = void 0;\n                                while ((iter = entries.next()) && !iter.done) {\n                                    var _a = iter.value, key = _a[0], value_1 = _a[1];\n                                    deletes.push({\n                                        op: exports.OPERATION.DELETE,\n                                        field: key,\n                                        value: undefined,\n                                        previousValue: value_1,\n                                    });\n                                }\n                                allChanges.set(previousValue['$changes'].refId, deletes);\n                            }\n                        }\n                        $root.addRef(refId_2, value, (valueRef !== previousValue));\n                        //\n                        // TODO: deprecate proxies on next version.\n                        // get proxy to target value.\n                        //\n                        if (typeDef.getProxy) {\n                            value = typeDef.getProxy(value);\n                        }\n                    }\n                    var hasChange = (previousValue !== value);\n                    if (value !== null &&\n                        value !== undefined) {\n                        if (value['$changes']) {\n                            value['$changes'].setParent(changeTree.ref, changeTree.root, fieldIndex);\n                        }\n                        if (ref instanceof Schema) {\n                            ref[fieldName] = value;\n                            //\n                            // FIXME: use `_field` instead of `field`.\n                            //\n                            // `field` is going to use the setter of the PropertyDescriptor\n                            // and create a proxy for array/map. This is only useful for\n                            // backwards-compatibility with @colyseus/schema@0.5.x\n                            //\n                            // // ref[_field] = value;\n                        }\n                        else if (ref instanceof MapSchema) {\n                            // const key = ref['$indexes'].get(field);\n                            var key = dynamicIndex;\n                            // ref.set(key, value);\n                            ref['$items'].set(key, value);\n                        }\n                        else if (ref instanceof ArraySchema) {\n                            // const key = ref['$indexes'][field];\n                            // console.log(\"SETTING FOR ArraySchema =>\", { field, key, value });\n                            // ref[key] = value;\n                            ref.setAt(fieldIndex, value);\n                        }\n                        else if (ref instanceof CollectionSchema) {\n                            var index = ref.add(value);\n                            ref['setIndex'](fieldIndex, index);\n                        }\n                        else if (ref instanceof SetSchema) {\n                            var index = ref.add(value);\n                            if (index !== false) {\n                                ref['setIndex'](fieldIndex, index);\n                            }\n                        }\n                    }\n                    if (hasChange\n                    // &&\n                    // (\n                    //     this.onChange || ref.$listeners[field]\n                    // )\n                    ) {\n                        changes.push({\n                            op: operation,\n                            field: fieldName,\n                            dynamicIndex: dynamicIndex,\n                            value: value,\n                            previousValue: previousValue,\n                        });\n                    }\n                }\n                this._triggerChanges(allChanges);\n                // drop references of unused schemas\n                $root.garbageCollectDeletedRefs();\n                return allChanges;\n            };\n            Schema.prototype.encode = function (encodeAll, bytes, useFilters) {\n                if (encodeAll === void 0) { encodeAll = false; }\n                if (bytes === void 0) { bytes = []; }\n                if (useFilters === void 0) { useFilters = false; }\n                var rootChangeTree = this.$changes;\n                var refIdsVisited = new WeakSet();\n                var changeTrees = [rootChangeTree];\n                var numChangeTrees = 1;\n                for (var i = 0; i < numChangeTrees; i++) {\n                    var changeTree = changeTrees[i];\n                    var ref = changeTree.ref;\n                    var isSchema = (ref instanceof Schema);\n                    // Generate unique refId for the ChangeTree.\n                    changeTree.ensureRefId();\n                    // mark this ChangeTree as visited.\n                    refIdsVisited.add(changeTree);\n                    // root `refId` is skipped.\n                    if (changeTree !== rootChangeTree &&\n                        (changeTree.changed || encodeAll)) {\n                        uint8$1(bytes, SWITCH_TO_STRUCTURE);\n                        number$1(bytes, changeTree.refId);\n                    }\n                    var changes = (encodeAll)\n                        ? Array.from(changeTree.allChanges)\n                        : Array.from(changeTree.changes.values());\n                    for (var j = 0, cl = changes.length; j < cl; j++) {\n                        var operation = (encodeAll)\n                            ? { op: exports.OPERATION.ADD, index: changes[j] }\n                            : changes[j];\n                        var fieldIndex = operation.index;\n                        var field = (isSchema)\n                            ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]\n                            : fieldIndex;\n                        // cache begin index if `useFilters`\n                        var beginIndex = bytes.length;\n                        // encode field index + operation\n                        if (operation.op !== exports.OPERATION.TOUCH) {\n                            if (isSchema) {\n                                //\n                                // Compress `fieldIndex` + `operation` into a single byte.\n                                // This adds a limitaion of 64 fields per Schema structure\n                                //\n                                uint8$1(bytes, (fieldIndex | operation.op));\n                            }\n                            else {\n                                uint8$1(bytes, operation.op);\n                                // custom operations\n                                if (operation.op === exports.OPERATION.CLEAR) {\n                                    continue;\n                                }\n                                // indexed operations\n                                number$1(bytes, fieldIndex);\n                            }\n                        }\n                        //\n                        // encode \"alias\" for dynamic fields (maps)\n                        //\n                        if (!isSchema &&\n                            (operation.op & exports.OPERATION.ADD) == exports.OPERATION.ADD // ADD or DELETE_AND_ADD\n                        ) {\n                            if (ref instanceof MapSchema) {\n                                //\n                                // MapSchema dynamic key\n                                //\n                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                string$1(bytes, dynamicIndex);\n                            }\n                        }\n                        if (operation.op === exports.OPERATION.DELETE) {\n                            //\n                            // TODO: delete from filter cache data.\n                            //\n                            // if (useFilters) {\n                            //     delete changeTree.caches[fieldIndex];\n                            // }\n                            continue;\n                        }\n                        // const type = changeTree.childType || ref._schema[field];\n                        var type = changeTree.getType(fieldIndex);\n                        // const type = changeTree.getType(fieldIndex);\n                        var value = changeTree.getValue(fieldIndex);\n                        // Enqueue ChangeTree to be visited\n                        if (value &&\n                            value['$changes'] &&\n                            !refIdsVisited.has(value['$changes'])) {\n                            changeTrees.push(value['$changes']);\n                            value['$changes'].ensureRefId();\n                            numChangeTrees++;\n                        }\n                        if (operation.op === exports.OPERATION.TOUCH) {\n                            continue;\n                        }\n                        if (Schema.is(type)) {\n                            assertInstanceType(value, type, ref, field);\n                            //\n                            // Encode refId for this instance.\n                            // The actual instance is going to be encoded on next `changeTree` iteration.\n                            //\n                            number$1(bytes, value.$changes.refId);\n                            // Try to encode inherited TYPE_ID if it's an ADD operation.\n                            if ((operation.op & exports.OPERATION.ADD) === exports.OPERATION.ADD) {\n                                this.tryEncodeTypeId(bytes, type, value.constructor);\n                            }\n                        }\n                        else if (typeof (type) === \"string\") {\n                            //\n                            // Primitive values\n                            //\n                            encodePrimitiveType(type, bytes, value, ref, field);\n                        }\n                        else {\n                            //\n                            // Custom type (MapSchema, ArraySchema, etc)\n                            //\n                            var definition = getType(Object.keys(type)[0]);\n                            //\n                            // ensure a ArraySchema has been provided\n                            //\n                            assertInstanceType(ref[\"_\" + field], definition.constructor, ref, field);\n                            //\n                            // Encode refId for this instance.\n                            // The actual instance is going to be encoded on next `changeTree` iteration.\n                            //\n                            number$1(bytes, value.$changes.refId);\n                        }\n                        if (useFilters) {\n                            // cache begin / end index\n                            changeTree.cache(fieldIndex, bytes.slice(beginIndex));\n                        }\n                    }\n                    if (!encodeAll && !useFilters) {\n                        changeTree.discard();\n                    }\n                }\n                return bytes;\n            };\n            Schema.prototype.encodeAll = function (useFilters) {\n                return this.encode(true, [], useFilters);\n            };\n            Schema.prototype.applyFilters = function (client, encodeAll) {\n                var _a, _b;\n                if (encodeAll === void 0) { encodeAll = false; }\n                var root = this;\n                var refIdsDissallowed = new Set();\n                var $filterState = ClientState.get(client);\n                var changeTrees = [this.$changes];\n                var numChangeTrees = 1;\n                var filteredBytes = [];\n                var _loop_1 = function (i) {\n                    var changeTree = changeTrees[i];\n                    if (refIdsDissallowed.has(changeTree.refId)) {\n                        return \"continue\";\n                    }\n                    var ref = changeTree.ref;\n                    var isSchema = ref instanceof Schema;\n                    uint8$1(filteredBytes, SWITCH_TO_STRUCTURE);\n                    number$1(filteredBytes, changeTree.refId);\n                    var clientHasRefId = $filterState.refIds.has(changeTree);\n                    var isEncodeAll = (encodeAll || !clientHasRefId);\n                    // console.log(\"REF:\", ref.constructor.name);\n                    // console.log(\"Encode all?\", isEncodeAll);\n                    //\n                    // include `changeTree` on list of known refIds by this client.\n                    //\n                    $filterState.addRefId(changeTree);\n                    var containerIndexes = $filterState.containerIndexes.get(changeTree);\n                    var changes = (isEncodeAll)\n                        ? Array.from(changeTree.allChanges)\n                        : Array.from(changeTree.changes.values());\n                    //\n                    // WORKAROUND: tries to re-evaluate previously not included @filter() attributes\n                    // - see \"DELETE a field of Schema\" test case.\n                    //\n                    if (!encodeAll &&\n                        isSchema &&\n                        ref._definition.indexesWithFilters) {\n                        var indexesWithFilters = ref._definition.indexesWithFilters;\n                        indexesWithFilters.forEach(function (indexWithFilter) {\n                            if (!containerIndexes.has(indexWithFilter) &&\n                                changeTree.allChanges.has(indexWithFilter)) {\n                                if (isEncodeAll) {\n                                    changes.push(indexWithFilter);\n                                }\n                                else {\n                                    changes.push({ op: exports.OPERATION.ADD, index: indexWithFilter, });\n                                }\n                            }\n                        });\n                    }\n                    for (var j = 0, cl = changes.length; j < cl; j++) {\n                        var change = (isEncodeAll)\n                            ? { op: exports.OPERATION.ADD, index: changes[j] }\n                            : changes[j];\n                        // custom operations\n                        if (change.op === exports.OPERATION.CLEAR) {\n                            uint8$1(filteredBytes, change.op);\n                            continue;\n                        }\n                        var fieldIndex = change.index;\n                        //\n                        // Deleting fields: encode the operation + field index\n                        //\n                        if (change.op === exports.OPERATION.DELETE) {\n                            //\n                            // DELETE operations also need to go through filtering.\n                            //\n                            // TODO: cache the previous value so we can access the value (primitive or `refId`)\n                            // (check against `$filterState.refIds`)\n                            //\n                            if (isSchema) {\n                                uint8$1(filteredBytes, change.op | fieldIndex);\n                            }\n                            else {\n                                uint8$1(filteredBytes, change.op);\n                                number$1(filteredBytes, fieldIndex);\n                            }\n                            continue;\n                        }\n                        // indexed operation\n                        var value = changeTree.getValue(fieldIndex);\n                        var type = changeTree.getType(fieldIndex);\n                        if (isSchema) {\n                            // Is a Schema!\n                            var filter = (ref._definition.filters &&\n                                ref._definition.filters[fieldIndex]);\n                            if (filter && !filter.call(ref, client, value, root)) {\n                                if (value && value['$changes']) {\n                                    refIdsDissallowed.add(value['$changes'].refId);\n                                }\n                                continue;\n                            }\n                        }\n                        else {\n                            // Is a collection! (map, array, etc.)\n                            var parent = changeTree.parent;\n                            var filter = changeTree.getChildrenFilter();\n                            if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {\n                                if (value && value['$changes']) {\n                                    refIdsDissallowed.add(value['$changes'].refId);\n                                }\n                                continue;\n                            }\n                        }\n                        // visit child ChangeTree on further iteration.\n                        if (value['$changes']) {\n                            changeTrees.push(value['$changes']);\n                            numChangeTrees++;\n                        }\n                        //\n                        // Copy cached bytes\n                        //\n                        if (change.op !== exports.OPERATION.TOUCH) {\n                            //\n                            // TODO: refactor me!\n                            //\n                            if (change.op === exports.OPERATION.ADD || isSchema) {\n                                //\n                                // use cached bytes directly if is from Schema type.\n                                //\n                                filteredBytes.push.apply(filteredBytes, (_a = changeTree.caches[fieldIndex]) !== null && _a !== void 0 ? _a : []);\n                                containerIndexes.add(fieldIndex);\n                            }\n                            else {\n                                if (containerIndexes.has(fieldIndex)) {\n                                    //\n                                    // use cached bytes if already has the field\n                                    //\n                                    filteredBytes.push.apply(filteredBytes, (_b = changeTree.caches[fieldIndex]) !== null && _b !== void 0 ? _b : []);\n                                }\n                                else {\n                                    //\n                                    // force ADD operation if field is not known by this client.\n                                    //\n                                    containerIndexes.add(fieldIndex);\n                                    uint8$1(filteredBytes, exports.OPERATION.ADD);\n                                    number$1(filteredBytes, fieldIndex);\n                                    if (ref instanceof MapSchema) {\n                                        //\n                                        // MapSchema dynamic key\n                                        //\n                                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                        string$1(filteredBytes, dynamicIndex);\n                                    }\n                                    if (value['$changes']) {\n                                        number$1(filteredBytes, value['$changes'].refId);\n                                    }\n                                    else {\n                                        // \"encodePrimitiveType\" without type checking.\n                                        // the type checking has been done on the first .encode() call.\n                                        encode[type](filteredBytes, value);\n                                    }\n                                }\n                            }\n                        }\n                        else if (value['$changes'] && !isSchema) {\n                            //\n                            // TODO:\n                            // - track ADD/REPLACE/DELETE instances on `$filterState`\n                            // - do NOT always encode dynamicIndex for MapSchema.\n                            //   (If client already has that key, only the first index is necessary.)\n                            //\n                            uint8$1(filteredBytes, exports.OPERATION.ADD);\n                            number$1(filteredBytes, fieldIndex);\n                            if (ref instanceof MapSchema) {\n                                //\n                                // MapSchema dynamic key\n                                //\n                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                string$1(filteredBytes, dynamicIndex);\n                            }\n                            number$1(filteredBytes, value['$changes'].refId);\n                        }\n                    }\n                };\n                for (var i = 0; i < numChangeTrees; i++) {\n                    _loop_1(i);\n                }\n                return filteredBytes;\n            };\n            Schema.prototype.clone = function () {\n                var cloned = new (this.constructor);\n                var schema = this._definition.schema;\n                for (var field in schema) {\n                    if (typeof (this[field]) === \"object\" &&\n                        typeof (this[field].clone) === \"function\") {\n                        // deep clone\n                        cloned[field] = this[field].clone();\n                    }\n                    else {\n                        // primitive values\n                        cloned[field] = this[field];\n                    }\n                }\n                return cloned;\n            };\n            Schema.prototype.triggerAll = function () {\n                // skip if haven't received any remote refs yet.\n                if (this.$changes.root.refs.size === 0) {\n                    return;\n                }\n                var allChanges = new Map();\n                Schema.prototype._triggerAllFillChanges.call(this, this, allChanges);\n                try {\n                    Schema.prototype._triggerChanges.call(this, allChanges);\n                }\n                catch (e) {\n                    Schema.onError(e);\n                }\n            };\n            Schema.prototype.toJSON = function () {\n                var schema = this._definition.schema;\n                var deprecated = this._definition.deprecated;\n                var obj = {};\n                for (var field in schema) {\n                    if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== \"undefined\") {\n                        obj[field] = (typeof (this[field]['toJSON']) === \"function\")\n                            ? this[field]['toJSON']()\n                            : this[\"_\" + field];\n                    }\n                }\n                return obj;\n            };\n            Schema.prototype.discardAllChanges = function () {\n                this.$changes.discardAll();\n            };\n            Schema.prototype.getByIndex = function (index) {\n                return this[this._definition.fieldsByIndex[index]];\n            };\n            Schema.prototype.deleteByIndex = function (index) {\n                this[this._definition.fieldsByIndex[index]] = undefined;\n            };\n            Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {\n                if (type._typeid !== targetType._typeid) {\n                    uint8$1(bytes, TYPE_ID);\n                    number$1(bytes, targetType._typeid);\n                }\n            };\n            Schema.prototype.getSchemaType = function (bytes, it, defaultType) {\n                var type;\n                if (bytes[it.offset] === TYPE_ID) {\n                    it.offset++;\n                    type = this.constructor._context.get(number(bytes, it));\n                }\n                return type || defaultType;\n            };\n            Schema.prototype.createTypeInstance = function (type) {\n                var instance = new type();\n                // assign root on $changes\n                instance.$changes.root = this.$changes.root;\n                return instance;\n            };\n            Schema.prototype._triggerAllFillChanges = function (ref, allChanges) {\n                if (allChanges.has(ref['$changes'].refId)) {\n                    return;\n                }\n                var changes = [];\n                allChanges.set(ref['$changes'].refId || 0, changes);\n                if (ref instanceof Schema) {\n                    var schema = ref._definition.schema;\n                    for (var fieldName in schema) {\n                        var _field = \"_\" + fieldName;\n                        var value = ref[_field];\n                        if (value !== undefined) {\n                            changes.push({\n                                op: exports.OPERATION.ADD,\n                                field: fieldName,\n                                value: value,\n                                previousValue: undefined\n                            });\n                            if (value['$changes'] !== undefined) {\n                                Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);\n                            }\n                        }\n                    }\n                }\n                else {\n                    var entries = ref.entries();\n                    var iter = void 0;\n                    while ((iter = entries.next()) && !iter.done) {\n                        var _a = iter.value, key = _a[0], value = _a[1];\n                        changes.push({\n                            op: exports.OPERATION.ADD,\n                            field: key,\n                            dynamicIndex: key,\n                            value: value,\n                            previousValue: undefined,\n                        });\n                        if (value['$changes'] !== undefined) {\n                            Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);\n                        }\n                    }\n                }\n            };\n            Schema.prototype._triggerChanges = function (allChanges) {\n                var _this = this;\n                allChanges.forEach(function (changes, refId) {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n                    if (changes.length > 0) {\n                        var ref = _this.$changes.root.refs.get(refId);\n                        var isSchema = ref instanceof Schema;\n                        for (var i = 0; i < changes.length; i++) {\n                            var change = changes[i];\n                            var listener = ref['$listeners'] && ref['$listeners'][change.field];\n                            if (!isSchema) {\n                                if (change.op === exports.OPERATION.ADD && change.previousValue === undefined) {\n                                    (_b = (_a = ref).onAdd) === null || _b === void 0 ? void 0 : _b.call(_a, change.value, (_c = change.dynamicIndex) !== null && _c !== void 0 ? _c : change.field);\n                                }\n                                else if (change.op === exports.OPERATION.DELETE) {\n                                    //\n                                    // FIXME: `previousValue` should always be avaiiable.\n                                    // ADD + DELETE operations are still encoding DELETE operation.\n                                    //\n                                    if (change.previousValue !== undefined) {\n                                        (_e = (_d = ref).onRemove) === null || _e === void 0 ? void 0 : _e.call(_d, change.previousValue, (_f = change.dynamicIndex) !== null && _f !== void 0 ? _f : change.field);\n                                    }\n                                }\n                                else if (change.op === exports.OPERATION.DELETE_AND_ADD) {\n                                    if (change.previousValue !== undefined) {\n                                        (_h = (_g = ref).onRemove) === null || _h === void 0 ? void 0 : _h.call(_g, change.previousValue, change.dynamicIndex);\n                                    }\n                                    (_k = (_j = ref).onAdd) === null || _k === void 0 ? void 0 : _k.call(_j, change.value, change.dynamicIndex);\n                                }\n                                else if (change.op === exports.OPERATION.REPLACE ||\n                                    change.value !== change.previousValue) {\n                                    (_m = (_l = ref).onChange) === null || _m === void 0 ? void 0 : _m.call(_l, change.value, change.dynamicIndex);\n                                }\n                            }\n                            //\n                            // trigger onRemove on child structure.\n                            //\n                            if ((change.op & exports.OPERATION.DELETE) === exports.OPERATION.DELETE &&\n                                change.previousValue instanceof Schema &&\n                                change.previousValue.onRemove) {\n                                change.previousValue.onRemove();\n                            }\n                            if (listener) {\n                                try {\n                                    listener.invoke(change.value, change.previousValue);\n                                }\n                                catch (e) {\n                                    Schema.onError(e);\n                                }\n                            }\n                        }\n                        if (isSchema) {\n                            if (ref.onChange) {\n                                try {\n                                    ref.onChange(changes);\n                                }\n                                catch (e) {\n                                    Schema.onError(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            };\n            Schema._definition = SchemaDefinition.create();\n            return Schema;\n        }());\n\n        function dumpChanges(schema) {\n            var changeTrees = [schema['$changes']];\n            var numChangeTrees = 1;\n            var dump = {};\n            var currentStructure = dump;\n            var _loop_1 = function (i) {\n                var changeTree = changeTrees[i];\n                changeTree.changes.forEach(function (change) {\n                    var ref = changeTree.ref;\n                    var fieldIndex = change.index;\n                    var field = (ref['_definition'])\n                        ? ref['_definition'].fieldsByIndex[fieldIndex]\n                        : ref['$indexes'].get(fieldIndex);\n                    currentStructure[field] = changeTree.getValue(fieldIndex);\n                });\n            };\n            for (var i = 0; i < numChangeTrees; i++) {\n                _loop_1(i);\n            }\n            return dump;\n        }\n\n        var reflectionContext = new Context();\n        /**\n         * Reflection\n         */\n        var ReflectionField = /** @class */ (function (_super) {\n            __extends(ReflectionField, _super);\n            function ReflectionField() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            __decorate([\n                type(\"string\", reflectionContext)\n            ], ReflectionField.prototype, \"name\", void 0);\n            __decorate([\n                type(\"string\", reflectionContext)\n            ], ReflectionField.prototype, \"type\", void 0);\n            __decorate([\n                type(\"number\", reflectionContext)\n            ], ReflectionField.prototype, \"referencedType\", void 0);\n            return ReflectionField;\n        }(Schema));\n        var ReflectionType = /** @class */ (function (_super) {\n            __extends(ReflectionType, _super);\n            function ReflectionType() {\n                var _this = _super !== null && _super.apply(this, arguments) || this;\n                _this.fields = new ArraySchema();\n                return _this;\n            }\n            __decorate([\n                type(\"number\", reflectionContext)\n            ], ReflectionType.prototype, \"id\", void 0);\n            __decorate([\n                type([ReflectionField], reflectionContext)\n            ], ReflectionType.prototype, \"fields\", void 0);\n            return ReflectionType;\n        }(Schema));\n        var Reflection = /** @class */ (function (_super) {\n            __extends(Reflection, _super);\n            function Reflection() {\n                var _this = _super !== null && _super.apply(this, arguments) || this;\n                _this.types = new ArraySchema();\n                return _this;\n            }\n            Reflection.encode = function (instance) {\n                var rootSchemaType = instance.constructor;\n                var reflection = new Reflection();\n                reflection.rootType = rootSchemaType._typeid;\n                var buildType = function (currentType, schema) {\n                    for (var fieldName in schema) {\n                        var field = new ReflectionField();\n                        field.name = fieldName;\n                        var fieldType = void 0;\n                        if (typeof (schema[fieldName]) === \"string\") {\n                            fieldType = schema[fieldName];\n                        }\n                        else {\n                            var type_1 = schema[fieldName];\n                            var childTypeSchema = void 0;\n                            //\n                            // TODO: refactor below.\n                            //\n                            if (Schema.is(type_1)) {\n                                fieldType = \"ref\";\n                                childTypeSchema = schema[fieldName];\n                            }\n                            else {\n                                fieldType = Object.keys(type_1)[0];\n                                if (typeof (type_1[fieldType]) === \"string\") {\n                                    fieldType += \":\" + type_1[fieldType]; // array:string\n                                }\n                                else {\n                                    childTypeSchema = type_1[fieldType];\n                                }\n                            }\n                            field.referencedType = (childTypeSchema)\n                                ? childTypeSchema._typeid\n                                : -1;\n                        }\n                        field.type = fieldType;\n                        currentType.fields.push(field);\n                    }\n                    reflection.types.push(currentType);\n                };\n                var types = rootSchemaType._context.types;\n                for (var typeid in types) {\n                    var type_2 = new ReflectionType();\n                    type_2.id = Number(typeid);\n                    buildType(type_2, types[typeid]._definition.schema);\n                }\n                return reflection.encodeAll();\n            };\n            Reflection.decode = function (bytes, it) {\n                var context = new Context();\n                var reflection = new Reflection();\n                reflection.decode(bytes, it);\n                var schemaTypes = reflection.types.reduce(function (types, reflectionType) {\n                    var schema = /** @class */ (function (_super) {\n                        __extends(_, _super);\n                        function _() {\n                            return _super !== null && _super.apply(this, arguments) || this;\n                        }\n                        return _;\n                    }(Schema));\n                    var typeid = reflectionType.id;\n                    types[typeid] = schema;\n                    context.add(schema, typeid);\n                    return types;\n                }, {});\n                reflection.types.forEach(function (reflectionType) {\n                    var schemaType = schemaTypes[reflectionType.id];\n                    reflectionType.fields.forEach(function (field) {\n                        var _a;\n                        if (field.referencedType !== undefined) {\n                            var fieldType = field.type;\n                            var refType = schemaTypes[field.referencedType];\n                            // map or array of primitive type (-1)\n                            if (!refType) {\n                                var typeInfo = field.type.split(\":\");\n                                fieldType = typeInfo[0];\n                                refType = typeInfo[1];\n                            }\n                            if (fieldType === \"ref\") {\n                                type(refType, context)(schemaType.prototype, field.name);\n                            }\n                            else {\n                                type((_a = {}, _a[fieldType] = refType, _a), context)(schemaType.prototype, field.name);\n                            }\n                        }\n                        else {\n                            type(field.type, context)(schemaType.prototype, field.name);\n                        }\n                    });\n                });\n                var rootType = schemaTypes[reflection.rootType];\n                var rootInstance = new rootType();\n                /**\n                 * auto-initialize referenced types on root type\n                 * to allow registering listeners immediatelly on client-side\n                 */\n                for (var fieldName in rootType._definition.schema) {\n                    var fieldType = rootType._definition.schema[fieldName];\n                    if (typeof (fieldType) !== \"string\") {\n                        rootInstance[fieldName] = (typeof (fieldType) === \"function\")\n                            ? new fieldType() // is a schema reference\n                            : new (getType(Object.keys(fieldType)[0])).constructor(); // is a \"collection\"\n                    }\n                }\n                return rootInstance;\n            };\n            __decorate([\n                type([ReflectionType], reflectionContext)\n            ], Reflection.prototype, \"types\", void 0);\n            __decorate([\n                type(\"number\", reflectionContext)\n            ], Reflection.prototype, \"rootType\", void 0);\n            return Reflection;\n        }(Schema));\n\n        registerType(\"map\", { constructor: MapSchema, getProxy: getMapProxy });\n        registerType(\"array\", { constructor: ArraySchema, getProxy: getArrayProxy });\n        registerType(\"set\", { constructor: SetSchema });\n        registerType(\"collection\", { constructor: CollectionSchema, });\n\n        exports.ArraySchema = ArraySchema;\n        exports.CollectionSchema = CollectionSchema;\n        exports.Context = Context;\n        exports.MapSchema = MapSchema;\n        exports.Reflection = Reflection;\n        exports.ReflectionField = ReflectionField;\n        exports.ReflectionType = ReflectionType;\n        exports.Schema = Schema;\n        exports.SchemaDefinition = SchemaDefinition;\n        exports.SetSchema = SetSchema;\n        exports.decode = decode;\n        exports.defineTypes = defineTypes;\n        exports.deprecated = deprecated;\n        exports.dumpChanges = dumpChanges;\n        exports.encode = encode;\n        exports.filter = filter;\n        exports.filterChildren = filterChildren;\n        exports.hasFilter = hasFilter;\n        exports.registerType = registerType;\n        exports.type = type;\n\n        Object.defineProperty(exports, '__esModule', { value: true });\n\n    })));\n    });\n\n    var Room = /** @class */ (function () {\n        function Room(name, rootSchema) {\n            var _this = this;\n            // Public signals\n            this.onStateChange = createSignal();\n            this.onError = createSignal();\n            this.onLeave = createSignal();\n            this.onJoin = createSignal();\n            this.hasJoined = false;\n            this.onMessageHandlers = createNanoEvents();\n            this.id = null;\n            this.name = name;\n            if (rootSchema) {\n                this.serializer = new (getSerializer(\"schema\"));\n                this.rootSchema = rootSchema;\n                this.serializer.state = new rootSchema();\n            }\n            this.onError(function (code, message) { return console.warn(\"colyseus.js - onError => (\" + code + \") \" + message); });\n            this.onLeave(function () { return _this.removeAllListeners(); });\n        }\n        Room.prototype.connect = function (endpoint) {\n            var _this = this;\n            this.connection = new Connection();\n            this.connection.events.onmessage = this.onMessageCallback.bind(this);\n            this.connection.events.onclose = function (e) {\n                if (!_this.hasJoined) {\n                    console.warn(\"Room connection was closed unexpectedly (\" + e.code + \"): \" + e.reason);\n                    _this.onError.invoke(e.code, e.reason);\n                    return;\n                }\n                _this.onLeave.invoke(e.code);\n                _this.destroy();\n            };\n            this.connection.events.onerror = function (e) {\n                console.warn(\"Room, onError (\" + e.code + \"): \" + e.reason);\n                _this.onError.invoke(e.code, e.reason);\n            };\n            this.connection.connect(endpoint);\n        };\n        Room.prototype.leave = function (consented) {\n            var _this = this;\n            if (consented === void 0) { consented = true; }\n            return new Promise(function (resolve) {\n                _this.onLeave(function (code) { return resolve(code); });\n                if (_this.connection) {\n                    if (consented) {\n                        _this.connection.send([exports.Protocol.LEAVE_ROOM]);\n                    }\n                    else {\n                        _this.connection.close();\n                    }\n                }\n                else {\n                    _this.onLeave.invoke(4000); // \"consented\" code\n                }\n            });\n        };\n        Room.prototype.onMessage = function (type, callback) {\n            return this.onMessageHandlers.on(this.getMessageHandlerKey(type), callback);\n        };\n        Room.prototype.send = function (type, message) {\n            var initialBytes = [exports.Protocol.ROOM_DATA];\n            if (typeof (type) === \"string\") {\n                umd.encode.string(initialBytes, type);\n            }\n            else {\n                umd.encode.number(initialBytes, type);\n            }\n            var arr;\n            if (message !== undefined) {\n                var encoded = encode(message);\n                arr = new Uint8Array(initialBytes.length + encoded.byteLength);\n                arr.set(new Uint8Array(initialBytes), 0);\n                arr.set(new Uint8Array(encoded), initialBytes.length);\n            }\n            else {\n                arr = new Uint8Array(initialBytes);\n            }\n            this.connection.send(arr.buffer);\n        };\n        Object.defineProperty(Room.prototype, \"state\", {\n            get: function () {\n                return this.serializer.getState();\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Room.prototype.removeAllListeners = function () {\n            this.onJoin.clear();\n            this.onStateChange.clear();\n            this.onError.clear();\n            this.onLeave.clear();\n            this.onMessageHandlers.events = {};\n        };\n        Room.prototype.onMessageCallback = function (event) {\n            var bytes = Array.from(new Uint8Array(event.data));\n            var code = bytes[0];\n            if (code === exports.Protocol.JOIN_ROOM) {\n                var offset = 1;\n                this.serializerId = utf8Read(bytes, offset);\n                offset += utf8Length(this.serializerId);\n                // Instantiate serializer if not locally available.\n                if (!this.serializer) {\n                    var serializer = getSerializer(this.serializerId);\n                    this.serializer = new serializer();\n                }\n                if (bytes.length > offset && this.serializer.handshake) {\n                    this.serializer.handshake(bytes, { offset: offset });\n                }\n                this.hasJoined = true;\n                this.onJoin.invoke();\n                // acknowledge successfull JOIN_ROOM\n                this.connection.send([exports.Protocol.JOIN_ROOM]);\n            }\n            else if (code === exports.Protocol.ERROR) {\n                var it_1 = { offset: 1 };\n                var code_1 = umd.decode.number(bytes, it_1);\n                var message = umd.decode.string(bytes, it_1);\n                this.onError.invoke(code_1, message);\n            }\n            else if (code === exports.Protocol.LEAVE_ROOM) {\n                this.leave();\n            }\n            else if (code === exports.Protocol.ROOM_DATA_SCHEMA) {\n                var it_2 = { offset: 1 };\n                var context_1 = this.serializer.getState().constructor._context;\n                var type = context_1.get(umd.decode.number(bytes, it_2));\n                var message = new type();\n                message.decode(bytes, it_2);\n                this.dispatchMessage(type, message);\n            }\n            else if (code === exports.Protocol.ROOM_STATE) {\n                bytes.shift(); // drop `code` byte\n                this.setState(bytes);\n            }\n            else if (code === exports.Protocol.ROOM_STATE_PATCH) {\n                bytes.shift(); // drop `code` byte\n                this.patch(bytes);\n            }\n            else if (code === exports.Protocol.ROOM_DATA) {\n                var it_3 = { offset: 1 };\n                var type = (umd.decode.stringCheck(bytes, it_3))\n                    ? umd.decode.string(bytes, it_3)\n                    : umd.decode.number(bytes, it_3);\n                var message = (bytes.length > it_3.offset)\n                    ? decode(event.data, it_3.offset)\n                    : undefined;\n                this.dispatchMessage(type, message);\n            }\n        };\n        Room.prototype.setState = function (encodedState) {\n            this.serializer.setState(encodedState);\n            this.onStateChange.invoke(this.serializer.getState());\n        };\n        Room.prototype.patch = function (binaryPatch) {\n            this.serializer.patch(binaryPatch);\n            this.onStateChange.invoke(this.serializer.getState());\n        };\n        Room.prototype.dispatchMessage = function (type, message) {\n            var messageType = this.getMessageHandlerKey(type);\n            if (this.onMessageHandlers.events[messageType]) {\n                this.onMessageHandlers.emit(messageType, message);\n            }\n            else if (this.onMessageHandlers.events['*']) {\n                this.onMessageHandlers.emit('*', type, message);\n            }\n            else {\n                console.warn(\"colyseus.js: onMessage() not registered for type '\" + type + \"'.\");\n            }\n        };\n        Room.prototype.destroy = function () {\n            if (this.serializer) {\n                this.serializer.teardown();\n            }\n        };\n        Room.prototype.getMessageHandlerKey = function (type) {\n            switch (typeof (type)) {\n                // typeof Schema\n                case \"function\": return \"$\" + type._typeid;\n                // string\n                case \"string\": return type;\n                // number\n                case \"number\": return \"i\" + type;\n                default: throw new Error(\"invalid message type.\");\n            }\n        };\n        return Room;\n    }());\n\n    /// <reference path=\"../typings/cocos-creator.d.ts\" />\n    /**\n     * We do not assign 'storage' to window.localStorage immediatelly for React\n     * Native compatibility. window.localStorage is not present when this module is\n     * loaded.\n     */\n    var storage;\n    function getStorage() {\n        if (!storage) {\n            storage = (typeof (cc) !== 'undefined' && cc.sys && cc.sys.localStorage)\n                ? cc.sys.localStorage // compatibility with cocos creator\n                : typeof (window) !== \"undefined\" && window.localStorage //RN does have window object at this point, but localStorage is not defined\n                    ? window.localStorage // regular browser environment\n                    : {\n                        cache: {},\n                        setItem: function (key, value) { this.cache[key] = value; },\n                        getItem: function (key) { this.cache[key]; },\n                        removeItem: function (key) { delete this.cache[key]; },\n                    };\n        }\n        return storage;\n    }\n    function setItem(key, value) {\n        getStorage().setItem(key, value);\n    }\n    function removeItem(key) {\n        getStorage().removeItem(key);\n    }\n    function getItem(key, callback) {\n        var value = getStorage().getItem(key);\n        if (typeof (Promise) === 'undefined' || // old browsers\n            !(value instanceof Promise)) {\n            // browser has synchronous return\n            callback(value);\n        }\n        else {\n            // react-native is asynchronous\n            value.then(function (id) { return callback(id); });\n        }\n    }\n\n    var TOKEN_STORAGE = \"colyseus-auth-token\";\n    exports.Platform = void 0;\n    (function (Platform) {\n        Platform[\"ios\"] = \"ios\";\n        Platform[\"android\"] = \"android\";\n    })(exports.Platform || (exports.Platform = {}));\n    var Auth = /** @class */ (function () {\n        function Auth(endpoint) {\n            var _this = this;\n            this._id = undefined;\n            this.username = undefined;\n            this.displayName = undefined;\n            this.avatarUrl = undefined;\n            this.isAnonymous = undefined;\n            this.email = undefined;\n            this.lang = undefined;\n            this.location = undefined;\n            this.timezone = undefined;\n            this.metadata = undefined;\n            this.devices = undefined;\n            this.facebookId = undefined;\n            this.twitterId = undefined;\n            this.googleId = undefined;\n            this.gameCenterId = undefined;\n            this.steamId = undefined;\n            this.friendIds = undefined;\n            this.blockedUserIds = undefined;\n            this.createdAt = undefined;\n            this.updatedAt = undefined;\n            // auth token\n            this.token = undefined;\n            this.endpoint = endpoint.replace(\"ws\", \"http\");\n            getItem(TOKEN_STORAGE, function (token) { return _this.token = token; });\n        }\n        Object.defineProperty(Auth.prototype, \"hasToken\", {\n            get: function () {\n                return !!this.token;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Auth.prototype.login = function (options) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                var queryParams, data, attr;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            queryParams = Object.assign({}, options);\n                            if (this.hasToken) {\n                                queryParams.token = this.token;\n                            }\n                            return [4 /*yield*/, this.request('post', '/auth', queryParams)];\n                        case 1:\n                            data = _a.sent();\n                            // set & cache token\n                            this.token = data.token;\n                            setItem(TOKEN_STORAGE, this.token);\n                            for (attr in data) {\n                                if (this.hasOwnProperty(attr)) {\n                                    this[attr] = data[attr];\n                                }\n                            }\n                            this.registerPingService();\n                            return [2 /*return*/, this];\n                    }\n                });\n            });\n        };\n        Auth.prototype.save = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('put', '/auth', {}, {\n                                username: this.username,\n                                displayName: this.displayName,\n                                avatarUrl: this.avatarUrl,\n                                lang: this.lang,\n                                location: this.location,\n                                timezone: this.timezone,\n                            })];\n                        case 1:\n                            _a.sent();\n                            return [2 /*return*/, this];\n                    }\n                });\n            });\n        };\n        Auth.prototype.getFriends = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('get', '/friends/all')];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.getOnlineFriends = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('get', '/friends/online')];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.getFriendRequests = function () {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('get', '/friends/requests')];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.sendFriendRequest = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('post', '/friends/requests', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.acceptFriendRequest = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('put', '/friends/requests', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.declineFriendRequest = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('del', '/friends/requests', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.blockUser = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('post', '/friends/block', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.unblockUser = function (friendId) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.request('put', '/friends/block', { userId: friendId })];\n                        case 1: return [2 /*return*/, (_a.sent())];\n                    }\n                });\n            });\n        };\n        Auth.prototype.request = function (method, segments, query, body, headers) {\n            if (query === void 0) { query = {}; }\n            if (headers === void 0) { headers = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                var queryParams, name_1, queryString, opts;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            headers['Accept'] = 'application/json';\n                            if (this.hasToken) {\n                                headers['Authorization'] = 'Bearer ' + this.token;\n                            }\n                            queryParams = [];\n                            for (name_1 in query) {\n                                queryParams.push(name_1 + \"=\" + query[name_1]);\n                            }\n                            queryString = (queryParams.length > 0)\n                                ? \"?\" + queryParams.join(\"&\")\n                                : '';\n                            opts = { headers: headers };\n                            if (body) {\n                                opts.body = body;\n                            }\n                            return [4 /*yield*/, http[method](\"\" + this.endpoint + segments + queryString, opts)];\n                        case 1: return [2 /*return*/, (_a.sent()).data];\n                    }\n                });\n            });\n        };\n        Auth.prototype.logout = function () {\n            this.token = undefined;\n            removeItem(TOKEN_STORAGE);\n            this.unregisterPingService();\n        };\n        Auth.prototype.registerPingService = function (timeout) {\n            var _this = this;\n            if (timeout === void 0) { timeout = 15000; }\n            this.unregisterPingService();\n            this.keepOnlineInterval = setInterval(function () { return _this.request('get', '/auth'); }, timeout);\n        };\n        Auth.prototype.unregisterPingService = function () {\n            clearInterval(this.keepOnlineInterval);\n        };\n        return Auth;\n    }());\n\n    var _a;\n    var MatchMakeError = /** @class */ (function (_super) {\n        __extends(MatchMakeError, _super);\n        function MatchMakeError(message, code) {\n            var _this = _super.call(this, message) || this;\n            _this.code = code;\n            Object.setPrototypeOf(_this, MatchMakeError.prototype);\n            return _this;\n        }\n        return MatchMakeError;\n    }(Error));\n    // - React Native does not provide `window.location`\n    // - Cocos Creator (Native) does not provide `window.location.hostname` \n    var DEFAULT_ENDPOINT = (typeof (window) !== \"undefined\" && typeof ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hostname) !== \"undefined\")\n        ? window.location.protocol.replace(\"http\", \"ws\") + \"//\" + window.location.hostname + (window.location.port && \":\" + window.location.port)\n        : \"ws://127.0.0.1:2567\";\n    var Client = /** @class */ (function () {\n        function Client(endpoint) {\n            if (endpoint === void 0) { endpoint = DEFAULT_ENDPOINT; }\n            this.endpoint = endpoint;\n        }\n        Object.defineProperty(Client.prototype, \"auth\", {\n            get: function () {\n                if (!this._auth) {\n                    this._auth = new Auth(this.endpoint);\n                }\n                return this._auth;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Client.prototype.joinOrCreate = function (roomName, options, rootSchema) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinOrCreate', roomName, options, rootSchema)];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.create = function (roomName, options, rootSchema) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('create', roomName, options, rootSchema)];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.join = function (roomName, options, rootSchema) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('join', roomName, options, rootSchema)];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.joinById = function (roomId, options, rootSchema) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinById', roomId, options, rootSchema)];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.reconnect = function (roomId, sessionId, rootSchema) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinById', roomId, { sessionId: sessionId }, rootSchema)];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        Client.prototype.getAvailableRooms = function (roomName) {\n            if (roomName === void 0) { roomName = \"\"; }\n            return __awaiter(this, void 0, void 0, function () {\n                var url;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            url = this.endpoint.replace(\"ws\", \"http\") + \"/matchmake/\" + roomName;\n                            return [4 /*yield*/, get_1(url, { headers: { 'Accept': 'application/json' } })];\n                        case 1: return [2 /*return*/, (_a.sent()).data];\n                    }\n                });\n            });\n        };\n        Client.prototype.consumeSeatReservation = function (response, rootSchema) {\n            return __awaiter(this, void 0, void 0, function () {\n                var room;\n                return __generator(this, function (_a) {\n                    room = this.createRoom(response.room.name, rootSchema);\n                    room.id = response.room.roomId;\n                    room.sessionId = response.sessionId;\n                    room.connect(this.buildEndpoint(response.room, { sessionId: room.sessionId }));\n                    return [2 /*return*/, new Promise(function (resolve, reject) {\n                            var onError = function (code, message) { return reject(new ServerError(code, message)); };\n                            room.onError.once(onError);\n                            room['onJoin'].once(function () {\n                                room.onError.remove(onError);\n                                resolve(room);\n                            });\n                        })];\n                });\n            });\n        };\n        Client.prototype.createMatchMakeRequest = function (method, roomName, options, rootSchema) {\n            if (options === void 0) { options = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                var url, response;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            url = this.endpoint.replace(\"ws\", \"http\") + \"/matchmake/\" + method + \"/\" + roomName;\n                            // automatically forward auth token, if present\n                            if (this._auth && this._auth.hasToken) {\n                                options.token = this._auth.token;\n                            }\n                            return [4 /*yield*/, post_1(url, {\n                                    headers: {\n                                        'Accept': 'application/json',\n                                        'Content-Type': 'application/json'\n                                    },\n                                    body: JSON.stringify(options)\n                                })];\n                        case 1:\n                            response = (_a.sent()).data;\n                            if (response.error) {\n                                throw new MatchMakeError(response.error, response.code);\n                            }\n                            return [2 /*return*/, this.consumeSeatReservation(response, rootSchema)];\n                    }\n                });\n            });\n        };\n        Client.prototype.createRoom = function (roomName, rootSchema) {\n            return new Room(roomName, rootSchema);\n        };\n        Client.prototype.buildEndpoint = function (room, options) {\n            if (options === void 0) { options = {}; }\n            var params = [];\n            for (var name_1 in options) {\n                if (!options.hasOwnProperty(name_1)) {\n                    continue;\n                }\n                params.push(name_1 + \"=\" + options[name_1]);\n            }\n            return this.endpoint + \"/\" + room.processId + \"/\" + room.roomId + \"?\" + params.join('&');\n        };\n        return Client;\n    }());\n\n    var SchemaSerializer = /** @class */ (function () {\n        function SchemaSerializer() {\n        }\n        SchemaSerializer.prototype.setState = function (rawState) {\n            this.state.decode(rawState);\n        };\n        SchemaSerializer.prototype.getState = function () {\n            return this.state;\n        };\n        SchemaSerializer.prototype.patch = function (patches) {\n            this.state.decode(patches);\n        };\n        SchemaSerializer.prototype.teardown = function () {\n            var _a, _b;\n            (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a['$changes']) === null || _b === void 0 ? void 0 : _b.root.clearRefs();\n        };\n        SchemaSerializer.prototype.handshake = function (bytes, it) {\n            if (this.state) {\n                // validate client/server definitinos\n                var reflection = new umd.Reflection();\n                reflection.decode(bytes, it);\n            }\n            else {\n                // initialize reflected state from server\n                this.state = umd.Reflection.decode(bytes, it);\n            }\n        };\n        return SchemaSerializer;\n    }());\n\n    var NoneSerializer = /** @class */ (function () {\n        function NoneSerializer() {\n        }\n        NoneSerializer.prototype.setState = function (rawState) { };\n        NoneSerializer.prototype.getState = function () { return null; };\n        NoneSerializer.prototype.patch = function (patches) { };\n        NoneSerializer.prototype.teardown = function () { };\n        NoneSerializer.prototype.handshake = function (bytes) { };\n        return NoneSerializer;\n    }());\n\n    registerSerializer('schema', SchemaSerializer);\n    registerSerializer('none', NoneSerializer);\n\n    exports.Auth = Auth;\n    exports.Client = Client;\n    exports.Room = Room;\n    exports.SchemaSerializer = SchemaSerializer;\n    exports.registerSerializer = registerSerializer;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=colyseus.js.map\n",
    "sha256": "909662fd01871257d49a782255288f6c6ed769126cdd7a5b4c2b4373e31d4c93"
  },
  {
    "path": "src/game.ts",
    "content": "\"use strict\";\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\ndefine(\"src/utils\", [\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.getSquareColor = exports.chessColor = exports.PieceType = exports.nextChar = exports.squareMap = exports.resizeFactor = void 0;\r\n    exports.resizeFactor = 1;\r\n    var xTranslation = -200.0;\r\n    var yTranslation = 0.0;\r\n    exports.squareMap = {\r\n        \"a1\": { xPosition: -224 + xTranslation, yPosition: -224 + yTranslation }, \"a2\": { xPosition: -224 + xTranslation, yPosition: -160 + yTranslation }, \"a3\": { xPosition: -224 + xTranslation, yPosition: -96 + yTranslation }, \"a4\": { xPosition: -224 + xTranslation, yPosition: -32 + yTranslation }, \"a5\": { xPosition: -224 + xTranslation, yPosition: 32 + yTranslation }, \"a6\": { xPosition: -224 + xTranslation, yPosition: 96 + yTranslation }, \"a7\": { xPosition: -224 + xTranslation, yPosition: 160 + yTranslation }, \"a8\": { xPosition: -224 + xTranslation, yPosition: 224 + yTranslation },\r\n        \"b1\": { xPosition: -160 + xTranslation, yPosition: -224 + yTranslation }, \"b2\": { xPosition: -160 + xTranslation, yPosition: -160 + yTranslation }, \"b3\": { xPosition: -160 + xTranslation, yPosition: -96 + yTranslation }, \"b4\": { xPosition: -160 + xTranslation, yPosition: -32 + yTranslation }, \"b5\": { xPosition: -160 + xTranslation, yPosition: 32 + yTranslation }, \"b6\": { xPosition: -160 + xTranslation, yPosition: 96 + yTranslation }, \"b7\": { xPosition: -160 + xTranslation, yPosition: 160 + yTranslation }, \"b8\": { xPosition: -160 + xTranslation, yPosition: 224 + yTranslation },\r\n        \"c1\": { xPosition: -96 + xTranslation, yPosition: -224 + yTranslation }, \"c2\": { xPosition: -96 + xTranslation, yPosition: -160 + yTranslation }, \"c3\": { xPosition: -96 + xTranslation, yPosition: -96 + yTranslation }, \"c4\": { xPosition: -96 + xTranslation, yPosition: -32 + yTranslation }, \"c5\": { xPosition: -96 + xTranslation, yPosition: 32 + yTranslation }, \"c6\": { xPosition: -96 + xTranslation, yPosition: 96 + yTranslation }, \"c7\": { xPosition: -96 + xTranslation, yPosition: 160 + yTranslation }, \"c8\": { xPosition: -96 + xTranslation, yPosition: 224 + yTranslation },\r\n        \"d1\": { xPosition: -32 + xTranslation, yPosition: -224 + yTranslation }, \"d2\": { xPosition: -32 + xTranslation, yPosition: -160 + yTranslation }, \"d3\": { xPosition: -32 + xTranslation, yPosition: -96 + yTranslation }, \"d4\": { xPosition: -32 + xTranslation, yPosition: -32 + yTranslation }, \"d5\": { xPosition: -32 + xTranslation, yPosition: 32 + yTranslation }, \"d6\": { xPosition: -32 + xTranslation, yPosition: 96 + yTranslation }, \"d7\": { xPosition: -32 + xTranslation, yPosition: 160 + yTranslation }, \"d8\": { xPosition: -32 + xTranslation, yPosition: 224 + yTranslation },\r\n        \"e1\": { xPosition: 32 + xTranslation, yPosition: -224 + yTranslation }, \"e2\": { xPosition: 32 + xTranslation, yPosition: -160 + yTranslation }, \"e3\": { xPosition: 32 + xTranslation, yPosition: -96 + yTranslation }, \"e4\": { xPosition: 32 + xTranslation, yPosition: -32 + yTranslation }, \"e5\": { xPosition: 32 + xTranslation, yPosition: 32 + yTranslation }, \"e6\": { xPosition: 32 + xTranslation, yPosition: 96 + yTranslation }, \"e7\": { xPosition: 32 + xTranslation, yPosition: 160 + yTranslation }, \"e8\": { xPosition: 32 + xTranslation, yPosition: 224 + yTranslation },\r\n        \"f1\": { xPosition: 96 + xTranslation, yPosition: -224 + yTranslation }, \"f2\": { xPosition: 96 + xTranslation, yPosition: -160 + yTranslation }, \"f3\": { xPosition: 96 + xTranslation, yPosition: -96 + yTranslation }, \"f4\": { xPosition: 96 + xTranslation, yPosition: -32 + yTranslation }, \"f5\": { xPosition: 96 + xTranslation, yPosition: 32 + yTranslation }, \"f6\": { xPosition: 96 + xTranslation, yPosition: 96 + yTranslation }, \"f7\": { xPosition: 96 + xTranslation, yPosition: 160 + yTranslation }, \"f8\": { xPosition: 96 + xTranslation, yPosition: 224 + yTranslation },\r\n        \"g1\": { xPosition: 160 + xTranslation, yPosition: -224 + yTranslation }, \"g2\": { xPosition: 160 + xTranslation, yPosition: -160 + yTranslation }, \"g3\": { xPosition: 160 + xTranslation, yPosition: -96 + yTranslation }, \"g4\": { xPosition: 160 + xTranslation, yPosition: -32 + yTranslation }, \"g5\": { xPosition: 160 + xTranslation, yPosition: 32 + yTranslation }, \"g6\": { xPosition: 160 + xTranslation, yPosition: 96 + yTranslation }, \"g7\": { xPosition: 160 + xTranslation, yPosition: 160 + yTranslation }, \"g8\": { xPosition: 160 + xTranslation, yPosition: 224 + yTranslation },\r\n        \"h1\": { xPosition: 224 + xTranslation, yPosition: -224 + yTranslation }, \"h2\": { xPosition: 224 + xTranslation, yPosition: -160 + yTranslation }, \"h3\": { xPosition: 224 + xTranslation, yPosition: -96 + yTranslation }, \"h4\": { xPosition: 224 + xTranslation, yPosition: -32 + yTranslation }, \"h5\": { xPosition: 224 + xTranslation, yPosition: 32 + yTranslation }, \"h6\": { xPosition: 224 + xTranslation, yPosition: 96 + yTranslation }, \"h7\": { xPosition: 224 + xTranslation, yPosition: 160 + yTranslation }, \"h8\": { xPosition: 224 + xTranslation, yPosition: 224 + yTranslation }\r\n    };\r\n    function nextChar(c) {\r\n        return String.fromCharCode(c.charCodeAt(0) + 1);\r\n    }\r\n    exports.nextChar = nextChar;\r\n    var PieceType;\r\n    (function (PieceType) {\r\n        PieceType[\"PAWN\"] = \"pawn\";\r\n        PieceType[\"KNIGHT\"] = \"knight\";\r\n        PieceType[\"BISHOP\"] = \"bishop\";\r\n        PieceType[\"ROOK\"] = \"rook\";\r\n        PieceType[\"QUEEN\"] = \"queen\";\r\n        PieceType[\"KING\"] = \"king\";\r\n    })(PieceType = exports.PieceType || (exports.PieceType = {}));\r\n    var chessColor;\r\n    (function (chessColor) {\r\n        chessColor[\"WHITE\"] = \"white\";\r\n        chessColor[\"BLACK\"] = \"black\";\r\n    })(chessColor = exports.chessColor || (exports.chessColor = {}));\r\n    //returns the color of a square -- getSquareColor('a1')\r\n    function getSquareColor(square) {\r\n        var column = square.charAt(square.length - 2);\r\n        var row = square.charAt(square.length - 1);\r\n        var a = 97; // 'a' ASCII code\r\n        var color = chessColor.WHITE;\r\n        if (((column.charCodeAt(0) - a + 1) + parseInt(row)) % 2 == 0)\r\n            color = chessColor.BLACK;\r\n        return color;\r\n    }\r\n    exports.getSquareColor = getSquareColor;\r\n});\r\ndefine(\"src/annotation\", [\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.Annotation = void 0;\r\n    var Annotation = /** @class */ (function () {\r\n        // color: chessColor\r\n        // these objects are not visible by default!\r\n        function Annotation(number, canvas, fen) {\r\n            this.white_movement = '';\r\n            this.black_movement = '';\r\n            this.fen = \"\"; //fen is a string representation of a chess position -- stored after move\r\n            this.move_number = number;\r\n            this.fen = fen;\r\n            this.graphical_representation = new UIText(canvas);\r\n            // this.white_movement = movement\r\n            // this.color = color\r\n            // this.graphical_representation.value = this.movement\r\n            // if(this.color == \"white\") this.graphical_representation.value = this.move_number + \". \" + this.movement\r\n            // this.graphical_representation.fontSize = 20\r\n            // this.graphical_representation.color = Color4.Black()\r\n            // this.graphical_representation.positionX = 50\r\n            // // if(this.color == \"black\") this.graphical_representation.positionX = 250\r\n            // this.graphical_representation.positionY = 0\r\n            // this.graphical_representation.visible = true\r\n        }\r\n        Annotation.prototype.getMovement = function () {\r\n            return [this.white_movement, this.black_movement];\r\n        };\r\n        Annotation.prototype.getMoveNumber = function () {\r\n            return this.move_number;\r\n        };\r\n        Annotation.prototype.getObject = function () {\r\n            return this.graphical_representation;\r\n        };\r\n        Annotation.prototype.getFen = function () {\r\n            return this.fen;\r\n        };\r\n        Annotation.prototype.storeFen = function (fen) {\r\n            this.fen = fen;\r\n        };\r\n        Annotation.prototype.setMovement = function (color, movement) {\r\n            if (color == \"white\" && !this.white_movement)\r\n                this.white_movement = movement;\r\n            else if (!this.black_movement)\r\n                this.black_movement = movement;\r\n            this.updateUI();\r\n        };\r\n        Annotation.prototype.updateUI = function () {\r\n            this.graphical_representation.fontSize = 15;\r\n            this.graphical_representation.color = Color4.Black();\r\n            var space;\r\n            this.graphical_representation.value = this.getMoveNumber() + \". \" + this.white_movement + Array(15 - (this.white_movement.length) * 2).join(\" \") + this.black_movement;\r\n            log(this.graphical_representation.value);\r\n            this.graphical_representation.positionX = 50;\r\n            this.graphical_representation.positionY = 0;\r\n            this.graphical_representation.width = 150;\r\n            this.graphical_representation.height = 25;\r\n            this.graphical_representation.visible = true;\r\n        };\r\n        return Annotation;\r\n    }());\r\n    exports.Annotation = Annotation;\r\n});\r\ndefine(\"src/annotations\", [\"require\", \"exports\", \"src/annotation\"], function (require, exports, annotation_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.Annotations = void 0;\r\n    var Annotations = /** @class */ (function () {\r\n        function Annotations(canvas) {\r\n            this.annotations = [];\r\n            this.move_counter = 0;\r\n            this.canvas = canvas;\r\n        }\r\n        Annotations.prototype.addMove = function (movement, color, fen) {\r\n            if (color == \"white\") {\r\n                var annotation = new annotation_1.Annotation(Math.floor((this.move_counter / 2) + 1), this.canvas, fen);\r\n                annotation.setMovement(color, movement);\r\n                this.annotations.push(annotation);\r\n            }\r\n            else\r\n                this.annotations[this.annotations.length - 1].setMovement(color, movement);\r\n            this.move_counter++;\r\n        };\r\n        Annotations.prototype.getMoves = function () {\r\n            var movements = [];\r\n            this.annotations.forEach(function (annotation) {\r\n                annotation.getMovement().forEach(function (movement) {\r\n                    movements.push(movement);\r\n                });\r\n            });\r\n            return movements;\r\n        };\r\n        return Annotations;\r\n    }());\r\n    exports.Annotations = Annotations;\r\n});\r\ndefine(\"src/piece\", [\"require\", \"exports\", \"src/utils\"], function (require, exports, utils_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.Piece = void 0;\r\n    // import * as Utils from './utils'\r\n    var piecesSize = {\r\n        \"pawn\": { \"height\": 48 / utils_1.resizeFactor, \"width\": 32 / utils_1.resizeFactor, \"source-left\": 0, \"source-top\": 0, \"source-width\": 60, \"source-height\": 78 },\r\n        \"knight\": { \"height\": 48 / utils_1.resizeFactor, \"width\": 48 / utils_1.resizeFactor, \"source-left\": 0, \"source-top\": 0, \"source-width\": 82, \"source-height\": 83 },\r\n        \"bishop\": { \"height\": 48 / utils_1.resizeFactor, \"width\": 48 / utils_1.resizeFactor, \"source-left\": 0, \"source-top\": 0, \"source-width\": 82, \"source-height\": 82 },\r\n        \"rook\": { \"height\": 48 / utils_1.resizeFactor, \"width\": 42 / utils_1.resizeFactor, \"source-left\": 0, \"source-top\": 0, \"source-width\": 69.5, \"source-height\": 78.5 },\r\n        \"queen\": { \"height\": 48 / utils_1.resizeFactor, \"width\": 48 / utils_1.resizeFactor, \"source-left\": 0, \"source-top\": 0, \"source-width\": 95, \"source-height\": 85 },\r\n        \"king\": { \"height\": 48 / utils_1.resizeFactor, \"width\": 48 / utils_1.resizeFactor, \"source-left\": 0, \"source-top\": 0, \"source-width\": 87.5, \"source-height\": 86.2 }\r\n    };\r\n    var Piece = /** @class */ (function () {\r\n        function Piece(_color, _piece, _position, _canvas) {\r\n            this.color = _color;\r\n            this.position = _position;\r\n            this.piece = _piece;\r\n            this.canvas = _canvas;\r\n            // this.height = \r\n            // this.width = \r\n            this.image = this.generate2UI();\r\n            this.set2UIProperties();\r\n        }\r\n        Piece.prototype.generate2UI = function () {\r\n            var path = \"images/chessboard/\" + this.color + \"-\" + this.piece + \".png\";\r\n            var image = new UIImage(this.canvas, new Texture(path));\r\n            return image;\r\n        };\r\n        Piece.prototype.set2UIProperties = function () {\r\n            this.image.visible = true;\r\n            this.image.width = piecesSize[this.piece][\"width\"];\r\n            this.image.height = piecesSize[this.piece][\"height\"];\r\n            this.image.sourceLeft = piecesSize[this.piece][\"source-left\"];\r\n            this.image.sourceTop = piecesSize[this.piece][\"source-top\"];\r\n            this.image.sourceWidth = piecesSize[this.piece][\"source-width\"];\r\n            this.image.sourceHeight = piecesSize[this.piece][\"source-height\"];\r\n            this.image.positionY = utils_1.squareMap[this.position].yPosition;\r\n            this.image.positionX = utils_1.squareMap[this.position].xPosition;\r\n        };\r\n        Piece.prototype.getColor = function () {\r\n            return this.color;\r\n        };\r\n        Piece.prototype.getPosition = function () {\r\n            return this.position;\r\n        };\r\n        Piece.prototype.getPiece = function () {\r\n            return this.piece;\r\n        };\r\n        Piece.prototype.setVisibility = function (mode) {\r\n            this.image.visible = mode;\r\n        };\r\n        //pre: The validity of the move has been checked\r\n        Piece.prototype.movePiece = function (square) {\r\n            // this.image.positionX = squareMap[square].xPosition\r\n            // this.image.positionY = squareMap[square].yPosition\r\n            // this.image = new UIImage(this.canvas,  Texture ())\r\n            // this.position = squarez\r\n            this.setVisibility(false);\r\n            this.constructor(this.color, this.piece, square, this.canvas);\r\n        };\r\n        return Piece;\r\n    }());\r\n    exports.Piece = Piece;\r\n});\r\ndefine(\"src/square\", [\"require\", \"exports\", \"src/utils\"], function (require, exports, utils_2) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.Square = void 0;\r\n    // import * as Utils from './utils'\r\n    var Square = /** @class */ (function () {\r\n        function Square(_name, _canvas, _path) {\r\n            if (_path === void 0) { _path = \"default\"; }\r\n            this.name = _name;\r\n            this.position = utils_2.squareMap[_name];\r\n            this.color = (0, utils_2.getSquareColor)(_name);\r\n            this.canvas = _canvas;\r\n            this.path = _path;\r\n            if (_path == \"default\")\r\n                this.image = (this.color == utils_2.chessColor.WHITE) ? new UIImage(_canvas, new Texture(\"images/chessboard/white-square.png\")) : new UIImage(_canvas, new Texture(\"images/chessboard/black-square.png\"));\r\n            else\r\n                this.image = new UIImage(_canvas, new Texture(_path));\r\n            this.setImageProperties();\r\n        }\r\n        Square.prototype.getColor = function () {\r\n            return this.color;\r\n        };\r\n        Square.prototype.getPosition = function () {\r\n            return this.position;\r\n        };\r\n        Square.prototype.getImage = function () {\r\n            return this.image;\r\n        };\r\n        // public modifyImage(path:string){\r\n        //     this.image = new UIImage(this.canvas, new Texture(path))\r\n        //     this.setImageProperties()\r\n        // }\r\n        Square.prototype.setImageProperties = function () {\r\n            this.image.positionX = this.position.xPosition;\r\n            this.image.positionY = this.position.yPosition;\r\n            this.image.sourceLeft = 0;\r\n            this.image.sourceTop = 0;\r\n            if (this.path != \"default\") {\r\n                this.image.sourceWidth = 90;\r\n                this.image.sourceHeight = 90;\r\n            }\r\n            this.image.height = 64 / utils_2.resizeFactor;\r\n            this.image.width = 64 / utils_2.resizeFactor;\r\n            this.image.visible = true;\r\n        };\r\n        //sets the square visible if mode == true\r\n        Square.prototype.setVisibiliy = function (mode) {\r\n            this.image.visible = mode;\r\n        };\r\n        return Square;\r\n    }());\r\n    exports.Square = Square;\r\n});\r\ndefine(\"node_modules/chess.ts/src/types\", [\"require\", \"exports\", \"node_modules/chess.ts/src/constants\", \"node_modules/chess.ts/src/state\"], function (require, exports, constants_1, state_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.State = void 0;\r\n    /** @public */\r\n    var State = /** @class */ (function () {\r\n        function State(board, kings, turn, castling, ep_square, half_moves, move_number) {\r\n            this.board = board || new Array(128);\r\n            this.kings = kings || { w: constants_1.EMPTY, b: constants_1.EMPTY };\r\n            this.turn = turn || constants_1.WHITE;\r\n            this.castling = castling || { w: 0, b: 0 };\r\n            this.ep_square = ep_square || constants_1.EMPTY;\r\n            this.half_moves = half_moves || 0;\r\n            this.move_number = move_number || 1;\r\n        }\r\n        State.prototype.clone = function () {\r\n            return new State(this.board.slice(), {\r\n                w: this.kings.w,\r\n                b: this.kings.b,\r\n            }, this.turn, {\r\n                w: this.castling.w,\r\n                b: this.castling.b,\r\n            }, this.ep_square, this.half_moves, this.move_number);\r\n        };\r\n        Object.defineProperty(State.prototype, \"fen\", {\r\n            get: function () {\r\n                return (0, state_1.getFen)(this);\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        return State;\r\n    }());\r\n    exports.State = State;\r\n});\r\ndefine(\"node_modules/chess.ts/src/constants\", [\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.ROOKS = exports.SQUARES = exports.RANKS = exports.RANK_8 = exports.RANK_7 = exports.RANK_6 = exports.RANK_5 = exports.RANK_4 = exports.RANK_3 = exports.RANK_2 = exports.RANK_1 = exports.BITS = exports.FLAGS = exports.SHIFTS = exports.RAYS = exports.ATTACKS = exports.PIECE_OFFSETS = exports.PAWN_OFFSETS = exports.POSSIBLE_RESULTS = exports.DEFAULT_POSITION = exports.SYMBOLS = exports.EMPTY = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\r\n    /** @public */\r\n    exports.WHITE = 'w';\r\n    /** @public */\r\n    exports.BLACK = 'b';\r\n    /** @public */\r\n    exports.PAWN = 'p';\r\n    /** @public */\r\n    exports.KNIGHT = 'n';\r\n    /** @public */\r\n    exports.BISHOP = 'b';\r\n    /** @public */\r\n    exports.ROOK = 'r';\r\n    /** @public */\r\n    exports.QUEEN = 'q';\r\n    /** @public */\r\n    exports.KING = 'k';\r\n    /** @public */\r\n    exports.EMPTY = -1;\r\n    exports.SYMBOLS = 'pnbrqkPNBRQK';\r\n    exports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\r\n    exports.POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];\r\n    exports.PAWN_OFFSETS = {\r\n        b: [16, 32, 17, 15],\r\n        w: [-16, -32, -17, -15]\r\n    };\r\n    exports.PIECE_OFFSETS = {\r\n        p: [],\r\n        n: [-18, -33, -31, -14, 18, 33, 31, 14],\r\n        b: [-17, -15, 17, 15],\r\n        r: [-16, 1, 16, -1],\r\n        q: [-17, -16, -15, 1, 17, 16, 15, -1],\r\n        k: [-17, -16, -15, 1, 17, 16, 15, -1]\r\n    };\r\n    // prettier-ignore\r\n    exports.ATTACKS = [\r\n        20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\r\n        0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\r\n        0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\r\n        0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n        24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\r\n        0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\r\n        0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\r\n        0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\r\n        20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\r\n    ];\r\n    // prettier-ignore\r\n    exports.RAYS = [\r\n        17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\r\n        0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\r\n        0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\r\n        0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\r\n        1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\r\n        0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\r\n        0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\r\n        0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\r\n        0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\r\n        -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\r\n    ];\r\n    exports.SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };\r\n    /** @public */\r\n    exports.FLAGS = {\r\n        NORMAL: 'n',\r\n        CAPTURE: 'c',\r\n        BIG_PAWN: 'b',\r\n        EP_CAPTURE: 'e',\r\n        PROMOTION: 'p',\r\n        KSIDE_CASTLE: 'k',\r\n        QSIDE_CASTLE: 'q'\r\n    };\r\n    /** @public */\r\n    exports.BITS = {\r\n        NORMAL: 1,\r\n        CAPTURE: 2,\r\n        BIG_PAWN: 4,\r\n        EP_CAPTURE: 8,\r\n        PROMOTION: 16,\r\n        KSIDE_CASTLE: 32,\r\n        QSIDE_CASTLE: 64\r\n    };\r\n    exports.RANK_1 = 7;\r\n    exports.RANK_2 = 6;\r\n    exports.RANK_3 = 5;\r\n    exports.RANK_4 = 4;\r\n    exports.RANK_5 = 3;\r\n    exports.RANK_6 = 2;\r\n    exports.RANK_7 = 1;\r\n    exports.RANK_8 = 0;\r\n    exports.RANKS = [exports.RANK_8, exports.RANK_7, exports.RANK_6, exports.RANK_5, exports.RANK_4, exports.RANK_3, exports.RANK_2, exports.RANK_1];\r\n    // prettier-ignore\r\n    /** @public */\r\n    exports.SQUARES = {\r\n        a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\r\n        a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\r\n        a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\r\n        a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\r\n        a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\r\n        a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\r\n        a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\r\n        a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\r\n    };\r\n    exports.ROOKS = {\r\n        w: [\r\n            { square: exports.SQUARES.a1, flag: exports.BITS.QSIDE_CASTLE },\r\n            { square: exports.SQUARES.h1, flag: exports.BITS.KSIDE_CASTLE }\r\n        ],\r\n        b: [\r\n            { square: exports.SQUARES.a8, flag: exports.BITS.QSIDE_CASTLE },\r\n            { square: exports.SQUARES.h8, flag: exports.BITS.KSIDE_CASTLE }\r\n        ]\r\n    };\r\n});\r\ndefine(\"node_modules/chess.ts/src/utils\", [\"require\", \"exports\", \"node_modules/chess.ts/src/constants\"], function (require, exports, constants_2) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.strippedSan = exports.validateFen = exports.isFlagKey = exports.isSquare = exports.isPieceSymbol = exports.isColor = exports.symbol = exports.isDigit = exports.swapColor = exports.algebraic = exports.file = exports.rank = void 0;\r\n    /**\r\n     * Extracts the zero-based rank of an 0x88 square.\r\n     * @public\r\n     */\r\n    function rank(i) {\r\n        return i >> 4;\r\n    }\r\n    exports.rank = rank;\r\n    /**\r\n     * Extracts the zero-based file of an 0x88 square.\r\n     * @public\r\n     */\r\n    function file(i) {\r\n        return i & 15;\r\n    }\r\n    exports.file = file;\r\n    /**\r\n     * Converts a 0x88 square to algebraic notation.\r\n     * @public\r\n     */\r\n    function algebraic(i) {\r\n        var f = file(i);\r\n        var r = rank(i);\r\n        return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1);\r\n    }\r\n    exports.algebraic = algebraic;\r\n    /**\r\n     * Returns the opposite color.\r\n     */\r\n    function swapColor(c) {\r\n        return c === constants_2.WHITE ? constants_2.BLACK : constants_2.WHITE;\r\n    }\r\n    exports.swapColor = swapColor;\r\n    /**\r\n     * Checks if a character is a numeric digit.\r\n     */\r\n    function isDigit(c) {\r\n        return /^[0-9]$/.test(c);\r\n    }\r\n    exports.isDigit = isDigit;\r\n    /**\r\n     * Returns the ASCII symbol for each piece.  White pieces are in uppercase,\r\n     * black in lowercase.\r\n     */\r\n    function symbol(_a) {\r\n        var type = _a.type, color = _a.color;\r\n        return color === constants_2.WHITE ? type.toUpperCase() : type.toLowerCase();\r\n    }\r\n    exports.symbol = symbol;\r\n    function isColor(color) {\r\n        return color === 'w' || color === 'b';\r\n    }\r\n    exports.isColor = isColor;\r\n    function isPieceSymbol(symbol) {\r\n        return /^[pnbrqk]$/.test(symbol);\r\n    }\r\n    exports.isPieceSymbol = isPieceSymbol;\r\n    function isSquare(sq) {\r\n        return /^[a-h][1-8]$/.test(sq);\r\n    }\r\n    exports.isSquare = isSquare;\r\n    function isFlagKey(key) {\r\n        var keys = ['NORMAL', 'CAPTURE', 'BIG_PAWN', 'EP_CAPTURE', 'PROMOTION', 'KSIDE_CASTLE', 'QSIDE_CASTLE'];\r\n        return keys.indexOf(key) !== -1;\r\n    }\r\n    exports.isFlagKey = isFlagKey;\r\n    /* TODO: this function is pretty much crap - it validates structure but\r\n     * completely ignores content (e.g. doesn't verify that each side has a king)\r\n     * ... we should rewrite this, and ditch the silly error_number field while\r\n     * we're at it\r\n     */\r\n    function validateFen(fen) {\r\n        var errors = {\r\n            0: 'No errors.',\r\n            1: 'FEN string must contain six space-delimited fields.',\r\n            2: '6th field (move number) must be a positive integer.',\r\n            3: '5th field (half move counter) must be a non-negative integer.',\r\n            4: '4th field (en-passant square) is invalid.',\r\n            5: '3rd field (castling availability) is invalid.',\r\n            6: '2nd field (side to move) is invalid.',\r\n            7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\r\n            8: '1st field (piece positions) is invalid [consecutive numbers].',\r\n            9: '1st field (piece positions) is invalid [invalid piece].',\r\n            10: '1st field (piece positions) is invalid [row too large].',\r\n            11: 'Illegal en-passant square'\r\n        };\r\n        /* 1st criterion: 6 space-seperated fields? */\r\n        var tokens = fen.split(/\\s+/);\r\n        if (tokens.length !== 6) {\r\n            return { valid: false, error_number: 1, error: errors[1] };\r\n        }\r\n        /* 2nd criterion: move number field is a integer value > 0? */\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\r\n            return { valid: false, error_number: 2, error: errors[2] };\r\n        }\r\n        /* 3rd criterion: half move counter is an integer >= 0? */\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\r\n            return { valid: false, error_number: 3, error: errors[3] };\r\n        }\r\n        /* 4th criterion: 4th field is a valid e.p.-string? */\r\n        if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\r\n            return { valid: false, error_number: 4, error: errors[4] };\r\n        }\r\n        /* 5th criterion: 3th field is a valid castle-string? */\r\n        if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\r\n            return { valid: false, error_number: 5, error: errors[5] };\r\n        }\r\n        /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\r\n        if (!/^(w|b)$/.test(tokens[1])) {\r\n            return { valid: false, error_number: 6, error: errors[6] };\r\n        }\r\n        /* 7th criterion: 1st field contains 8 rows? */\r\n        var rows = tokens[0].split('/');\r\n        if (rows.length !== 8) {\r\n            return { valid: false, error_number: 7, error: errors[7] };\r\n        }\r\n        /* 8th criterion: every row is valid? */\r\n        for (var i = 0; i < rows.length; i++) {\r\n            /* check for right sum of fields AND not two numbers in succession */\r\n            var sum_fields = 0;\r\n            var previous_was_number = false;\r\n            for (var k = 0; k < rows[i].length; k++) {\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                if (!isNaN(rows[i][k])) {\r\n                    if (previous_was_number) {\r\n                        return { valid: false, error_number: 8, error: errors[8] };\r\n                    }\r\n                    sum_fields += parseInt(rows[i][k], 10);\r\n                    previous_was_number = true;\r\n                }\r\n                else {\r\n                    if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\r\n                        return { valid: false, error_number: 9, error: errors[9] };\r\n                    }\r\n                    sum_fields += 1;\r\n                    previous_was_number = false;\r\n                }\r\n            }\r\n            if (sum_fields !== 8) {\r\n                return { valid: false, error_number: 10, error: errors[10] };\r\n            }\r\n        }\r\n        if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\r\n            (tokens[3][1] == '6' && tokens[1] == 'b')) {\r\n            return { valid: false, error_number: 11, error: errors[11] };\r\n        }\r\n        /* everything's okay! */\r\n        return { valid: true, error_number: 0, error: errors[0] };\r\n    }\r\n    exports.validateFen = validateFen;\r\n    // parses all of the decorators out of a SAN string\r\n    function strippedSan(move) {\r\n        return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\r\n    }\r\n    exports.strippedSan = strippedSan;\r\n});\r\ndefine(\"node_modules/chess.ts/src/state\", [\"require\", \"exports\", \"node_modules/chess.ts/src/constants\", \"node_modules/chess.ts/src/types\", \"node_modules/chess.ts/src/utils\"], function (require, exports, constants_3, types_1, utils_3) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.validateMove = exports.getBoard = exports.ascii = exports.buildMove = exports.makeMove = exports.insufficientMaterial = exports.inStalemate = exports.inCheckmate = exports.inCheck = exports.isKingAttacked = exports.isAttacked = exports.makePretty = exports.sanToMove = exports.moveToSan = exports.generateMoves = exports.removePiece = exports.putPiece = exports.clonePiece = exports.cloneMove = exports.getPiece = exports.loadPgn = exports.getPgn = exports.loadFen = exports.getFen = exports.getDisambiguator = void 0;\r\n    /* this function is used to uniquely identify ambiguous moves */\r\n    function getDisambiguator(state, move, sloppy) {\r\n        var moves = generateMoves(state, { legal: !sloppy });\r\n        var from = move.from;\r\n        var to = move.to;\r\n        var piece = move.piece;\r\n        var ambiguities = 0;\r\n        var same_rank = 0;\r\n        var same_file = 0;\r\n        for (var i = 0, len = moves.length; i < len; i++) {\r\n            var ambig_from = moves[i].from;\r\n            var ambig_to = moves[i].to;\r\n            var ambig_piece = moves[i].piece;\r\n            /* if a move of the same piece type ends on the same to square, we'll\r\n             * need to add a disambiguator to the algebraic notation\r\n             */\r\n            if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\r\n                ambiguities++;\r\n                if ((0, utils_3.rank)(from) === (0, utils_3.rank)(ambig_from)) {\r\n                    same_rank++;\r\n                }\r\n                if ((0, utils_3.file)(from) === (0, utils_3.file)(ambig_from)) {\r\n                    same_file++;\r\n                }\r\n            }\r\n        }\r\n        if (ambiguities > 0) {\r\n            /* if there exists a similar moving piece on the same rank and file as\r\n             * the move in question, use the square as the disambiguator\r\n             */\r\n            if (same_rank > 0 && same_file > 0) {\r\n                return (0, utils_3.algebraic)(from);\r\n            }\r\n            else if (same_file > 0) {\r\n                /* if the moving piece rests on the same file, use the rank symbol as the\r\n                 * disambiguator\r\n                 */\r\n                return (0, utils_3.algebraic)(from).charAt(1);\r\n            }\r\n            else {\r\n                /* else use the file symbol */\r\n                return (0, utils_3.algebraic)(from).charAt(0);\r\n            }\r\n        }\r\n        return '';\r\n    }\r\n    exports.getDisambiguator = getDisambiguator;\r\n    function getFen(state) {\r\n        var empty = 0;\r\n        var fen = '';\r\n        for (var i = constants_3.SQUARES.a8; i <= constants_3.SQUARES.h1; i++) {\r\n            var piece = state.board[i];\r\n            if (!piece) {\r\n                empty++;\r\n            }\r\n            else {\r\n                if (empty > 0) {\r\n                    fen += empty;\r\n                    empty = 0;\r\n                }\r\n                var color = piece.color;\r\n                var piece_type = piece.type;\r\n                fen += color === constants_3.WHITE ? piece_type.toUpperCase() : piece_type.toLowerCase();\r\n            }\r\n            if ((i + 1) & 0x88) {\r\n                if (empty > 0) {\r\n                    fen += empty;\r\n                }\r\n                if (i !== constants_3.SQUARES.h1) {\r\n                    fen += '/';\r\n                }\r\n                empty = 0;\r\n                i += 8;\r\n            }\r\n        }\r\n        var cflags = '';\r\n        if (state.castling[constants_3.WHITE] & constants_3.BITS.KSIDE_CASTLE) {\r\n            cflags += 'K';\r\n        }\r\n        if (state.castling[constants_3.WHITE] & constants_3.BITS.QSIDE_CASTLE) {\r\n            cflags += 'Q';\r\n        }\r\n        if (state.castling[constants_3.BLACK] & constants_3.BITS.KSIDE_CASTLE) {\r\n            cflags += 'k';\r\n        }\r\n        if (state.castling[constants_3.BLACK] & constants_3.BITS.QSIDE_CASTLE) {\r\n            cflags += 'q';\r\n        }\r\n        /* do we have an empty castling flag? */\r\n        cflags = cflags || '-';\r\n        var epflags = state.ep_square === constants_3.EMPTY ? '-' : (0, utils_3.algebraic)(state.ep_square);\r\n        return [fen, state.turn, cflags, epflags, state.half_moves, state.move_number].join(' ');\r\n    }\r\n    exports.getFen = getFen;\r\n    function loadFen(fen) {\r\n        var tokens = fen.split(/\\s+/);\r\n        var position = tokens[0];\r\n        var square = 0;\r\n        if (!(0, utils_3.validateFen)(fen).valid) {\r\n            return null;\r\n        }\r\n        var state = new types_1.State();\r\n        for (var i = 0; i < position.length; i++) {\r\n            var piece = position.charAt(i);\r\n            if (piece === '/') {\r\n                square += 8;\r\n            }\r\n            else if ((0, utils_3.isDigit)(piece)) {\r\n                square += parseInt(piece, 10);\r\n            }\r\n            else {\r\n                var color = piece < 'a' ? constants_3.WHITE : constants_3.BLACK;\r\n                var newState = putPiece(state, { type: piece.toLowerCase(), color: color }, (0, utils_3.algebraic)(square));\r\n                if (!newState) {\r\n                    return null;\r\n                }\r\n                state = newState;\r\n                square++;\r\n            }\r\n        }\r\n        state.turn = tokens[1] === constants_3.BLACK ? constants_3.BLACK : constants_3.WHITE;\r\n        if (tokens[2].indexOf('K') > -1) {\r\n            state.castling.w |= constants_3.BITS.KSIDE_CASTLE;\r\n        }\r\n        if (tokens[2].indexOf('Q') > -1) {\r\n            state.castling.w |= constants_3.BITS.QSIDE_CASTLE;\r\n        }\r\n        if (tokens[2].indexOf('k') > -1) {\r\n            state.castling.b |= constants_3.BITS.KSIDE_CASTLE;\r\n        }\r\n        if (tokens[2].indexOf('q') > -1) {\r\n            state.castling.b |= constants_3.BITS.QSIDE_CASTLE;\r\n        }\r\n        state.ep_square = tokens[3] === '-' ? constants_3.EMPTY : constants_3.SQUARES[tokens[3]];\r\n        state.half_moves = parseInt(tokens[4], 10);\r\n        state.move_number = parseInt(tokens[5], 10);\r\n        return state;\r\n    }\r\n    exports.loadFen = loadFen;\r\n    function getPgn(state, header, comments, history, options) {\r\n        if (options === void 0) { options = {}; }\r\n        /* using the specification from http://www.chessclub.com/help/PGN-spec\r\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\r\n         */\r\n        var _a = options.newline_char, newline = _a === void 0 ? '\\n' : _a, _b = options.max_width, max_width = _b === void 0 ? 0 : _b;\r\n        var result = [];\r\n        var header_exists = false;\r\n        /* add the PGN header headerrmation */\r\n        for (var i in header) {\r\n            /* TODO: order of enumerated properties in header object is not\r\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\r\n             */\r\n            result.push('[' + i + ' \"' + header[i] + '\"]' + newline);\r\n            header_exists = true;\r\n        }\r\n        if (header_exists && history.length) {\r\n            result.push(newline);\r\n        }\r\n        var appendComment = function (moveStr) {\r\n            var comment = comments[state.fen];\r\n            if (typeof comment !== 'undefined') {\r\n                var delimiter = moveStr.length > 0 ? ' ' : '';\r\n                moveStr = \"\".concat(moveStr).concat(delimiter, \"{\").concat(comment, \"}\");\r\n            }\r\n            return moveStr;\r\n        };\r\n        // Set initial state\r\n        if (history[0]) {\r\n            state = history[0].state;\r\n        }\r\n        var moves = [];\r\n        var moveStr = '';\r\n        /* special case of a commented starting position with no moves */\r\n        if (history.length === 0) {\r\n            moves.push(appendComment(''));\r\n        }\r\n        /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\r\n        history.forEach(function (historyState, i) {\r\n            var move = historyState.move;\r\n            moveStr = appendComment(moveStr);\r\n            /* if the position started with black to move, start PGN with 1. ... */\r\n            if (i === 0 && move.color === constants_3.BLACK) {\r\n                moveStr = state.move_number + '. ...';\r\n            }\r\n            else if (move.color === constants_3.WHITE) {\r\n                /* store the previous generated move_string if we have one */\r\n                if (moveStr.length) {\r\n                    moves.push(moveStr);\r\n                }\r\n                moveStr = state.move_number + '.';\r\n            }\r\n            moveStr = moveStr + ' ' + moveToSan(state, move);\r\n            state = makeMove(state, move);\r\n        });\r\n        // Append leftover moves\r\n        if (moveStr.length) {\r\n            moves.push(appendComment(moveStr));\r\n        }\r\n        /* is there a result? */\r\n        if (typeof header.Result !== 'undefined') {\r\n            moves.push(header.Result);\r\n        }\r\n        /* history should be back to what it was before we started generating PGN,\r\n         * so join together moves\r\n         */\r\n        if (max_width === 0) {\r\n            return result.join('') + moves.join(' ');\r\n        }\r\n        var strip = function () {\r\n            if (result.length > 0 && result[result.length - 1] === ' ') {\r\n                result.pop();\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        /* NB: this does not preserve comment whitespace. */\r\n        var wrapComment = function (width, move) {\r\n            var e_1, _a;\r\n            try {\r\n                for (var _b = __values(move.split(' ')), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var token = _c.value;\r\n                    if (!token) {\r\n                        continue;\r\n                    }\r\n                    if (width + token.length > max_width) {\r\n                        while (strip()) {\r\n                            width--;\r\n                        }\r\n                        result.push(newline);\r\n                        width = 0;\r\n                    }\r\n                    result.push(token);\r\n                    width += token.length;\r\n                    result.push(' ');\r\n                    width++;\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            if (strip()) {\r\n                width--;\r\n            }\r\n            return width;\r\n        };\r\n        /* wrap the PGN output at max_width */\r\n        var currentWidth = 0;\r\n        for (var i = 0; i < moves.length; i++) {\r\n            if (currentWidth + moves[i].length > max_width) {\r\n                if (moves[i].includes('{')) {\r\n                    currentWidth = wrapComment(currentWidth, moves[i]);\r\n                    continue;\r\n                }\r\n            }\r\n            /* if the current move will push past max_width */\r\n            if (currentWidth + moves[i].length > max_width && i !== 0) {\r\n                /* don't end the line with whitespace */\r\n                if (result[result.length - 1] === ' ') {\r\n                    result.pop();\r\n                }\r\n                result.push(newline);\r\n                currentWidth = 0;\r\n            }\r\n            else if (i !== 0) {\r\n                result.push(' ');\r\n                currentWidth++;\r\n            }\r\n            result.push(moves[i]);\r\n            currentWidth += moves[i].length;\r\n        }\r\n        return result.join('');\r\n    }\r\n    exports.getPgn = getPgn;\r\n    function loadPgn(pgn, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _a = options.newline_char, newline_char = _a === void 0 ? '\\r?\\n' : _a, \r\n        // allow the user to specify the sloppy move parser to work around over\r\n        // disambiguation bugs in Fritz and Chessbase\r\n        _b = options.sloppy, \r\n        // allow the user to specify the sloppy move parser to work around over\r\n        // disambiguation bugs in Fritz and Chessbase\r\n        sloppy = _b === void 0 ? false : _b;\r\n        var mask = function (str) {\r\n            return str.replace(/\\\\/g, '\\\\');\r\n        };\r\n        var parse_pgn_header = function (header, options) {\r\n            var newline_char = options.newline_char;\r\n            var header_obj = {};\r\n            var headers = header.split(new RegExp(mask(newline_char)));\r\n            var key = '';\r\n            var value = '';\r\n            for (var i = 0; i < headers.length; i++) {\r\n                key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1');\r\n                value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\" *\\]$/, '$1');\r\n                if (key.trim().length > 0) {\r\n                    header_obj[key.trim()] = value;\r\n                }\r\n            }\r\n            return header_obj;\r\n        };\r\n        // RegExp to split header. Takes advantage of the fact that header and movetext\r\n        // will always have a blank line between them (ie, two newline_char's).\r\n        // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\r\n        var header_regex = new RegExp('^(\\\\[((?:' +\r\n            mask(newline_char) +\r\n            ')|.)*\\\\])' +\r\n            '(?:' +\r\n            mask(newline_char) +\r\n            '){2}');\r\n        // If no header given, begin with moves.\r\n        var header_string = header_regex.test(pgn) ? header_regex.exec(pgn)[1] : '';\r\n        // Put the board in the starting position\r\n        var state = loadFen(constants_3.DEFAULT_POSITION);\r\n        /* parse PGN header */\r\n        var header = parse_pgn_header(header_string, { newline_char: newline_char, sloppy: sloppy });\r\n        /* load the starting position indicated by [Setup '1'] and\r\n         * [FEN position] */\r\n        if (header['SetUp'] === '1') {\r\n            if ('FEN' in header) {\r\n                var newState = loadFen(header['FEN']);\r\n                if (!newState) {\r\n                    return null;\r\n                }\r\n                state = newState;\r\n            }\r\n        }\r\n        /* NB: the regexes below that delete move numbers, recursive\r\n         * annotations, and numeric annotation glyphs may also match\r\n         * text in comments. To prevent this, we transform comments\r\n         * by hex-encoding them in place and decoding them again after\r\n         * the other tokens have been deleted.\r\n         *\r\n         * While the spec states that PGN files should be ASCII encoded,\r\n         * we use {en,de}codeURIComponent here to support arbitrary UTF8\r\n         * as a convenience for modern users */\r\n        var toHex = function (str) {\r\n            return Array\r\n                .from(str)\r\n                .map(function (c) {\r\n                /* encodeURI doesn't transform most ASCII characters,\r\n                 * so we handle these ourselves */\r\n                return c.charCodeAt(0) < 128\r\n                    ? c.charCodeAt(0).toString(16)\r\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\r\n            })\r\n                .join('');\r\n        };\r\n        var fromHex = function (str) {\r\n            var _a;\r\n            return str.length == 0\r\n                ? ''\r\n                : decodeURIComponent('%' + ((_a = str === null || str === void 0 ? void 0 : str.match(/.{1,2}/g)) === null || _a === void 0 ? void 0 : _a.join('%')));\r\n        };\r\n        var encodeComment = function (str) {\r\n            str = str.replace(new RegExp(mask(newline_char), 'g'), ' ');\r\n            return \"{\".concat(toHex(str.slice(1, str.length - 1)), \"}\");\r\n        };\r\n        var decodeComment = function (str) {\r\n            if (str.startsWith('{') && str.endsWith('}')) {\r\n                return fromHex(str.slice(1, str.length - 1));\r\n            }\r\n        };\r\n        /* delete header to get the moves */\r\n        var ms = pgn\r\n            .replace(header_string, '')\r\n            .replace(\r\n        /* encode comments so they don't get deleted below */\r\n        new RegExp(\"({[^}]*})+?|;([^\".concat(mask(newline_char), \"]*)\"), 'g'), function (_, bracket, semicolon) {\r\n            return bracket !== undefined\r\n                ? encodeComment(bracket)\r\n                : ' ' + encodeComment(\"{\".concat(semicolon.slice(1), \"}\"));\r\n        })\r\n            .replace(new RegExp(mask(newline_char), 'g'), ' ');\r\n        /* delete recursive annotation variations */\r\n        var rav_regex = /(\\([^()]+\\))+?/g;\r\n        while (rav_regex.test(ms)) {\r\n            ms = ms.replace(rav_regex, '');\r\n        }\r\n        /* delete move numbers */\r\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\r\n        /* delete ... indicating black to move */\r\n        ms = ms.replace(/\\.\\.\\./g, '');\r\n        /* delete numeric annotation glyphs */\r\n        ms = ms.replace(/\\$\\d+/g, '');\r\n        /* trim and get array of moves/comments */\r\n        var tokens = ms\r\n            .trim()\r\n            .split(new RegExp(/\\s+/))\r\n            .join(',')\r\n            .replace(/,,+/g, ',')\r\n            .split(',');\r\n        var comments = {};\r\n        var history = [];\r\n        for (var half_move = 0; half_move < tokens.length; half_move++) {\r\n            var token = tokens[half_move];\r\n            var comment = decodeComment(token);\r\n            if (comment !== undefined) {\r\n                comments[state.fen] = comment;\r\n                continue;\r\n            }\r\n            if (half_move === tokens.length - 1 && constants_3.POSSIBLE_RESULTS.indexOf(token) !== -1) {\r\n                if (Object.keys(header).length && typeof header.Result === 'undefined') {\r\n                    header['Result'] = token;\r\n                }\r\n                continue;\r\n            }\r\n            var move = sanToMove(state, tokens[half_move], { sloppy: sloppy });\r\n            if (move === null) {\r\n                return null;\r\n            }\r\n            else {\r\n                history.push({ move: move, state: state });\r\n                var newState = makeMove(state, move);\r\n                if (!newState) {\r\n                    return null;\r\n                }\r\n                state = newState;\r\n            }\r\n        }\r\n        return [state, header, comments, history];\r\n    }\r\n    exports.loadPgn = loadPgn;\r\n    function getPiece(state, square) {\r\n        if (!square)\r\n            return null;\r\n        square = square.toLowerCase();\r\n        if (!(0, utils_3.isSquare)(square))\r\n            return null;\r\n        var sq = constants_3.SQUARES[square];\r\n        var piece = state.board[sq];\r\n        if (piece) {\r\n            return clonePiece(piece);\r\n        }\r\n        return null;\r\n    }\r\n    exports.getPiece = getPiece;\r\n    function cloneMove(move) {\r\n        return {\r\n            to: move.to,\r\n            from: move.from,\r\n            color: move.color,\r\n            flags: move.flags,\r\n            piece: move.piece,\r\n            captured: move.captured,\r\n            promotion: move.promotion,\r\n            san: move.san,\r\n        };\r\n    }\r\n    exports.cloneMove = cloneMove;\r\n    function clonePiece(piece) {\r\n        return {\r\n            color: piece.color,\r\n            type: piece.type,\r\n        };\r\n    }\r\n    exports.clonePiece = clonePiece;\r\n    function putPiece(prevState, piece, square) {\r\n        var type = piece.type, color = piece.color;\r\n        /* check for presence */\r\n        if (!type || !color || !square) {\r\n            return null;\r\n        }\r\n        type = type.toLowerCase();\r\n        color = color.toLowerCase();\r\n        square = square.toLowerCase();\r\n        /* check for valid params */\r\n        if (!(0, utils_3.isPieceSymbol)(type) || !(0, utils_3.isColor)(color) || !(0, utils_3.isSquare)(square)) {\r\n            return null;\r\n        }\r\n        var state = prevState.clone();\r\n        /* don't let the user place more than one king */\r\n        var sq = constants_3.SQUARES[square];\r\n        if (type === constants_3.KING &&\r\n            state.kings[color] !== constants_3.EMPTY &&\r\n            state.kings[color] !== sq) {\r\n            return null;\r\n        }\r\n        state.board[sq] = { type: type, color: color };\r\n        if (type === constants_3.KING) {\r\n            state.kings[color] = sq;\r\n        }\r\n        return state;\r\n    }\r\n    exports.putPiece = putPiece;\r\n    function removePiece(prevState, square) {\r\n        if (!square)\r\n            return null;\r\n        square = square.toLowerCase();\r\n        if (!(0, utils_3.isSquare)(square))\r\n            return null;\r\n        var sq = constants_3.SQUARES[square];\r\n        var piece = prevState.board[sq];\r\n        if (!piece)\r\n            return null;\r\n        var state = prevState.clone();\r\n        var type = piece.type, color = piece.color;\r\n        if (type === constants_3.KING) {\r\n            state.kings[color] = constants_3.EMPTY;\r\n        }\r\n        delete state.board[sq];\r\n        return state;\r\n    }\r\n    exports.removePiece = removePiece;\r\n    function generateMoves(state, options) {\r\n        var _a, _b;\r\n        if (options === void 0) { options = {}; }\r\n        var _c = options.legal, legal = _c === void 0 ? true : _c;\r\n        var add_move = function (board, moves, from, to, flags) {\r\n            /* if pawn promotion */\r\n            var piece = board[from];\r\n            if (piece &&\r\n                piece.type === constants_3.PAWN &&\r\n                ((0, utils_3.rank)(to) === constants_3.RANK_8 || (0, utils_3.rank)(to) === constants_3.RANK_1)) {\r\n                var pieces = [constants_3.QUEEN, constants_3.ROOK, constants_3.BISHOP, constants_3.KNIGHT];\r\n                for (var i = 0, len = pieces.length; i < len; i++) {\r\n                    moves.push(buildMove(state, from, to, flags, pieces[i]));\r\n                }\r\n            }\r\n            else {\r\n                moves.push(buildMove(state, from, to, flags));\r\n            }\r\n        };\r\n        var moves = [];\r\n        var us = state.turn;\r\n        var them = (0, utils_3.swapColor)(us);\r\n        var second_rank = { b: constants_3.RANK_7, w: constants_3.RANK_2 };\r\n        var first_sq = constants_3.SQUARES.a8;\r\n        var last_sq = constants_3.SQUARES.h1;\r\n        var single_square = false;\r\n        /* are we generating moves for a single square? */\r\n        var square = options.square;\r\n        if (square) {\r\n            square = square.toLowerCase();\r\n            if ((0, utils_3.isSquare)(square)) {\r\n                first_sq = last_sq = constants_3.SQUARES[square];\r\n                single_square = true;\r\n            }\r\n            else {\r\n                /* invalid square */\r\n                return [];\r\n            }\r\n        }\r\n        for (var i = first_sq; i <= last_sq; i++) {\r\n            /* did we run off the end of the board */\r\n            if (i & 0x88) {\r\n                i += 7;\r\n                continue;\r\n            }\r\n            var piece = state.board[i];\r\n            if (!piece || piece.color !== us) {\r\n                continue;\r\n            }\r\n            if (piece.type === constants_3.PAWN) {\r\n                /* single square, non-capturing */\r\n                var square1 = i + constants_3.PAWN_OFFSETS[us][0];\r\n                if (!state.board[square1]) {\r\n                    add_move(state.board, moves, i, square1, constants_3.BITS.NORMAL);\r\n                    /* double square */\r\n                    var square2 = i + constants_3.PAWN_OFFSETS[us][1];\r\n                    if (second_rank[us] === (0, utils_3.rank)(i) && !state.board[square2]) {\r\n                        add_move(state.board, moves, i, square2, constants_3.BITS.BIG_PAWN);\r\n                    }\r\n                }\r\n                /* pawn captures */\r\n                for (var j = 2; j < 4; j++) {\r\n                    var square_1 = i + constants_3.PAWN_OFFSETS[us][j];\r\n                    if (square_1 & 0x88)\r\n                        continue;\r\n                    if (state.board[square_1] && ((_a = state.board[square_1]) === null || _a === void 0 ? void 0 : _a.color) === them) {\r\n                        add_move(state.board, moves, i, square_1, constants_3.BITS.CAPTURE);\r\n                    }\r\n                    else if (square_1 === state.ep_square) {\r\n                        add_move(state.board, moves, i, state.ep_square, constants_3.BITS.EP_CAPTURE);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (var j = 0, len = constants_3.PIECE_OFFSETS[piece.type].length; j < len; j++) {\r\n                    var offset = constants_3.PIECE_OFFSETS[piece.type][j];\r\n                    var square_2 = i;\r\n                    while (true) {\r\n                        square_2 += offset;\r\n                        if (square_2 & 0x88)\r\n                            break;\r\n                        if (!state.board[square_2]) {\r\n                            add_move(state.board, moves, i, square_2, constants_3.BITS.NORMAL);\r\n                        }\r\n                        else {\r\n                            if (((_b = state.board[square_2]) === null || _b === void 0 ? void 0 : _b.color) === us)\r\n                                break;\r\n                            add_move(state.board, moves, i, square_2, constants_3.BITS.CAPTURE);\r\n                            break;\r\n                        }\r\n                        /* break, if knight or king */\r\n                        if (piece.type === 'n' || piece.type === 'k')\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /* check for castling if: a) we're generating all moves, or b) we're doing\r\n         * single square move generation on the king's square\r\n         */\r\n        if (!single_square || last_sq === state.kings[us]) {\r\n            /* king-side castling */\r\n            if (state.castling[us] & constants_3.BITS.KSIDE_CASTLE) {\r\n                var castling_from = state.kings[us];\r\n                var castling_to = castling_from + 2;\r\n                if (!state.board[castling_from + 1] &&\r\n                    !state.board[castling_to] &&\r\n                    !isAttacked(state, them, state.kings[us]) &&\r\n                    !isAttacked(state, them, castling_from + 1) &&\r\n                    !isAttacked(state, them, castling_to)) {\r\n                    add_move(state.board, moves, state.kings[us], castling_to, constants_3.BITS.KSIDE_CASTLE);\r\n                }\r\n            }\r\n            /* queen-side castling */\r\n            if (state.castling[us] & constants_3.BITS.QSIDE_CASTLE) {\r\n                var castling_from = state.kings[us];\r\n                var castling_to = castling_from - 2;\r\n                if (!state.board[castling_from - 1] &&\r\n                    !state.board[castling_from - 2] &&\r\n                    !state.board[castling_from - 3] &&\r\n                    !isAttacked(state, them, state.kings[us]) &&\r\n                    !isAttacked(state, them, castling_from - 1) &&\r\n                    !isAttacked(state, them, castling_to)) {\r\n                    add_move(state.board, moves, state.kings[us], castling_to, constants_3.BITS.QSIDE_CASTLE);\r\n                }\r\n            }\r\n        }\r\n        /* return all pseudo-legal moves (this includes moves that allow the king\r\n         * to be captured)\r\n         */\r\n        if (!legal) {\r\n            return moves;\r\n        }\r\n        /* filter out illegal moves */\r\n        var legal_moves = [];\r\n        for (var i = 0, len = moves.length; i < len; i++) {\r\n            var newState = makeMove(state, moves[i]);\r\n            if (!isKingAttacked(newState, us)) {\r\n                legal_moves.push(moves[i]);\r\n            }\r\n        }\r\n        return legal_moves;\r\n    }\r\n    exports.generateMoves = generateMoves;\r\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\r\n     * (SAN)\r\n     *\r\n     * @param {boolean} sloppy Use the sloppy SAN generator to work around over\r\n     * disambiguation bugs in Fritz and Chessbase.  See below:\r\n     *\r\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\r\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\r\n     * 4. ... Ne7 is technically the valid SAN\r\n     */\r\n    function moveToSan(state, move, options) {\r\n        var _a;\r\n        if (options === void 0) { options = {}; }\r\n        var _b = options.sloppy, sloppy = _b === void 0 ? false : _b, _c = options.checkPromotion, checkPromotion = _c === void 0 ? true : _c;\r\n        var output = '';\r\n        if (move.flags & constants_3.BITS.KSIDE_CASTLE) {\r\n            output = 'O-O';\r\n        }\r\n        else if (move.flags & constants_3.BITS.QSIDE_CASTLE) {\r\n            output = 'O-O-O';\r\n        }\r\n        else {\r\n            var disambiguator = getDisambiguator(state, move, sloppy);\r\n            if (move.piece !== constants_3.PAWN) {\r\n                output += move.piece.toUpperCase() + disambiguator;\r\n            }\r\n            if (move.flags & (constants_3.BITS.CAPTURE | constants_3.BITS.EP_CAPTURE)) {\r\n                if (move.piece === constants_3.PAWN) {\r\n                    output += (0, utils_3.algebraic)(move.from)[0];\r\n                }\r\n                output += 'x';\r\n            }\r\n            output += (0, utils_3.algebraic)(move.to);\r\n            if (checkPromotion && move.flags & constants_3.BITS.PROMOTION) {\r\n                output += '=' + ((_a = move.promotion) === null || _a === void 0 ? void 0 : _a.toUpperCase());\r\n            }\r\n        }\r\n        var newState = makeMove(state, move);\r\n        if (inCheck(newState)) {\r\n            if (inCheckmate(newState)) {\r\n                output += '#';\r\n            }\r\n            else {\r\n                output += '+';\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n    exports.moveToSan = moveToSan;\r\n    function sanToMove(state, move, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _a = options.sloppy, sloppy = _a === void 0 ? false : _a, _b = options.checkPromotion, checkPromotion = _b === void 0 ? true : _b;\r\n        // strip off any move decorations: e.g Nf3+?!\r\n        var cleanMove = (0, utils_3.strippedSan)(move);\r\n        var matches, piece, from, to, promotion;\r\n        // if we're using the sloppy parser run a regex to grab piece, to, and from\r\n        // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\r\n        if (sloppy) {\r\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\r\n            if (matches) {\r\n                piece = matches[1];\r\n                from = matches[2];\r\n                to = matches[3];\r\n                promotion = matches[4];\r\n            }\r\n        }\r\n        var moves = generateMoves(state, { square: from });\r\n        for (var i = 0, len = moves.length; i < len; i++) {\r\n            // try the strict parser first, then the sloppy parser if requested\r\n            // by the user\r\n            var san = moveToSan(state, moves[i], { checkPromotion: checkPromotion });\r\n            if (cleanMove === (0, utils_3.strippedSan)(san) ||\r\n                (sloppy && cleanMove === (0, utils_3.strippedSan)(moveToSan(state, moves[i], options)))) {\r\n                return moves[i];\r\n            }\r\n            if (from &&\r\n                to &&\r\n                (0, utils_3.isSquare)(from) &&\r\n                (0, utils_3.isSquare)(to) &&\r\n                matches &&\r\n                (!piece || piece.toLowerCase() == moves[i].piece) &&\r\n                constants_3.SQUARES[from] == moves[i].from &&\r\n                constants_3.SQUARES[to] == moves[i].to &&\r\n                (!checkPromotion || !promotion || promotion.toLowerCase() == moves[i].promotion)) {\r\n                return moves[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    exports.sanToMove = sanToMove;\r\n    function makePretty(state, ugly_move) {\r\n        var move = cloneMove(ugly_move);\r\n        var flags = '';\r\n        for (var flag in constants_3.BITS) {\r\n            if ((0, utils_3.isFlagKey)(flag) && constants_3.BITS[flag] & move.flags) {\r\n                flags += constants_3.FLAGS[flag];\r\n            }\r\n        }\r\n        return {\r\n            to: (0, utils_3.algebraic)(move.to),\r\n            from: (0, utils_3.algebraic)(move.from),\r\n            color: move.color,\r\n            flags: flags,\r\n            piece: move.piece,\r\n            san: moveToSan(state, move),\r\n            captured: move.captured,\r\n            promotion: move.promotion,\r\n        };\r\n    }\r\n    exports.makePretty = makePretty;\r\n    function isAttacked(state, color, square) {\r\n        var _a;\r\n        for (var i = constants_3.SQUARES.a8; i <= constants_3.SQUARES.h1; i++) {\r\n            /* did we run off the end of the board */\r\n            if (i & 0x88) {\r\n                i += 7;\r\n                continue;\r\n            }\r\n            /* if empty square or wrong color */\r\n            if (state.board[i] == null || ((_a = state.board[i]) === null || _a === void 0 ? void 0 : _a.color) !== color)\r\n                continue;\r\n            var piece = state.board[i];\r\n            var difference = i - square;\r\n            var index = difference + 119;\r\n            if (piece && constants_3.ATTACKS[index] & (1 << constants_3.SHIFTS[piece.type])) {\r\n                if (piece.type === constants_3.PAWN) {\r\n                    if (difference > 0) {\r\n                        if (piece.color === constants_3.WHITE)\r\n                            return true;\r\n                    }\r\n                    else {\r\n                        if (piece.color === constants_3.BLACK)\r\n                            return true;\r\n                    }\r\n                    continue;\r\n                }\r\n                /* if the piece is a knight or a king */\r\n                if (piece.type === 'n' || piece.type === 'k')\r\n                    return true;\r\n                var offset = constants_3.RAYS[index];\r\n                var j = i + offset;\r\n                var blocked = false;\r\n                while (j !== square) {\r\n                    if (state.board[j]) {\r\n                        blocked = true;\r\n                        break;\r\n                    }\r\n                    j += offset;\r\n                }\r\n                if (!blocked)\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    exports.isAttacked = isAttacked;\r\n    function isKingAttacked(state, color) {\r\n        return isAttacked(state, (0, utils_3.swapColor)(color), state.kings[color]);\r\n    }\r\n    exports.isKingAttacked = isKingAttacked;\r\n    function inCheck(state) {\r\n        return isKingAttacked(state, state.turn);\r\n    }\r\n    exports.inCheck = inCheck;\r\n    function inCheckmate(state) {\r\n        return inCheck(state) && generateMoves(state).length === 0;\r\n    }\r\n    exports.inCheckmate = inCheckmate;\r\n    function inStalemate(state) {\r\n        return !inCheck(state) && generateMoves(state).length === 0;\r\n    }\r\n    exports.inStalemate = inStalemate;\r\n    function insufficientMaterial(state) {\r\n        var pieces = {};\r\n        var bishops = [];\r\n        var num_pieces = 0;\r\n        var sq_color = 0;\r\n        for (var i = constants_3.SQUARES.a8; i <= constants_3.SQUARES.h1; i++) {\r\n            sq_color = (sq_color + 1) % 2;\r\n            if (i & 0x88) {\r\n                i += 7;\r\n                continue;\r\n            }\r\n            var piece = state.board[i];\r\n            if (piece) {\r\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\r\n                if (piece.type === constants_3.BISHOP) {\r\n                    bishops.push(sq_color);\r\n                }\r\n                num_pieces++;\r\n            }\r\n        }\r\n        /* k vs. k */\r\n        if (num_pieces === 2) {\r\n            return true;\r\n        }\r\n        else if (\r\n        /* k vs. kn .... or .... k vs. kb */\r\n        num_pieces === 3 &&\r\n            (pieces[constants_3.BISHOP] === 1 || pieces[constants_3.KNIGHT] === 1)) {\r\n            return true;\r\n        }\r\n        else if (num_pieces === pieces[constants_3.BISHOP] + 2) {\r\n            /* kb vs. kb where any number of bishops are all on the same color */\r\n            var sum = 0;\r\n            var len = bishops.length;\r\n            for (var i = 0; i < len; i++) {\r\n                sum += bishops[i];\r\n            }\r\n            if (sum === 0 || sum === len) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    exports.insufficientMaterial = insufficientMaterial;\r\n    function makeMove(prevState, move) {\r\n        var state = prevState.clone();\r\n        var us = state.turn;\r\n        var them = (0, utils_3.swapColor)(us);\r\n        // this.push(move)\r\n        state.board[move.to] = state.board[move.from];\r\n        delete state.board[move.from];\r\n        /* if ep capture, remove the captured pawn */\r\n        if (move.flags & constants_3.BITS.EP_CAPTURE) {\r\n            if (state.turn === constants_3.BLACK) {\r\n                delete state.board[move.to - 16];\r\n            }\r\n            else {\r\n                delete state.board[move.to + 16];\r\n            }\r\n        }\r\n        /* if pawn promotion, replace with new piece */\r\n        if (move.flags & constants_3.BITS.PROMOTION && move.promotion && (0, utils_3.isPieceSymbol)(move.promotion)) {\r\n            state.board[move.to] = { type: move.promotion, color: us };\r\n        }\r\n        /* if we moved the king */\r\n        var piece = state.board[move.to];\r\n        if (piece && piece.type === constants_3.KING) {\r\n            state.kings[piece.color] = move.to;\r\n            /* if we castled, move the rook next to the king */\r\n            if (move.flags & constants_3.BITS.KSIDE_CASTLE) {\r\n                var castling_to = move.to - 1;\r\n                var castling_from = move.to + 1;\r\n                state.board[castling_to] = state.board[castling_from];\r\n                delete state.board[castling_from];\r\n            }\r\n            else if (move.flags & constants_3.BITS.QSIDE_CASTLE) {\r\n                var castling_to = move.to + 1;\r\n                var castling_from = move.to - 2;\r\n                state.board[castling_to] = state.board[castling_from];\r\n                delete state.board[castling_from];\r\n            }\r\n            /* turn off castling */\r\n            state.castling[us] = 0;\r\n        }\r\n        /* turn off castling if we move a rook */\r\n        if (state.castling[us]) {\r\n            for (var i = 0, len = constants_3.ROOKS[us].length; i < len; i++) {\r\n                if (move.from === constants_3.ROOKS[us][i].square &&\r\n                    state.castling[us] & constants_3.ROOKS[us][i].flag) {\r\n                    state.castling[us] ^= constants_3.ROOKS[us][i].flag;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        /* turn off castling if we capture a rook */\r\n        if (state.castling[them]) {\r\n            for (var i = 0, len = constants_3.ROOKS[them].length; i < len; i++) {\r\n                if (move.to === constants_3.ROOKS[them][i].square &&\r\n                    state.castling[them] & constants_3.ROOKS[them][i].flag) {\r\n                    state.castling[them] ^= constants_3.ROOKS[them][i].flag;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        /* if big pawn move, update the en passant square */\r\n        if (move.flags & constants_3.BITS.BIG_PAWN) {\r\n            if (state.turn === 'b') {\r\n                state.ep_square = move.to - 16;\r\n            }\r\n            else {\r\n                state.ep_square = move.to + 16;\r\n            }\r\n        }\r\n        else {\r\n            state.ep_square = constants_3.EMPTY;\r\n        }\r\n        /* reset the 50 move counter if a pawn is moved or a piece is captured */\r\n        if (move.piece === constants_3.PAWN) {\r\n            state.half_moves = 0;\r\n        }\r\n        else if (move.flags & (constants_3.BITS.CAPTURE | constants_3.BITS.EP_CAPTURE)) {\r\n            state.half_moves = 0;\r\n        }\r\n        else {\r\n            state.half_moves++;\r\n        }\r\n        if (state.turn === constants_3.BLACK) {\r\n            state.move_number++;\r\n        }\r\n        state.turn = (0, utils_3.swapColor)(state.turn);\r\n        return state;\r\n    }\r\n    exports.makeMove = makeMove;\r\n    function buildMove(state, from, to, flags, promotion) {\r\n        var _a;\r\n        var move = {\r\n            color: state.turn,\r\n            from: from,\r\n            to: to,\r\n            flags: flags,\r\n            piece: state.board[from].type\r\n        };\r\n        if (promotion && (0, utils_3.isPieceSymbol)(promotion)) {\r\n            move.flags |= constants_3.BITS.PROMOTION;\r\n            move.promotion = promotion;\r\n        }\r\n        if (state.board[to]) {\r\n            move.captured = (_a = state.board[to]) === null || _a === void 0 ? void 0 : _a.type;\r\n        }\r\n        else if (flags & constants_3.BITS.EP_CAPTURE) {\r\n            move.captured = constants_3.PAWN;\r\n        }\r\n        return move;\r\n    }\r\n    exports.buildMove = buildMove;\r\n    function ascii(board, eol) {\r\n        if (eol === void 0) { eol = '\\n'; }\r\n        var pieces = constants_3.RANKS.map(function (rank) {\r\n            var e_2, _a;\r\n            var rankPieces = board.slice(rank * 16, rank * 16 + 8);\r\n            // Use a loop because `map` skips empty indexes\r\n            var row = [];\r\n            try {\r\n                for (var rankPieces_1 = __values(rankPieces), rankPieces_1_1 = rankPieces_1.next(); !rankPieces_1_1.done; rankPieces_1_1 = rankPieces_1.next()) {\r\n                    var piece = rankPieces_1_1.value;\r\n                    row.push(piece ? \" \".concat((0, utils_3.symbol)(piece), \" \") : ' . ');\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (rankPieces_1_1 && !rankPieces_1_1.done && (_a = rankPieces_1.return)) _a.call(rankPieces_1);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n            var rankStr = row.join('');\r\n            return '87654321'[rank] + ' |' + rankStr + '|';\r\n        });\r\n        return [\r\n            '  +------------------------+',\r\n            pieces.join(eol),\r\n            '  +------------------------+',\r\n            '    a  b  c  d  e  f  g  h',\r\n        ].join(eol);\r\n    }\r\n    exports.ascii = ascii;\r\n    function getBoard(board) {\r\n        var output = [];\r\n        var row = [];\r\n        for (var i = constants_3.SQUARES.a8; i <= constants_3.SQUARES.h1; i++) {\r\n            var piece = board[i];\r\n            if (piece == null) {\r\n                row.push(null);\r\n            }\r\n            else {\r\n                row.push({ type: piece.type, color: piece.color });\r\n            }\r\n            if ((i + 1) & 0x88) {\r\n                output.push(row);\r\n                row = [];\r\n                i += 8;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n    exports.getBoard = getBoard;\r\n    function validateMove(state, move, options) {\r\n        var e_3, _a;\r\n        if (options === void 0) { options = {}; }\r\n        // Allow the user to specify the sloppy move parser to work around over\r\n        // disambiguation bugs in Fritz and Chessbase\r\n        var _b = options.checkPromotion, checkPromotion = _b === void 0 ? true : _b;\r\n        if (typeof move === 'string') {\r\n            return sanToMove(state, move, options);\r\n        }\r\n        else if (typeof move === 'object') {\r\n            var moves = generateMoves(state, { square: move.from });\r\n            try {\r\n                // Find a matching move\r\n                for (var moves_1 = __values(moves), moves_1_1 = moves_1.next(); !moves_1_1.done; moves_1_1 = moves_1.next()) {\r\n                    var moveObj = moves_1_1.value;\r\n                    if (move.from === (0, utils_3.algebraic)(moveObj.from) &&\r\n                        move.to === (0, utils_3.algebraic)(moveObj.to) &&\r\n                        (!checkPromotion || !('promotion' in moveObj) ||\r\n                            move.promotion === moveObj.promotion)) {\r\n                        return moveObj;\r\n                    }\r\n                }\r\n            }\r\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n            finally {\r\n                try {\r\n                    if (moves_1_1 && !moves_1_1.done && (_a = moves_1.return)) _a.call(moves_1);\r\n                }\r\n                finally { if (e_3) throw e_3.error; }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    exports.validateMove = validateMove;\r\n});\r\ndefine(\"node_modules/chess.ts/src/chess\", [\"require\", \"exports\", \"node_modules/chess.ts/src/state\", \"node_modules/chess.ts/src/types\", \"node_modules/chess.ts/src/utils\", \"node_modules/chess.ts/src/constants\"], function (require, exports, state_2, types_2, utils_4, constants_4) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.Chess = void 0;\r\n    /** @public */\r\n    var Chess = /** @class */ (function () {\r\n        /**\r\n         * The Chess() constructor takes an optional parameter which specifies the board configuration\r\n         * in [Forsyth-Edwards Notation](http://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation).\r\n         *\r\n         * @example\r\n         * ```js\r\n         * // board defaults to the starting position when called with no parameters\r\n         * const chess = new Chess()\r\n         *\r\n         * // pass in a FEN string to load a particular position\r\n         * const chess = new Chess(\r\n         *     'r1k4r/p2nb1p1/2b4p/1p1n1p2/2PP4/3Q1NB1/1P3PPP/R5K1 b - c3 0 19'\r\n         * )\r\n         * ```\r\n         */\r\n        function Chess(fen) {\r\n            if (fen === void 0) { fen = constants_4.DEFAULT_POSITION; }\r\n            this._whiteResigned = false;\r\n            this._blackResigned = false;\r\n            this._drawAgreed = false;\r\n            this._state = new types_2.State();\r\n            this._history = [];\r\n            this._header = {};\r\n            this._comments = {};\r\n            if (!this.load(fen)) {\r\n                throw new Error('Error loading fen');\r\n            }\r\n        }\r\n        Object.defineProperty(Chess.prototype, \"state\", {\r\n            /** @internal */\r\n            get: function () {\r\n                return this._state.clone();\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Chess.prototype, \"states\", {\r\n            /** @internal **/\r\n            get: function () {\r\n                return __spreadArray(__spreadArray([], __read(this._history.map(function (gameHistory) { return gameHistory.state.clone(); })), false), [this.state], false);\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * Clears the board and loads the Forsythâ€“Edwards Notation (FEN) string.\r\n         *\r\n         * @param fen - FEN string\r\n         * @param keepHeaders - Flag to keep headers\r\n         * @returns True if the position was successfully loaded, otherwise false.\r\n         */\r\n        Chess.prototype.load = function (fen, keepHeaders) {\r\n            if (keepHeaders === void 0) { keepHeaders = false; }\r\n            var state = (0, state_2.loadFen)(fen);\r\n            if (!state) {\r\n                return false;\r\n            }\r\n            this._state = state;\r\n            this._history = [];\r\n            if (!keepHeaders)\r\n                this._header = {};\r\n            this._comments = {};\r\n            this.updateSetup();\r\n            return true;\r\n        };\r\n        /**\r\n         * Clears the board.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.clear()\r\n         * chess.fen()\r\n         * // -> '8/8/8/8/8/8/8/8 w - - 0 1' <- empty board\r\n         * ```\r\n         *\r\n         * @param keepHeaders - Flag to keep headers\r\n         */\r\n        Chess.prototype.clear = function (keepHeaders) {\r\n            if (keepHeaders === void 0) { keepHeaders = false; }\r\n            this._state = new types_2.State();\r\n            this._history = [];\r\n            if (!keepHeaders)\r\n                this._header = {};\r\n            this._comments = {};\r\n            this.updateSetup();\r\n        };\r\n        /**\r\n         * Reset the board to the initial starting position.\r\n         */\r\n        Chess.prototype.reset = function () {\r\n            this.load(constants_4.DEFAULT_POSITION);\r\n        };\r\n        /**\r\n         * Returns the piece on the square.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.clear()\r\n         * chess.put({ type: chess.PAWN, color: chess.BLACK }, 'a5') // put a black pawn on a5\r\n         *\r\n         * chess.get('a5')\r\n         * // -> { type: 'p', color: 'b' },\r\n         * chess.get('a6')\r\n         * // -> null\r\n         * ```\r\n         *\r\n         * @param square - e.g. 'e4'\r\n         * @returns Copy of the piece or null\r\n         */\r\n        Chess.prototype.get = function (square) {\r\n            return (0, state_2.getPiece)(this._state, square);\r\n        };\r\n        /**\r\n         * Place a piece on the square where piece is an object with the form\r\n         * `{ type: ..., color: ... }`. Returns true if the piece was successfully\r\n         * placed, otherwise, the board remains unchanged and false is returned.\r\n         * `put()` will fail when passed an invalid piece or square, or when two or\r\n         * more kings of the same color are placed.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.clear()\r\n         *\r\n         * chess.put({ type: chess.PAWN, color: chess.BLACK }, 'a5') // put a black pawn on a5\r\n         * // -> true\r\n         * chess.put({ type: 'k', color: 'w' }, 'h1') // shorthand\r\n         * // -> true\r\n         *\r\n         * chess.fen()\r\n         * // -> '8/8/8/p7/8/8/8/7K w - - 0 0'\r\n         *\r\n         * chess.put({ type: 'z', color: 'w' }, 'a1') // invalid piece\r\n         * // -> false\r\n         *\r\n         * chess.clear()\r\n         *\r\n         * chess.put({ type: 'k', color: 'w' }, 'a1')\r\n         * // -> true\r\n         *\r\n         * chess.put({ type: 'k', color: 'w' }, 'h1') // fail - two kings\r\n         * // -> false\r\n         * ```\r\n         *\r\n         * @param piece - Object of the form `{ type: 'p', color: 'w' }`\r\n         * @param square - e.g. `'e4'`\r\n         * @returns True if placed successfully, otherwise false\r\n         */\r\n        Chess.prototype.put = function (piece, square) {\r\n            var newState = (0, state_2.putPiece)(this._state, piece, square);\r\n            if (newState) {\r\n                this._state = newState;\r\n                this.updateSetup();\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        /**\r\n         * Remove and return the piece on `square`.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.clear()\r\n         * chess.put({ type: chess.PAWN, color: chess.BLACK }, 'a5') // put a black pawn on a5\r\n         * chess.put({ type: chess.KING, color: chess.WHITE }, 'h1') // put a white king on h1\r\n         *\r\n         * chess.remove('a5')\r\n         * // -> { type: 'p', color: 'b' },\r\n         * chess.remove('h1')\r\n         * // -> { type: 'k', color: 'w' },\r\n         * chess.remove('e1')\r\n         * // -> null\r\n         * ```\r\n         *\r\n         * @param square - e.g. 'e4'\r\n         * @returns Piece or null\r\n         */\r\n        Chess.prototype.remove = function (square) {\r\n            var piece = (0, state_2.getPiece)(this._state, square);\r\n            if (!piece) {\r\n                return null;\r\n            }\r\n            var newState = (0, state_2.removePiece)(this._state, square);\r\n            if (!newState) {\r\n                return null;\r\n            }\r\n            this._state = newState;\r\n            return piece;\r\n        };\r\n        Chess.prototype.moves = function (options) {\r\n            var _this = this;\r\n            if (options === void 0) { options = {}; }\r\n            // The internal representation of a chess move is in 0x88 format, and\r\n            // not meant to be human-readable.  The code below converts the 0x88\r\n            // square coordinates to algebraic coordinates.  It also prunes an\r\n            // unnecessary move keys resulting from a verbose call.\r\n            var square = options.square, _a = options.verbose, verbose = _a === void 0 ? false : _a;\r\n            var uglyMoves = (0, state_2.generateMoves)(this._state, { square: square });\r\n            if (verbose) {\r\n                return uglyMoves.map(function (uglyMove) { return (0, state_2.makePretty)(_this._state, uglyMove); });\r\n            }\r\n            return uglyMoves.map(function (uglyMove) { return (0, state_2.moveToSan)(_this._state, uglyMove); });\r\n        };\r\n        /**\r\n         * Returns the FEN string for the current position.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * // make some moves\r\n         * chess.move('e4')\r\n         * chess.move('e5')\r\n         * chess.move('f4')\r\n         *\r\n         * chess.fen()\r\n         * // -> 'rnbqkbnr/pppp1ppp/8/4p3/4PP2/8/PPPP2PP/RNBQKBNR b KQkq f3 0 2'\r\n         * ```\r\n         */\r\n        Chess.prototype.fen = function () {\r\n            return this._state.fen;\r\n        };\r\n        /**\r\n         * Returns true or false if the side to move is in check.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess(\r\n         *     'rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3'\r\n         * )\r\n         * chess.inCheck()\r\n         * // -> true\r\n         * ```\r\n         */\r\n        Chess.prototype.inCheck = function () {\r\n            return (0, state_2.inCheck)(this._state);\r\n        };\r\n        /**\r\n         * Returns true or false if the side to move has been checkmated.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess(\r\n         *     'rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3'\r\n         * )\r\n         * chess.inCheckmate()\r\n         * // -> true\r\n         * ```\r\n         */\r\n        Chess.prototype.inCheckmate = function () {\r\n            return (0, state_2.inCheckmate)(this._state);\r\n        };\r\n        /**\r\n         * Returns true or false if the side to move has been stalemated.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')\r\n         * chess.inStalemate()\r\n         * // -> true\r\n         * ```\r\n         */\r\n        Chess.prototype.inStalemate = function () {\r\n            return (0, state_2.inStalemate)(this._state);\r\n        };\r\n        /**\r\n         * Returns true if the game is drawn due to insufficient material (K vs. K,\r\n         * K vs. KB, or K vs. KN) otherwise false.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess('k7/8/n7/8/8/8/8/7K b - - 0 1')\r\n         * chess.insufficientMaterial()\r\n         * // -> true\r\n         * ```\r\n         */\r\n        Chess.prototype.insufficientMaterial = function () {\r\n            return (0, state_2.insufficientMaterial)(this._state);\r\n        };\r\n        /**\r\n         * Returns true or false if the current board position has occurred three or more\r\n         * times.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1')\r\n         * // -> true\r\n         * // rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq occurs 1st time\r\n         * chess.inThreefoldRepetition()\r\n         * // -> false\r\n         *\r\n         * chess.move('Nf3') chess.move('Nf6') chess.move('Ng1') chess.move('Ng8')\r\n         * // rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq occurs 2nd time\r\n         * chess.inThreefoldRepetition()\r\n         * // -> false\r\n         *\r\n         * chess.move('Nf3') chess.move('Nf6') chess.move('Ng1') chess.move('Ng8')\r\n         * // rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq occurs 3rd time\r\n         * chess.inThreefoldRepetition()\r\n         * // -> true\r\n         * ```\r\n         */\r\n        Chess.prototype.inThreefoldRepetition = function () {\r\n            var e_4, _a;\r\n            var positions = {};\r\n            var checkState = function (state) {\r\n                var key = state.fen.split(' ').slice(0, 4).join(' ');\r\n                // Has the position occurred three or move times?\r\n                positions[key] = key in positions ? positions[key] + 1 : 1;\r\n                if (positions[key] >= 3) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            };\r\n            try {\r\n                for (var _b = __values(this._history), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var state = _c.value.state;\r\n                    if (checkState(state)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_4) throw e_4.error; }\r\n            }\r\n            return checkState(this._state);\r\n        };\r\n        /**\r\n         * Returns true or false if the game is drawn (50-move rule or insufficient material).\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')\r\n         * chess.inDraw()\r\n         * // -> true\r\n         * ```\r\n         */\r\n        Chess.prototype.inDraw = function () {\r\n            return (this._state.half_moves >= 100 ||\r\n                this.inStalemate() ||\r\n                this.insufficientMaterial() ||\r\n                this.inThreefoldRepetition());\r\n        };\r\n        /**\r\n         * Returns true if the game has ended via checkmate, stalemate, draw,\r\n         * threefold repetition, or insufficient material. Otherwise, returns false.\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         * chess.gameOver()\r\n         * // -> false\r\n         *\r\n         * // stalemate\r\n         * chess.load('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')\r\n         * chess.gameOver()\r\n         * // -> true\r\n         *\r\n         * // checkmate\r\n         * chess.load('rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3')\r\n         * chess.gameOver()\r\n         * // -> true\r\n         * ```\r\n         */\r\n        Chess.prototype.gameOver = function () {\r\n            return this.inCheckmate() || this.inDraw() || this._whiteResigned || this._blackResigned;\r\n        };\r\n        /**\r\n         * Returns an 2D array representation of the current position. Empty squares\r\n         * are represented by `null`.\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.board()\r\n         * // -> [[{type: 'r', color: 'b'},\r\n         *         {type: 'n', color: 'b'},\r\n         *         {type: 'b', color: 'b'},\r\n         *         {type: 'q', color: 'b'},\r\n         *         {type: 'k', color: 'b'},\r\n         *         {type: 'b', color: 'b'},\r\n         *         {type: 'n', color: 'b'},\r\n         *         {type: 'r', color: 'b'}],\r\n         *         [...],\r\n         *         [...],\r\n         *         [...],\r\n         *         [...],\r\n         *         [...],\r\n         *         [{type: 'r', color: 'w'},\r\n         *          {type: 'n', color: 'w'},\r\n         *          {type: 'b', color: 'w'},\r\n         *          {type: 'q', color: 'w'},\r\n         *          {type: 'k', color: 'w'},\r\n         *          {type: 'b', color: 'w'},\r\n         *          {type: 'n', color: 'w'},\r\n         *          {type: 'r', color: 'w'}]]\r\n         * ```\r\n         */\r\n        Chess.prototype.board = function () {\r\n            return (0, state_2.getBoard)(this._state.board);\r\n        };\r\n        /**\r\n         * Returns the game in PGN format. Options is an optional parameter which may include\r\n         * max width and/or a newline character settings.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         * chess.header('White', 'Plunky', 'Black', 'Plinkie')\r\n         * chess.move('e4')\r\n         * chess.move('e5')\r\n         * chess.move('Nc3')\r\n         * chess.move('Nc6')\r\n         *\r\n         * chess.pgn({ max_width: 5, newline_char: '<br />' })\r\n         * // -> '[White \"Plunky\"]<br />[Black \"Plinkie\"]<br /><br />1. e4 e5<br />2. Nc3 Nc6'\r\n         * ```\r\n         */\r\n        Chess.prototype.pgn = function (options) {\r\n            if (options === void 0) { options = {}; }\r\n            return (0, state_2.getPgn)(this._state, this._header, this._comments, this._history, options);\r\n        };\r\n        /**\r\n         * Load the moves of a game stored in\r\n         * [Portable Game Notation](http://en.wikipedia.org/wiki/Portable_Game_Notation).\r\n         * `pgn` should be a string. Options is an optional `object` which may contain\r\n         * a string `newline_char` and a boolean `sloppy`.\r\n         *\r\n         * The `newline_char` is a string representation of a valid RegExp fragment and is\r\n         * used to process the PGN. It defaults to `\\r?\\n`. Special characters\r\n         * should not be pre-escaped, but any literal special characters should be escaped\r\n         * as is normal for a RegExp. Keep in mind that backslashes in JavaScript strings\r\n         * must themselves be escaped (see `sloppy_pgn` example below). Avoid using\r\n         * a `newline_char` that may occur elsewhere in a PGN, such as `.` or `x`, as this\r\n         * will result in unexpected behavior.\r\n         *\r\n         * The `sloppy` flag is a boolean that permits chess.js to parse moves in\r\n         * non-standard notations. See `.move` documentation for more information about\r\n         * non-SAN notations.\r\n         *\r\n         * The method will return `true` if the PGN was parsed successfully, otherwise `false`.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         * const pgn = [\r\n         *     '[Event \"Casual Game\"]',\r\n         *     '[Site \"Berlin GER\"]',\r\n         *     '[Date \"1852.??.??\"]',\r\n         *     '[EventDate \"?\"]',\r\n         *     '[Round \"?\"]',\r\n         *     '[Result \"1-0\"]',\r\n         *     '[White \"Adolf Anderssen\"]',\r\n         *     '[Black \"Jean Dufresne\"]',\r\n         *     '[ECO \"C52\"]',\r\n         *     '[WhiteElo \"?\"]',\r\n         *     '[BlackElo \"?\"]',\r\n         *     '[PlyCount \"47\"]',\r\n         *     '',\r\n         *     '1.e4 e5 2.Nf3 Nc6 3.Bc4 Bc5 4.b4 Bxb4 5.c3 Ba5 6.d4 exd4 7.O-O',\r\n         *     'd3 8.Qb3 Qf6 9.e5 Qg6 10.Re1 Nge7 11.Ba3 b5 12.Qxb5 Rb8 13.Qa4',\r\n         *     'Bb6 14.Nbd2 Bb7 15.Ne4 Qf5 16.Bxd3 Qh5 17.Nf6+ gxf6 18.exf6',\r\n         *     'Rg8 19.Rad1 Qxf3 20.Rxe7+ Nxe7 21.Qxd7+ Kxd7 22.Bf5+ Ke8',\r\n         *     '23.Bd7+ Kf8 24.Bxe7# 1-0'\r\n         * ]\r\n         *\r\n         * chess.loadPgn(pgn.join('\\n'))\r\n         * // -> true\r\n         *\r\n         * chess.fen()\r\n         * // -> 1r3kr1/pbpBBp1p/1b3P2/8/8/2P2q2/P4PPP/3R2K1 b - - 0 24\r\n         *\r\n         * chess.ascii()\r\n         * // -> '  +------------------------+\r\n         * //     8 | .  r  .  .  .  k  r  . |\r\n         * //     7 | p  b  p  B  B  p  .  p |\r\n         * //     6 | .  b  .  .  .  P  .  . |\r\n         * //     5 | .  .  .  .  .  .  .  . |\r\n         * //     4 | .  .  .  .  .  .  .  . |\r\n         * //     3 | .  .  P  .  .  q  .  . |\r\n         * //     2 | P  .  .  .  .  P  P  P |\r\n         * //     1 | .  .  .  R  .  .  K  . |\r\n         * //       +------------------------+\r\n         * //         a  b  c  d  e  f  g  h'\r\n         *\r\n         * // Parse non-standard move formats and unusual line separators\r\n         * const sloppyPgn = [\r\n         *     '[Event \"Wijk aan Zee (Netherlands)\"]',\r\n         *     '[Date \"1971.01.26\"]',\r\n         *     '[Result \"1-0\"]',\r\n         *     '[White \"Tigran Vartanovich Petrosian\"]',\r\n         *     '[Black \"Hans Ree\"]',\r\n         *     '[ECO \"A29\"]',\r\n         *     '',\r\n         *     '1. Pc2c4 Pe7e5', // non-standard\r\n         *     '2. Nc3 Nf6',\r\n         *     '3. Nf3 Nc6',\r\n         *     '4. g2g3 Bb4', // non-standard\r\n         *     '5. Nd5 Nxd5',\r\n         *     '6. c4xd5 e5-e4', // non-standard\r\n         *     '7. dxc6 exf3',\r\n         *     '8. Qb3 1-0'\r\n         * ].join('|')\r\n         *\r\n         * const options = {\r\n         *     newline_char: '\\\\|', // Literal '|' character escaped\r\n         *     sloppy: true\r\n         * }\r\n         *\r\n         * chess.loadPgn(sloppyPgn)\r\n         * // -> false\r\n         *\r\n         * chess.loadPgn(sloppyPgn, options)\r\n         * // -> true\r\n         *\r\n         * chess.fen()\r\n         * // -> 'r1bqk2r/pppp1ppp/2P5/8/1b6/1Q3pP1/PP1PPP1P/R1B1KB1R b KQkq - 1 8'\r\n         * ```\r\n         */\r\n        Chess.prototype.loadPgn = function (pgn, options) {\r\n            if (options === void 0) { options = {}; }\r\n            var res = (0, state_2.loadPgn)(pgn, options);\r\n            if (!res) {\r\n                return false;\r\n            }\r\n            var _a = __read(res, 4), state = _a[0], header = _a[1], comments = _a[2], history = _a[3];\r\n            this._state = state;\r\n            this._header = header;\r\n            this._comments = comments;\r\n            this._history = history;\r\n            return true;\r\n        };\r\n        /**\r\n         * Returns PGN header information as an object.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.header()\r\n         * // -> { White: 'Morphy', Black: 'Anderssen', Date: '1858-??-??' }\r\n         * ```\r\n         */\r\n        Chess.prototype.header = function () {\r\n            return this._header;\r\n        };\r\n        /**\r\n         * Sets PGN header information.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.setHeader({\r\n         *   'White': 'Robert James Fischer',\r\n         *   'Black': 'Mikhail Tal'\r\n         * })\r\n         * ```\r\n         */\r\n        Chess.prototype.setHeader = function (header) {\r\n            this._header = header;\r\n        };\r\n        /**\r\n         * Adds a PGN header entry\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.addHeader('White', 'Robert James Fischer')\r\n         * chess.addHeader('Black', 'Mikhail Tal')\r\n         * ```\r\n         */\r\n        Chess.prototype.addHeader = function (key, val) {\r\n            this._header[key] = val;\r\n        };\r\n        /**\r\n         * Removes a PGN header entry\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.removeHeader('White')\r\n         * ```\r\n         */\r\n        Chess.prototype.removeHeader = function (key) {\r\n            delete this._header[key];\r\n        };\r\n        /**\r\n         * Removes all PGN header information.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.setHeader('White', 'Robert James Fischer')\r\n         * chess.setHeader('Black', 'Mikhail Tal')\r\n         * ```\r\n         */\r\n        Chess.prototype.clearHeader = function () {\r\n            this._header = {};\r\n        };\r\n        /**\r\n         * Returns a string containing an ASCII diagram of the current position.\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * // Make some moves\r\n         * chess.move('e4')\r\n         * chess.move('e5')\r\n         * chess.move('f4')\r\n         *\r\n         * chess.ascii()\r\n         * // -> '   +------------------------+\r\n         * //      8 | r  n  b  q  k  b  n  r |\r\n         * //      7 | p  p  p  p  .  p  p  p |\r\n         * //      6 | .  .  .  .  .  .  .  . |\r\n         * //      5 | .  .  .  .  p  .  .  . |\r\n         * //      4 | .  .  .  .  P  P  .  . |\r\n         * //      3 | .  .  .  .  .  .  .  . |\r\n         * //      2 | P  P  P  P  .  .  P  P |\r\n         * //      1 | R  N  B  Q  K  B  N  R |\r\n         * //        +------------------------+\r\n         * //          a  b  c  d  e  f  g  h'\r\n         * ```\r\n         */\r\n        Chess.prototype.ascii = function (eol) {\r\n            if (eol === void 0) { eol = '\\n'; }\r\n            return (0, state_2.ascii)(this._state.board, eol);\r\n        };\r\n        /**\r\n         * Returns the current side to move.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.load('rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1')\r\n         * chess.turn()\r\n         * // -> 'b'\r\n         * ```\r\n         */\r\n        Chess.prototype.turn = function () {\r\n            return this._state.turn;\r\n        };\r\n        /**\r\n         * Attempts to make a move on the board, returning a move object if the move was\r\n         * legal, otherwise null. The .move function can be called two ways, by passing\r\n         * a string in Standard Algebraic Notation (SAN):\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.move('e4')\r\n         * // -> { color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' }\r\n         *\r\n         * chess.move('nf6') // SAN is case sensitive!!\r\n         * // -> null\r\n         *\r\n         * chess.move('Nf6')\r\n         * // -> { color: 'b', from: 'g8', to: 'f6', flags: 'n', piece: 'n', san: 'Nf6' }\r\n         * ```\r\n         *\r\n         *\r\n         * Or by passing .move() a move object (only the 'to', 'from', and when necessary\r\n         * 'promotion', fields are needed):\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.move({ from: 'g2', to: 'g3' })\r\n         * // -> { color: 'w', from: 'g2', to: 'g3', flags: 'n', piece: 'p', san: 'g3' }\r\n         * ```\r\n         *\r\n         * An optional sloppy flag can be used to parse a variety of non-standard move\r\n         * notations:\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * // various forms of Long Algebraic Notation\r\n         * chess.move('e2e4', { sloppy: true })\r\n         * // -> { color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' }\r\n         * chess.move('e7-e5', { sloppy: true })\r\n         * // -> { color: 'b', from: 'e7', to: 'e5', flags: 'b', piece: 'p', san: 'e5' }\r\n         * chess.move('Pf2f4', { sloppy: true })\r\n         * // -> { color: 'w', from: 'f2', to: 'f4', flags: 'b', piece: 'p', san: 'f4' }\r\n         * chess.move('Pe5xf4', { sloppy: true })\r\n         * // -> { color: 'b', from: 'e5', to: 'f4', flags: 'c', piece: 'p', captured: 'p', san: 'exf4' }\r\n         *\r\n         * // correctly parses incorrectly disambiguated moves\r\n         * chess = new Chess(\r\n         *     'r2qkbnr/ppp2ppp/2n5/1B2pQ2/4P3/8/PPP2PPP/RNB1K2R b KQkq - 3 7'\r\n         * )\r\n         *\r\n         * chess.move('Nge7') // Ne7 is unambiguous because the knight on c6 is pinned\r\n         * // -> null\r\n         *\r\n         * chess.move('Nge7', { sloppy: true })\r\n         * // -> { color: 'b', from: 'g8', to: 'e7', flags: 'n', piece: 'n', san: 'Ne7' }\r\n         * ```\r\n         *\r\n         * @param move - Case-sensitive SAN string or object, e.g. `'Nxb7'` or\r\n         * `{ from: 'h7', to: 'h8', promotion: 'q' }`\r\n         * @param options - Options to enable parsing of a variety of non-standard\r\n         * move notations\r\n         */\r\n        Chess.prototype.move = function (move, options) {\r\n            if (options === void 0) { options = {}; }\r\n            var validMove = (0, state_2.validateMove)(this._state, move, options);\r\n            if (!validMove) {\r\n                return null;\r\n            }\r\n            // Create pretty move before updating the state\r\n            var prettyMove = (0, state_2.makePretty)(this._state, validMove);\r\n            if (!options.dry_run) {\r\n                this.makeMove(validMove);\r\n            }\r\n            return prettyMove;\r\n        };\r\n        /**\r\n         * Validates a sequence of moves, returning an array of move objects if the\r\n         * moves are all legal, otherwise null.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.validateMoves(['e4', 'Nf6'])\r\n         * // -> [{ color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' },\r\n         *        { color: 'b', from: 'g8', to: 'f6', flags: 'n', piece: 'n', san: 'Nf6' }]\r\n         *\r\n         * chess.validateMoves(['e4, 'nf6']) // SAN is case sensitive!!\r\n         * // -> null\r\n         * ```\r\n         *\r\n         * @param moves - Array of case-sensitive SAN strings or objects, e.g. `'Nxb7'` or\r\n         * `{ from: 'h7', to: 'h8', promotion: 'q' }`\r\n         * @param options - Options to enable parsing of a variety of non-standard\r\n         * move notations\r\n         */\r\n        Chess.prototype.validateMoves = function (moves, options) {\r\n            var e_5, _a;\r\n            if (options === void 0) { options = {}; }\r\n            var validMoves = [];\r\n            var state = this._state;\r\n            try {\r\n                for (var moves_2 = __values(moves), moves_2_1 = moves_2.next(); !moves_2_1.done; moves_2_1 = moves_2.next()) {\r\n                    var move = moves_2_1.value;\r\n                    var validMove = (0, state_2.validateMove)(state, move, options);\r\n                    if (!validMove) {\r\n                        return null;\r\n                    }\r\n                    validMoves.push((0, state_2.makePretty)(state, validMove));\r\n                    state = (0, state_2.makeMove)(state, validMove);\r\n                }\r\n            }\r\n            catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n            finally {\r\n                try {\r\n                    if (moves_2_1 && !moves_2_1.done && (_a = moves_2.return)) _a.call(moves_2);\r\n                }\r\n                finally { if (e_5) throw e_5.error; }\r\n            }\r\n            return validMoves;\r\n        };\r\n        /**\r\n         * Checks if a move results in a promotion.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.isPromotion('e4')\r\n         * // -> false\r\n         *\r\n         * chess.load('8/2P2k2/8/8/8/5K2/8/8 w - - 0 1')\r\n         * chess.isPromotion('c8')\r\n         * // -> true\r\n         * ```\r\n         *\r\n         * @param move - Case-sensitive SAN string or object, e.g. `'Nxb7'` or\r\n         * `{ from: 'h7', to: 'h8' }`\r\n         * @param options - Options to enable parsing of a variety of non-standard\r\n         * move notations\r\n         */\r\n        Chess.prototype.isPromotion = function (move, options) {\r\n            if (options === void 0) { options = {}; }\r\n            var validMove = (0, state_2.validateMove)(this._state, move, __assign(__assign({}, options), { checkPromotion: false }));\r\n            if (!validMove) {\r\n                return false;\r\n            }\r\n            return !!(validMove.flags & constants_4.BITS.PROMOTION);\r\n        };\r\n        /**\r\n         * Takeback the last half-move, returning a move object if successful, otherwise null.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.fen()\r\n         * // -> 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\r\n         * chess.move('e4')\r\n         * chess.fen()\r\n         * // -> 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1'\r\n         *\r\n         * chess.undo()\r\n         * // -> { color: 'w', from: 'e2', to: 'e4', flags: 'b', piece: 'p', san: 'e4' }\r\n         * chess.fen()\r\n         * // -> 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\r\n         * chess.undo()\r\n         * // -> null\r\n         * ```\r\n         */\r\n        Chess.prototype.undo = function () {\r\n            var move = this.undoMove();\r\n            return move ? (0, state_2.makePretty)(this._state, move) : null;\r\n        };\r\n        /**\r\n         * Returns the color of the square ('light' or 'dark').\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = Chess()\r\n         * chess.squareColor('h1')\r\n         * // -> 'light'\r\n         * chess.squareColor('a7')\r\n         * // -> 'dark'\r\n         * chess.squareColor('bogus square')\r\n         * // -> null\r\n         * ```\r\n         */\r\n        Chess.prototype.squareColor = function (square) {\r\n            if ((0, utils_4.isSquare)(square)) {\r\n                var sq_0x88 = constants_4.SQUARES[square];\r\n                return ((0, utils_4.rank)(sq_0x88) + (0, utils_4.file)(sq_0x88)) % 2 === 0 ? 'light' : 'dark';\r\n            }\r\n            return null;\r\n        };\r\n        Chess.prototype.history = function (options) {\r\n            if (options === void 0) { options = {}; }\r\n            var _a = options.verbose, verbose = _a === void 0 ? false : _a;\r\n            if (!this._history.length) {\r\n                return [];\r\n            }\r\n            var state;\r\n            if (verbose) {\r\n                return this._history.map(function (gameHistory) {\r\n                    var move = gameHistory.move;\r\n                    state = gameHistory.state;\r\n                    return (0, state_2.makePretty)(state, move);\r\n                });\r\n            }\r\n            return this._history.map(function (gameHistory) {\r\n                var move = gameHistory.move;\r\n                state = gameHistory.state;\r\n                return (0, state_2.moveToSan)(state, move);\r\n            });\r\n        };\r\n        /**\r\n         * Retrieve the comment for a position, if it exists.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.loadPgn(\"1. e4 e5 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *\")\r\n         *\r\n         * chess.getComment()\r\n         * // -> \"giuoco piano\"\r\n         * ```\r\n         *\r\n         * @param fen - Defaults to the current position\r\n         */\r\n        Chess.prototype.getComment = function (fen) {\r\n            fen = fen || this.fen();\r\n            return this._comments[fen];\r\n        };\r\n        /**\r\n         * Retrieve comments for all positions.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.loadPgn(\"1. e4 e5 {king's pawn opening} 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *\")\r\n         *\r\n         * chess.getComments()\r\n         * // -> [\r\n         * //     {\r\n         * //       fen: \"rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2\",\r\n         * //       comment: \"king's pawn opening\"\r\n         * //     },\r\n         * //     {\r\n         * //       fen: \"r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3\",\r\n         * //       comment: \"giuoco piano\"\r\n         * //     }\r\n         * //    ]\r\n         * ```\r\n         */\r\n        Chess.prototype.getComments = function () {\r\n            var _this = this;\r\n            this.pruneComments();\r\n            return Object.keys(this._comments).map(function (fen) {\r\n                return { fen: fen, comment: _this._comments[fen] };\r\n            });\r\n        };\r\n        /**\r\n         * Comment on a position.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.move(\"e4\")\r\n         * chess.setComment(\"king's pawn opening\")\r\n         *\r\n         * chess.pgn()\r\n         * // -> \"1. e4 {king's pawn opening}\"\r\n         * ```\r\n         *\r\n         * @param comment\r\n         * @param fen - Defaults to the current position\r\n         */\r\n        Chess.prototype.setComment = function (comment, fen) {\r\n            fen = fen || this.fen();\r\n            this._comments[fen] = comment.replace('{', '[').replace('}', ']');\r\n        };\r\n        /**\r\n         * Delete and return the comment for a position, if it exists.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.loadPgn(\"1. e4 e5 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *\")\r\n         *\r\n         * chess.getComment()\r\n         * // -> \"giuoco piano\"\r\n         *\r\n         * chess.deleteComments()\r\n         * // -> \"giuoco piano\"\r\n         *\r\n         * chess.getComment()\r\n         * // -> undefined\r\n         * ```\r\n         *\r\n         * @param fen - Defaults to the current position\r\n         */\r\n        Chess.prototype.deleteComment = function (fen) {\r\n            fen = fen || this.fen();\r\n            var comment = this._comments[fen];\r\n            delete this._comments[fen];\r\n            return comment;\r\n        };\r\n        /**\r\n         * Delete and return comments for all positions.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * const chess = new Chess()\r\n         *\r\n         * chess.loadPgn(\"1. e4 e5 {king's pawn opening} 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *\")\r\n         *\r\n         * chess.deleteComments()\r\n         * // -> [\r\n         * //     {\r\n         * //       fen: \"rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2\",\r\n         * //       comment: \"king's pawn opening\"\r\n         * //     },\r\n         * //     {\r\n         * //       fen: \"r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3\",\r\n         * //       comment: \"giuoco piano\"\r\n         * //     }\r\n         * //    ]\r\n         *\r\n         * chess.getComments()\r\n         * // -> []\r\n         * ```\r\n         */\r\n        Chess.prototype.deleteComments = function () {\r\n            var _this = this;\r\n            this.pruneComments();\r\n            return Object.keys(this._comments).map(function (fen) {\r\n                var comment = _this._comments[fen];\r\n                delete _this._comments[fen];\r\n                return { fen: fen, comment: comment };\r\n            });\r\n        };\r\n        /**\r\n         * Returns a validation object specifying validity or the errors found\r\n         * within the FEN string.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * chess.validateFen('2n1r3/p1k2pp1/B1p3b1/P7/5bP1/2N1B3/1P2KP2/2R5 b - - 4 25')\r\n         * // -> { valid: true, error_number: 0, error: 'No errors.' }\r\n         *\r\n         * chess.validateFen('4r3/8/X12XPk/1p6/pP2p1R1/P1B5/2P2K2/3r4 w - - 1 45')\r\n         * // -> { valid: false, error_number: 9,\r\n         * //     error: '1st field (piece positions) is invalid [invalid piece].' }\r\n         * ```\r\n         */\r\n        Chess.prototype.validateFen = function (fen) {\r\n            return (0, utils_4.validateFen)(fen);\r\n        };\r\n        /** @internal */\r\n        Chess.prototype.clone = function () {\r\n            var clone = new Chess();\r\n            clone._state = this._state;\r\n            clone._history = __spreadArray([], __read(this._history), false);\r\n            clone._header = __assign({}, this._header);\r\n            clone._comments = __assign({}, this._comments);\r\n            return clone;\r\n        };\r\n        /** @internal */\r\n        Chess.prototype.perft = function (depth) {\r\n            var moves = (0, state_2.generateMoves)(this._state, { legal: false });\r\n            var nodes = 0;\r\n            var color = this._state.turn;\r\n            for (var i = 0, len = moves.length; i < len; i++) {\r\n                this.makeMove(moves[i]);\r\n                if (!this.kingAttacked(color)) {\r\n                    if (depth - 1 > 0) {\r\n                        var child_nodes = this.perft(depth - 1);\r\n                        nodes += child_nodes;\r\n                    }\r\n                    else {\r\n                        nodes++;\r\n                    }\r\n                }\r\n                this.undoMove();\r\n            }\r\n            return nodes;\r\n        };\r\n        /**\r\n         * Called when the initial board setup is changed with put() or remove().\r\n         * modifies the SetUp and FEN properties of the header object.  if the FEN is\r\n         * equal to the default position, the SetUp and FEN are deleted\r\n         * the setup is only updated if history.length is zero, ie moves haven't been\r\n         * made.\r\n         *\r\n         * @internal\r\n         */\r\n        Chess.prototype.updateSetup = function () {\r\n            var fen = this._state.fen;\r\n            if (this._history.length > 0)\r\n                return;\r\n            if (fen !== constants_4.DEFAULT_POSITION) {\r\n                this._header['SetUp'] = '1';\r\n                this._header['FEN'] = fen;\r\n            }\r\n            else {\r\n                delete this._header['SetUp'];\r\n                delete this._header['FEN'];\r\n            }\r\n        };\r\n        /** @internal */\r\n        Chess.prototype.pruneComments = function () {\r\n            var _this = this;\r\n            var comments = {};\r\n            var copyComments = function (fen) {\r\n                if (fen in _this._comments) {\r\n                    comments[fen] = _this._comments[fen];\r\n                }\r\n            };\r\n            this._history.forEach(function (_a) {\r\n                var historyState = _a.state;\r\n                state = historyState;\r\n                copyComments(state.fen);\r\n            });\r\n            var state = this._state;\r\n            copyComments(state.fen);\r\n            this._comments = comments;\r\n        };\r\n        /**\r\n         * Parses all of the decorators out of a SAN string\r\n         *\r\n         * @internal\r\n         */\r\n        Chess.prototype.strippedSan = function (move) {\r\n            return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\r\n        };\r\n        /** @internal */\r\n        Chess.prototype.attacked = function (color, square) {\r\n            return (0, state_2.isAttacked)(this._state, color, square);\r\n        };\r\n        /** @internal */\r\n        Chess.prototype.kingAttacked = function (color) {\r\n            return this.attacked((0, utils_4.swapColor)(color), this._state.kings[color]);\r\n        };\r\n        /** @internal */\r\n        Chess.prototype.makeMove = function (move) {\r\n            this._history.push({\r\n                move: move,\r\n                state: this._state,\r\n            });\r\n            this._state = (0, state_2.makeMove)(this._state, move);\r\n        };\r\n        /** @internal */\r\n        Chess.prototype.undoMove = function () {\r\n            var prev = this._history.pop();\r\n            if (prev == null) {\r\n                return null;\r\n            }\r\n            this._state = prev.state;\r\n            return prev.move;\r\n        };\r\n        return Chess;\r\n    }());\r\n    exports.Chess = Chess;\r\n});\r\ndefine(\"src/board\", [\"require\", \"exports\", \"src/piece\", \"src/square\", \"src/annotations\", \"node_modules/chess.ts/src/chess\", \"src/utils\"], function (require, exports, piece_1, square_3, annotations_1, chess_1, utils_5) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.Board = void 0;\r\n    var Board = /** @class */ (function () {\r\n        function Board(room) {\r\n            this.white_pieces = [];\r\n            this.black_pieces = [];\r\n            this.possibleMovesImages = {};\r\n            this.chessgame = new chess_1.Chess();\r\n            this.canvas = new UICanvas();\r\n            this.canvas_container = new UIContainerStack(this.canvas); //declare parent element\r\n            this.annotations_container = new UIContainerStack(this.canvas);\r\n            this.configureContainer(\"canvas\");\r\n            this.configureContainer(\"annotations\");\r\n            this.annotations = new annotations_1.Annotations(this.annotations_container);\r\n            this.squares = this.generateBoard();\r\n            this.white_pieces = this.generatePieces(utils_5.chessColor.WHITE);\r\n            this.black_pieces = this.generatePieces(utils_5.chessColor.BLACK);\r\n            this.setAllVisible();\r\n            this.room = room;\r\n            this.turn = false;\r\n            // this.annotations_container.\r\n        }\r\n        //supports modes \"canvas\" and \"annotations\"\r\n        Board.prototype.configureContainer = function (container_name) {\r\n            if (container_name == \"canvas\") {\r\n                this.canvas_container.adaptWidth = true;\r\n                this.canvas_container.width = \"70%\";\r\n                this.canvas_container.height = \"100%\";\r\n                this.canvas_container.opacity = 1;\r\n                this.canvas_container.color = Color4.Gray(); //set background-color\r\n                this.canvas_container.visible = false;\r\n            }\r\n            else if (container_name == \"annotations\") {\r\n                this.annotations_container.adaptWidth = true;\r\n                this.annotations_container.width = \"25%\";\r\n                this.annotations_container.height = \"90%\";\r\n                this.annotations_container.opacity = 1;\r\n                this.annotations_container.color = Color4.White(); //set background-color\r\n                this.annotations_container.visible = true;\r\n                this.annotations_container.positionX = utils_5.squareMap['h4'].xPosition + 260;\r\n                this.annotations_container.positionY = utils_5.squareMap['h4'].yPosition + 30;\r\n                this.annotations_container.adaptWidth = false;\r\n                this.annotations_container.adaptHeight = false; //-> TODO: make it scrollable\r\n            }\r\n        };\r\n        // generateBoardFromFen(fen:string){\r\n        //     this.chessgame.load(fen)\r\n        //     let rows = fen.split(\"/\", 8)\r\n        //     rows.forEach((row, index) => {\r\n        //     })\r\n        // }\r\n        //fills this.squares with Square objects\r\n        Board.prototype.generateBoard = function () {\r\n            var board = {};\r\n            var square = 'a1';\r\n            var board_built = false;\r\n            var counter_x = 1, counter_y = 1;\r\n            while (!board_built) {\r\n                square = String.fromCharCode(96 + counter_x) + String.fromCharCode(48 + counter_y);\r\n                board[square] = new square_3.Square(square, this.canvas);\r\n                if (counter_x == 8 && counter_y == 8) {\r\n                    board_built = true;\r\n                }\r\n                else if (counter_y == 8) {\r\n                    counter_y = 1;\r\n                    counter_x++;\r\n                }\r\n                else\r\n                    counter_y++;\r\n            }\r\n            return board;\r\n        };\r\n        //fils this.white_pieces & this.black_pieces with Pieces objects\r\n        Board.prototype.generatePieces = function (color) {\r\n            var _this = this;\r\n            var pieces = [];\r\n            var _loop_1 = function (i) {\r\n                var column = String.fromCharCode(i), row = (color == utils_5.chessColor.WHITE) ? '2' : '7';\r\n                var square_4 = column + row;\r\n                var pawn = new piece_1.Piece(color, utils_5.PieceType.PAWN, square_4, this_1.canvas);\r\n                pawn.image.onClick = new OnPointerDown(function () {\r\n                    if (!_this.chessgame.gameOver())\r\n                        _this.displayPosibilities(pawn);\r\n                });\r\n                pieces.push(pawn);\r\n            };\r\n            var this_1 = this;\r\n            //PAWNS\r\n            for (var i = 97; i <= 104; i++) {\r\n                _loop_1(i);\r\n            }\r\n            var _loop_2 = function (i) {\r\n                var column = String.fromCharCode(i), row = (color == utils_5.chessColor.WHITE) ? '1' : '8';\r\n                var square_5 = column + row;\r\n                var knight = new piece_1.Piece(color, utils_5.PieceType.KNIGHT, square_5, this_2.canvas);\r\n                knight.image.onClick = new OnPointerDown(function () {\r\n                    if (!_this.chessgame.gameOver())\r\n                        _this.displayPosibilities(knight);\r\n                });\r\n                pieces.push(knight);\r\n            };\r\n            var this_2 = this;\r\n            //KNIGHT\r\n            for (var i = 98; i <= 103; i = i + 5) {\r\n                _loop_2(i);\r\n            }\r\n            var _loop_3 = function (i) {\r\n                var column = String.fromCharCode(i), row = (color == utils_5.chessColor.WHITE) ? '1' : '8';\r\n                var square_6 = column + row;\r\n                var bishop = new piece_1.Piece(color, utils_5.PieceType.BISHOP, square_6, this_3.canvas);\r\n                bishop.image.onClick = new OnPointerDown(function () {\r\n                    if (!_this.chessgame.gameOver())\r\n                        _this.displayPosibilities(bishop);\r\n                });\r\n                pieces.push(bishop);\r\n            };\r\n            var this_3 = this;\r\n            //BISHOPS\r\n            for (var i = 99; i <= 102; i = i + 3) {\r\n                _loop_3(i);\r\n            }\r\n            var _loop_4 = function (i) {\r\n                var column = String.fromCharCode(i), row = (color == utils_5.chessColor.WHITE) ? '1' : '8';\r\n                var square_7 = column + row;\r\n                var rook = new piece_1.Piece(color, utils_5.PieceType.ROOK, square_7, this_4.canvas);\r\n                rook.image.onClick = new OnPointerDown(function () {\r\n                    if (!_this.chessgame.gameOver())\r\n                        _this.displayPosibilities(rook);\r\n                });\r\n                pieces.push(rook);\r\n            };\r\n            var this_4 = this;\r\n            //ROOK\r\n            for (var i = 97; i <= 104; i = i + 7) {\r\n                _loop_4(i);\r\n            }\r\n            //QUEEN\r\n            var square = (color == utils_5.chessColor.WHITE) ? 'd1' : 'd8';\r\n            var queen = new piece_1.Piece(color, utils_5.PieceType.QUEEN, square, this.canvas);\r\n            queen.image.onClick = new OnPointerDown(function () {\r\n                if (!_this.chessgame.gameOver())\r\n                    _this.displayPosibilities(queen);\r\n            });\r\n            pieces.push(queen);\r\n            //KING\r\n            square = (color == utils_5.chessColor.WHITE) ? 'e1' : 'e8';\r\n            var king = new piece_1.Piece(color, utils_5.PieceType.KING, square, this.canvas);\r\n            king.image.onClick = new OnPointerDown(function () {\r\n                if (!_this.chessgame.gameOver())\r\n                    _this.displayPosibilities(king);\r\n            });\r\n            pieces.push(king);\r\n            return pieces;\r\n        };\r\n        //sets all elements visible\r\n        Board.prototype.setAllVisible = function () {\r\n            this.canvas_container.visible = true;\r\n            this.canvas.visible = true;\r\n            this.white_pieces.forEach(function (white_piece, index) {\r\n                white_piece.setVisibility(true);\r\n            });\r\n            this.black_pieces.forEach(function (black_piece, index) {\r\n                black_piece.setVisibility(true);\r\n            });\r\n        };\r\n        //moves a piece to a square\r\n        Board.prototype.movePiece = function (piece, movement) {\r\n            var _this = this;\r\n            if (this.turn == true) {\r\n                this.chessgame.move(movement); //make move in chessgame\r\n                this.resetPossibleMoves();\r\n                log(\"dos cops?\");\r\n                var color = piece.getColor();\r\n                log(\"aqui no arriba sas\");\r\n                if (movement == \"O-O\") {\r\n                    piece.movePiece(color == \"white\" ? 'g1' : 'g8');\r\n                    var rook_1 = this.getPiece(color == 'white' ? 'h1' : 'h8');\r\n                    rook_1.movePiece(color == \"white\" ? 'f1' : 'f8');\r\n                    rook_1.image.onClick = piece.image.onClick = new OnPointerDown(function () {\r\n                        _this.displayPosibilities(rook_1);\r\n                    });\r\n                }\r\n                else if (movement == \"O-O-O\") {\r\n                    piece.movePiece(color == \"white\" ? 'c1' : 'c8');\r\n                    var rook_2 = this.getPiece(color == 'white' ? 'a1' : 'a8');\r\n                    rook_2.movePiece(color == \"white\" ? 'd1' : 'd8');\r\n                    rook_2.image.onClick = piece.image.onClick = new OnPointerDown(function () {\r\n                        _this.displayPosibilities(rook_2);\r\n                    });\r\n                }\r\n                //Normal move\r\n                else\r\n                    piece.movePiece(movement.substr(movement.length - 2));\r\n                piece.image.onClick = piece.image.onClick = new OnPointerDown(function () {\r\n                    _this.displayPosibilities(piece);\r\n                });\r\n                //this.room.send(\"moverFicha\", {move: movement, pie: piece})\r\n                this.annotations.addMove(movement, piece.getColor(), this.chessgame.fen());\r\n                this.turn = false; //poso el torn un altre cop a fals fins que la senyal em digui el contrari\r\n            }\r\n        };\r\n        //gets piece on a square\r\n        Board.prototype.getPiece = function (position) {\r\n            // let piece: Piece = new Piece(chessColor.WHITE, PieceType.PAWN, \"a1\", this.canvas)\r\n            for (var i = 0; i < this.white_pieces.length; i++) {\r\n                if (this.white_pieces[i].position == position) {\r\n                    return this.white_pieces[i];\r\n                }\r\n            }\r\n            for (var i = 0; i < this.black_pieces.length; i++) {\r\n                if (this.black_pieces[i].position == position) {\r\n                    return this.black_pieces[i];\r\n                }\r\n            }\r\n            var piece = new piece_1.Piece(utils_5.chessColor.WHITE, utils_5.PieceType.PAWN, \"a1\", this.canvas);\r\n            piece.setVisibility(false);\r\n            return piece;\r\n        };\r\n        //sets board attribute possibleMovesImages with a list of Square variables. Each one of these variables points to a square \r\n        //on the board whose image will have changed to a selector image\r\n        Board.prototype.displayPosibilities = function (piece) {\r\n            var _this = this;\r\n            this.resetPossibleMoves();\r\n            this.resetPieceEvents();\r\n            var square = piece.position; //piece position\r\n            var moves = this.chessgame.moves({ square: square }); //possible moves for piece\r\n            // piece.setPossibleMoves(moves) \r\n            moves.forEach(function (move) {\r\n                move = move.replace('#', '');\r\n                move = move.replace('+', '');\r\n                log(move);\r\n                //short castling\r\n                if (move == \"O-O\") {\r\n                    var square_position = piece.getColor() == \"white\" ? 'g1' : 'g8';\r\n                    var square_8 = new square_3.Square(square_position, _this.canvas, \"images/chessboard/move-\" + (0, utils_5.getSquareColor)(square_position) + \"-square.png\");\r\n                    square_8.image.onClick = new OnPointerDown(function () {\r\n                        _this.room.send(\"moverFicha\", { move: \"O-O\", original_position: piece.position }); //cuando se realiza un movimiento se manda una seÃ±al a la room para que el servidor se lo haga saber a los demÃ¡s jugadores\r\n                        _this.movePiece(piece, 'O-O');\r\n                    });\r\n                    _this.possibleMovesImages[square_position] = _this.squares[square_position];\r\n                }\r\n                //long castling\r\n                else if (move == \"O-O-O\") {\r\n                    var square_position = piece.getColor() == \"white\" ? 'c1' : 'c8';\r\n                    var square_9 = new square_3.Square(square_position, _this.canvas, \"images/chessboard/move-\" + (0, utils_5.getSquareColor)(square_position) + \"-square.png\");\r\n                    square_9.image.onClick = new OnPointerDown(function () {\r\n                        _this.room.send(\"moverFicha\", { move: \"O-O-O\", original_position: piece.position }); //cuando se realiza un movimiento se manda una seÃ±al a la room para que el servidor se lo haga saber a los demÃ¡s jugadores\r\n                        _this.movePiece(piece, 'O-O-O');\r\n                    });\r\n                    _this.possibleMovesImages[square_position] = _this.squares[square_position];\r\n                }\r\n                //capture move\r\n                else if (move.indexOf(\"x\") != -1) {\r\n                    var square_to_move = move.substr(move.length - 2);\r\n                    var piece_on_square_1 = _this.getPiece(square_to_move);\r\n                    if (piece_on_square_1.image.visible == true) { // if there's a enemy piece on that square\r\n                        piece_on_square_1.image.onClick = new OnPointerDown(function () {\r\n                            if (!_this.chessgame.gameOver()) {\r\n                                piece_on_square_1.image.visible = false;\r\n                                piece_on_square_1.getColor() == \"white\" ? _this.white_pieces.splice(_this.white_pieces.indexOf(piece_on_square_1), 1) : _this.black_pieces.splice(_this.black_pieces.indexOf(piece_on_square_1), 1);\r\n                                _this.room.send(\"moverFicha\", { move: move, original_position: piece.position }); //cuando se realiza un movimiento se manda una seÃ±al a la room para que el servidor se lo haga saber a los demÃ¡s jugadores\r\n                                _this.movePiece(piece, move);\r\n                            }\r\n                        });\r\n                    }\r\n                    else if (piece.getPiece() == utils_5.PieceType.PAWN) {\r\n                        var square_position = \"\";\r\n                        if (piece.color == \"white\")\r\n                            square_position = square_to_move[0] + String.fromCharCode(square_to_move.charCodeAt(1) - 1);\r\n                        else\r\n                            square_position = square_to_move[0] + String.fromCharCode(square_to_move.charCodeAt(1) + 1);\r\n                        var pawn_to_take_1 = _this.getPiece(square_position);\r\n                        if (_this.getPiece(square_position).piece == \"pawn\" && pawn_to_take_1.image.visible && pawn_to_take_1.color != piece.color) { //comer al paso?\r\n                            var square_10 = new square_3.Square(move.substr(move.length - 2), _this.canvas, \"images/chessboard/move-\" + (0, utils_5.getSquareColor)(move.substr(move.length - 2)) + \"-square.png\");\r\n                            square_10.image.onClick = new OnPointerDown(function () {\r\n                                //create an event on the square object\r\n                                if (!_this.chessgame.gameOver()) {\r\n                                    _this.room.send(\"moverFicha\", { move: move, original_position: piece.position }); //cuando se realiza un movimiento se manda una seÃ±al a la room para que el servidor se lo haga saber a los demÃ¡s jugadores\r\n                                    _this.movePiece(piece, move);\r\n                                    pawn_to_take_1.image.visible = false;\r\n                                    pawn_to_take_1.getColor() == \"white\" ? _this.white_pieces.splice(_this.white_pieces.indexOf(pawn_to_take_1), 1) : _this.black_pieces.splice(_this.black_pieces.indexOf(pawn_to_take_1), 1);\r\n                                }\r\n                            });\r\n                            _this.squares[move.substr(move.length - 2)] = square_10;\r\n                            _this.possibleMovesImages[move.substr(move.length - 2)] = _this.squares[move.substr(move.length - 2)];\r\n                        }\r\n                    }\r\n                }\r\n                //promotion\r\n                // else if (move.indexOf(\"=\") !=  -1){\r\n                //     let square_to_move:string = move.substr(move.length-2)\r\n                //     let piece_on_square: Piece = this.getPiece(square_to_move) \r\n                //     if(piece_on_square.image.visible == true){                      // if there's a enemy piece on that square\r\n                //         piece_on_square.image.onClick = new OnPointerDown(()=> {    //create an event on the piece object\r\n                //             piece_on_square.image.visible = false;\r\n                //             piece_on_square.getColor() == \"white\" ? this.white_pieces.splice(this.white_pieces.indexOf(piece_on_square), 1) : this.black_pieces.splice(this.black_pieces.indexOf(piece_on_square), 1)\r\n                //             this.movePiece(piece, move)\r\n                //         })\r\n                //     }\r\n                // }\r\n                else {\r\n                    var square_11 = new square_3.Square(move.substr(move.length - 2), _this.canvas, \"images/chessboard/move-\" + (0, utils_5.getSquareColor)(move.substr(move.length - 2)) + \"-square.png\");\r\n                    square_11.image.onClick = new OnPointerDown(function () {\r\n                        _this.room.send(\"moverFicha\", { move: move, original_position: piece.position }); //cuando se realiza un movimiento se manda una seÃ±al a la room para que el servidor se lo haga saber a los demÃ¡s jugadores\r\n                        _this.movePiece(piece, move);\r\n                    });\r\n                    _this.squares[move.substr(move.length - 2)] = square_11;\r\n                    _this.possibleMovesImages[move.substr(move.length - 2)] = _this.squares[move.substr(move.length - 2)];\r\n                }\r\n            });\r\n        };\r\n        //resets board attribute possibleMovesImages and sets all squares to their original image\r\n        Board.prototype.resetPossibleMoves = function () {\r\n            var _this = this;\r\n            Object.keys(this.possibleMovesImages).forEach(function (square) {\r\n                _this.squares[square] = new square_3.Square(square, _this.canvas);\r\n            });\r\n            this.possibleMovesImages = {};\r\n        };\r\n        //resets onPointerDown events on all pieces to displayPosibilities -- this default event may have changed when a piece was selected\r\n        Board.prototype.resetPieceEvents = function () {\r\n            var _this = this;\r\n            this.white_pieces.forEach(function (piece) {\r\n                piece.image.onClick = new OnPointerDown(function () {\r\n                    _this.displayPosibilities(piece);\r\n                });\r\n            });\r\n            this.black_pieces.forEach(function (piece) {\r\n                piece.image.onClick = new OnPointerDown(function () {\r\n                    _this.displayPosibilities(piece);\r\n                });\r\n            });\r\n        };\r\n        return Board;\r\n    }());\r\n    exports.Board = Board;\r\n});\r\n// setPieces(){\r\n//     //set pawns\r\n//     let ascii_code = 'a'.charCodeAt(0) \r\n//     for (let i = 0; i < 8; i++){\r\n//         let white_square:string = String.fromCharCode(ascii_code)+'2'\r\n//         let black_square:string = String.fromCharCode(ascii_code)+'7'\r\n//         let white_pawn:Piece = new Piece(PieceColor.WHITE, PieceType.PAWN, white_square, this.canvas)\r\n//         let black_pawn:Piece = new Piece(PieceColor.BLACK, PieceType.PAWN, black_square, this.canvas)\r\n//         ascii_code++;\r\n//         this.white_pieces.push(white_pawn)\r\n//         this.black_pieces.push(black_pawn)\r\n//     }\r\n// }\r\n// export const canvasContainer = new UIContainerStack(canvas) //declare parent element\r\n// canvasContainer.adaptWidth = true\r\n// canvasContainer.width = \"70%\"\r\n// canvasContainer.height = \"100%\"\r\n// canvasContainer.opacity = 1\r\n// canvasContainer.color = Color4.Gray() //set background-color\r\n// canvasContainer.visible = false\r\n// //sets all the canvas elements visibility to type's value\r\n// const board: { [key: string]: UIImage } = {};\r\n// let boardBuilt: boolean = false\r\n// let square:string = 'a1' \r\n// let count:number = 0 //keeps track on whether the square should be black or white\r\n// while (!boardBuilt){\r\n//     board[square] = count%2==0 ? new UIImage(canvas, new Texture(\"images/chessboard/black-square.png\")) : new UIImage(canvas, new Texture(\"images/chessboard/white-square.png\"))\r\n//     board[square].positionX = squareMap[square].xPosition\r\n//     board[square].positionY = squareMap[square].yPosition\r\n//     board[square].height = 64/resizeFactor\r\n//     board[square].width = 64/resizeFactor\r\n//     board[square].visible = false \r\n//     if (square.charAt(0) != 'h')\r\n//         square = square.replace(square.charAt(0), String.fromCharCode(square.charCodeAt(0)+1));\r\n//     else{\r\n//         square = square.replace(square.charAt(0), 'a');\r\n//         count--\r\n//         if (square.charAt(1) == '8')\r\n//             boardBuilt = true\r\n//         else  \r\n//             square = square.replace(square.charAt(1), String.fromCharCode(square.charCodeAt(1)+1));\r\n//     }\r\n//     count++\r\n// }\r\n// const closeButton:UIImage = new UIImage(canvas, new Texture(\"images/chessboard/close-button.png\"))\r\n// closeButton.visible = false\r\n// closeButton.width = 32\r\n// closeButton.height = 32\r\n// closeButton.sourceLeft = 0\r\n// closeButton.sourceTop = 0\r\n// closeButton.sourceWidth = 860\r\n// closeButton.sourceHeight = 896\r\n// closeButton.hAlign=\"right\"\r\n// closeButton.vAlign=\"top\"\r\n// closeButton.positionX=\"-240\"\r\n// closeButton.positionY=squareMap['e1'].yPosition\r\n// closeButton.positionX=squareMap['e2'].xPosition\r\n// let ascii_code = 'a'.charCodeAt(0) \r\n// for (let i = 0; i < 8; i++){\r\n//     const whitePawn = new UIImage(canvas, new Texture(\"images/chessboard/white-pawn.png\"))\r\n//     whitePawn.visible = false\r\n//     whitePawn.width = 32\r\n//     whitePawn.height = 48\r\n//     whitePawn.sourceLeft = 0\r\n//     whitePawn.sourceTop = 0\r\n//     whitePawn.sourceWidth = 60\r\n//     whitePawn.sourceHeight = 78\r\n//     whitePawn.positionY=squareMap[String.fromCharCode(ascii_code)+'2'].yPosition\r\n//     whitePawn.positionX=squareMap[String.fromCharCode(ascii_code)+'2'].xPosition\r\n//     ascii_code++;\r\n//     whitePieces.push(whitePawn)\r\n// }\r\n// ascii_code = 'a'.charCodeAt(0) \r\n// for (let i = 0; i < 8; i++){\r\n//     const blackPawn = new UIImage(canvas, new Texture(\"images/chessboard/black-pawn.png\"))\r\n//     blackPawn.visible = false\r\n//     blackPawn.width = 32\r\n//     blackPawn.height = 48\r\n//     blackPawn.sourceLeft = 0\r\n//     blackPawn.sourceTop = 0\r\n//     blackPawn.sourceWidth = 60\r\n//     blackPawn.sourceHeight = 78\r\n//     blackPawn.positionY=squareMap[String.fromCharCode(ascii_code)+'7'].yPosition\r\n//     blackPawn.positionX=squareMap[String.fromCharCode(ascii_code)+'7'].xPosition\r\n//     ascii_code++;\r\n//     blackPieces.push(blackPawn)\r\n// }\r\n// for (let i = 0; i < 2; i++){\r\n//     const blackKnight = new UIImage(canvas, new Texture(\"images/chessboard/black-knight.png\"))\r\n//     blackKnight.visible = false\r\n//     blackKnight.width = 48\r\n//     blackKnight.height = 48\r\n//     blackKnight.sourceLeft = 0\r\n//     blackKnight.sourceTop = 0\r\n//     blackKnight.sourceWidth = 82\r\n//     blackKnight.sourceHeight = 83\r\n//     if(i==0){\r\n//         blackKnight.positionY=squareMap['b8'].yPosition\r\n//         blackKnight.positionX=squareMap['b8'].xPosition\r\n//     }\r\n//     else{\r\n//         blackKnight.positionY=squareMap['g8'].yPosition\r\n//         blackKnight.positionX=squareMap['g8'].xPosition\r\n//     }\r\n//     blackPieces.push(blackKnight)\r\n// }\r\n// for (let i = 0; i < 2; i++){\r\n//     const whiteBishop = new UIImage(canvas, new Texture(\"images/chessboard/white-bishop.png\"))\r\n//     whiteBishop.visible = false\r\n//     whiteBishop.width = 48\r\n//     whiteBishop.height = 48\r\n//     whiteBishop.sourceLeft = 0\r\n//     whiteBishop.sourceTop = 0\r\n//     whiteBishop.sourceWidth = 82\r\n//     whiteBishop.sourceHeight = 82\r\n//     if(i==0){\r\n//         whiteBishop.positionY=squareMap['c1'].yPosition\r\n//         whiteBishop.positionX=squareMap['c1'].xPosition\r\n//     }\r\n//     else{\r\n//         whiteBishop.positionY=squareMap['f1'].yPosition\r\n//         whiteBishop.positionX=squareMap['f1'].xPosition\r\n//     }\r\n//     whitePieces.push(whiteBishop)\r\n// }\r\n// for (let i = 0; i < 2; i++){\r\n//     const blackBishop = new UIImage(canvas, new Texture(\"images/chessboard/black-bishop.png\"))\r\n//     blackBishop.visible = false\r\n//     blackBishop.width = 48\r\n//     blackBishop.height = 48\r\n//     blackBishop.sourceLeft = 0\r\n//     blackBishop.sourceTop = 0\r\n//     blackBishop.sourceWidth = 82\r\n//     blackBishop.sourceHeight = 82\r\n//     if(i==0){\r\n//         blackBishop.positionY=squareMap['c8'].yPosition\r\n//         blackBishop.positionX=squareMap['c8'].xPosition\r\n//     }\r\n//     else{\r\n//         blackBishop.positionY=squareMap['f8'].yPosition\r\n//         blackBishop.positionX=squareMap['f8'].xPosition\r\n//     }\r\n//     blackPieces.push(blackBishop)\r\n// }\r\n// for (let i = 0; i < 2; i++){\r\n//     const whiteKnight = new UIImage(canvas, new Texture(\"images/chessboard/white-knight.png\"))\r\n//     whiteKnight.visible = false\r\n//     whiteKnight.width = 48\r\n//     whiteKnight.height = 48\r\n//     whiteKnight.sourceLeft = 0\r\n//     whiteKnight.sourceTop = 0\r\n//     whiteKnight.sourceWidth = 82\r\n//     whiteKnight.sourceHeight = 82\r\n//     if(i==0){\r\n//         whiteKnight.positionY=squareMap['b1'].yPosition\r\n//         whiteKnight.positionX=squareMap['b1'].xPosition\r\n//     }\r\n//     else{\r\n//         whiteKnight.positionY=squareMap['g1'].yPosition\r\n//         whiteKnight.positionX=squareMap['g1'].xPosition\r\n//     }\r\n//     whitePieces.push(whiteKnight)\r\n// }\r\n// for (let i = 0; i < 2; i++){\r\n//     const whiteRook = new UIImage(canvas, new Texture(\"images/chessboard/white-rook.png\"))\r\n//     whiteRook.visible = false\r\n//     whiteRook.width = 42\r\n//     whiteRook.height = 48\r\n//     whiteRook.sourceLeft = 0\r\n//     whiteRook.sourceTop = 0\r\n//     whiteRook.sourceWidth = 69\r\n//     whiteRook.sourceHeight = 78\r\n//     if (i==0){\r\n//         whiteRook.positionY=squareMap['a1'].yPosition\r\n//         whiteRook.positionX=squareMap['a1'].xPosition\r\n//     }\r\n//     else{\r\n//         whiteRook.positionY=squareMap['h1'].yPosition\r\n//         whiteRook.positionX=squareMap['h1'].xPosition\r\n//     }\r\n//     whitePieces.push(whiteRook)\r\n// }\r\n// for (let i = 0; i < 2; i++){\r\n//     const blackRook = new UIImage(canvas, new Texture(\"images/chessboard/black-rook.png\"))\r\n//     blackRook.visible = false\r\n//     blackRook.width = 42\r\n//     blackRook.height = 48\r\n//     blackRook.sourceLeft = 0\r\n//     blackRook.sourceTop = 0\r\n//     blackRook.sourceWidth = 70\r\n//     blackRook.sourceHeight = 77\r\n//     if (i==0){\r\n//         blackRook.positionY=squareMap['a8'].yPosition\r\n//         blackRook.positionX=squareMap['a8'].xPosition\r\n//     }\r\n//     else{\r\n//         blackRook.positionY=squareMap['h8'].yPosition\r\n//         blackRook.positionX=squareMap['h8'].xPosition\r\n//     }\r\n//     blackPieces.push(blackRook)\r\n// }\r\n// const whiteQueen:UIImage = new UIImage(canvas, new Texture(\"images/chessboard/white-queen.png\"))\r\n// whiteQueen.visible = false\r\n// whiteQueen.width = 48\r\n// whiteQueen.height = 48\r\n// whiteQueen.sourceLeft = 0\r\n// whiteQueen.sourceTop = 0\r\n// whiteQueen.sourceWidth = 95\r\n// whiteQueen.sourceHeight = 85\r\n// whiteQueen.positionY=squareMap['d1'].yPosition\r\n// whiteQueen.positionX=squareMap['d1'].xPosition\r\n// whitePieces.push(whiteQueen)\r\n// const blackQueen:UIImage = new UIImage(canvas, new Texture(\"images/chessboard/black-queen.png\"))\r\n// blackQueen.visible = false\r\n// blackQueen.width = 48\r\n// blackQueen.height = 48\r\n// blackQueen.sourceLeft = 0\r\n// blackQueen.sourceTop = 0\r\n// blackQueen.sourceWidth = 94\r\n// blackQueen.sourceHeight = 90\r\n// blackQueen.positionY=squareMap['d8'].yPosition\r\n// blackQueen.positionX=squareMap['d8'].xPosition\r\n// blackPieces.push(blackQueen)\r\n// const whiteKing:UIImage = new UIImage(canvas, new Texture(\"images/chessboard/white-king.png\"))\r\n// whiteKing.visible = false\r\n// whiteKing.width = 48\r\n// whiteKing.height = 48\r\n// whiteKing.sourceLeft = 0\r\n// whiteKing.sourceTop = 0\r\n// whiteKing.sourceWidth = 87\r\n// whiteKing.sourceHeight = 85\r\n// whiteKing.positionY=squareMap['e1'].yPosition\r\n// whiteKing.positionX=squareMap['e1'].xPosition\r\n// whitePieces.push(whiteKing)\r\n// const blackKing:UIImage = new UIImage(canvas, new Texture(\"images/chessboard/black-king.png\"))\r\n// blackKing.visible = false\r\n// blackKing.width = 48\r\n// blackKing.height = 48\r\n// blackKing.sourceLeft = 0\r\n// blackKing.sourceTop = 0\r\n// blackKing.sourceWidth = 88\r\n// blackKing.sourceHeight = 87\r\n// blackKing.positionY=squareMap['e8'].yPosition\r\n// blackKing.positionX=squareMap['e8'].xPosition\r\n// blackPieces.push(blackKing)\r\n// for(let i=0; i<whitePieces.length;i++){\r\n//     whitePieces[i].width = parseFloat(whitePieces[i].width.replace('px','')) / resizeFactor\r\n//     blackPieces[i].width = parseFloat(blackPieces[i].width.replace('px','')) / resizeFactor\r\n// }\r\n/*import {Board} from './board'\r\n\nclass chessGame {\r\n    board: Board\r\n    constructor(){\r\n        this.board = new Board()\r\n    }\r\n}*/ \r\ndefine(\"src/clock\", [\"require\", \"exports\", \"src/utils\"], function (require, exports, utils_6) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.Clock = void 0;\r\n    var Clock = /** @class */ (function () {\r\n        function Clock(color, timer, canvas) {\r\n            this.timer = timer;\r\n            this.clock = new UIText(canvas);\r\n            this.clock.value = timer.toString();\r\n            this.clock.fontSize = 25;\r\n            if (color == \"white\") {\r\n                this.clock.positionX = utils_6.squareMap['h1'].xPosition + 10;\r\n                this.clock.positionY = utils_6.squareMap['h1'].yPosition - 45;\r\n            }\r\n            else {\r\n                this.clock.positionX = utils_6.squareMap['h8'].xPosition + 10;\r\n                this.clock.positionY = utils_6.squareMap['h8'].yPosition + 62;\r\n            }\r\n            this.updateTimer();\r\n        }\r\n        Clock.prototype.updateTimer = function () {\r\n            var minutes = Math.floor(this.timer / 60).toString();\r\n            var seconds = (Math.round(this.timer % 60)).toString();\r\n            if (seconds.length == 1) {\r\n                seconds = \"0\" + seconds;\r\n            }\r\n            this.clock.value = minutes + \":\" + seconds;\r\n        };\r\n        return Clock;\r\n    }());\r\n    exports.Clock = Clock;\r\n});\r\n//\r\n// IMPORTANT :\r\n// - include `noLib: false` to your tsconfig.json file, under \"compilerOptions\"\r\n//\r\n///<reference lib=\"es2015.symbol\" />\r\n///<reference lib=\"es2015.symbol.wellknown\" />\r\n///<reference lib=\"es2015.collection\" />\r\n///<reference lib=\"es2015.iterable\" />\r\ndefine(\"src/connection\", [\"require\", \"exports\", \"colyseus.js\", \"@decentraland/EnvironmentAPI\", \"@decentraland/Identity\"], function (require, exports, colyseus_js_1, EnvironmentAPI_1, Identity_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.connect = exports.setUserData = exports.userData = void 0;\r\n    function setUserData() {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, (0, Identity_1.getUserData)()];\r\n                    case 1:\r\n                        exports.userData = _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    }\r\n    exports.setUserData = setUserData;\r\n    function connect(roomName, options) {\r\n        if (options === void 0) { options = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var isPreview, realm, ENDPOINT, client, room, e_6;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, (0, EnvironmentAPI_1.isPreviewMode)()];\r\n                    case 1:\r\n                        isPreview = _a.sent();\r\n                        return [4 /*yield*/, (0, EnvironmentAPI_1.getCurrentRealm)()\r\n                            //\r\n                            // make sure users are matched together by the same \"realm\".\r\n                            //\r\n                        ];\r\n                    case 2:\r\n                        realm = _a.sent();\r\n                        //\r\n                        // make sure users are matched together by the same \"realm\".\r\n                        //\r\n                        if (isPreview) {\r\n                            options.realm = 'test';\r\n                        }\r\n                        else {\r\n                            options.realm = realm === null || realm === void 0 ? void 0 : realm.displayName;\r\n                        }\r\n                        if (!!exports.userData) return [3 /*break*/, 4];\r\n                        return [4 /*yield*/, setUserData()];\r\n                    case 3:\r\n                        _a.sent();\r\n                        _a.label = 4;\r\n                    case 4:\r\n                        options.userData = exports.userData;\r\n                        log('data sent:', options);\r\n                        ENDPOINT = isPreview\r\n                            ? 'ws://127.0.0.1:2567' // local environment\r\n                            : 'wss://l9tio3.colyseus.dev' // production environment\r\n                        ;\r\n                        if (isPreview) {\r\n                            addConnectionDebugger(ENDPOINT);\r\n                        }\r\n                        client = new colyseus_js_1.Client(ENDPOINT);\r\n                        _a.label = 5;\r\n                    case 5:\r\n                        _a.trys.push([5, 7, , 8]);\r\n                        return [4 /*yield*/, client.joinOrCreate(roomName, options)];\r\n                    case 6:\r\n                        room = _a.sent();\r\n                        if (isPreview) {\r\n                            updateConnectionDebugger(room);\r\n                        }\r\n                        return [2 /*return*/, room];\r\n                    case 7:\r\n                        e_6 = _a.sent();\r\n                        updateConnectionMessage(\"Error: \", Color4.Red());\r\n                        throw e_6;\r\n                    case 8: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    }\r\n    exports.connect = connect;\r\n    var message;\r\n    function addConnectionDebugger(endpoint) {\r\n        var canvas = new UICanvas();\r\n        message = new UIText(canvas);\r\n        message.fontSize = 15;\r\n        message.width = 120;\r\n        message.height = 30;\r\n        message.hTextAlign = 'center';\r\n        message.vAlign = 'bottom';\r\n        message.positionX = -80;\r\n        updateConnectionMessage(\"Connecting to \".concat(endpoint), Color4.White());\r\n    }\r\n    function updateConnectionMessage(value, color) {\r\n        message.value = value;\r\n        message.color = color;\r\n    }\r\n    function updateConnectionDebugger(room) {\r\n        updateConnectionMessage('Connected.', Color4.Green());\r\n        room.onLeave(function () { return updateConnectionMessage('Connection lost', Color4.Red()); });\r\n    }\r\n});\r\ndefine(\"src/game\", [\"require\", \"exports\", \"src/board\", \"src/clock\", \"src/connection\"], function (require, exports, board_1, clock_1, connection_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    (0, connection_1.connect)('my_room').then(function (room) {\r\n        //let my_turn: boolean = false\r\n        var white_timer = 300;\r\n        var black_timer = 300;\r\n        var RotatorSystem = /** @class */ (function () {\r\n            function RotatorSystem() {\r\n                // this group will contain every entity that has a Transform component\r\n                this.group = engine.getComponentGroup(Transform);\r\n            }\r\n            RotatorSystem.prototype.update = function (dt) {\r\n                var e_7, _a;\r\n                try {\r\n                    // iterate over the entities of the group\r\n                    for (var _b = __values(this.group.entities), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                        var entity = _c.value;\r\n                        // get the Transform component of the entity\r\n                        var transform = entity.getComponent(Transform);\r\n                        // mutate the rotation\r\n                        transform.rotate(Vector3.Up(), dt * 10);\r\n                    }\r\n                }\r\n                catch (e_7_1) { e_7 = { error: e_7_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_7) throw e_7.error; }\r\n                }\r\n            };\r\n            return RotatorSystem;\r\n        }());\r\n        //updates boards timer values\r\n        var TimerSystem = /** @class */ (function () {\r\n            function TimerSystem() {\r\n                this.group = engine.getComponentGroup(Transform);\r\n            }\r\n            TimerSystem.prototype.update = function (dt) {\r\n                board.chessgame.turn() == 'w' ? white_clock.timer -= dt : black_clock.timer -= dt;\r\n                board.chessgame.turn() == 'w' ? white_clock.updateTimer() : black_clock.updateTimer();\r\n                if (white_clock.timer <= 0) {\r\n                    // board.chessgame.gameOver()\r\n                }\r\n                else if (black_clock.timer <= 0) {\r\n                    // board.chessgame.move('w', 'resign')\r\n                }\r\n            };\r\n            return TimerSystem;\r\n        }());\r\n        // Add a new instance of the system to the engine\r\n        //engine.addSystem(new RotatorSystem())\r\n        /// --- Spawner function ---\r\n        function spawnCube(x, y, z) {\r\n            // create the entity\r\n            var cube = new Entity();\r\n            // add a transform to the entity\r\n            cube.addComponent(new Transform({ position: new Vector3(x, y, z) }));\r\n            // add a shape to the entity\r\n            cube.addComponent(new BoxShape());\r\n            // add the entity to the engine\r\n            engine.addEntity(cube);\r\n            return cube;\r\n        }\r\n        var cube = spawnCube(8, 1, 8);\r\n        var board;\r\n        var white_clock;\r\n        var black_clock;\r\n        cube.addComponent(new OnPointerDown(function () {\r\n            cube.getComponent(Transform).scale.z *= 1.1;\r\n            cube.getComponent(Transform).scale.x *= 0.9;\r\n            board = new board_1.Board(room);\r\n            white_clock = new clock_1.Clock('white', white_timer, board.canvas);\r\n            black_clock = new clock_1.Clock('black', white_timer, board.canvas);\r\n            engine.addSystem(new TimerSystem());\r\n        }));\r\n        room.onMessage(\"flashMovement\", function (data) {\r\n            log(\"he recbido el mov\");\r\n            //let p: Piece = data.piece\r\n            //let m: string = data.piece\r\n            board.getPiece(data.original_position);\r\n            var piece = board.getPiece(data.original_position);\r\n            board.movePiece(piece, data.movement);\r\n            log(data.original_position);\r\n            log(data.movement);\r\n            //board.movePiece(data.movement)\r\n        });\r\n        room.onMessage(\"YourTurn\", function (data) {\r\n            board.turn = true;\r\n        });\r\n        var cp = new Entity();\r\n        cp.addComponent(new GLTFShape('models/CP_MDL.glb'));\r\n        cp.addComponent(new Transform({\r\n            position: new Vector3(8, 0, 8),\r\n            scale: new Vector3(100, 100, 100)\r\n        }));\r\n        engine.addEntity(cp);\r\n    });\r\n});\r\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2FtZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9ib2FyZF9vbGQudHMiLCIuLi9zcmMvdXRpbHMudHMiLCIuLi9zcmMvYW5ub3RhdGlvbi50cyIsIi4uL3NyYy9hbm5vdGF0aW9ucy50cyIsIi4uL3NyYy9waWVjZS50cyIsIi4uL3NyYy9zcXVhcmUudHMiLCIuLi9ub2RlX21vZHVsZXMvY2hlc3MudHMvc3JjL3R5cGVzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2NoZXNzLnRzL3NyYy9jb25zdGFudHMudHMiLCIuLi9ub2RlX21vZHVsZXMvY2hlc3MudHMvc3JjL3V0aWxzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL2NoZXNzLnRzL3NyYy9zdGF0ZS50cyIsIi4uL25vZGVfbW9kdWxlcy9jaGVzcy50cy9zcmMvY2hlc3MudHMiLCIuLi9zcmMvYm9hcmQudHMiLCIuLi9zcmMvY2hlc3NnYW1lLnRzIiwiLi4vc3JjL2Nsb2NrLnRzIiwiLi4vc3JjL2Nvbm5lY3Rpb24udHMiLCIuLi9zcmMvZ2FtZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDQWEsUUFBQSxZQUFZLEdBQVUsQ0FBQyxDQUFBO0lBQ3BDLElBQU0sWUFBWSxHQUFVLENBQUMsS0FBSyxDQUFBO0lBQ2xDLElBQU0sWUFBWSxHQUFVLEdBQUcsQ0FBQTtJQUVsQixRQUFBLFNBQVMsR0FBbUM7UUFDckQsSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUUsSUFBSSxFQUFDLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRSxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRSxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUUsSUFBSSxFQUFDLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRSxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBQyxFQUFFLElBQUksRUFBQyxFQUFHLFNBQVMsRUFBQyxDQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUUsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUMsRUFBRSxJQUFJLEVBQUMsRUFBRyxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFHLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUUsSUFBSSxFQUFDLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRSxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBQztRQUNqakIsSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUUsSUFBSSxFQUFDLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRSxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRSxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUUsSUFBSSxFQUFDLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRSxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBQyxFQUFFLElBQUksRUFBQyxFQUFHLFNBQVMsRUFBQyxDQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUUsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUMsRUFBRSxJQUFJLEVBQUMsRUFBRyxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFHLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUUsSUFBSSxFQUFDLEVBQUcsU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBRSxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBQztRQUNqakIsSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBSSxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFFLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBSSxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUksSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBQyxFQUFHLElBQUksRUFBQyxFQUFFLFNBQVMsRUFBQyxDQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUcsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUMsRUFBRyxJQUFJLEVBQUMsRUFBRSxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFJLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBQztRQUNqakIsSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBSSxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFFLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBSSxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUksSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBQyxFQUFHLElBQUksRUFBQyxFQUFFLFNBQVMsRUFBQyxDQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUcsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUMsRUFBRyxJQUFJLEVBQUMsRUFBRSxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFJLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBQztRQUNqakIsSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUssU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBQyxFQUFJLElBQUksRUFBRSxFQUFDLFNBQVMsRUFBQyxFQUFFLEdBQUcsWUFBWSxFQUFLLFNBQVMsRUFBQyxDQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUMsRUFBSSxJQUFJLEVBQUMsRUFBQyxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBSSxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUssSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUksU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBQyxFQUFJLElBQUksRUFBQyxFQUFDLFNBQVMsRUFBQyxFQUFFLEdBQUcsWUFBWSxFQUFJLFNBQVMsRUFBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUksSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUksU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUMsRUFBSSxJQUFJLEVBQUMsRUFBQyxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBSyxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBQyxFQUFJLElBQUksRUFBQyxFQUFDLFNBQVMsRUFBQyxFQUFFLEdBQUcsWUFBWSxFQUFJLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFDO1FBQ2pqQixJQUFJLEVBQUMsRUFBQyxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBSyxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUksSUFBSSxFQUFFLEVBQUMsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUssU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBQyxFQUFJLElBQUksRUFBQyxFQUFDLFNBQVMsRUFBQyxFQUFFLEdBQUcsWUFBWSxFQUFJLFNBQVMsRUFBQyxDQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUMsRUFBSyxJQUFJLEVBQUMsRUFBQyxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBSSxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUksSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUksU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUMsRUFBSSxJQUFJLEVBQUMsRUFBQyxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBSSxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBQyxFQUFJLElBQUksRUFBQyxFQUFDLFNBQVMsRUFBQyxFQUFFLEdBQUcsWUFBWSxFQUFLLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUksSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUksU0FBUyxFQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUM7UUFDampCLElBQUksRUFBQyxFQUFDLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFJLFNBQVMsRUFBQyxDQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUMsRUFBRyxJQUFJLEVBQUUsRUFBRSxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBSSxTQUFTLEVBQUMsQ0FBQyxHQUFHLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUcsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBQyxFQUFJLElBQUksRUFBQyxFQUFFLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFHLFNBQVMsRUFBQyxDQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUMsRUFBRyxJQUFJLEVBQUMsRUFBRSxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsRUFBRSxHQUFHLFlBQVksRUFBQyxFQUFHLElBQUksRUFBQyxFQUFFLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFHLFNBQVMsRUFBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUksU0FBUyxFQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUMsRUFBRyxJQUFJLEVBQUMsRUFBRSxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBQztRQUNqakIsSUFBSSxFQUFDLEVBQUMsU0FBUyxFQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUksU0FBUyxFQUFDLENBQUMsR0FBRyxHQUFHLFlBQVksRUFBQyxFQUFHLElBQUksRUFBRSxFQUFFLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFJLFNBQVMsRUFBQyxDQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUMsRUFBRyxJQUFJLEVBQUMsRUFBRSxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBRyxTQUFTLEVBQUMsQ0FBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUksSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUcsU0FBUyxFQUFDLENBQUMsRUFBRSxHQUFHLFlBQVksRUFBQyxFQUFHLElBQUksRUFBQyxFQUFFLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFHLFNBQVMsRUFBQyxFQUFFLEdBQUcsWUFBWSxFQUFDLEVBQUcsSUFBSSxFQUFDLEVBQUUsU0FBUyxFQUFDLEdBQUcsR0FBRyxZQUFZLEVBQUcsU0FBUyxFQUFDLEVBQUUsR0FBRyxZQUFZLEVBQUMsRUFBRyxJQUFJLEVBQUMsRUFBRSxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBSSxTQUFTLEVBQUMsR0FBRyxHQUFHLFlBQVksRUFBQyxFQUFHLElBQUksRUFBQyxFQUFFLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFHLFNBQVMsRUFBQyxHQUFHLEdBQUcsWUFBWSxFQUFDO0tBQ3BqQixDQUFBO0lBR0QsU0FBZ0IsUUFBUSxDQUFDLENBQVE7UUFDN0IsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJ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RSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUN0QyxDQUFBO0lBRUQsa0JBQWtCO0lBQ0wsUUFBQSxPQUFPLEdBQWE7UUFDL0IsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUUsQ0FBQztRQUNoRCxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUcsQ0FBQyxFQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNqRCxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRyxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNoRCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ2hELENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDaEQsQ0FBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUNoRCxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ2pELEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRTtLQUMvQyxDQUFBO0lBRUQsa0JBQWtCO0lBQ0wsUUFBQSxJQUFJLEdBQWE7UUFDM0IsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUM1RCxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRSxDQUFDO1FBQzVELENBQUMsRUFBRyxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRSxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUM7UUFDNUQsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRSxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztRQUM1RCxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO1FBQzVELENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsRUFBRSxFQUFHLENBQUMsRUFBRSxFQUFFLEVBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUM7UUFDNUQsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztRQUM1RCxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFHLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDNUQsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztRQUM1RCxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFDLENBQUMsRUFBRSxFQUFHLENBQUMsRUFBQyxDQUFDLEVBQUUsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO1FBQzVELENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBQyxDQUFDLEVBQUUsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFDLENBQUMsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUM7UUFDNUQsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQztRQUM1RCxDQUFDLEVBQUcsQ0FBQyxFQUFDLENBQUMsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBQyxDQUFDLEVBQUUsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRSxDQUFDO1FBQzVELENBQUMsRUFBQyxDQUFDLEVBQUUsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFDLENBQUMsRUFBRSxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFFLENBQUM7UUFDOUQsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUcsQ0FBQyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUMsQ0FBQyxFQUFFO0tBQzVELENBQUE7SUFFWSxRQUFBLE1BQU0sR0FBZ0MsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFBO0lBRXpGLGNBQWM7SUFDRCxRQUFBLEtBQUssR0FBNEI7UUFDNUMsTUFBTSxFQUFFLEdBQUc7UUFDWCxPQUFPLEVBQUUsR0FBRztRQUNaLFFBQVEsRUFBRSxHQUFHO1FBQ2IsVUFBVSxFQUFFLEdBQUc7UUFDZixTQUFTLEVBQUUsR0FBRztRQUNkLFlBQVksRUFBRSxHQUFHO1FBQ2pCLFlBQVksRUFBRSxHQUFHO0tBQ2xCLENBQUE7SUFFRCxjQUFjO0lBQ0QsUUFBQSxJQUFJLEdBQTRCO1FBQzNDLE1BQU0sRUFBRSxDQUFDO1FBQ1QsT0FBTyxFQUFFLENBQUM7UUFDVixRQUFRLEVBQUUsQ0FBQztRQUNYLFVBQVUsRUFBRSxDQUFDO1FBQ2IsU0FBUyxFQUFFLEVBQUU7UUFDYixZQUFZLEVBQUUsRUFBRTtRQUNoQixZQUFZLEVBQUUsRUFBRTtLQUNqQixDQUFBO0lBRVksUUFBQSxNQUFNLEdBQUcsQ0FBQyxDQUFBO0lBQ1YsUUFBQSxNQUFNLEdBQUcsQ0FBQyxDQUFBO0lBQ1YsUUFBQSxNQUFNLEdBQUcsQ0FBQyxDQUFBO0lBQ1YsUUFBQSxNQUFNLEdBQUcsQ0FBQyxDQUFBO0lBQ1YsUUFBQSxNQUFNLEdBQUcsQ0FBQyxDQUFBO0lBQ1YsUUFBQSxNQUFNLEdBQUcsQ0FBQyxDQUFBO0lBQ1YsUUFBQSxNQUFNLEdBQUcsQ0FBQyxDQUFBO0lBQ1YsUUFBQSxNQUFNLEdBQUcsQ0FBQyxDQUFBO0lBRVYsUUFBQSxLQUFLLEdBQUcsQ0FBQyxjQUFNLEVBQUUsY0FBTSxFQUFFLGNBQU0sRUFBRSxjQUFNLEVBQUUsY0FBTSxFQUFFLGNBQU0sRUFBRSxjQUFNLEVBQUUsY0FBTSxDQUFDLENBQUE7SUFFckYsa0JBQWtCO0lBQ2xCLGNBQWM7SUFDRCxRQUFBLE9BQU8sR0FBMkI7UUFDN0MsRUFBRSxFQUFJLENBQUMsRUFBRSxFQUFFLEVBQUksQ0FBQyxFQUFFLEVBQUUsRUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFJLENBQUMsRUFBRSxFQUFFLEVBQUksQ0FBQyxFQUFFLEVBQUUsRUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFJLENBQUMsRUFBRSxFQUFFLEVBQUksQ0FBQztRQUN0RSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFO1FBQ3RFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUU7UUFDdEUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRTtRQUN0RSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFO1FBQ3RFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUU7UUFDdEUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRyxFQUFFLEVBQUUsRUFBRSxFQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRztRQUN0RSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHO0tBQ3ZFLENBQUE7SUFFWSxRQUFBLEtBQUssR0FBc0Q7UUFDdEUsQ0FBQyxFQUFFO1lBQ0QsRUFBRSxNQUFNLEVBQUUsZUFBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsWUFBSSxDQUFDLFlBQVksRUFBRTtZQUMvQyxFQUFFLE1BQU0sRUFBRSxlQUFPLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxZQUFJLENBQUMsWUFBWSxFQUFFO1NBQ2hEO1FBQ0QsQ0FBQyxFQUFFO1lBQ0QsRUFBRSxNQUFNLEVBQUUsZUFBTyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsWUFBSSxDQUFDLFlBQVksRUFBRTtZQUMvQyxFQUFFLE1BQU0sRUFBRSxlQUFPLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxZQUFJLENBQUMsWUFBWSxFQUFFO1NBQ2hEO0tBQ0YsQ0FBQTs7Ozs7O0lDaklEOzs7T0FHRztJQUNILFNBQWdCLElBQUksQ0FBQyxDQUFTO1FBQzVCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUNmLENBQUM7SUFGRCxvQkFFQztJQUVEOzs7T0FHRztJQUNILFNBQWdCLElBQUksQ0FBQyxDQUFTO1FBQzVCLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQTtJQUNmLENBQUM7SUFGRCxvQkFFQztJQUVEOzs7T0FHRztJQUNILFNBQWdCLFNBQVMsQ0FBQyxDQUFTO1FBQ2pDLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUNqQixJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDakIsT0FBTyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO0lBQ3hFLENBQUM7SUFKRCw4QkFJQztJQUVEOztPQUVHO0lBQ0gsU0FBZ0IsU0FBUyxDQUFDLENBQVE7UUFDaEMsT0FBTyxDQUFDLEtBQUssaUJBQUssQ0FBQyxDQUFDLENBQUMsaUJBQUssQ0FBQyxDQUFDLENBQUMsaUJBQUssQ0FBQTtJQUNwQyxDQUFDO0lBRkQsOEJBRUM7SUFFRDs7T0FFRztJQUNILFNBQWdCLE9BQU8sQ0FBQyxDQUFTO1FBQy9CLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUMxQixDQUFDO0lBRkQsMEJBRUM7SUFFRDs7O09BR0c7SUFDSCxTQUFnQixNQUFNLENBQUMsRUFBc0I7WUFBcEIsSUFBSSxVQUFBLEVBQUUsS0FBSyxXQUFBO1FBQ2xDLE9BQU8sS0FBSyxLQUFLLGlCQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFBO0lBQ2xFLENBQUM7SUFGRCx3QkFFQztJQUVELFNBQWdCLE9BQU8sQ0FBQyxLQUFhO1FBQ25DLE9BQU8sS0FBSyxLQUFLLEdBQUcsSUFBSSxLQUFLLEtBQUssR0FBRyxDQUFBO0lBQ3ZDLENBQUM7SUFGRCwwQkFFQztJQUVELFNBQWdCLGFBQWEsQ0FBQyxNQUFjO1FBQzFDLE9BQU8sWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUNsQyxDQUFDO0lBRkQsc0NBRUM7SUFFRCxTQUFnQixRQUFRLENBQUMsRUFBVTtRQUNqQyxPQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUE7SUFDaEMsQ0FBQztJQUZELDRCQUVDO0lBRUQsU0FBZ0IsU0FBUyxDQUFDLEdBQVc7UUFDbkMsSUFBTSxJQUFJLEdBQUcsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUMsQ0FBQTtRQUN6RyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUE7SUFDakMsQ0FBQztJQUhELDhCQUdDO0lBRUQ7Ozs7T0FJRztJQUNILFNBQWdCLFdBQVcsQ0FBQyxHQUFXO1FBQ3JDLElBQU0sTUFBTSxHQUEyQjtZQUNyQyxDQUFDLEVBQUUsWUFBWTtZQUNmLENBQUMsRUFBRSxxREFBcUQ7WUFDeEQsQ0FBQyxFQUFFLHFEQUFxRDtZQUN4RCxDQUFDLEVBQUUsK0RBQStEO1lBQ2xFLENBQUMsRUFBRSwyQ0FBMkM7WUFDOUMsQ0FBQyxFQUFFLCtDQUErQztZQUNsRCxDQUFDLEVBQUUsc0NBQXNDO1lBQ3pDLENBQUMsRUFBRSxvRUFBb0U7WUFDdkUsQ0FBQyxFQUFFLCtEQUErRDtZQUNsRSxDQUFDLEVBQUUseURBQXlEO1lBQzVELEVBQUUsRUFBRSx5REFBeUQ7WUFDN0QsRUFBRSxFQUFFLDJCQUEyQjtTQUNoQyxDQUFBO1FBRUQsOENBQThDO1FBQzlDLElBQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDL0IsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtTQUMzRDtRQUVELDhEQUE4RDtRQUM5RCw4REFBOEQ7UUFDOUQsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBUSxDQUFDLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDM0QsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7U0FDM0Q7UUFFRCwwREFBMEQ7UUFDMUQsOERBQThEO1FBQzlELElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzFELE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFBO1NBQzNEO1FBRUQsc0RBQXNEO1FBQ3RELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDM0MsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7U0FDM0Q7UUFFRCx3REFBd0Q7UUFDeEQsSUFBSSxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNoRCxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtTQUMzRDtRQUVELDZEQUE2RDtRQUM3RCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUM5QixPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtTQUMzRDtRQUVELCtDQUErQztRQUMvQyxJQUFNLElBQUksR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1FBQ2pDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDckIsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7U0FDM0Q7UUFFRCx3Q0FBd0M7UUFDeEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDcEMscUVBQXFFO1lBQ3JFLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQTtZQUNsQixJQUFJLG1CQUFtQixHQUFHLEtBQUssQ0FBQTtZQUUvQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdkMsOERBQThEO2dCQUM5RCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQVEsQ0FBQyxFQUFFO29CQUM3QixJQUFJLG1CQUFtQixFQUFFO3dCQUN2QixPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtxQkFDM0Q7b0JBQ0QsVUFBVSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUE7b0JBQ3RDLG1CQUFtQixHQUFHLElBQUksQ0FBQTtpQkFDM0I7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTt3QkFDeEMsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7cUJBQzNEO29CQUNELFVBQVUsSUFBSSxDQUFDLENBQUE7b0JBQ2YsbUJBQW1CLEdBQUcsS0FBSyxDQUFBO2lCQUM1QjthQUNGO1lBQ0QsSUFBSSxVQUFVLEtBQUssQ0FBQyxFQUFFO2dCQUNwQixPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQTthQUM3RDtTQUNGO1FBRUQsSUFDRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQztZQUN2QyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUMzQztZQUNBLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFBO1NBQzdEO1FBRUQsd0JBQXdCO1FBQ3hCLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFBO0lBQzNELENBQUM7SUEzRkQsa0NBMkZDO0lBRUQsbURBQW1EO0lBQ25ELFNBQWdCLFdBQVcsQ0FBQyxJQUFZO1FBQ3RDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUMsQ0FBQTtJQUN6RCxDQUFDO0lBRkQsa0NBRUM7Ozs7OztJQzdIRCxnRUFBZ0U7SUFDaEUsU0FBZ0IsZ0JBQWdCLENBQUMsS0FBWSxFQUFFLElBQWEsRUFBRSxNQUFlO1FBQzNFLElBQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFBO1FBRXRELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUE7UUFDdEIsSUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQTtRQUNsQixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFBO1FBRXhCLElBQUksV0FBVyxHQUFHLENBQUMsQ0FBQTtRQUNuQixJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUE7UUFDakIsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFBO1FBRWpCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDaEQsSUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQTtZQUNoQyxJQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFBO1lBQzVCLElBQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUE7WUFFbEM7O2VBRUc7WUFDSCxJQUFJLEtBQUssS0FBSyxXQUFXLElBQUksSUFBSSxLQUFLLFVBQVUsSUFBSSxFQUFFLEtBQUssUUFBUSxFQUFFO2dCQUNuRSxXQUFXLEVBQUUsQ0FBQTtnQkFFYixJQUFJLElBQUEsWUFBSSxFQUFDLElBQUksQ0FBQyxLQUFLLElBQUEsWUFBSSxFQUFDLFVBQVUsQ0FBQyxFQUFFO29CQUNuQyxTQUFTLEVBQUUsQ0FBQTtpQkFDWjtnQkFFRCxJQUFJLElBQUEsWUFBSSxFQUFDLElBQUksQ0FBQyxLQUFLLElBQUEsWUFBSSxFQUFDLFVBQVUsQ0FBQyxFQUFFO29CQUNuQyxTQUFTLEVBQUUsQ0FBQTtpQkFDWjthQUNGO1NBQ0Y7UUFFRCxJQUFJLFdBQVcsR0FBRyxDQUFDLEVBQUU7WUFDbkI7O2VBRUc7WUFDSCxJQUFJLFNBQVMsR0FBRyxDQUFDLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRTtnQkFDbEMsT0FBTyxJQUFBLGlCQUFTLEVBQUMsSUFBSSxDQUFDLENBQUE7YUFDdkI7aUJBQU0sSUFBSSxTQUFTLEdBQUcsQ0FBQyxFQUFFO2dCQUN4Qjs7bUJBRUc7Z0JBQ0gsT0FBTyxJQUFBLGlCQUFTLEVBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO2FBQ2pDO2lCQUFNO2dCQUNMLDhCQUE4QjtnQkFDOUIsT0FBTyxJQUFBLGlCQUFTLEVBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO2FBQ2pDO1NBQ0Y7UUFFRCxPQUFPLEVBQUUsQ0FBQTtJQUNYLENBQUM7SUFsREQsNENBa0RDO0lBRUQsU0FBZ0IsTUFBTSxDQUFDLEtBQVk7UUFDakMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFBO1FBQ2IsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFBO1FBRVosS0FBSyxJQUFJLENBQUMsR0FBRyxtQkFBTyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksbUJBQU8sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDN0MsSUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUM1QixJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNWLEtBQUssRUFBRSxDQUFBO2FBQ1I7aUJBQU07Z0JBQ0wsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO29CQUNiLEdBQUcsSUFBSSxLQUFLLENBQUE7b0JBQ1osS0FBSyxHQUFHLENBQUMsQ0FBQTtpQkFDVjtnQkFDRCxJQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFBO2dCQUN6QixJQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFBO2dCQUU3QixHQUFHLElBQUksS0FBSyxLQUFLLGlCQUFLLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFBO2FBQzdFO1lBRUQsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUU7Z0JBQ2xCLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtvQkFDYixHQUFHLElBQUksS0FBSyxDQUFBO2lCQUNiO2dCQUVELElBQUksQ0FBQyxLQUFLLG1CQUFPLENBQUMsRUFBRSxFQUFFO29CQUNwQixHQUFHLElBQUksR0FBRyxDQUFBO2lCQUNYO2dCQUVELEtBQUssR0FBRyxDQUFDLENBQUE7Z0JBQ1QsQ0FBQyxJQUFJLENBQUMsQ0FBQTthQUNQO1NBQ0Y7UUFFRCxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUE7UUFDZixJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsaUJBQUssQ0FBQyxHQUFHLGdCQUFJLENBQUMsWUFBWSxFQUFFO1lBQzdDLE1BQU0sSUFBSSxHQUFHLENBQUE7U0FDZDtRQUNELElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxpQkFBSyxDQUFDLEdBQUcsZ0JBQUksQ0FBQyxZQUFZLEVBQUU7WUFDN0MsTUFBTSxJQUFJLEdBQUcsQ0FBQTtTQUNkO1FBQ0QsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLGlCQUFLLENBQUMsR0FBRyxnQkFBSSxDQUFDLFlBQVksRUFBRTtZQUM3QyxNQUFNLElBQUksR0FBRyxDQUFBO1NBQ2Q7UUFDRCxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsaUJBQUssQ0FBQyxHQUFHLGdCQUFJLENBQUMsWUFBWSxFQUFFO1lBQzdDLE1BQU0sSUFBSSxHQUFHLENBQUE7U0FDZDtRQUVELHdDQUF3QztRQUN4QyxNQUFNLEdBQUcsTUFBTSxJQUFJLEdBQUcsQ0FBQTtRQUN0QixJQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxLQUFLLGlCQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBQSxpQkFBUyxFQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQTtRQUU1RSxPQUFPLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDMUYsQ0FBQztJQXBERCx3QkFvREM7SUFFRCxTQUFnQixPQUFPLENBQUMsR0FBVztRQUNqQyxJQUFNLE1BQU0sR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFBO1FBQy9CLElBQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUMxQixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUE7UUFFZCxJQUFJLENBQUMsSUFBQSxtQkFBVyxFQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRTtZQUMzQixPQUFPLElBQUksQ0FBQTtTQUNaO1FBRUQsSUFBSSxLQUFLLEdBQUcsSUFBSSxhQUFLLEVBQUUsQ0FBQTtRQUV2QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QyxJQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBRWhDLElBQUksS0FBSyxLQUFLLEdBQUcsRUFBRTtnQkFDakIsTUFBTSxJQUFJLENBQUMsQ0FBQTthQUNaO2lCQUFNLElBQUksSUFBQSxlQUFPLEVBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3pCLE1BQU0sSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFBO2FBQzlCO2lCQUFNO2dCQUNMLElBQU0sS0FBSyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLGlCQUFLLENBQUMsQ0FBQyxDQUFDLGlCQUFLLENBQUE7Z0JBQ3pDLElBQU0sUUFBUSxHQUFHLFFBQVEsQ0FDdkIsS0FBSyxFQUNMLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxXQUFXLEVBQUUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQzNDLElBQUEsaUJBQVMsRUFBQyxNQUFNLENBQUMsQ0FDbEIsQ0FBQTtnQkFDRCxJQUFJLENBQUMsUUFBUSxFQUFFO29CQUNiLE9BQU8sSUFBSSxDQUFBO2lCQUNaO2dCQUNELEtBQUssR0FBRyxRQUFRLENBQUE7Z0JBQ2hCLE1BQU0sRUFBRSxDQUFBO2FBQ1Q7U0FDRjtRQUVELEtBQUssQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLGlCQUFLLENBQUMsQ0FBQyxDQUFDLGlCQUFLLENBQUMsQ0FBQyxDQUFDLGlCQUFLLENBQUE7UUFFaEQsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQy9CLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLGdCQUFJLENBQUMsWUFBWSxDQUFBO1NBQ3RDO1FBQ0QsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQy9CLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLGdCQUFJLENBQUMsWUFBWSxDQUFBO1NBQ3RDO1FBQ0QsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQy9CLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLGdCQUFJLENBQUMsWUFBWSxDQUFBO1NBQ3RDO1FBQ0QsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQy9CLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLGdCQUFJLENBQUMsWUFBWSxDQUFBO1NBQ3RDO1FBRUQsS0FBSyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxpQkFBSyxDQUFDLENBQUMsQ0FBQyxtQkFBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQVcsQ0FBQyxDQUFBO1FBQzFFLEtBQUssQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQTtRQUMxQyxLQUFLLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUE7UUFFM0MsT0FBTyxLQUFLLENBQUE7SUFDZCxDQUFDO0lBckRELDBCQXFEQztJQUVELFNBQWdCLE1BQU0sQ0FDcEIsS0FBWSxFQUNaLE1BQThCLEVBQzlCLFFBQWtCLEVBQ2xCLE9BQXNCLEVBQ3RCLE9BQTJEO1FBQTNELHdCQUFBLEVBQUEsWUFBMkQ7UUFFM0Q7O1dBRUc7UUFFRCxJQUFBLEtBRUUsT0FBTyxhQUZtQixFQUFkLE9BQU8sbUJBQUcsSUFBSSxLQUFBLEVBQzVCLEtBQ0UsT0FBTyxVQURJLEVBQWIsU0FBUyxtQkFBRyxDQUFDLEtBQUEsQ0FDSjtRQUVYLElBQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQTtRQUMzQixJQUFJLGFBQWEsR0FBRyxLQUFLLENBQUE7UUFFekIsc0NBQXNDO1FBQ3RDLEtBQUssSUFBTSxDQUFDLElBQUksTUFBTSxFQUFFO1lBQ3RCOztlQUVHO1lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLE9BQU8sQ0FBQyxDQUFBO1lBQ3hELGFBQWEsR0FBRyxJQUFJLENBQUE7U0FDckI7UUFFRCxJQUFJLGFBQWEsSUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO1lBQ25DLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUE7U0FDckI7UUFFRCxJQUFNLGFBQWEsR0FBRyxVQUFDLE9BQWU7WUFDcEMsSUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQTtZQUNuQyxJQUFJLE9BQU8sT0FBTyxLQUFLLFdBQVcsRUFBRTtnQkFDbEMsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFBO2dCQUMvQyxPQUFPLEdBQUcsVUFBRyxPQUFPLFNBQUcsU0FBUyxjQUFJLE9BQU8sTUFBRyxDQUFBO2FBQy9DO1lBQ0QsT0FBTyxPQUFPLENBQUE7UUFDaEIsQ0FBQyxDQUFBO1FBRUQsb0JBQW9CO1FBQ3BCLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2QsS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUE7U0FDekI7UUFFRCxJQUFNLEtBQUssR0FBRyxFQUFFLENBQUE7UUFDaEIsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFBO1FBRWhCLGlFQUFpRTtRQUNqRSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3hCLEtBQUssQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7U0FDOUI7UUFFRCxvRUFBb0U7UUFDcEUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFDLFlBQVksRUFBRSxDQUFDO1lBQzlCLElBQU0sSUFBSSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUE7WUFFOUIsT0FBTyxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQTtZQUVoQyx1RUFBdUU7WUFDdkUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssaUJBQUssRUFBRTtnQkFDbkMsT0FBTyxHQUFHLEtBQUssQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFBO2FBQ3RDO2lCQUFNLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxpQkFBSyxFQUFFO2dCQUMvQiw2REFBNkQ7Z0JBQzdELElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtvQkFDbEIsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQTtpQkFDcEI7Z0JBQ0QsT0FBTyxHQUFHLEtBQUssQ0FBQyxXQUFXLEdBQUcsR0FBRyxDQUFBO2FBQ2xDO1lBRUQsT0FBTyxHQUFHLE9BQU8sR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQTtZQUNoRCxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQTtRQUMvQixDQUFDLENBQUMsQ0FBQTtRQUVGLHdCQUF3QjtRQUN4QixJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7WUFDbEIsS0FBSyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQTtTQUNuQztRQUVELHdCQUF3QjtRQUN4QixJQUFJLE9BQU8sTUFBTSxDQUFDLE1BQU0sS0FBSyxXQUFXLEVBQUU7WUFDeEMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUE7U0FDMUI7UUFFRDs7V0FFRztRQUNILElBQUksU0FBUyxLQUFLLENBQUMsRUFBRTtZQUNuQixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtTQUN6QztRQUVELElBQU0sS0FBSyxHQUFHO1lBQ1osSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7Z0JBQzFELE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQTtnQkFDWixPQUFPLElBQUksQ0FBQTthQUNaO1lBQ0QsT0FBTyxLQUFLLENBQUE7UUFDZCxDQUFDLENBQUE7UUFFRCxvREFBb0Q7UUFDcEQsSUFBTSxXQUFXLEdBQUcsVUFBQyxLQUFhLEVBQUUsSUFBWTs7O2dCQUM5QyxLQUFvQixJQUFBLEtBQUEsU0FBQSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBLGdCQUFBLDRCQUFFO29CQUFoQyxJQUFNLEtBQUssV0FBQTtvQkFDZCxJQUFJLENBQUMsS0FBSyxFQUFFO3dCQUNWLFNBQVE7cUJBQ1Q7b0JBQ0QsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU0sR0FBRyxTQUFTLEVBQUU7d0JBQ3BDLE9BQU8sS0FBSyxFQUFFLEVBQUU7NEJBQ2QsS0FBSyxFQUFFLENBQUE7eUJBQ1I7d0JBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQTt3QkFDcEIsS0FBSyxHQUFHLENBQUMsQ0FBQTtxQkFDVjtvQkFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO29CQUNsQixLQUFLLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQTtvQkFDckIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtvQkFDaEIsS0FBSyxFQUFFLENBQUE7aUJBQ1I7Ozs7Ozs7OztZQUNELElBQUksS0FBSyxFQUFFLEVBQUU7Z0JBQ1gsS0FBSyxFQUFFLENBQUE7YUFDUjtZQUNELE9BQU8sS0FBSyxDQUFBO1FBQ2QsQ0FBQyxDQUFBO1FBRUQsc0NBQXNDO1FBQ3RDLElBQUksWUFBWSxHQUFHLENBQUMsQ0FBQTtRQUNwQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNyQyxJQUFJLFlBQVksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLFNBQVMsRUFBRTtnQkFDOUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUMxQixZQUFZLEdBQUcsV0FBVyxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtvQkFDbEQsU0FBUTtpQkFDVDthQUNGO1lBQ0Qsa0RBQWtEO1lBQ2xELElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsU0FBUyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3pELHdDQUF3QztnQkFDeEMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7b0JBQ3JDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQTtpQkFDYjtnQkFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFBO2dCQUNwQixZQUFZLEdBQUcsQ0FBQyxDQUFBO2FBQ2pCO2lCQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDbEIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtnQkFDaEIsWUFBWSxFQUFFLENBQUE7YUFDZjtZQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDckIsWUFBWSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUE7U0FDaEM7UUFFRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUE7SUFDeEIsQ0FBQztJQXRKRCx3QkFzSkM7SUFFRCxTQUFnQixPQUFPLENBQ3JCLEdBQVcsRUFDWCxPQUF5RDtRQUF6RCx3QkFBQSxFQUFBLFlBQXlEO1FBR3ZELElBQUEsS0FJRSxPQUFPLGFBSmEsRUFBdEIsWUFBWSxtQkFBRyxPQUFPLEtBQUE7UUFDdEIsdUVBQXVFO1FBQ3ZFLDZDQUE2QztRQUM3QyxLQUNFLE9BQU8sT0FESztRQUZkLHVFQUF1RTtRQUN2RSw2Q0FBNkM7UUFDN0MsTUFBTSxtQkFBRyxLQUFLLEtBQUEsQ0FDTDtRQUVYLElBQU0sSUFBSSxHQUFHLFVBQUMsR0FBVztZQUN2QixPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFBO1FBQ2pDLENBQUMsQ0FBQTtRQUVELElBQU0sZ0JBQWdCLEdBQUcsVUFDdkIsTUFBYyxFQUNkLE9BQWtEO1lBRWxELElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUE7WUFDekMsSUFBTSxVQUFVLEdBQThCLEVBQUUsQ0FBQTtZQUNoRCxJQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDNUQsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFBO1lBQ1osSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFBO1lBRWQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3ZDLEdBQUcsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFLElBQUksQ0FBQyxDQUFBO2dCQUM1RCxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQywyQkFBMkIsRUFBRSxJQUFJLENBQUMsQ0FBQTtnQkFDN0QsSUFBSSxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDekIsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQTtpQkFDL0I7YUFDRjtZQUVELE9BQU8sVUFBVSxDQUFBO1FBQ25CLENBQUMsQ0FBQTtRQUVELCtFQUErRTtRQUMvRSx1RUFBdUU7UUFDdkUsNkVBQTZFO1FBQzdFLElBQU0sWUFBWSxHQUFHLElBQUksTUFBTSxDQUM3QixXQUFXO1lBQ1QsSUFBSSxDQUFDLFlBQVksQ0FBQztZQUNsQixXQUFXO1lBQ1gsS0FBSztZQUNMLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDbEIsTUFBTSxDQUNULENBQUE7UUFFRCx3Q0FBd0M7UUFDeEMsSUFBTSxhQUFhLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUUsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFBO1FBRTNGLHlDQUF5QztRQUN6QyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsNEJBQWdCLENBQVUsQ0FBQTtRQUU5QyxzQkFBc0I7UUFDdEIsSUFBTSxNQUFNLEdBQUcsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLEVBQUUsWUFBWSxjQUFBLEVBQUUsTUFBTSxRQUFBLEVBQUUsQ0FBQyxDQUFBO1FBRXhFOzRCQUNvQjtRQUNwQixJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLEVBQUU7WUFDM0IsSUFBSSxLQUFLLElBQUksTUFBTSxFQUFFO2dCQUNuQixJQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBVyxDQUFDLENBQUE7Z0JBQ2pELElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2IsT0FBTyxJQUFJLENBQUE7aUJBQ1o7Z0JBQ0QsS0FBSyxHQUFHLFFBQVEsQ0FBQTthQUNqQjtTQUNGO1FBRUQ7Ozs7Ozs7OytDQVF1QztRQUV2QyxJQUFNLEtBQUssR0FBRyxVQUFDLEdBQVc7WUFDeEIsT0FBTyxLQUFLO2lCQUNULElBQUksQ0FBQyxHQUFHLENBQUM7aUJBQ1QsR0FBRyxDQUFDLFVBQVMsQ0FBQztnQkFDYjtrREFDa0M7Z0JBQ2xDLE9BQU8sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHO29CQUMxQixDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO29CQUM5QixDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQTtZQUMzRCxDQUFDLENBQUM7aUJBQ0QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFBO1FBQ2IsQ0FBQyxDQUFBO1FBRUQsSUFBTSxPQUFPLEdBQUcsVUFBQyxHQUFXOztZQUMxQixPQUFPLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQztnQkFDcEIsQ0FBQyxDQUFDLEVBQUU7Z0JBQ0osQ0FBQyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsSUFBRyxNQUFBLEdBQUcsYUFBSCxHQUFHLHVCQUFILEdBQUcsQ0FBRSxLQUFLLENBQUMsU0FBUyxDQUFDLDBDQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQSxDQUFDLENBQUE7UUFDaEUsQ0FBQyxDQUFBO1FBRUQsSUFBTSxhQUFhLEdBQUcsVUFBUyxHQUFXO1lBQ3hDLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQTtZQUMzRCxPQUFPLFdBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBRyxDQUFBO1FBQ25ELENBQUMsQ0FBQTtRQUVELElBQU0sYUFBYSxHQUFHLFVBQVMsR0FBVztZQUN4QyxJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDNUMsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBO2FBQzdDO1FBQ0gsQ0FBQyxDQUFBO1FBRUQsb0NBQW9DO1FBQ3BDLElBQUksRUFBRSxHQUFHLEdBQUc7YUFDVCxPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQzthQUMxQixPQUFPO1FBQ04scURBQXFEO1FBQ3JELElBQUksTUFBTSxDQUFDLDBCQUFtQixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQUssRUFBRSxHQUFHLENBQUMsRUFDM0QsVUFBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLFNBQVM7WUFDcEIsT0FBTyxPQUFPLEtBQUssU0FBUztnQkFDMUIsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUM7Z0JBQ3hCLENBQUMsQ0FBQyxHQUFHLEdBQUcsYUFBYSxDQUFDLFdBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBRyxDQUFDLENBQUE7UUFDcEQsQ0FBQyxDQUNGO2FBQ0EsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQTtRQUVwRCw0Q0FBNEM7UUFDNUMsSUFBTSxTQUFTLEdBQUcsaUJBQWlCLENBQUE7UUFDbkMsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ3pCLEVBQUUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQTtTQUMvQjtRQUVELHlCQUF5QjtRQUN6QixFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDLENBQUE7UUFFcEMseUNBQXlDO1FBQ3pDLEVBQUUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQTtRQUU5QixzQ0FBc0M7UUFDdEMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFBO1FBRTdCLDBDQUEwQztRQUMxQyxJQUFNLE1BQU0sR0FBRyxFQUFFO2FBQ2QsSUFBSSxFQUFFO2FBQ04sS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUM7YUFDVCxPQUFPLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQzthQUNwQixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7UUFFYixJQUFNLFFBQVEsR0FBYSxFQUFFLENBQUE7UUFDN0IsSUFBTSxPQUFPLEdBQWtCLEVBQUUsQ0FBQTtRQUVqQyxLQUFLLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRSxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFBRTtZQUM5RCxJQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUE7WUFDL0IsSUFBTSxPQUFPLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFBO1lBQ3BDLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtnQkFDekIsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUE7Z0JBQzdCLFNBQVE7YUFDVDtZQUVELElBQUksU0FBUyxLQUFLLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLDRCQUFnQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtnQkFDN0UsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxPQUFPLE1BQU0sQ0FBQyxNQUFNLEtBQUssV0FBVyxFQUFFO29CQUN0RSxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsS0FBSyxDQUFBO2lCQUN6QjtnQkFDRCxTQUFRO2FBQ1Q7WUFFRCxJQUFNLElBQUksR0FBRyxTQUFTLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLE1BQU0sUUFBQSxFQUFFLENBQUMsQ0FBQTtZQUM1RCxJQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFBO2FBQ1o7aUJBQU07Z0JBQ0wsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksTUFBQSxFQUFFLEtBQUssT0FBQSxFQUFFLENBQUMsQ0FBQTtnQkFDN0IsSUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQTtnQkFDdEMsSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDYixPQUFPLElBQUksQ0FBQTtpQkFDWjtnQkFDRCxLQUFLLEdBQUcsUUFBUSxDQUFBO2FBQ2pCO1NBQ0Y7UUFFRCxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUE7SUFDM0MsQ0FBQztJQWxMRCwwQkFrTEM7SUFFRCxTQUFnQixRQUFRLENBQUMsS0FBWSxFQUFFLE1BQWU7UUFDcEQsSUFBSSxDQUFDLE1BQU07WUFBRSxPQUFPLElBQUksQ0FBQTtRQUN4QixNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQzdCLElBQUksQ0FBQyxJQUFBLGdCQUFRLEVBQUMsTUFBTSxDQUFDO1lBQUUsT0FBTyxJQUFJLENBQUE7UUFFbEMsSUFBTSxFQUFFLEdBQUcsbUJBQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQTtRQUMxQixJQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFBO1FBQzdCLElBQUksS0FBSyxFQUFFO1lBQ1QsT0FBTyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUE7U0FDekI7UUFDRCxPQUFPLElBQUksQ0FBQTtJQUNiLENBQUM7SUFYRCw0QkFXQztJQUVELFNBQWdCLFNBQVMsQ0FBQyxJQUFhO1FBQ3JDLE9BQU87WUFDTCxFQUFFLEVBQUUsSUFBSSxDQUFDLEVBQUU7WUFDWCxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7WUFDakIsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO1lBQ2pCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO1lBQ3pCLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztTQUNkLENBQUE7SUFDSCxDQUFDO0lBWEQsOEJBV0M7SUFFRCxTQUFnQixVQUFVLENBQUMsS0FBWTtRQUNyQyxPQUFPO1lBQ0wsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO1lBQ2xCLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSTtTQUNqQixDQUFBO0lBQ0gsQ0FBQztJQUxELGdDQUtDO0lBRUQsU0FBZ0IsUUFBUSxDQUN0QixTQUFnQixFQUNoQixLQUF3QyxFQUFFLE1BQWU7UUFFbkQsSUFBQSxJQUFJLEdBQVksS0FBSyxLQUFqQixFQUFFLEtBQUssR0FBSyxLQUFLLE1BQVYsQ0FBVTtRQUUzQix3QkFBd0I7UUFDeEIsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUM5QixPQUFPLElBQUksQ0FBQTtTQUNaO1FBRUQsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQTtRQUN6QixLQUFLLEdBQUcsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQzNCLE1BQU0sR0FBRyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUE7UUFFN0IsNEJBQTRCO1FBQzVCLElBQUksQ0FBQyxJQUFBLHFCQUFhLEVBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFBLGVBQU8sRUFBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUEsZ0JBQVEsRUFBQyxNQUFNLENBQUMsRUFBRTtZQUNoRSxPQUFPLElBQUksQ0FBQTtTQUNaO1FBRUQsSUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFBO1FBQy9CLGlEQUFpRDtRQUNqRCxJQUFNLEVBQUUsR0FBRyxtQkFBTyxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQzFCLElBQUksSUFBSSxLQUFLLGdCQUFJO1lBQ2YsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxpQkFBSztZQUM1QixLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUMzQixPQUFPLElBQUksQ0FBQTtTQUNaO1FBRUQsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLElBQUksTUFBQSxFQUFFLEtBQUssT0FBQSxFQUFFLENBQUE7UUFDakMsSUFBSSxJQUFJLEtBQUssZ0JBQUksRUFBRTtZQUNqQixLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQTtTQUN4QjtRQUVELE9BQU8sS0FBSyxDQUFBO0lBQ2QsQ0FBQztJQW5DRCw0QkFtQ0M7SUFFRCxTQUFnQixXQUFXLENBQUMsU0FBZ0IsRUFBRSxNQUFlO1FBQzNELElBQUksQ0FBQyxNQUFNO1lBQUUsT0FBTyxJQUFJLENBQUE7UUFFeEIsTUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQTtRQUM3QixJQUFJLENBQUMsSUFBQSxnQkFBUSxFQUFDLE1BQU0sQ0FBQztZQUFFLE9BQU8sSUFBSSxDQUFBO1FBRWxDLElBQU0sRUFBRSxHQUFHLG1CQUFPLENBQUMsTUFBTSxDQUFDLENBQUE7UUFDMUIsSUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUNqQyxJQUFJLENBQUMsS0FBSztZQUFFLE9BQU8sSUFBSSxDQUFBO1FBRXZCLElBQU0sS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtRQUN2QixJQUFBLElBQUksR0FBWSxLQUFLLEtBQWpCLEVBQUUsS0FBSyxHQUFLLEtBQUssTUFBVixDQUFVO1FBQzdCLElBQUksSUFBSSxLQUFLLGdCQUFJLEVBQUU7WUFDakIsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxpQkFBSyxDQUFBO1NBQzNCO1FBQ0QsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFBO1FBQ3RCLE9BQU8sS0FBSyxDQUFBO0lBQ2QsQ0FBQztJQWpCRCxrQ0FpQkM7SUFFRCxTQUFnQixhQUFhLENBQzNCLEtBQVksRUFDWixPQUFrRDs7UUFBbEQsd0JBQUEsRUFBQSxZQUFrRDtRQUUxQyxJQUFBLEtBQWlCLE9BQU8sTUFBWixFQUFaLEtBQUssbUJBQUcsSUFBSSxLQUFBLENBQVk7UUFDaEMsSUFBTSxRQUFRLEdBQUcsVUFBQyxLQUFZLEVBQUUsS0FBZ0IsRUFBRSxJQUFZLEVBQUUsRUFBVSxFQUFFLEtBQWE7WUFDdkYsdUJBQXVCO1lBQ3ZCLElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUN6QixJQUNFLEtBQUs7Z0JBQ0gsS0FBSyxDQUFDLElBQUksS0FBSyxnQkFBSTtnQkFDbkIsQ0FBQyxJQUFBLFlBQUksRUFBQyxFQUFFLENBQUMsS0FBSyxrQkFBTSxJQUFJLElBQUEsWUFBSSxFQUFDLEVBQUUsQ0FBQyxLQUFLLGtCQUFNLENBQUMsRUFDOUM7Z0JBQ0EsSUFBTSxNQUFNLEdBQUcsQ0FBQyxpQkFBSyxFQUFFLGdCQUFJLEVBQUUsa0JBQU0sRUFBRSxrQkFBTSxDQUFDLENBQUE7Z0JBQzVDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ2pELEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO2lCQUN6RDthQUNGO2lCQUFNO2dCQUNMLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUE7YUFDOUM7UUFDSCxDQUFDLENBQUE7UUFFRCxJQUFNLEtBQUssR0FBYyxFQUFFLENBQUE7UUFDM0IsSUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQTtRQUNyQixJQUFNLElBQUksR0FBRyxJQUFBLGlCQUFTLEVBQUMsRUFBRSxDQUFDLENBQUE7UUFDMUIsSUFBTSxXQUFXLEdBQThCLEVBQUUsQ0FBQyxFQUFFLGtCQUFNLEVBQUUsQ0FBQyxFQUFFLGtCQUFNLEVBQUUsQ0FBQTtRQUV2RSxJQUFJLFFBQVEsR0FBRyxtQkFBTyxDQUFDLEVBQUUsQ0FBQTtRQUN6QixJQUFJLE9BQU8sR0FBRyxtQkFBTyxDQUFDLEVBQUUsQ0FBQTtRQUN4QixJQUFJLGFBQWEsR0FBRyxLQUFLLENBQUE7UUFFekIsa0RBQWtEO1FBQzVDLElBQUEsTUFBTSxHQUFLLE9BQU8sT0FBWixDQUFZO1FBQ3hCLElBQUksTUFBTSxFQUFFO1lBQ1YsTUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQTtZQUM3QixJQUFJLElBQUEsZ0JBQVEsRUFBQyxNQUFNLENBQUMsRUFBRTtnQkFDcEIsUUFBUSxHQUFHLE9BQU8sR0FBRyxtQkFBTyxDQUFDLE1BQU0sQ0FBQyxDQUFBO2dCQUNwQyxhQUFhLEdBQUcsSUFBSSxDQUFBO2FBQ3JCO2lCQUFNO2dCQUNMLG9CQUFvQjtnQkFDcEIsT0FBTyxFQUFFLENBQUE7YUFDVjtTQUNGO1FBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxJQUFJLE9BQU8sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4Qyx5Q0FBeUM7WUFDekMsSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFO2dCQUNaLENBQUMsSUFBSSxDQUFDLENBQUE7Z0JBQ04sU0FBUTthQUNUO1lBRUQsSUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUM1QixJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssRUFBRSxFQUFFO2dCQUNoQyxTQUFRO2FBQ1Q7WUFFRCxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssZ0JBQUksRUFBRTtnQkFDdkIsa0NBQWtDO2dCQUNsQyxJQUFNLE9BQU8sR0FBRyxDQUFDLEdBQUcsd0JBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtnQkFDdkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ3pCLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLGdCQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7b0JBRXJELG1CQUFtQjtvQkFDbkIsSUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFHLHdCQUFZLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7b0JBQ3ZDLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxLQUFLLElBQUEsWUFBSSxFQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRTt3QkFDeEQsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsZ0JBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTtxQkFDeEQ7aUJBQ0Y7Z0JBRUQsbUJBQW1CO2dCQUNuQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUMxQixJQUFNLFFBQU0sR0FBRyxDQUFDLEdBQUcsd0JBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtvQkFDdEMsSUFBSSxRQUFNLEdBQUcsSUFBSTt3QkFBRSxTQUFRO29CQUUzQixJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBTSxDQUFDLElBQUksQ0FBQSxNQUFBLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBTSxDQUFDLDBDQUFFLEtBQUssTUFBSyxJQUFJLEVBQUU7d0JBQzlELFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsUUFBTSxFQUFFLGdCQUFJLENBQUMsT0FBTyxDQUFDLENBQUE7cUJBQ3REO3lCQUFNLElBQUksUUFBTSxLQUFLLEtBQUssQ0FBQyxTQUFTLEVBQUU7d0JBQ3JDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLFNBQVMsRUFBRSxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFBO3FCQUNsRTtpQkFDRjthQUNGO2lCQUFNO2dCQUNMLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyx5QkFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDcEUsSUFBTSxNQUFNLEdBQUcseUJBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7b0JBQzNDLElBQUksUUFBTSxHQUFHLENBQUMsQ0FBQTtvQkFFZCxPQUFPLElBQUksRUFBRTt3QkFDWCxRQUFNLElBQUksTUFBTSxDQUFBO3dCQUNoQixJQUFJLFFBQU0sR0FBRyxJQUFJOzRCQUFFLE1BQUs7d0JBRXhCLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQU0sQ0FBQyxFQUFFOzRCQUN4QixRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLFFBQU0sRUFBRSxnQkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO3lCQUNyRDs2QkFBTTs0QkFDTCxJQUFJLENBQUEsTUFBQSxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQU0sQ0FBQywwQ0FBRSxLQUFLLE1BQUssRUFBRTtnQ0FBRSxNQUFLOzRCQUM1QyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLFFBQU0sRUFBRSxnQkFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFBOzRCQUNyRCxNQUFLO3lCQUNOO3dCQUVELDhCQUE4Qjt3QkFDOUIsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLEdBQUc7NEJBQUUsTUFBSztxQkFDcEQ7aUJBQ0Y7YUFDRjtTQUNGO1FBRUQ7O1dBRUc7UUFDSCxJQUFJLENBQUMsYUFBYSxJQUFJLE9BQU8sS0FBSyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ2pELHdCQUF3QjtZQUN4QixJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsZ0JBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQzFDLElBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUE7Z0JBQ3JDLElBQU0sV0FBVyxHQUFHLGFBQWEsR0FBRyxDQUFDLENBQUE7Z0JBRXJDLElBQ0UsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7b0JBQzdCLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUM7b0JBQ3pCLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDekMsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxhQUFhLEdBQUcsQ0FBQyxDQUFDO29CQUMzQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxFQUN2QztvQkFDQSxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxXQUFXLEVBQUUsZ0JBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQTtpQkFDOUU7YUFDRjtZQUVELHlCQUF5QjtZQUN6QixJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsZ0JBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQzFDLElBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUE7Z0JBQ3JDLElBQU0sV0FBVyxHQUFHLGFBQWEsR0FBRyxDQUFDLENBQUE7Z0JBRXJDLElBQ0UsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUM7b0JBQzdCLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO29CQUMvQixDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztvQkFDL0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUN6QyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLGFBQWEsR0FBRyxDQUFDLENBQUM7b0JBQzNDLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLEVBQ3ZDO29CQUNBLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxnQkFBSSxDQUFDLFlBQVksQ0FBQyxDQUFBO2lCQUM5RTthQUNGO1NBQ0Y7UUFFRDs7V0FFRztRQUNILElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDVixPQUFPLEtBQUssQ0FBQTtTQUNiO1FBRUQsOEJBQThCO1FBQzlCLElBQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQTtRQUN0QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2hELElBQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDMUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLEVBQUU7Z0JBQ2pDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7YUFDM0I7U0FDRjtRQUVELE9BQU8sV0FBVyxDQUFBO0lBQ3BCLENBQUM7SUEvSkQsc0NBK0pDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsU0FBZ0IsU0FBUyxDQUN2QixLQUFZLEVBQ1osSUFBYSxFQUNiLE9BQTREOztRQUE1RCx3QkFBQSxFQUFBLFlBQTREO1FBRXBELElBQUEsS0FBMEMsT0FBTyxPQUFuQyxFQUFkLE1BQU0sbUJBQUcsS0FBSyxLQUFBLEVBQUUsS0FBMEIsT0FBTyxlQUFaLEVBQXJCLGNBQWMsbUJBQUcsSUFBSSxLQUFBLENBQVk7UUFDekQsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFBO1FBRWYsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLGdCQUFJLENBQUMsWUFBWSxFQUFFO1lBQ2xDLE1BQU0sR0FBRyxLQUFLLENBQUE7U0FDZjthQUFNLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxnQkFBSSxDQUFDLFlBQVksRUFBRTtZQUN6QyxNQUFNLEdBQUcsT0FBTyxDQUFBO1NBQ2pCO2FBQU07WUFDTCxJQUFNLGFBQWEsR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFBO1lBRTNELElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxnQkFBSSxFQUFFO2dCQUN2QixNQUFNLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsR0FBRyxhQUFhLENBQUE7YUFDbkQ7WUFFRCxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxnQkFBSSxDQUFDLE9BQU8sR0FBRyxnQkFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dCQUNqRCxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssZ0JBQUksRUFBRTtvQkFDdkIsTUFBTSxJQUFJLElBQUEsaUJBQVMsRUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7aUJBQ2xDO2dCQUNELE1BQU0sSUFBSSxHQUFHLENBQUE7YUFDZDtZQUVELE1BQU0sSUFBSSxJQUFBLGlCQUFTLEVBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFBO1lBRTVCLElBQUksY0FBYyxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsZ0JBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQ2pELE1BQU0sSUFBSSxHQUFHLElBQUcsTUFBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxXQUFXLEVBQUUsQ0FBQSxDQUFBO2FBQzlDO1NBQ0Y7UUFFRCxJQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFBO1FBQ3RDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ3JCLElBQUksV0FBVyxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUN6QixNQUFNLElBQUksR0FBRyxDQUFBO2FBQ2Q7aUJBQU07Z0JBQ0wsTUFBTSxJQUFJLEdBQUcsQ0FBQTthQUNkO1NBQ0Y7UUFFRCxPQUFPLE1BQU0sQ0FBQTtJQUNmLENBQUM7SUEzQ0QsOEJBMkNDO0lBRUQsU0FBZ0IsU0FBUyxDQUN2QixLQUFZLEVBQ1osSUFBWSxFQUNaLE9BQTREO1FBQTVELHdCQUFBLEVBQUEsWUFBNEQ7UUFFcEQsSUFBQSxLQUEwQyxPQUFPLE9BQW5DLEVBQWQsTUFBTSxtQkFBRyxLQUFLLEtBQUEsRUFBRSxLQUEwQixPQUFPLGVBQVosRUFBckIsY0FBYyxtQkFBRyxJQUFJLEtBQUEsQ0FBWTtRQUV6RCw2Q0FBNkM7UUFDN0MsSUFBTSxTQUFTLEdBQUcsSUFBQSxtQkFBVyxFQUFDLElBQUksQ0FBQyxDQUFBO1FBRW5DLElBQUksT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQTtRQUV2QywyRUFBMkU7UUFDM0UsNERBQTREO1FBQzVELElBQUksTUFBTSxFQUFFO1lBQ1YsT0FBTyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQ3ZCLDREQUE0RCxDQUM3RCxDQUFBO1lBQ0QsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQTtnQkFDbEIsSUFBSSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQTtnQkFDakIsRUFBRSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQTtnQkFDZixTQUFTLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFBO2FBQ3ZCO1NBQ0Y7UUFFRCxJQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUE7UUFDcEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNoRCxtRUFBbUU7WUFDbkUsY0FBYztZQUNkLElBQU0sR0FBRyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsY0FBYyxnQkFBQSxFQUFFLENBQUMsQ0FBQTtZQUMxRCxJQUFJLFNBQVMsS0FBSyxJQUFBLG1CQUFXLEVBQUMsR0FBRyxDQUFDO2dCQUNoQyxDQUFDLE1BQU0sSUFBSSxTQUFTLEtBQUssSUFBQSxtQkFBVyxFQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDNUUsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUE7YUFDaEI7WUFDRCxJQUNFLElBQUk7Z0JBQ0YsRUFBRTtnQkFDRixJQUFBLGdCQUFRLEVBQUMsSUFBSSxDQUFDO2dCQUNkLElBQUEsZ0JBQVEsRUFBQyxFQUFFLENBQUM7Z0JBQ1osT0FBTztnQkFDUCxDQUFDLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO2dCQUNqRCxtQkFBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO2dCQUM5QixtQkFBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUMxQixDQUFDLENBQUMsY0FBYyxJQUFJLENBQUMsU0FBUyxJQUFJLFNBQVMsQ0FBQyxXQUFXLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQ2xGO2dCQUNBLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFBO2FBQ2hCO1NBQ0Y7UUFFRCxPQUFPLElBQUksQ0FBQTtJQUNiLENBQUM7SUFuREQsOEJBbURDO0lBRUQsU0FBZ0IsVUFBVSxDQUFDLEtBQVksRUFBRSxTQUFrQjtRQUN6RCxJQUFNLElBQUksR0FBWSxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUE7UUFFMUMsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFBO1FBQ2QsS0FBSyxJQUFNLElBQUksSUFBSSxnQkFBSSxFQUFFO1lBQ3ZCLElBQUksSUFBQSxpQkFBUyxFQUFDLElBQUksQ0FBQyxJQUFJLGdCQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDOUMsS0FBSyxJQUFJLGlCQUFLLENBQUMsSUFBSSxDQUFDLENBQUE7YUFDckI7U0FDRjtRQUVELE9BQU87WUFDTCxFQUFFLEVBQUUsSUFBQSxpQkFBUyxFQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDdEIsSUFBSSxFQUFFLElBQUEsaUJBQVMsRUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQzFCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixLQUFLLE9BQUE7WUFDTCxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7WUFDakIsR0FBRyxFQUFFLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDO1lBQzNCLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtZQUN2QixTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVM7U0FDMUIsQ0FBQTtJQUNILENBQUM7SUFwQkQsZ0NBb0JDO0lBRUQsU0FBZ0IsVUFBVSxDQUFDLEtBQVksRUFBRSxLQUFhLEVBQUUsTUFBYzs7UUFDcEUsS0FBSyxJQUFJLENBQUMsR0FBRyxtQkFBTyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksbUJBQU8sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDN0MseUNBQXlDO1lBQ3pDLElBQUksQ0FBQyxHQUFHLElBQUksRUFBRTtnQkFDWixDQUFDLElBQUksQ0FBQyxDQUFBO2dCQUNOLFNBQVE7YUFDVDtZQUVELG9DQUFvQztZQUNwQyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUEsTUFBQSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQywwQ0FBRSxLQUFLLE1BQUssS0FBSztnQkFBRSxTQUFRO1lBRXZFLElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDNUIsSUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQTtZQUM3QixJQUFNLEtBQUssR0FBRyxVQUFVLEdBQUcsR0FBRyxDQUFBO1lBRTlCLElBQUksS0FBSyxJQUFJLG1CQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksa0JBQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtnQkFDdkQsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLGdCQUFJLEVBQUU7b0JBQ3ZCLElBQUksVUFBVSxHQUFHLENBQUMsRUFBRTt3QkFDbEIsSUFBSSxLQUFLLENBQUMsS0FBSyxLQUFLLGlCQUFLOzRCQUFFLE9BQU8sSUFBSSxDQUFBO3FCQUN2Qzt5QkFBTTt3QkFDTCxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssaUJBQUs7NEJBQUUsT0FBTyxJQUFJLENBQUE7cUJBQ3ZDO29CQUNELFNBQVE7aUJBQ1Q7Z0JBRUQsd0NBQXdDO2dCQUN4QyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssR0FBRztvQkFBRSxPQUFPLElBQUksQ0FBQTtnQkFFekQsSUFBTSxNQUFNLEdBQUcsZ0JBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtnQkFDMUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQTtnQkFFbEIsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFBO2dCQUNuQixPQUFPLENBQUMsS0FBSyxNQUFNLEVBQUU7b0JBQ25CLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRTt3QkFDbEIsT0FBTyxHQUFHLElBQUksQ0FBQTt3QkFDZCxNQUFLO3FCQUNOO29CQUNELENBQUMsSUFBSSxNQUFNLENBQUE7aUJBQ1o7Z0JBRUQsSUFBSSxDQUFDLE9BQU87b0JBQUUsT0FBTyxJQUFJLENBQUE7YUFDMUI7U0FDRjtRQUVELE9BQU8sS0FBSyxDQUFBO0lBQ2QsQ0FBQztJQTdDRCxnQ0E2Q0M7SUFFRCxTQUFnQixjQUFjLENBQUMsS0FBWSxFQUFFLEtBQVk7UUFDdkQsT0FBTyxVQUFVLENBQUMsS0FBSyxFQUFFLElBQUEsaUJBQVMsRUFBQyxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUE7SUFDaEUsQ0FBQztJQUZELHdDQUVDO0lBRUQsU0FBZ0IsT0FBTyxDQUFDLEtBQVk7UUFDbEMsT0FBTyxjQUFjLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUMxQyxDQUFDO0lBRkQsMEJBRUM7SUFFRCxTQUFnQixXQUFXLENBQUMsS0FBWTtRQUN0QyxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQTtJQUM1RCxDQUFDO0lBRkQsa0NBRUM7SUFFRCxTQUFnQixXQUFXLENBQUMsS0FBWTtRQUN0QyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFBO0lBQzdELENBQUM7SUFGRCxrQ0FFQztJQUVELFNBQWdCLG9CQUFvQixDQUFDLEtBQVk7UUFDL0MsSUFBTSxNQUFNLEdBQTRCLEVBQUUsQ0FBQTtRQUMxQyxJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUE7UUFDbEIsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFBO1FBQ2xCLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQTtRQUVoQixLQUFLLElBQUksQ0FBQyxHQUFHLG1CQUFPLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxtQkFBTyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM3QyxRQUFRLEdBQUcsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1lBQzdCLElBQUksQ0FBQyxHQUFHLElBQUksRUFBRTtnQkFDWixDQUFDLElBQUksQ0FBQyxDQUFBO2dCQUNOLFNBQVE7YUFDVDtZQUVELElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDNUIsSUFBSSxLQUFLLEVBQUU7Z0JBQ1QsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtnQkFDdEUsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLGtCQUFNLEVBQUU7b0JBQ3pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUE7aUJBQ3ZCO2dCQUNELFVBQVUsRUFBRSxDQUFBO2FBQ2I7U0FDRjtRQUVELGFBQWE7UUFDYixJQUFJLFVBQVUsS0FBSyxDQUFDLEVBQUU7WUFDcEIsT0FBTyxJQUFJLENBQUE7U0FDWjthQUFNO1FBQ0wsb0NBQW9DO1FBQ3BDLFVBQVUsS0FBSyxDQUFDO1lBQ2QsQ0FBQyxNQUFNLENBQUMsa0JBQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsa0JBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUNoRDtZQUNBLE9BQU8sSUFBSSxDQUFBO1NBQ1o7YUFBTSxJQUFJLFVBQVUsS0FBSyxNQUFNLENBQUMsa0JBQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUM1QyxxRUFBcUU7WUFDckUsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFBO1lBQ1gsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQTtZQUMxQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM1QixHQUFHLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFBO2FBQ2xCO1lBQ0QsSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLEdBQUcsS0FBSyxHQUFHLEVBQUU7Z0JBQzVCLE9BQU8sSUFBSSxDQUFBO2FBQ1o7U0FDRjtRQUVELE9BQU8sS0FBSyxDQUFBO0lBQ2QsQ0FBQztJQTdDRCxvREE2Q0M7SUFFRCxTQUFnQixRQUFRLENBQUMsU0FBZ0IsRUFBRSxJQUFhO1FBQ3RELElBQU0sS0FBSyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtRQUMvQixJQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFBO1FBQ3JCLElBQU0sSUFBSSxHQUFHLElBQUEsaUJBQVMsRUFBQyxFQUFFLENBQUMsQ0FBQTtRQUMxQixrQkFBa0I7UUFFbEIsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7UUFDN0MsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUU3Qiw2Q0FBNkM7UUFDN0MsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLGdCQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2hDLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxpQkFBSyxFQUFFO2dCQUN4QixPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQTthQUNqQztpQkFBTTtnQkFDTCxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQTthQUNqQztTQUNGO1FBRUQsK0NBQStDO1FBQy9DLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxnQkFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUEscUJBQWEsRUFBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDbEYsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUE7U0FDM0Q7UUFFRCwwQkFBMEI7UUFDMUIsSUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUE7UUFDbEMsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxnQkFBSSxFQUFFO1lBQ2hDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUE7WUFFbEMsbURBQW1EO1lBQ25ELElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxnQkFBSSxDQUFDLFlBQVksRUFBRTtnQkFDbEMsSUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUE7Z0JBQy9CLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFBO2dCQUNqQyxLQUFLLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUE7Z0JBQ3JELE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQTthQUNsQztpQkFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsZ0JBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ3pDLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFBO2dCQUMvQixJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQTtnQkFDakMsS0FBSyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFBO2dCQUNyRCxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUE7YUFDbEM7WUFFRCx1QkFBdUI7WUFDdkIsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUE7U0FDdkI7UUFFRCx5Q0FBeUM7UUFDekMsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ3RCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxpQkFBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUNwRCxJQUNFLElBQUksQ0FBQyxJQUFJLEtBQUssaUJBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNO29CQUMvQixLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxHQUFHLGlCQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUN4QztvQkFDQSxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLGlCQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFBO29CQUN2QyxNQUFLO2lCQUNOO2FBQ0Y7U0FDRjtRQUVELDRDQUE0QztRQUM1QyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDeEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLGlCQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3RELElBQ0UsSUFBSSxDQUFDLEVBQUUsS0FBSyxpQkFBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU07b0JBQy9CLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsaUJBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQzVDO29CQUNBLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksaUJBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUE7b0JBQzNDLE1BQUs7aUJBQ047YUFDRjtTQUNGO1FBRUQsb0RBQW9EO1FBQ3BELElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxnQkFBSSxDQUFDLFFBQVEsRUFBRTtZQUM5QixJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssR0FBRyxFQUFFO2dCQUN0QixLQUFLLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFBO2FBQy9CO2lCQUFNO2dCQUNMLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUE7YUFDL0I7U0FDRjthQUFNO1lBQ0wsS0FBSyxDQUFDLFNBQVMsR0FBRyxpQkFBSyxDQUFBO1NBQ3hCO1FBRUQseUVBQXlFO1FBQ3pFLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxnQkFBSSxFQUFFO1lBQ3ZCLEtBQUssQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFBO1NBQ3JCO2FBQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsZ0JBQUksQ0FBQyxPQUFPLEdBQUcsZ0JBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN4RCxLQUFLLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQTtTQUNyQjthQUFNO1lBQ0wsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFBO1NBQ25CO1FBRUQsSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLGlCQUFLLEVBQUU7WUFDeEIsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFBO1NBQ3BCO1FBQ0QsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFBLGlCQUFTLEVBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ2xDLE9BQU8sS0FBSyxDQUFBO0lBQ2QsQ0FBQztJQWhHRCw0QkFnR0M7SUFFRCxTQUFnQixTQUFTLENBQUMsS0FBWSxFQUFFLElBQVksRUFBRSxFQUFVLEVBQUUsS0FBYSxFQUFFLFNBQWtCOztRQUNqRyxJQUFNLElBQUksR0FBWTtZQUNwQixLQUFLLEVBQUUsS0FBSyxDQUFDLElBQUk7WUFDakIsSUFBSSxFQUFFLElBQUk7WUFDVixFQUFFLEVBQUUsRUFBRTtZQUNOLEtBQUssRUFBRSxLQUFLO1lBQ1osS0FBSyxFQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFXLENBQUMsSUFBSTtTQUN6QyxDQUFBO1FBRUQsSUFBSSxTQUFTLElBQUksSUFBQSxxQkFBYSxFQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3pDLElBQUksQ0FBQyxLQUFLLElBQUksZ0JBQUksQ0FBQyxTQUFTLENBQUE7WUFDNUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUE7U0FDM0I7UUFFRCxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFBLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLDBDQUFFLElBQUksQ0FBQTtTQUN0QzthQUFNLElBQUksS0FBSyxHQUFHLGdCQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2xDLElBQUksQ0FBQyxRQUFRLEdBQUcsZ0JBQUksQ0FBQTtTQUNyQjtRQUNELE9BQU8sSUFBSSxDQUFBO0lBQ2IsQ0FBQztJQXBCRCw4QkFvQkM7SUFFRCxTQUFnQixLQUFLLENBQUMsS0FBWSxFQUFFLEdBQVU7UUFBVixvQkFBQSxFQUFBLFVBQVU7UUFDNUMsSUFBTSxNQUFNLEdBQUcsaUJBQUssQ0FBQyxHQUFHLENBQUMsVUFBQSxJQUFJOztZQUMzQixJQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxFQUFFLEVBQUUsSUFBSSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQTtZQUN4RCwrQ0FBK0M7WUFDL0MsSUFBTSxHQUFHLEdBQWEsRUFBRSxDQUFBOztnQkFDeEIsS0FBb0IsSUFBQSxlQUFBLFNBQUEsVUFBVSxDQUFBLHNDQUFBLDhEQUFFO29CQUEzQixJQUFNLEtBQUssdUJBQUE7b0JBQ2QsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFdBQUksSUFBQSxjQUFNLEVBQUMsS0FBSyxDQUFDLE1BQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUE7aUJBQy9DOzs7Ozs7Ozs7WUFDRCxJQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFBO1lBRTVCLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxPQUFPLEdBQUcsR0FBRyxDQUFBO1FBQ2hELENBQUMsQ0FBQyxDQUFBO1FBRUYsT0FBTztZQUNMLDhCQUE4QjtZQUM5QixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztZQUNoQiw4QkFBOEI7WUFDOUIsNEJBQTRCO1NBQzdCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0lBQ2IsQ0FBQztJQW5CRCxzQkFtQkM7SUFFRCxTQUFnQixRQUFRLENBQUMsS0FBWTtRQUNuQyxJQUFNLE1BQU0sR0FBRyxFQUFFLENBQUE7UUFDakIsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFBO1FBRVosS0FBSyxJQUFJLENBQUMsR0FBRyxtQkFBTyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksbUJBQU8sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDN0MsSUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ3RCLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtnQkFDakIsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTthQUNmO2lCQUFNO2dCQUNMLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUE7YUFDbkQ7WUFDRCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksRUFBRTtnQkFDbEIsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtnQkFDaEIsR0FBRyxHQUFHLEVBQUUsQ0FBQTtnQkFDUixDQUFDLElBQUksQ0FBQyxDQUFBO2FBQ1A7U0FDRjtRQUVELE9BQU8sTUFBTSxDQUFBO0lBQ2YsQ0FBQztJQW5CRCw0QkFtQkM7SUFFRCxTQUFnQixZQUFZLENBQzFCLEtBQVksRUFDWixJQUEwQixFQUMxQixPQUE0RDs7UUFBNUQsd0JBQUEsRUFBQSxZQUE0RDtRQUU1RCx1RUFBdUU7UUFDdkUsNkNBQTZDO1FBQ3JDLElBQUEsS0FBMEIsT0FBTyxlQUFaLEVBQXJCLGNBQWMsbUJBQUcsSUFBSSxLQUFBLENBQVk7UUFFekMsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDNUIsT0FBTyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQTtTQUN2QzthQUFNLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQ25DLElBQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUE7O2dCQUN6RCx1QkFBdUI7Z0JBQ3ZCLEtBQXNCLElBQUEsVUFBQSxTQUFBLEtBQUssQ0FBQSw0QkFBQSwrQ0FBRTtvQkFBeEIsSUFBTSxPQUFPLGtCQUFBO29CQUNoQixJQUNFLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBQSxpQkFBUyxFQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7d0JBQ25DLElBQUksQ0FBQyxFQUFFLEtBQUssSUFBQSxpQkFBUyxFQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7d0JBQ2pDLENBQUMsQ0FBQyxjQUFjLElBQUksQ0FBQyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUM7NEJBQzNDLElBQUksQ0FBQyxTQUFTLEtBQUssT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUN6Qzt3QkFDQSxPQUFPLE9BQU8sQ0FBQTtxQkFDZjtpQkFDRjs7Ozs7Ozs7O1NBQ0Y7UUFFRCxPQUFPLElBQUksQ0FBQTtJQUNiLENBQUM7SUEzQkQsb0NBMkJDOzs7Ozs7SUM5cENELGNBQWM7SUFDZDtRQWdCRTs7Ozs7Ozs7Ozs7Ozs7V0FjRztRQUNILGVBQVksR0FBOEI7WUFBOUIsb0JBQUEsRUFBQSxNQUFjLDRCQUFnQjtZQWxCMUMsbUJBQWMsR0FBVyxLQUFLLENBQUE7WUFDOUIsbUJBQWMsR0FBVyxLQUFLLENBQUE7WUFDOUIsZ0JBQVcsR0FBWSxLQUFLLENBQUE7WUFpQjFCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxhQUFLLEVBQUUsQ0FBQTtZQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQTtZQUNsQixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQTtZQUNqQixJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQTtZQUVuQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBO2FBQ3JDO1FBQ0gsQ0FBQztRQUdELHNCQUFXLHdCQUFLO1lBRGhCLGdCQUFnQjtpQkFDaEI7Z0JBQ0UsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFBO1lBQzVCLENBQUM7OztXQUFBO1FBR0Qsc0JBQVcseUJBQU07WUFEakIsaUJBQWlCO2lCQUNqQjtnQkFDRSw4Q0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFDLFdBQVcsSUFBSyxPQUFBLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQXpCLENBQXlCLENBQUMsWUFBRSxJQUFJLENBQUMsS0FBSyxVQUFDO1lBQ3ZGLENBQUM7OztXQUFBO1FBRUQ7Ozs7OztXQU1HO1FBQ0ksb0JBQUksR0FBWCxVQUFZLEdBQVcsRUFBRSxXQUFtQjtZQUFuQiw0QkFBQSxFQUFBLG1CQUFtQjtZQUMxQyxJQUFNLEtBQUssR0FBRyxJQUFBLGVBQU8sRUFBQyxHQUFHLENBQUMsQ0FBQTtZQUMxQixJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNWLE9BQU8sS0FBSyxDQUFBO2FBQ2I7WUFDRCxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQTtZQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQTtZQUNsQixJQUFJLENBQUMsV0FBVztnQkFBRSxJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQTtZQUNuQyxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQTtZQUNuQixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUE7WUFDbEIsT0FBTyxJQUFJLENBQUE7UUFDYixDQUFDO1FBRUQ7Ozs7Ozs7Ozs7O1dBV0c7UUFDSSxxQkFBSyxHQUFaLFVBQWEsV0FBbUI7WUFBbkIsNEJBQUEsRUFBQSxtQkFBbUI7WUFDOUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLGFBQUssRUFBRSxDQUFBO1lBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFBO1lBQ2xCLElBQUksQ0FBQyxXQUFXO2dCQUFFLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFBO1lBQ25DLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFBO1lBQ25CLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQTtRQUNwQixDQUFDO1FBRUQ7O1dBRUc7UUFDSSxxQkFBSyxHQUFaO1lBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyw0QkFBZ0IsQ0FBQyxDQUFBO1FBQzdCLENBQUM7UUFFRDs7Ozs7Ozs7Ozs7Ozs7OztXQWdCRztRQUNJLG1CQUFHLEdBQVYsVUFBVyxNQUFlO1lBQ3hCLE9BQU8sSUFBQSxnQkFBUSxFQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFDdEMsQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBa0NHO1FBQ0ksbUJBQUcsR0FBVixVQUFXLEtBQXdDLEVBQUUsTUFBZTtZQUNsRSxJQUFNLFFBQVEsR0FBRyxJQUFBLGdCQUFRLEVBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUE7WUFDckQsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osSUFBSSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUE7Z0JBQ3RCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQTtnQkFDbEIsT0FBTyxJQUFJLENBQUE7YUFDWjtZQUNELE9BQU8sS0FBSyxDQUFBO1FBQ2QsQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBbUJHO1FBQ0ksc0JBQU0sR0FBYixVQUFjLE1BQWU7WUFDM0IsSUFBTSxLQUFLLEdBQUcsSUFBQSxnQkFBUSxFQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUE7WUFDM0MsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDVixPQUFPLElBQUksQ0FBQTthQUNaO1lBRUQsSUFBTSxRQUFRLEdBQUcsSUFBQSxtQkFBVyxFQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUE7WUFDakQsSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDYixPQUFPLElBQUksQ0FBQTthQUNaO1lBQ0QsSUFBSSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUE7WUFDdEIsT0FBTyxLQUFLLENBQUE7UUFDZCxDQUFDO1FBNENNLHFCQUFLLEdBQVosVUFBYSxPQUFtRDtZQUFoRSxpQkFZQztZQVpZLHdCQUFBLEVBQUEsWUFBbUQ7WUFDOUQscUVBQXFFO1lBQ3JFLG9FQUFvRTtZQUNwRSxrRUFBa0U7WUFDbEUsdURBQXVEO1lBQy9DLElBQUEsTUFBTSxHQUFzQixPQUFPLE9BQTdCLEVBQUUsS0FBb0IsT0FBTyxRQUFaLEVBQWYsT0FBTyxtQkFBRyxLQUFLLEtBQUEsQ0FBWTtZQUMzQyxJQUFNLFNBQVMsR0FBRyxJQUFBLHFCQUFhLEVBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLE1BQU0sUUFBQSxFQUFFLENBQUMsQ0FBQTtZQUV4RCxJQUFJLE9BQU8sRUFBRTtnQkFDWCxPQUFPLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBQyxRQUFRLElBQUssT0FBQSxJQUFBLGtCQUFVLEVBQUMsS0FBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsRUFBakMsQ0FBaUMsQ0FBQyxDQUFBO2FBQ3RFO1lBQ0QsT0FBTyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQUMsUUFBUSxJQUFLLE9BQUEsSUFBQSxpQkFBUyxFQUFDLEtBQUksQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEVBQWhDLENBQWdDLENBQUMsQ0FBQTtRQUN0RSxDQUFDO1FBRUQ7Ozs7Ozs7Ozs7Ozs7OztXQWVHO1FBQ0ksbUJBQUcsR0FBVjtZQUNFLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUE7UUFDeEIsQ0FBQztRQUVEOzs7Ozs7Ozs7OztXQVdHO1FBQ0ksdUJBQU8sR0FBZDtZQUNFLE9BQU8sSUFBQSxlQUFPLEVBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQzdCLENBQUM7UUFFRDs7Ozs7Ozs7Ozs7V0FXRztRQUNJLDJCQUFXLEdBQWxCO1lBQ0UsT0FBTyxJQUFBLG1CQUFXLEVBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQ2pDLENBQUM7UUFFRDs7Ozs7Ozs7O1dBU0c7UUFDSSwyQkFBVyxHQUFsQjtZQUNFLE9BQU8sSUFBQSxtQkFBVyxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTtRQUNqQyxDQUFDO1FBRUQ7Ozs7Ozs7Ozs7V0FVRztRQUNJLG9DQUFvQixHQUEzQjtZQUNFLE9BQU8sSUFBQSw0QkFBb0IsRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7UUFDMUMsQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBc0JHO1FBQ0kscUNBQXFCLEdBQTVCOztZQUNFLElBQU0sU0FBUyxHQUEyQixFQUFFLENBQUE7WUFFNUMsSUFBTSxVQUFVLEdBQUcsVUFBQyxLQUFZO2dCQUM5QixJQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtnQkFFdEQsaURBQWlEO2dCQUNqRCxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO2dCQUMxRCxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ3ZCLE9BQU8sSUFBSSxDQUFBO2lCQUNaO2dCQUNELE9BQU8sS0FBSyxDQUFBO1lBQ2QsQ0FBQyxDQUFBOztnQkFFRCxLQUF3QixJQUFBLEtBQUEsU0FBQSxJQUFJLENBQUMsUUFBUSxDQUFBLGdCQUFBLDRCQUFFO29CQUExQixJQUFBLEtBQUssaUJBQUE7b0JBQ2hCLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO3dCQUNyQixPQUFPLElBQUksQ0FBQTtxQkFDWjtpQkFDRjs7Ozs7Ozs7O1lBQ0QsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQ2hDLENBQUM7UUFFRDs7Ozs7Ozs7V0FRRztRQUNJLHNCQUFNLEdBQWI7WUFDRSxPQUFPLENBQ0wsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLElBQUksR0FBRztnQkFDM0IsSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDbEIsSUFBSSxDQUFDLG9CQUFvQixFQUFFO2dCQUMzQixJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FDL0IsQ0FBQTtRQUNILENBQUM7UUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQW1CRztRQUNJLHdCQUFRLEdBQWY7WUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksSUFBSSxDQUFDLGNBQWMsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFBO1FBQzFGLENBQUM7UUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBOEJHO1FBQ0kscUJBQUssR0FBWjtZQUNFLE9BQU8sSUFBQSxnQkFBUSxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUE7UUFDcEMsQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7Ozs7O1dBZ0JHO1FBQ0ksbUJBQUcsR0FBVixVQUFXLE9BQTJEO1lBQTNELHdCQUFBLEVBQUEsWUFBMkQ7WUFDcEUsT0FBTyxJQUFBLGNBQU0sRUFBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFBO1FBQ2xGLENBQUM7UUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBZ0dHO1FBQ0ksdUJBQU8sR0FBZCxVQUNFLEdBQVcsRUFDWCxPQUF5RDtZQUF6RCx3QkFBQSxFQUFBLFlBQXlEO1lBRXpELElBQU0sR0FBRyxHQUFHLElBQUEsZUFBTyxFQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQTtZQUNqQyxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNSLE9BQU8sS0FBSyxDQUFBO2FBQ2I7WUFFSyxJQUFBLEtBQUEsT0FBdUMsR0FBRyxJQUFBLEVBQXhDLEtBQUssUUFBQSxFQUFFLE1BQU0sUUFBQSxFQUFFLFFBQVEsUUFBQSxFQUFFLE9BQU8sUUFBUSxDQUFBO1lBQ2hELElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFBO1lBQ25CLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFBO1lBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFBO1lBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFBO1lBQ3ZCLE9BQU8sSUFBSSxDQUFBO1FBQ2IsQ0FBQztRQUVEOzs7Ozs7OztXQVFHO1FBQ0ksc0JBQU0sR0FBYjtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQTtRQUNyQixDQUFDO1FBRUQ7Ozs7Ozs7Ozs7V0FVRztRQUNJLHlCQUFTLEdBQWhCLFVBQWlCLE1BQThCO1lBQzdDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFBO1FBQ3ZCLENBQUM7UUFFRDs7Ozs7Ozs7V0FRRztRQUNJLHlCQUFTLEdBQWhCLFVBQWlCLEdBQVcsRUFBRSxHQUFXO1lBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFBO1FBQ3pCLENBQUM7UUFFRDs7Ozs7OztXQU9HO1FBQ0ksNEJBQVksR0FBbkIsVUFBb0IsR0FBVztZQUM3QixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUE7UUFDMUIsQ0FBQztRQUVEOzs7Ozs7OztXQVFHO1FBQ0ksMkJBQVcsR0FBbEI7WUFDRSxJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQTtRQUNuQixDQUFDO1FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQXdCRztRQUNJLHFCQUFLLEdBQVosVUFBYSxHQUFVO1lBQVYsb0JBQUEsRUFBQSxVQUFVO1lBQ3JCLE9BQU8sSUFBQSxhQUFLLEVBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUE7UUFDdEMsQ0FBQztRQUVEOzs7Ozs7Ozs7V0FTRztRQUNJLG9CQUFJLEdBQVg7WUFDRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFBO1FBQ3pCLENBQUM7UUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQWdFRztRQUNJLG9CQUFJLEdBQVgsVUFDRSxJQUEwQixFQUMxQixPQUFxRDtZQUFyRCx3QkFBQSxFQUFBLFlBQXFEO1lBRXJELElBQU0sU0FBUyxHQUFHLElBQUEsb0JBQVksRUFBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQTtZQUUxRCxJQUFJLENBQUMsU0FBUyxFQUFFO2dCQUNkLE9BQU8sSUFBSSxDQUFBO2FBQ1o7WUFFRCwrQ0FBK0M7WUFDL0MsSUFBTSxVQUFVLEdBQUcsSUFBQSxrQkFBVSxFQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUE7WUFDckQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUE7YUFDekI7WUFDRCxPQUFPLFVBQVUsQ0FBQTtRQUNuQixDQUFDO1FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBb0JHO1FBQ0ksNkJBQWEsR0FBcEIsVUFDRSxLQUErQixFQUMvQixPQUFrQzs7WUFBbEMsd0JBQUEsRUFBQSxZQUFrQztZQUVsQyxJQUFNLFVBQVUsR0FBVyxFQUFFLENBQUE7WUFDN0IsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQTs7Z0JBQ3ZCLEtBQW1CLElBQUEsVUFBQSxTQUFBLEtBQUssQ0FBQSw0QkFBQSwrQ0FBRTtvQkFBckIsSUFBTSxJQUFJLGtCQUFBO29CQUNiLElBQU0sU0FBUyxHQUFHLElBQUEsb0JBQVksRUFBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFBO29CQUNwRCxJQUFJLENBQUMsU0FBUyxFQUFFO3dCQUNkLE9BQU8sSUFBSSxDQUFBO3FCQUNaO29CQUNELFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBQSxrQkFBVSxFQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFBO29CQUM3QyxLQUFLLEdBQUcsSUFBQSxnQkFBUSxFQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQTtpQkFDbkM7Ozs7Ozs7OztZQUNELE9BQU8sVUFBVSxDQUFBO1FBQ25CLENBQUM7UUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQW1CRztRQUNJLDJCQUFXLEdBQWxCLFVBQ0UsSUFBMEIsRUFDMUIsT0FBa0M7WUFBbEMsd0JBQUEsRUFBQSxZQUFrQztZQUVsQyxJQUFNLFNBQVMsR0FBRyxJQUFBLG9CQUFZLEVBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLHdCQUFPLE9BQU8sS0FBRSxjQUFjLEVBQUUsS0FBSyxJQUFHLENBQUE7WUFFeEYsSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDZCxPQUFPLEtBQUssQ0FBQTthQUNiO1lBRUQsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLGdCQUFJLENBQUMsU0FBUyxDQUFDLENBQUE7UUFDN0MsQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQW9CRztRQUNJLG9CQUFJLEdBQVg7WUFDRSxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUE7WUFDNUIsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUEsa0JBQVUsRUFBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUE7UUFDcEQsQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7O1dBYUc7UUFDSSwyQkFBVyxHQUFsQixVQUFtQixNQUFjO1lBQy9CLElBQUksSUFBQSxnQkFBUSxFQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNwQixJQUFNLE9BQU8sR0FBRyxtQkFBTyxDQUFDLE1BQU0sQ0FBQyxDQUFBO2dCQUMvQixPQUFPLENBQUMsSUFBQSxZQUFJLEVBQUMsT0FBTyxDQUFDLEdBQUcsSUFBQSxZQUFJLEVBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQTthQUNwRTtZQUVELE9BQU8sSUFBSSxDQUFBO1FBQ2IsQ0FBQztRQXVDTSx1QkFBTyxHQUFkLFVBQWUsT0FBbUM7WUFBbkMsd0JBQUEsRUFBQSxZQUFtQztZQUN4QyxJQUFBLEtBQW9CLE9BQU8sUUFBWixFQUFmLE9BQU8sbUJBQUcsS0FBSyxLQUFBLENBQVk7WUFFbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFO2dCQUN6QixPQUFPLEVBQUUsQ0FBQTthQUNWO1lBRUQsSUFBSSxLQUFLLENBQUE7WUFDVCxJQUFJLE9BQU8sRUFBRTtnQkFDWCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQUMsV0FBVztvQkFDbkMsSUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQTtvQkFDN0IsS0FBSyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUE7b0JBQ3pCLE9BQU8sSUFBQSxrQkFBVSxFQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQTtnQkFDaEMsQ0FBQyxDQUFDLENBQUE7YUFDSDtZQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBQyxXQUFXO2dCQUNuQyxJQUFNLElBQUksR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFBO2dCQUM3QixLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQTtnQkFDekIsT0FBTyxJQUFBLGlCQUFTLEVBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFBO1lBQy9CLENBQUMsQ0FBQyxDQUFBO1FBQ0osQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7OztXQWNHO1FBQ0ksMEJBQVUsR0FBakIsVUFBa0IsR0FBWTtZQUM1QixHQUFHLEdBQUcsR0FBRyxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQTtZQUN2QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUE7UUFDNUIsQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FxQkc7UUFDSSwyQkFBVyxHQUFsQjtZQUFBLGlCQUtDO1lBSkMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFBO1lBQ3BCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQUMsR0FBRztnQkFDekMsT0FBTyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEtBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUMsQ0FBQTtZQUNqRCxDQUFDLENBQWlCLENBQUE7UUFDcEIsQ0FBQztRQUVEOzs7Ozs7Ozs7Ozs7Ozs7O1dBZ0JHO1FBQ0ksMEJBQVUsR0FBakIsVUFBa0IsT0FBZSxFQUFFLEdBQVk7WUFDN0MsR0FBRyxHQUFHLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUE7WUFDdkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFBO1FBQ25FLENBQUM7UUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FvQkc7UUFDSSw2QkFBYSxHQUFwQixVQUFxQixHQUFZO1lBQy9CLEdBQUcsR0FBRyxHQUFHLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFBO1lBQ3ZCLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUE7WUFDbkMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFBO1lBQzFCLE9BQU8sT0FBTyxDQUFBO1FBQ2hCLENBQUM7UUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBd0JHO1FBQ0ksOEJBQWMsR0FBckI7WUFBQSxpQkFPQztZQU5DLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQTtZQUNwQixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFDLEdBQUc7Z0JBQ3pDLElBQU0sT0FBTyxHQUFHLEtBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUE7Z0JBQ25DLE9BQU8sS0FBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQTtnQkFDMUIsT0FBTyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBQyxDQUFBO1lBQ3JDLENBQUMsQ0FBaUIsQ0FBQTtRQUNwQixDQUFDO1FBRUQ7Ozs7Ozs7Ozs7Ozs7V0FhRztRQUNJLDJCQUFXLEdBQWxCLFVBQW1CLEdBQVc7WUFDNUIsT0FBTyxJQUFBLG1CQUFXLEVBQUMsR0FBRyxDQUFDLENBQUE7UUFDekIsQ0FBQztRQUVELGdCQUFnQjtRQUNULHFCQUFLLEdBQVo7WUFDRSxJQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFBO1lBQ3pCLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQTtZQUMxQixLQUFLLENBQUMsUUFBUSw0QkFBTyxJQUFJLENBQUMsUUFBUSxTQUFDLENBQUE7WUFDbkMsS0FBSyxDQUFDLE9BQU8sZ0JBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFBO1lBQ2pDLEtBQUssQ0FBQyxTQUFTLGdCQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQTtZQUNyQyxPQUFPLEtBQUssQ0FBQTtRQUNkLENBQUM7UUFFRCxnQkFBZ0I7UUFDVCxxQkFBSyxHQUFaLFVBQWEsS0FBYTtZQUN4QixJQUFNLEtBQUssR0FBRyxJQUFBLHFCQUFhLEVBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFBO1lBQzFELElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQTtZQUNiLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFBO1lBRTlCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2hELElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7Z0JBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUM3QixJQUFJLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO3dCQUNqQixJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQTt3QkFDekMsS0FBSyxJQUFJLFdBQVcsQ0FBQTtxQkFDckI7eUJBQU07d0JBQ0wsS0FBSyxFQUFFLENBQUE7cUJBQ1I7aUJBQ0Y7Z0JBQ0QsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFBO2FBQ2hCO1lBRUQsT0FBTyxLQUFLLENBQUE7UUFDZCxDQUFDO1FBRUQ7Ozs7Ozs7O1dBUUc7UUFDTywyQkFBVyxHQUFyQjtZQUNFLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFBO1lBQzNCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQztnQkFBRSxPQUFNO1lBRXBDLElBQUksR0FBRyxLQUFLLDRCQUFnQixFQUFFO2dCQUM1QixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQTtnQkFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUE7YUFDMUI7aUJBQU07Z0JBQ0wsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFBO2dCQUM1QixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUE7YUFDM0I7UUFDSCxDQUFDO1FBRUQsZ0JBQWdCO1FBQ04sNkJBQWEsR0FBdkI7WUFBQSxpQkFrQkM7WUFqQkMsSUFBTSxRQUFRLEdBQWEsRUFBRSxDQUFBO1lBRTdCLElBQU0sWUFBWSxHQUFHLFVBQUMsR0FBVztnQkFDL0IsSUFBSSxHQUFHLElBQUksS0FBSSxDQUFDLFNBQVMsRUFBRTtvQkFDekIsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUE7aUJBQ3BDO1lBQ0gsQ0FBQyxDQUFBO1lBRUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQyxFQUF1QjtvQkFBZCxZQUFZLFdBQUE7Z0JBQzFDLEtBQUssR0FBRyxZQUFZLENBQUE7Z0JBQ3BCLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7WUFDekIsQ0FBQyxDQUFDLENBQUE7WUFFRixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFBO1lBQ3ZCLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7WUFFdkIsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUE7UUFDM0IsQ0FBQztRQUVEOzs7O1dBSUc7UUFDTywyQkFBVyxHQUFyQixVQUFzQixJQUFZO1lBQ2hDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUMsQ0FBQTtRQUN6RCxDQUFDO1FBRUQsZ0JBQWdCO1FBQ04sd0JBQVEsR0FBbEIsVUFBbUIsS0FBYSxFQUFFLE1BQWM7WUFDOUMsT0FBTyxJQUFBLGtCQUFVLEVBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUE7UUFDL0MsQ0FBQztRQUVELGdCQUFnQjtRQUNOLDRCQUFZLEdBQXRCLFVBQXVCLEtBQVk7WUFDakMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUEsaUJBQVMsRUFBQyxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBO1FBQ2xFLENBQUM7UUFFRCxnQkFBZ0I7UUFDTix3QkFBUSxHQUFsQixVQUFtQixJQUFhO1lBQzlCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO2dCQUNqQixJQUFJLEVBQUUsSUFBSTtnQkFDVixLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU07YUFDbkIsQ0FBQyxDQUFBO1lBQ0YsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFBLGdCQUFRLEVBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQTtRQUMzQyxDQUFDO1FBRUQsZ0JBQWdCO1FBQ04sd0JBQVEsR0FBbEI7WUFDRSxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFBO1lBQ2hDLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtnQkFDaEIsT0FBTyxJQUFJLENBQUE7YUFDWjtZQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQTtZQUN4QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUE7UUFDbEIsQ0FBQztRQUNILFlBQUM7SUFBRCxDQUFDLEFBM3NDRCxJQTJzQ0M7SUEzc0NZLHNCQUFLOzs7Ozs7SUN2Q2xCO1FBYUksZUFBWSxJQUFVO1lBVHRCLGlCQUFZLEdBQVcsRUFBRSxDQUFBO1lBQ3pCLGlCQUFZLEdBQVcsRUFBRSxDQUFBO1lBSXpCLHdCQUFtQixHQUE2QixFQUFFLENBQUE7WUFLOUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLGFBQUssRUFBRSxDQUFBO1lBQzVCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxRQUFRLEVBQUUsQ0FBQTtZQUM1QixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUEsQ0FBQyx3QkFBd0I7WUFDbEYsSUFBSSxDQUFDLHFCQUFxQixHQUFHLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1lBQzlELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsQ0FBQTtZQUNqQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLENBQUE7WUFDdEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLHlCQUFXLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUE7WUFDOUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUE7WUFDbkMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGtCQUFVLENBQUMsS0FBSyxDQUFDLENBQUE7WUFDekQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGtCQUFVLENBQUMsS0FBSyxDQUFDLENBQUE7WUFDekQsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFBO1lBQ3BCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFBO1lBQ2hCLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFBO1lBRWpCLDhCQUE4QjtRQUNsQyxDQUFDO1FBRUQsMkNBQTJDO1FBQzNDLGtDQUFrQixHQUFsQixVQUFtQixjQUFxQjtZQUNwQyxJQUFJLGNBQWMsSUFBSSxRQUFRLEVBQUM7Z0JBQzNCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFBO2dCQUN2QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQTtnQkFDbkMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7Z0JBQ3JDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFBO2dCQUNqQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQSxDQUFDLHNCQUFzQjtnQkFDbEUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUE7YUFDeEM7aUJBRUksSUFBRyxjQUFjLElBQUksYUFBYSxFQUFDO2dCQUNwQyxJQUFJLENBQUMscUJBQXFCLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQTtnQkFDNUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEtBQUssR0FBRyxLQUFLLENBQUE7Z0JBQ3hDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFBO2dCQUN6QyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQTtnQkFDdEMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUEsQ0FBQyxzQkFBc0I7Z0JBQ3hFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFBO2dCQUN6QyxJQUFJLENBQUMscUJBQXFCLENBQUMsU0FBUyxHQUFHLGlCQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQTtnQkFDdEUsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsR0FBRyxpQkFBUyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUE7Z0JBQ3JFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEdBQUUsS0FBSyxDQUFBO2dCQUM1QyxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxHQUFFLEtBQUssQ0FBQSxDQUFDLDZCQUE2QjthQUM5RTtRQUNMLENBQUM7UUFFRCxvQ0FBb0M7UUFDcEMsK0JBQStCO1FBQy9CLG1DQUFtQztRQUNuQyxxQ0FBcUM7UUFFckMsU0FBUztRQUNULElBQUk7UUFFSix3Q0FBd0M7UUFDeEMsNkJBQWEsR0FBYjtZQUNJLElBQU0sS0FBSyxHQUE4QixFQUFFLENBQUM7WUFDNUMsSUFBSSxNQUFNLEdBQVUsSUFBSSxDQUFBO1lBQ3hCLElBQUksV0FBVyxHQUFZLEtBQUssQ0FBQTtZQUNoQyxJQUFJLFNBQVMsR0FBVSxDQUFDLEVBQUUsU0FBUyxHQUFVLENBQUMsQ0FBQTtZQUM5QyxPQUFPLENBQUMsV0FBVyxFQUFDO2dCQUNoQixNQUFNLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLEdBQUcsU0FBUyxDQUFDLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLEdBQUcsU0FBUyxDQUFDLENBQUM7Z0JBQ25GLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLGVBQU0sQ0FBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO2dCQUNoRCxJQUFHLFNBQVMsSUFBSSxDQUFDLElBQUksU0FBUyxJQUFJLENBQUMsRUFBQztvQkFDaEMsV0FBVyxHQUFHLElBQUksQ0FBQTtpQkFDckI7cUJBQ0ksSUFBRyxTQUFTLElBQUksQ0FBQyxFQUFDO29CQUNuQixTQUFTLEdBQUcsQ0FBQyxDQUFDO29CQUNkLFNBQVMsRUFBRSxDQUFDO2lCQUNmOztvQkFDSSxTQUFTLEVBQUUsQ0FBQzthQUNwQjtZQUVELE9BQU8sS0FBSyxDQUFBO1FBQ2hCLENBQUM7UUFFRCxnRUFBZ0U7UUFDaEUsOEJBQWMsR0FBZCxVQUFlLEtBQWlCO1lBQWhDLGlCQXdFQztZQXZFRyxJQUFJLE1BQU0sR0FBWSxFQUFFLENBQUE7b0NBR2YsQ0FBQztnQkFDTixJQUFJLE1BQU0sR0FBVSxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBVSxDQUFDLEtBQUssSUFBSSxrQkFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQTtnQkFDaEcsSUFBSSxRQUFNLEdBQVUsTUFBTSxHQUFHLEdBQUcsQ0FBQTtnQkFDaEMsSUFBSSxJQUFJLEdBQVMsSUFBSSxhQUFLLENBQUMsS0FBSyxFQUFFLGlCQUFTLENBQUMsSUFBSSxFQUFFLFFBQU0sRUFBRyxPQUFLLE1BQU0sQ0FBQyxDQUFBO2dCQUN2RSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLGFBQWEsQ0FBQztvQkFDbkMsSUFBRyxDQUFDLEtBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO3dCQUN6QixLQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUE7Z0JBQ3RDLENBQUMsQ0FBQyxDQUFBO2dCQUVGLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7OztZQVZyQixPQUFPO1lBQ1AsS0FBSyxJQUFJLENBQUMsR0FBUSxFQUFFLEVBQUUsQ0FBQyxJQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUU7d0JBQXhCLENBQUM7YUFVVDtvQ0FHTyxDQUFDO2dCQUNMLElBQUksTUFBTSxHQUFVLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFVLENBQUMsS0FBSyxJQUFJLGtCQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFBO2dCQUNoRyxJQUFJLFFBQU0sR0FBVSxNQUFNLEdBQUcsR0FBRyxDQUFBO2dCQUNoQyxJQUFJLE1BQU0sR0FBUyxJQUFJLGFBQUssQ0FBQyxLQUFLLEVBQUUsaUJBQVMsQ0FBQyxNQUFNLEVBQUUsUUFBTSxFQUFHLE9BQUssTUFBTSxDQUFDLENBQUE7Z0JBQzNFLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksYUFBYSxDQUFDO29CQUNyQyxJQUFHLENBQUMsS0FBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUU7d0JBQ3pCLEtBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQTtnQkFDeEMsQ0FBQyxDQUFDLENBQUE7Z0JBQ0YsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTs7O1lBVHZCLFFBQVE7WUFDUixLQUFJLElBQUksQ0FBQyxHQUFRLEVBQUUsRUFBRSxDQUFDLElBQUUsR0FBRyxFQUFFLENBQUMsR0FBQyxDQUFDLEdBQUMsQ0FBQzt3QkFBMUIsQ0FBQzthQVNSO29DQUdPLENBQUM7Z0JBQ0wsSUFBSSxNQUFNLEdBQVUsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLEdBQVUsQ0FBQyxLQUFLLElBQUksa0JBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUE7Z0JBQ2hHLElBQUksUUFBTSxHQUFVLE1BQU0sR0FBRyxHQUFHLENBQUE7Z0JBQ2hDLElBQUksTUFBTSxHQUFTLElBQUksYUFBSyxDQUFDLEtBQUssRUFBRSxpQkFBUyxDQUFDLE1BQU0sRUFBRSxRQUFNLEVBQUcsT0FBSyxNQUFNLENBQUMsQ0FBQTtnQkFDM0UsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxhQUFhLENBQUM7b0JBQ3JDLElBQUcsQ0FBQyxLQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRTt3QkFDekIsS0FBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFBO2dCQUN4QyxDQUFDLENBQUMsQ0FBQTtnQkFDRixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBOzs7WUFUdkIsU0FBUztZQUNULEtBQUksSUFBSSxDQUFDLEdBQVEsRUFBRSxFQUFFLENBQUMsSUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFDLENBQUMsR0FBQyxDQUFDO3dCQUExQixDQUFDO2FBU1I7b0NBR08sQ0FBQztnQkFDTCxJQUFJLE1BQU0sR0FBVSxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBVSxDQUFDLEtBQUssSUFBSSxrQkFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQTtnQkFDaEcsSUFBSSxRQUFNLEdBQVUsTUFBTSxHQUFHLEdBQUcsQ0FBQTtnQkFDaEMsSUFBSSxJQUFJLEdBQVMsSUFBSSxhQUFLLENBQUMsS0FBSyxFQUFFLGlCQUFTLENBQUMsSUFBSSxFQUFFLFFBQU0sRUFBRyxPQUFLLE1BQU0sQ0FBQyxDQUFBO2dCQUN2RSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLGFBQWEsQ0FBQztvQkFDbkMsSUFBRyxDQUFDLEtBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO3dCQUN6QixLQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUE7Z0JBQ3RDLENBQUMsQ0FBQyxDQUFBO2dCQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7OztZQVRyQixNQUFNO1lBQ04sS0FBSSxJQUFJLENBQUMsR0FBUSxFQUFFLEVBQUUsQ0FBQyxJQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUMsQ0FBQyxHQUFDLENBQUM7d0JBQTFCLENBQUM7YUFTUjtZQUVELE9BQU87WUFDUCxJQUFJLE1BQU0sR0FBVSxDQUFDLEtBQUssSUFBSSxrQkFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQTtZQUM3RCxJQUFJLEtBQUssR0FBUyxJQUFJLGFBQUssQ0FBQyxLQUFLLEVBQUUsaUJBQVMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTtZQUN6RSxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLGFBQWEsQ0FBQztnQkFDcEMsSUFBRyxDQUFDLEtBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO29CQUN6QixLQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUE7WUFDdkMsQ0FBQyxDQUFDLENBQUE7WUFDRixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO1lBRWxCLE1BQU07WUFDTixNQUFNLEdBQUcsQ0FBQyxLQUFLLElBQUksa0JBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUE7WUFDbEQsSUFBSSxJQUFJLEdBQVMsSUFBSSxhQUFLLENBQUMsS0FBSyxFQUFFLGlCQUFTLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7WUFDdkUsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxhQUFhLENBQUM7Z0JBQ25DLElBQUcsQ0FBQyxLQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRTtvQkFDekIsS0FBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFBO1lBQ3RDLENBQUMsQ0FBQyxDQUFBO1lBQ0YsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUVqQixPQUFPLE1BQU0sQ0FBQTtRQUVqQixDQUFDO1FBR0QsMkJBQTJCO1FBQzNCLDZCQUFhLEdBQWI7WUFDSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQTtZQUNwQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUE7WUFDMUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsVUFBQyxXQUFXLEVBQUUsS0FBSztnQkFDekMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUNuQyxDQUFDLENBQUMsQ0FBQTtZQUVGLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQUMsV0FBVyxFQUFFLEtBQUs7Z0JBQ3pDLFdBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUE7WUFDbkMsQ0FBQyxDQUFDLENBQUE7UUFDTixDQUFDO1FBRUQsMkJBQTJCO1FBQzNCLHlCQUFTLEdBQVQsVUFBVSxLQUFZLEVBQUUsUUFBZ0I7WUFBeEMsaUJBb0NDO1lBbkNHLElBQUcsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBLENBQUMsd0JBQXdCO2dCQUN0RCxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQTtnQkFDekIsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFBO2dCQUNoQixJQUFJLEtBQUssR0FBVSxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUE7Z0JBQ25DLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFBO2dCQUN6QixJQUFHLFFBQVEsSUFBSSxLQUFLLEVBQUM7b0JBQ2pCLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxJQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtvQkFDN0MsSUFBSSxNQUFJLEdBQVMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLElBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFBO29CQUM1RCxNQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssSUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUE7b0JBQzVDLE1BQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksYUFBYSxDQUFDO3dCQUN6RCxLQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBSSxDQUFDLENBQUE7b0JBQ2xDLENBQUMsQ0FBQyxDQUFBO2lCQUNMO3FCQUVJLElBQUcsUUFBUSxJQUFJLE9BQU8sRUFBQztvQkFDeEIsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLElBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFBO29CQUM3QyxJQUFJLE1BQUksR0FBUyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssSUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUE7b0JBQzVELE1BQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxJQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtvQkFDNUMsTUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxhQUFhLENBQUM7d0JBQ3pELEtBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFJLENBQUMsQ0FBQTtvQkFDbEMsQ0FBQyxDQUFDLENBQUE7aUJBQ0w7Z0JBQ0QsYUFBYTs7b0JBRVQsS0FBSyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtnQkFFdkQsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUUsSUFBSSxhQUFhLENBQUM7b0JBQ3pELEtBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQTtnQkFDbkMsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsNERBQTREO2dCQUM1RCxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQTtnQkFDMUUsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUEsQ0FBQywwRUFBMEU7YUFDL0Y7UUFDTCxDQUFDO1FBRUQsd0JBQXdCO1FBQ3hCLHdCQUFRLEdBQVIsVUFBUyxRQUFlO1lBQ3BCLG9GQUFvRjtZQUNwRixLQUFJLElBQUksQ0FBQyxHQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUM7Z0JBQ3BELElBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQUksUUFBUSxFQUFDO29CQUN6QyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUE7aUJBQzlCO2FBQ0o7WUFDRCxLQUFJLElBQUksQ0FBQyxHQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUM7Z0JBQ3BELElBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQUksUUFBUSxFQUFDO29CQUN6QyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUE7aUJBQzlCO2FBQ0o7WUFFRCxJQUFJLEtBQUssR0FBVSxJQUFJLGFBQUssQ0FBQyxrQkFBVSxDQUFDLEtBQUssRUFBRSxpQkFBUyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1lBQ2pGLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUE7WUFDMUIsT0FBTyxLQUFLLENBQUM7UUFDakIsQ0FBQztRQUVELDJIQUEySDtRQUMzSCxnRUFBZ0U7UUFDaEUsbUNBQW1CLEdBQW5CLFVBQW9CLEtBQVk7WUFBaEMsaUJBc0dDO1lBckdHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFBO1lBQ3pCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFBO1lBQ3ZCLElBQUksTUFBTSxHQUFVLEtBQUssQ0FBQyxRQUFRLENBQUEsQ0FBMEIsZ0JBQWdCO1lBQzVFLElBQUksS0FBSyxHQUFZLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUMsTUFBTSxFQUFFLE1BQU0sRUFBQyxDQUFDLENBQUEsQ0FBQywwQkFBMEI7WUFDdEYsaUNBQWlDO1lBQ2pDLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJO2dCQUNmLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBQyxFQUFFLENBQUMsQ0FBQTtnQkFDM0IsSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFDLEVBQUUsQ0FBQyxDQUFBO2dCQUMzQixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUE7Z0JBQ1QsZ0JBQWdCO2dCQUNoQixJQUFHLElBQUksSUFBSSxLQUFLLEVBQUM7b0JBQ2IsSUFBSSxlQUFlLEdBQVUsS0FBSyxDQUFDLFFBQVEsRUFBRSxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUE7b0JBQ3RFLElBQUksUUFBTSxHQUFVLElBQUksZUFBTSxDQUFDLGVBQWUsRUFBRSxLQUFJLENBQUMsTUFBTSxFQUFFLHlCQUF5QixHQUFHLElBQUEsc0JBQWMsRUFBQyxlQUFlLENBQUMsR0FBRyxhQUFhLENBQUMsQ0FBQTtvQkFDekksUUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxhQUFhLENBQUM7d0JBQ3JDLEtBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsaUJBQWlCLEVBQUUsS0FBSyxDQUFDLFFBQVEsRUFBQyxDQUFDLENBQUEsQ0FBQywwSEFBMEg7d0JBQ3pNLEtBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFBO29CQUVoQyxDQUFDLENBQUMsQ0FBQTtvQkFDRixLQUFJLENBQUMsbUJBQW1CLENBQUMsZUFBZSxDQUFDLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQTtpQkFDNUU7Z0JBQ0QsZUFBZTtxQkFDVixJQUFHLElBQUksSUFBSSxPQUFPLEVBQUM7b0JBQ3BCLElBQUksZUFBZSxHQUFVLEtBQUssQ0FBQyxRQUFRLEVBQUUsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFBO29CQUN0RSxJQUFJLFFBQU0sR0FBVSxJQUFJLGVBQU0sQ0FBQyxlQUFlLEVBQUUsS0FBSSxDQUFDLE1BQU0sRUFBRSx5QkFBeUIsR0FBRyxJQUFBLHNCQUFjLEVBQUMsZUFBZSxDQUFDLEdBQUcsYUFBYSxDQUFDLENBQUE7b0JBQ3pJLFFBQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksYUFBYSxDQUFDO3dCQUNyQyxLQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLEtBQUssQ0FBQyxRQUFRLEVBQUMsQ0FBQyxDQUFBLENBQUMsMEhBQTBIO3dCQUUzTSxLQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQTtvQkFFbEMsQ0FBQyxDQUFDLENBQUE7b0JBQ0YsS0FBSSxDQUFDLG1CQUFtQixDQUFDLGVBQWUsQ0FBQyxHQUFHLEtBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUE7aUJBQzVFO2dCQUNELGNBQWM7cUJBQ1QsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFLLENBQUMsQ0FBQyxFQUFDO29CQUM5QixJQUFJLGNBQWMsR0FBVSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUE7b0JBQ3RELElBQUksaUJBQWUsR0FBVSxLQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFBO29CQUMxRCxJQUFHLGlCQUFlLENBQUMsS0FBSyxDQUFDLE9BQU8sSUFBSSxJQUFJLEVBQUMsRUFBdUIsMENBQTBDO3dCQUN0RyxpQkFBZSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxhQUFhLENBQUM7NEJBQzlDLElBQUcsQ0FBQyxLQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxFQUFDO2dDQUMxQixpQkFBZSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO2dDQUN0QyxpQkFBZSxDQUFDLFFBQVEsRUFBRSxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsaUJBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxpQkFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7Z0NBQ3pMLEtBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsaUJBQWlCLEVBQUUsS0FBSyxDQUFDLFFBQVEsRUFBQyxDQUFDLENBQUEsQ0FBQywwSEFBMEg7Z0NBRXhNLEtBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFBOzZCQUU5Qjt3QkFDTCxDQUFDLENBQUMsQ0FBQTtxQkFDTDt5QkFFSSxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsSUFBSSxpQkFBUyxDQUFDLElBQUksRUFBQzt3QkFDeEMsSUFBSSxlQUFlLEdBQVUsRUFBRSxDQUFBO3dCQUMvQixJQUFHLEtBQUssQ0FBQyxLQUFLLElBQUksT0FBTzs0QkFDckIsZUFBZSxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUE7OzRCQUd6RixlQUFlLEdBQUcsY0FBYyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQTt3QkFFN0YsSUFBSSxjQUFZLEdBQUcsS0FBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQTt3QkFDakQsSUFBRyxLQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEtBQUssSUFBSSxNQUFNLElBQUksY0FBWSxDQUFDLEtBQUssQ0FBQyxPQUFPLElBQUksY0FBWSxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFDLEVBQUksZ0JBQWdCOzRCQUNySSxJQUFJLFNBQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSSxDQUFDLE1BQU0sRUFBRSx5QkFBeUIsR0FBRyxJQUFBLHNCQUFjLEVBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsYUFBYSxDQUFDLENBQUE7NEJBQ3hKLFNBQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksYUFBYSxDQUFDO2dDQUNyQyxzQ0FBc0M7Z0NBQ3RDLElBQUcsQ0FBQyxLQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxFQUFDO29DQUMxQixLQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLGlCQUFpQixFQUFFLEtBQUssQ0FBQyxRQUFRLEVBQUMsQ0FBQyxDQUFBLENBQUMsMEhBQTBIO29DQUV4TSxLQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQTtvQ0FFM0IsY0FBWSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO29DQUNuQyxjQUFZLENBQUMsUUFBUSxFQUFFLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxjQUFZLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsY0FBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7aUNBQ25MOzRCQUNMLENBQUMsQ0FBQyxDQUFBOzRCQUNGLEtBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBTSxDQUFBOzRCQUNqRCxLQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTt5QkFDbEc7cUJBQ0o7aUJBQ0o7Z0JBRUQsV0FBVztnQkFDWCxzQ0FBc0M7Z0JBQ3RDLDZEQUE2RDtnQkFDN0Qsa0VBQWtFO2dCQUNsRSxpSEFBaUg7Z0JBQ2pILDRHQUE0RztnQkFDNUcscURBQXFEO2dCQUNyRCx3TUFBd007Z0JBQ3hNLDBDQUEwQztnQkFDMUMsYUFBYTtnQkFDYixRQUFRO2dCQUNSLElBQUk7cUJBRUE7b0JBQ0EsSUFBSSxTQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUksQ0FBQyxNQUFNLEVBQUUseUJBQXlCLEdBQUcsSUFBQSxzQkFBYyxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFBO29CQUN4SixTQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLGFBQWEsQ0FBQzt3QkFDckMsS0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxpQkFBaUIsRUFBRSxLQUFLLENBQUMsUUFBUSxFQUFDLENBQUMsQ0FBQSxDQUFDLDBIQUEwSDt3QkFFeE0sS0FBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUE7b0JBQy9CLENBQUMsQ0FBQyxDQUFBO29CQUNGLEtBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsU0FBTSxDQUFBO29CQUNqRCxLQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtpQkFDbEc7WUFDTCxDQUFDLENBQUMsQ0FBQTtRQUNOLENBQUM7UUFFRCx5RkFBeUY7UUFDekYsa0NBQWtCLEdBQWxCO1lBQUEsaUJBS0M7WUFKRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFDLE1BQU07Z0JBQ2pELEtBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxlQUFNLENBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTtZQUMxRCxDQUFDLENBQUMsQ0FBQTtZQUNGLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLENBQUE7UUFDakMsQ0FBQztRQUVELG1JQUFtSTtRQUNuSSxnQ0FBZ0IsR0FBaEI7WUFBQSxpQkFZQztZQVhHLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBSztnQkFDNUIsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxhQUFhLENBQUM7b0JBQ3BDLEtBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQTtnQkFDbkMsQ0FBQyxDQUFDLENBQUE7WUFDTixDQUFDLENBQUMsQ0FBQTtZQUVGLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBSztnQkFDNUIsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxhQUFhLENBQUM7b0JBQ3BDLEtBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQTtnQkFDbkMsQ0FBQyxDQUFDLENBQUE7WUFDTixDQUFDLENBQUMsQ0FBQTtRQUNOLENBQUM7UUFDTCxZQUFDO0lBQUQsQ0FBQyxBQXpXRCxJQXlXQztJQXpXWSxzQkFBSzs7QVhOZCxlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLDBDQUEwQztBQUMxQyxtQ0FBbUM7QUFDbkMsd0VBQXdFO0FBQ3hFLHdFQUF3RTtBQUN4RSx3R0FBd0c7QUFDeEcsd0dBQXdHO0FBQ3hHLHdCQUF3QjtBQUN4Qiw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLFFBQVE7QUFDUixJQUFJO0FBR1IsdUZBQXVGO0FBQ3ZGLG9DQUFvQztBQUNwQyxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QiwrREFBK0Q7QUFDL0Qsa0NBQWtDO0FBR2xDLDREQUE0RDtBQUM1RCxnREFBZ0Q7QUFDaEQsa0NBQWtDO0FBQ2xDLDRCQUE0QjtBQUM1QixvRkFBb0Y7QUFDcEYsdUJBQXVCO0FBQ3ZCLG1MQUFtTDtBQUNuTCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDZDQUE2QztBQUM3Qyw0Q0FBNEM7QUFDNUMscUNBQXFDO0FBRXJDLG1DQUFtQztBQUNuQyxrR0FBa0c7QUFFbEcsWUFBWTtBQUNaLDBEQUEwRDtBQUMxRCxrQkFBa0I7QUFDbEIsdUNBQXVDO0FBQ3ZDLGdDQUFnQztBQUNoQyxpQkFBaUI7QUFDakIsc0dBQXNHO0FBQ3RHLFFBQVE7QUFDUixjQUFjO0FBQ2QsSUFBSTtBQUVKLHFHQUFxRztBQUNyRyw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQiwrQkFBK0I7QUFDL0Isa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUVsRCxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CLDZGQUE2RjtBQUM3RixnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QiwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsbUZBQW1GO0FBQ25GLG1GQUFtRjtBQUNuRixvQkFBb0I7QUFDcEIsa0NBQWtDO0FBQ2xDLElBQUk7QUFHSixrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CLDZGQUE2RjtBQUM3RixnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QiwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsbUZBQW1GO0FBQ25GLG1GQUFtRjtBQUNuRixvQkFBb0I7QUFDcEIsa0NBQWtDO0FBQ2xDLElBQUk7QUFHSiwrQkFBK0I7QUFDL0IsaUdBQWlHO0FBQ2pHLGtDQUFrQztBQUNsQyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQyxnQkFBZ0I7QUFDaEIsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCxRQUFRO0FBQ1IsWUFBWTtBQUNaLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsUUFBUTtBQUNSLG9DQUFvQztBQUNwQyxJQUFJO0FBR0osK0JBQStCO0FBQy9CLGlHQUFpRztBQUNqRyxrQ0FBa0M7QUFDbEMsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQyxvQ0FBb0M7QUFDcEMsZ0JBQWdCO0FBQ2hCLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsUUFBUTtBQUNSLFlBQVk7QUFDWiwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELFFBQVE7QUFDUixvQ0FBb0M7QUFDcEMsSUFBSTtBQUdKLCtCQUErQjtBQUMvQixpR0FBaUc7QUFDakcsa0NBQWtDO0FBQ2xDLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDLGdCQUFnQjtBQUNoQiwwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELFFBQVE7QUFDUixZQUFZO0FBQ1osMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCxRQUFRO0FBQ1Isb0NBQW9DO0FBQ3BDLElBQUk7QUFFSiwrQkFBK0I7QUFDL0IsaUdBQWlHO0FBQ2pHLGtDQUFrQztBQUNsQyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQyxnQkFBZ0I7QUFDaEIsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCxRQUFRO0FBQ1IsWUFBWTtBQUNaLDBEQUEwRDtBQUMxRCwwREFBMEQ7QUFDMUQsUUFBUTtBQUNSLG9DQUFvQztBQUNwQyxJQUFJO0FBRUosK0JBQStCO0FBQy9CLDZGQUE2RjtBQUM3RixnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QiwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsaUJBQWlCO0FBQ2pCLHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQsUUFBUTtBQUNSLFlBQVk7QUFDWix3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hELFFBQVE7QUFDUixrQ0FBa0M7QUFDbEMsSUFBSTtBQUVKLCtCQUErQjtBQUMvQiw2RkFBNkY7QUFDN0YsZ0NBQWdDO0FBQ2hDLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLGlCQUFpQjtBQUNqQix3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hELFFBQVE7QUFDUixZQUFZO0FBQ1osd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCxRQUFRO0FBQ1Isa0NBQWtDO0FBQ2xDLElBQUk7QUFFSixtR0FBbUc7QUFDbkcsNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQsK0JBQStCO0FBRS9CLG1HQUFtRztBQUNuRyw2QkFBNkI7QUFDN0Isd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0IsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRCwrQkFBK0I7QUFJL0IsaUdBQWlHO0FBQ2pHLDRCQUE0QjtBQUM1Qix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5QixnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELDhCQUE4QjtBQUU5QixpR0FBaUc7QUFDakcsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsOEJBQThCO0FBRTlCLDBDQUEwQztBQUMxQyw4RkFBOEY7QUFDOUYsOEZBQThGO0FBQzlGLElBQUk7QVluUko7Ozs7Ozs7R0FPRzs7Ozs7SUNMSDtRQUlJLGVBQVksS0FBWSxFQUFFLEtBQVksRUFBRSxNQUFlO1lBQ25ELElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFBO1lBQ2xCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUE7WUFDL0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFBO1lBQ25DLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQTtZQUN4QixJQUFHLEtBQUssSUFBSSxPQUFPLEVBQUM7Z0JBQ2hCLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLGlCQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQTtnQkFDckQsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsaUJBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFBO2FBQ3hEO2lCQUNHO2dCQUNBLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLGlCQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQTtnQkFDckQsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsaUJBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFBO2FBQ3hEO1lBQ0QsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFBO1FBQ3RCLENBQUM7UUFFRCwyQkFBVyxHQUFYO1lBQ0ksSUFBSSxPQUFPLEdBQVUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFBO1lBQ3pELElBQUksT0FBTyxHQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUE7WUFDM0QsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBQztnQkFDcEIsT0FBTyxHQUFHLEdBQUcsR0FBRyxPQUFPLENBQUE7YUFDMUI7WUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxPQUFPLEdBQUMsR0FBRyxHQUFDLE9BQU8sQ0FBQTtRQUMxQyxDQUFDO1FBQ0wsWUFBQztJQUFELENBQUMsQUE1QkQsSUE0QkM7SUE1Qlksc0JBQUs7O0FDRmxCLEVBQUU7QUFDRixjQUFjO0FBQ2QsK0VBQStFO0FBQy9FLEVBQUU7QUFDRixvQ0FBb0M7QUFDcEMsOENBQThDO0FBQzlDLHdDQUF3QztBQUN4QyxzQ0FBc0M7Ozs7O0lBV3RDLFNBQXNCLFdBQVc7Ozs7NEJBQ3BCLHFCQUFNLElBQUEsc0JBQVcsR0FBRSxFQUFBOzt3QkFBOUIsZ0JBQVEsR0FBRyxTQUFtQixDQUFBOzs7OztLQUMvQjtJQUZELGtDQUVDO0lBRUQsU0FBc0IsT0FBTyxDQUFDLFFBQWdCLEVBQUUsT0FBaUI7UUFBakIsd0JBQUEsRUFBQSxZQUFpQjs7Ozs7NEJBQzdDLHFCQUFNLElBQUEsOEJBQWEsR0FBRSxFQUFBOzt3QkFBakMsU0FBUyxHQUFHLFNBQXFCO3dCQUN6QixxQkFBTSxJQUFBLGdDQUFlLEdBQUU7NEJBRXJDLEVBQUU7NEJBQ0YsNERBQTREOzRCQUM1RCxFQUFFOzBCQUptQzs7d0JBQS9CLEtBQUssR0FBRyxTQUF1Qjt3QkFFckMsRUFBRTt3QkFDRiw0REFBNEQ7d0JBQzVELEVBQUU7d0JBQ0YsSUFBSSxTQUFTLEVBQUU7NEJBQ2IsT0FBTyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUE7eUJBQ3ZCOzZCQUFNOzRCQUNMLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLFdBQVcsQ0FBQTt5QkFDbkM7NkJBRUcsQ0FBQyxnQkFBUSxFQUFULHdCQUFTO3dCQUNYLHFCQUFNLFdBQVcsRUFBRSxFQUFBOzt3QkFBbkIsU0FBbUIsQ0FBQTs7O3dCQUVyQixPQUFPLENBQUMsUUFBUSxHQUFHLGdCQUFRLENBQUE7d0JBRTNCLEdBQUcsQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUE7d0JBR3BCLFFBQVEsR0FBRyxTQUFTOzRCQUN4QixDQUFDLENBQUMscUJBQXFCLENBQUMsb0JBQW9COzRCQUM1QyxDQUFDLENBQUMsMkJBQTJCLENBQUMseUJBQXlCO3dCQUExQixDQUFBO3dCQUUvQixJQUFJLFNBQVMsRUFBRTs0QkFDYixxQkFBcUIsQ0FBQyxRQUFRLENBQUMsQ0FBQTt5QkFDaEM7d0JBQ0ssTUFBTSxHQUFHLElBQUksb0JBQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQTs7Ozt3QkFNcEIscUJBQU0sTUFBTSxDQUFDLFlBQVksQ0FBTSxRQUFRLEVBQUUsT0FBTyxDQUFDLEVBQUE7O3dCQUF4RCxJQUFJLEdBQUcsU0FBaUQ7d0JBQzlELElBQUksU0FBUyxFQUFFOzRCQUNiLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFBO3lCQUMvQjt3QkFFRCxzQkFBTyxJQUFJLEVBQUE7Ozt3QkFFWCx1QkFBdUIsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUE7d0JBQ2hELE1BQU0sR0FBQyxDQUFBOzs7OztLQUVWO0lBNUNELDBCQTRDQztJQUVELElBQUksT0FBZSxDQUFBO0lBRW5CLFNBQVMscUJBQXFCLENBQUMsUUFBZ0I7UUFDN0MsSUFBTSxNQUFNLEdBQUcsSUFBSSxRQUFRLEVBQUUsQ0FBQTtRQUM3QixPQUFPLEdBQUcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUE7UUFDNUIsT0FBTyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUE7UUFDckIsT0FBTyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUE7UUFDbkIsT0FBTyxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUE7UUFDbkIsT0FBTyxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUE7UUFDN0IsT0FBTyxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUE7UUFDekIsT0FBTyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsQ0FBQTtRQUN2Qix1QkFBdUIsQ0FBQyx3QkFBaUIsUUFBUSxDQUFFLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUE7SUFDdEUsQ0FBQztJQUVELFNBQVMsdUJBQXVCLENBQUMsS0FBYSxFQUFFLEtBQWE7UUFDM0QsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUE7UUFDckIsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUE7SUFDdkIsQ0FBQztJQUVELFNBQVMsd0JBQXdCLENBQUMsSUFBVTtRQUMxQyx1QkFBdUIsQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUE7UUFDckQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFNLE9BQUEsdUJBQXVCLENBQUMsaUJBQWlCLEVBQUUsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQXhELENBQXdELENBQUMsQ0FBQTtJQUM5RSxDQUFDOzs7OztJQ25GRCxJQUFBLG9CQUFPLEVBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsSUFBSTtRQUczQiw4QkFBOEI7UUFDOUIsSUFBSSxXQUFXLEdBQVUsR0FBRyxDQUFBO1FBQzVCLElBQUksV0FBVyxHQUFVLEdBQUcsQ0FBQTtRQUU1QjtZQUFBO2dCQUNFLHNFQUFzRTtnQkFDdEUsVUFBSyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQTtZQVk3QyxDQUFDO1lBVkMsOEJBQU0sR0FBTixVQUFPLEVBQVU7OztvQkFDZix5Q0FBeUM7b0JBQ3pDLEtBQW1CLElBQUEsS0FBQSxTQUFBLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFBLGdCQUFBLDRCQUFFO3dCQUFuQyxJQUFJLE1BQU0sV0FBQTt3QkFDYiw0Q0FBNEM7d0JBQzVDLElBQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUE7d0JBRWhELHNCQUFzQjt3QkFDdEIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFBO3FCQUN4Qzs7Ozs7Ozs7O1lBQ0gsQ0FBQztZQUNILG9CQUFDO1FBQUQsQ0FBQyxBQWRELElBY0M7UUFFRCw2QkFBNkI7UUFDN0I7WUFBQTtnQkFDRSxVQUFLLEdBQUcsTUFBTSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFBO1lBVzdDLENBQUM7WUFWQyw0QkFBTSxHQUFOLFVBQU8sRUFBVTtnQkFDZixLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFBO2dCQUNqRixLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLENBQUE7Z0JBQ3JGLElBQUksV0FBVyxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUM7b0JBQ3pCLDZCQUE2QjtpQkFDOUI7cUJBQ0ksSUFBRyxXQUFXLENBQUMsS0FBSyxJQUFJLENBQUMsRUFBQztvQkFDN0Isc0NBQXNDO2lCQUN2QztZQUNILENBQUM7WUFDSCxrQkFBQztRQUFELENBQUMsQUFaRCxJQVlDO1FBR0QsaURBQWlEO1FBQ2pELHVDQUF1QztRQUV2Qyw0QkFBNEI7UUFFNUIsU0FBUyxTQUFTLENBQUMsQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTO1lBQ2hELG9CQUFvQjtZQUNwQixJQUFNLElBQUksR0FBRyxJQUFJLE1BQU0sRUFBRSxDQUFBO1lBRXpCLGdDQUFnQztZQUNoQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksU0FBUyxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7WUFFcEUsNEJBQTRCO1lBQzVCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxRQUFRLEVBQUUsQ0FBQyxDQUFBO1lBRWpDLCtCQUErQjtZQUMvQixNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFBO1lBRXRCLE9BQU8sSUFBSSxDQUFBO1FBQ2IsQ0FBQztRQUVELElBQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO1FBQy9CLElBQUksS0FBVyxDQUFBO1FBQ2YsSUFBSSxXQUFpQixDQUFBO1FBQ3JCLElBQUksV0FBaUIsQ0FBQTtRQUNyQixJQUFJLENBQUMsWUFBWSxDQUNmLElBQUksYUFBYSxDQUFDO1lBQ2hCLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUE7WUFDM0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQTtZQUMzQyxLQUFLLEdBQUcsSUFBSSxhQUFLLENBQUMsSUFBSSxDQUFDLENBQUE7WUFDdkIsV0FBVyxHQUFHLElBQUksYUFBSyxDQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFBO1lBQzNELFdBQVcsR0FBRyxJQUFJLGFBQUssQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQTtZQUUzRCxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksV0FBVyxFQUFFLENBQUMsQ0FBQTtRQUNyQyxDQUFDLENBQUMsQ0FDSCxDQUFBO1FBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLEVBQUUsVUFBQyxJQUFJO1lBQ25DLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBO1lBQ3hCLDJCQUEyQjtZQUMzQiw0QkFBNEI7WUFDNUIsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtZQUN0QyxJQUFJLEtBQUssR0FBVSxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO1lBQ3pELEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTtZQUNyQyxHQUFHLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUE7WUFDM0IsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQTtZQUNsQixnQ0FBZ0M7UUFDbEMsQ0FBQyxDQUFDLENBQUE7UUFFRixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxVQUFDLElBQUk7WUFDOUIsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUE7UUFDbkIsQ0FBQyxDQUFDLENBQUE7UUFFRixJQUFJLEVBQUUsR0FBRyxJQUFJLE1BQU0sRUFBRSxDQUFBO1FBQ3JCLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxTQUFTLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFBO1FBQ25ELEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxTQUFTLENBQUM7WUFDNUIsUUFBUSxFQUFFLElBQUksT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzlCLEtBQUssRUFBRSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztTQUNsQyxDQUFDLENBQUMsQ0FBQTtRQUNILE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUE7SUFDdEIsQ0FBQyxDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAvLyBzZXRQaWVjZXMoKXtcbiAgICAvLyAgICAgLy9zZXQgcGF3bnNcbiAgICAvLyAgICAgbGV0IGFzY2lpX2NvZGUgPSAnYScuY2hhckNvZGVBdCgwKSBcbiAgICAvLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspe1xuICAgIC8vICAgICAgICAgbGV0IHdoaXRlX3NxdWFyZTpzdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFzY2lpX2NvZGUpKycyJ1xuICAgIC8vICAgICAgICAgbGV0IGJsYWNrX3NxdWFyZTpzdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFzY2lpX2NvZGUpKyc3J1xuICAgIC8vICAgICAgICAgbGV0IHdoaXRlX3Bhd246UGllY2UgPSBuZXcgUGllY2UoUGllY2VDb2xvci5XSElURSwgUGllY2VUeXBlLlBBV04sIHdoaXRlX3NxdWFyZSwgdGhpcy5jYW52YXMpXG4gICAgLy8gICAgICAgICBsZXQgYmxhY2tfcGF3bjpQaWVjZSA9IG5ldyBQaWVjZShQaWVjZUNvbG9yLkJMQUNLLCBQaWVjZVR5cGUuUEFXTiwgYmxhY2tfc3F1YXJlLCB0aGlzLmNhbnZhcylcbiAgICAvLyAgICAgICAgIGFzY2lpX2NvZGUrKztcbiAgICAvLyAgICAgICAgIHRoaXMud2hpdGVfcGllY2VzLnB1c2god2hpdGVfcGF3bilcbiAgICAvLyAgICAgICAgIHRoaXMuYmxhY2tfcGllY2VzLnB1c2goYmxhY2tfcGF3bilcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuXG4vLyBleHBvcnQgY29uc3QgY2FudmFzQ29udGFpbmVyID0gbmV3IFVJQ29udGFpbmVyU3RhY2soY2FudmFzKSAvL2RlY2xhcmUgcGFyZW50IGVsZW1lbnRcbi8vIGNhbnZhc0NvbnRhaW5lci5hZGFwdFdpZHRoID0gdHJ1ZVxuLy8gY2FudmFzQ29udGFpbmVyLndpZHRoID0gXCI3MCVcIlxuLy8gY2FudmFzQ29udGFpbmVyLmhlaWdodCA9IFwiMTAwJVwiXG4vLyBjYW52YXNDb250YWluZXIub3BhY2l0eSA9IDFcbi8vIGNhbnZhc0NvbnRhaW5lci5jb2xvciA9IENvbG9yNC5HcmF5KCkgLy9zZXQgYmFja2dyb3VuZC1jb2xvclxuLy8gY2FudmFzQ29udGFpbmVyLnZpc2libGUgPSBmYWxzZVxuXG5cbi8vIC8vc2V0cyBhbGwgdGhlIGNhbnZhcyBlbGVtZW50cyB2aXNpYmlsaXR5IHRvIHR5cGUncyB2YWx1ZVxuLy8gY29uc3QgYm9hcmQ6IHsgW2tleTogc3RyaW5nXTogVUlJbWFnZSB9ID0ge307XG4vLyBsZXQgYm9hcmRCdWlsdDogYm9vbGVhbiA9IGZhbHNlXG4vLyBsZXQgc3F1YXJlOnN0cmluZyA9ICdhMScgXG4vLyBsZXQgY291bnQ6bnVtYmVyID0gMCAvL2tlZXBzIHRyYWNrIG9uIHdoZXRoZXIgdGhlIHNxdWFyZSBzaG91bGQgYmUgYmxhY2sgb3Igd2hpdGVcbi8vIHdoaWxlICghYm9hcmRCdWlsdCl7XG4vLyAgICAgYm9hcmRbc3F1YXJlXSA9IGNvdW50JTI9PTAgPyBuZXcgVUlJbWFnZShjYW52YXMsIG5ldyBUZXh0dXJlKFwiaW1hZ2VzL2NoZXNzYm9hcmQvYmxhY2stc3F1YXJlLnBuZ1wiKSkgOiBuZXcgVUlJbWFnZShjYW52YXMsIG5ldyBUZXh0dXJlKFwiaW1hZ2VzL2NoZXNzYm9hcmQvd2hpdGUtc3F1YXJlLnBuZ1wiKSlcbi8vICAgICBib2FyZFtzcXVhcmVdLnBvc2l0aW9uWCA9IHNxdWFyZU1hcFtzcXVhcmVdLnhQb3NpdGlvblxuLy8gICAgIGJvYXJkW3NxdWFyZV0ucG9zaXRpb25ZID0gc3F1YXJlTWFwW3NxdWFyZV0ueVBvc2l0aW9uXG4vLyAgICAgYm9hcmRbc3F1YXJlXS5oZWlnaHQgPSA2NC9yZXNpemVGYWN0b3Jcbi8vICAgICBib2FyZFtzcXVhcmVdLndpZHRoID0gNjQvcmVzaXplRmFjdG9yXG4vLyAgICAgYm9hcmRbc3F1YXJlXS52aXNpYmxlID0gZmFsc2UgXG5cbi8vICAgICBpZiAoc3F1YXJlLmNoYXJBdCgwKSAhPSAnaCcpXG4vLyAgICAgICAgIHNxdWFyZSA9IHNxdWFyZS5yZXBsYWNlKHNxdWFyZS5jaGFyQXQoMCksIFN0cmluZy5mcm9tQ2hhckNvZGUoc3F1YXJlLmNoYXJDb2RlQXQoMCkrMSkpO1xuICAgIFxuLy8gICAgIGVsc2V7XG4vLyAgICAgICAgIHNxdWFyZSA9IHNxdWFyZS5yZXBsYWNlKHNxdWFyZS5jaGFyQXQoMCksICdhJyk7XG4vLyAgICAgICAgIGNvdW50LS1cbi8vICAgICAgICAgaWYgKHNxdWFyZS5jaGFyQXQoMSkgPT0gJzgnKVxuLy8gICAgICAgICAgICAgYm9hcmRCdWlsdCA9IHRydWVcbi8vICAgICAgICAgZWxzZSAgXG4vLyAgICAgICAgICAgICBzcXVhcmUgPSBzcXVhcmUucmVwbGFjZShzcXVhcmUuY2hhckF0KDEpLCBTdHJpbmcuZnJvbUNoYXJDb2RlKHNxdWFyZS5jaGFyQ29kZUF0KDEpKzEpKTtcbi8vICAgICB9XG4vLyAgICAgY291bnQrK1xuLy8gfVxuXG4vLyBjb25zdCBjbG9zZUJ1dHRvbjpVSUltYWdlID0gbmV3IFVJSW1hZ2UoY2FudmFzLCBuZXcgVGV4dHVyZShcImltYWdlcy9jaGVzc2JvYXJkL2Nsb3NlLWJ1dHRvbi5wbmdcIikpXG4vLyBjbG9zZUJ1dHRvbi52aXNpYmxlID0gZmFsc2Vcbi8vIGNsb3NlQnV0dG9uLndpZHRoID0gMzJcbi8vIGNsb3NlQnV0dG9uLmhlaWdodCA9IDMyXG4vLyBjbG9zZUJ1dHRvbi5zb3VyY2VMZWZ0ID0gMFxuLy8gY2xvc2VCdXR0b24uc291cmNlVG9wID0gMFxuLy8gY2xvc2VCdXR0b24uc291cmNlV2lkdGggPSA4NjBcbi8vIGNsb3NlQnV0dG9uLnNvdXJjZUhlaWdodCA9IDg5NlxuLy8gY2xvc2VCdXR0b24uaEFsaWduPVwicmlnaHRcIlxuLy8gY2xvc2VCdXR0b24udkFsaWduPVwidG9wXCJcbi8vIGNsb3NlQnV0dG9uLnBvc2l0aW9uWD1cIi0yNDBcIlxuLy8gY2xvc2VCdXR0b24ucG9zaXRpb25ZPXNxdWFyZU1hcFsnZTEnXS55UG9zaXRpb25cbi8vIGNsb3NlQnV0dG9uLnBvc2l0aW9uWD1zcXVhcmVNYXBbJ2UyJ10ueFBvc2l0aW9uXG5cbi8vIGxldCBhc2NpaV9jb2RlID0gJ2EnLmNoYXJDb2RlQXQoMCkgXG4vLyBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKyl7XG4vLyAgICAgY29uc3Qgd2hpdGVQYXduID0gbmV3IFVJSW1hZ2UoY2FudmFzLCBuZXcgVGV4dHVyZShcImltYWdlcy9jaGVzc2JvYXJkL3doaXRlLXBhd24ucG5nXCIpKVxuLy8gICAgIHdoaXRlUGF3bi52aXNpYmxlID0gZmFsc2Vcbi8vICAgICB3aGl0ZVBhd24ud2lkdGggPSAzMlxuLy8gICAgIHdoaXRlUGF3bi5oZWlnaHQgPSA0OFxuLy8gICAgIHdoaXRlUGF3bi5zb3VyY2VMZWZ0ID0gMFxuLy8gICAgIHdoaXRlUGF3bi5zb3VyY2VUb3AgPSAwXG4vLyAgICAgd2hpdGVQYXduLnNvdXJjZVdpZHRoID0gNjBcbi8vICAgICB3aGl0ZVBhd24uc291cmNlSGVpZ2h0ID0gNzhcbi8vICAgICB3aGl0ZVBhd24ucG9zaXRpb25ZPXNxdWFyZU1hcFtTdHJpbmcuZnJvbUNoYXJDb2RlKGFzY2lpX2NvZGUpKycyJ10ueVBvc2l0aW9uXG4vLyAgICAgd2hpdGVQYXduLnBvc2l0aW9uWD1zcXVhcmVNYXBbU3RyaW5nLmZyb21DaGFyQ29kZShhc2NpaV9jb2RlKSsnMiddLnhQb3NpdGlvblxuLy8gICAgIGFzY2lpX2NvZGUrKztcbi8vICAgICB3aGl0ZVBpZWNlcy5wdXNoKHdoaXRlUGF3bilcbi8vIH1cblxuXG4vLyBhc2NpaV9jb2RlID0gJ2EnLmNoYXJDb2RlQXQoMCkgXG4vLyBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKyl7XG4vLyAgICAgY29uc3QgYmxhY2tQYXduID0gbmV3IFVJSW1hZ2UoY2FudmFzLCBuZXcgVGV4dHVyZShcImltYWdlcy9jaGVzc2JvYXJkL2JsYWNrLXBhd24ucG5nXCIpKVxuLy8gICAgIGJsYWNrUGF3bi52aXNpYmxlID0gZmFsc2Vcbi8vICAgICBibGFja1Bhd24ud2lkdGggPSAzMlxuLy8gICAgIGJsYWNrUGF3bi5oZWlnaHQgPSA0OFxuLy8gICAgIGJsYWNrUGF3bi5zb3VyY2VMZWZ0ID0gMFxuLy8gICAgIGJsYWNrUGF3bi5zb3VyY2VUb3AgPSAwXG4vLyAgICAgYmxhY2tQYXduLnNvdXJjZVdpZHRoID0gNjBcbi8vICAgICBibGFja1Bhd24uc291cmNlSGVpZ2h0ID0gNzhcbi8vICAgICBibGFja1Bhd24ucG9zaXRpb25ZPXNxdWFyZU1hcFtTdHJpbmcuZnJvbUNoYXJDb2RlKGFzY2lpX2NvZGUpKyc3J10ueVBvc2l0aW9uXG4vLyAgICAgYmxhY2tQYXduLnBvc2l0aW9uWD1zcXVhcmVNYXBbU3RyaW5nLmZyb21DaGFyQ29kZShhc2NpaV9jb2RlKSsnNyddLnhQb3NpdGlvblxuLy8gICAgIGFzY2lpX2NvZGUrKztcbi8vICAgICBibGFja1BpZWNlcy5wdXNoKGJsYWNrUGF3bilcbi8vIH1cblxuXG4vLyBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKyl7XG4vLyAgICAgY29uc3QgYmxhY2tLbmlnaHQgPSBuZXcgVUlJbWFnZShjYW52YXMsIG5ldyBUZXh0dXJlKFwiaW1hZ2VzL2NoZXNzYm9hcmQvYmxhY2sta25pZ2h0LnBuZ1wiKSlcbi8vICAgICBibGFja0tuaWdodC52aXNpYmxlID0gZmFsc2Vcbi8vICAgICBibGFja0tuaWdodC53aWR0aCA9IDQ4XG4vLyAgICAgYmxhY2tLbmlnaHQuaGVpZ2h0ID0gNDhcbi8vICAgICBibGFja0tuaWdodC5zb3VyY2VMZWZ0ID0gMFxuLy8gICAgIGJsYWNrS25pZ2h0LnNvdXJjZVRvcCA9IDBcbi8vICAgICBibGFja0tuaWdodC5zb3VyY2VXaWR0aCA9IDgyXG4vLyAgICAgYmxhY2tLbmlnaHQuc291cmNlSGVpZ2h0ID0gODNcbi8vICAgICBpZihpPT0wKXtcbi8vICAgICAgICAgYmxhY2tLbmlnaHQucG9zaXRpb25ZPXNxdWFyZU1hcFsnYjgnXS55UG9zaXRpb25cbi8vICAgICAgICAgYmxhY2tLbmlnaHQucG9zaXRpb25YPXNxdWFyZU1hcFsnYjgnXS54UG9zaXRpb25cbi8vICAgICB9XG4vLyAgICAgZWxzZXtcbi8vICAgICAgICAgYmxhY2tLbmlnaHQucG9zaXRpb25ZPXNxdWFyZU1hcFsnZzgnXS55UG9zaXRpb25cbi8vICAgICAgICAgYmxhY2tLbmlnaHQucG9zaXRpb25YPXNxdWFyZU1hcFsnZzgnXS54UG9zaXRpb25cbi8vICAgICB9XG4vLyAgICAgYmxhY2tQaWVjZXMucHVzaChibGFja0tuaWdodClcbi8vIH1cblxuXG4vLyBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKyl7XG4vLyAgICAgY29uc3Qgd2hpdGVCaXNob3AgPSBuZXcgVUlJbWFnZShjYW52YXMsIG5ldyBUZXh0dXJlKFwiaW1hZ2VzL2NoZXNzYm9hcmQvd2hpdGUtYmlzaG9wLnBuZ1wiKSlcbi8vICAgICB3aGl0ZUJpc2hvcC52aXNpYmxlID0gZmFsc2Vcbi8vICAgICB3aGl0ZUJpc2hvcC53aWR0aCA9IDQ4XG4vLyAgICAgd2hpdGVCaXNob3AuaGVpZ2h0ID0gNDhcbi8vICAgICB3aGl0ZUJpc2hvcC5zb3VyY2VMZWZ0ID0gMFxuLy8gICAgIHdoaXRlQmlzaG9wLnNvdXJjZVRvcCA9IDBcbi8vICAgICB3aGl0ZUJpc2hvcC5zb3VyY2VXaWR0aCA9IDgyXG4vLyAgICAgd2hpdGVCaXNob3Auc291cmNlSGVpZ2h0ID0gODJcbi8vICAgICBpZihpPT0wKXtcbi8vICAgICAgICAgd2hpdGVCaXNob3AucG9zaXRpb25ZPXNxdWFyZU1hcFsnYzEnXS55UG9zaXRpb25cbi8vICAgICAgICAgd2hpdGVCaXNob3AucG9zaXRpb25YPXNxdWFyZU1hcFsnYzEnXS54UG9zaXRpb25cbi8vICAgICB9XG4vLyAgICAgZWxzZXtcbi8vICAgICAgICAgd2hpdGVCaXNob3AucG9zaXRpb25ZPXNxdWFyZU1hcFsnZjEnXS55UG9zaXRpb25cbi8vICAgICAgICAgd2hpdGVCaXNob3AucG9zaXRpb25YPXNxdWFyZU1hcFsnZjEnXS54UG9zaXRpb25cbi8vICAgICB9XG4vLyAgICAgd2hpdGVQaWVjZXMucHVzaCh3aGl0ZUJpc2hvcClcbi8vIH1cblxuXG4vLyBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKyl7XG4vLyAgICAgY29uc3QgYmxhY2tCaXNob3AgPSBuZXcgVUlJbWFnZShjYW52YXMsIG5ldyBUZXh0dXJlKFwiaW1hZ2VzL2NoZXNzYm9hcmQvYmxhY2stYmlzaG9wLnBuZ1wiKSlcbi8vICAgICBibGFja0Jpc2hvcC52aXNpYmxlID0gZmFsc2Vcbi8vICAgICBibGFja0Jpc2hvcC53aWR0aCA9IDQ4XG4vLyAgICAgYmxhY2tCaXNob3AuaGVpZ2h0ID0gNDhcbi8vICAgICBibGFja0Jpc2hvcC5zb3VyY2VMZWZ0ID0gMFxuLy8gICAgIGJsYWNrQmlzaG9wLnNvdXJjZVRvcCA9IDBcbi8vICAgICBibGFja0Jpc2hvcC5zb3VyY2VXaWR0aCA9IDgyXG4vLyAgICAgYmxhY2tCaXNob3Auc291cmNlSGVpZ2h0ID0gODJcbi8vICAgICBpZihpPT0wKXtcbi8vICAgICAgICAgYmxhY2tCaXNob3AucG9zaXRpb25ZPXNxdWFyZU1hcFsnYzgnXS55UG9zaXRpb25cbi8vICAgICAgICAgYmxhY2tCaXNob3AucG9zaXRpb25YPXNxdWFyZU1hcFsnYzgnXS54UG9zaXRpb25cbi8vICAgICB9XG4vLyAgICAgZWxzZXtcbi8vICAgICAgICAgYmxhY2tCaXNob3AucG9zaXRpb25ZPXNxdWFyZU1hcFsnZjgnXS55UG9zaXRpb25cbi8vICAgICAgICAgYmxhY2tCaXNob3AucG9zaXRpb25YPXNxdWFyZU1hcFsnZjgnXS54UG9zaXRpb25cbi8vICAgICB9XG4vLyAgICAgYmxhY2tQaWVjZXMucHVzaChibGFja0Jpc2hvcClcbi8vIH1cblxuLy8gZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspe1xuLy8gICAgIGNvbnN0IHdoaXRlS25pZ2h0ID0gbmV3IFVJSW1hZ2UoY2FudmFzLCBuZXcgVGV4dHVyZShcImltYWdlcy9jaGVzc2JvYXJkL3doaXRlLWtuaWdodC5wbmdcIikpXG4vLyAgICAgd2hpdGVLbmlnaHQudmlzaWJsZSA9IGZhbHNlXG4vLyAgICAgd2hpdGVLbmlnaHQud2lkdGggPSA0OFxuLy8gICAgIHdoaXRlS25pZ2h0LmhlaWdodCA9IDQ4XG4vLyAgICAgd2hpdGVLbmlnaHQuc291cmNlTGVmdCA9IDBcbi8vICAgICB3aGl0ZUtuaWdodC5zb3VyY2VUb3AgPSAwXG4vLyAgICAgd2hpdGVLbmlnaHQuc291cmNlV2lkdGggPSA4MlxuLy8gICAgIHdoaXRlS25pZ2h0LnNvdXJjZUhlaWdodCA9IDgyXG4vLyAgICAgaWYoaT09MCl7XG4vLyAgICAgICAgIHdoaXRlS25pZ2h0LnBvc2l0aW9uWT1zcXVhcmVNYXBbJ2IxJ10ueVBvc2l0aW9uXG4vLyAgICAgICAgIHdoaXRlS25pZ2h0LnBvc2l0aW9uWD1zcXVhcmVNYXBbJ2IxJ10ueFBvc2l0aW9uXG4vLyAgICAgfVxuLy8gICAgIGVsc2V7XG4vLyAgICAgICAgIHdoaXRlS25pZ2h0LnBvc2l0aW9uWT1zcXVhcmVNYXBbJ2cxJ10ueVBvc2l0aW9uXG4vLyAgICAgICAgIHdoaXRlS25pZ2h0LnBvc2l0aW9uWD1zcXVhcmVNYXBbJ2cxJ10ueFBvc2l0aW9uXG4vLyAgICAgfVxuLy8gICAgIHdoaXRlUGllY2VzLnB1c2god2hpdGVLbmlnaHQpXG4vLyB9XG5cbi8vIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKXtcbi8vICAgICBjb25zdCB3aGl0ZVJvb2sgPSBuZXcgVUlJbWFnZShjYW52YXMsIG5ldyBUZXh0dXJlKFwiaW1hZ2VzL2NoZXNzYm9hcmQvd2hpdGUtcm9vay5wbmdcIikpXG4vLyAgICAgd2hpdGVSb29rLnZpc2libGUgPSBmYWxzZVxuLy8gICAgIHdoaXRlUm9vay53aWR0aCA9IDQyXG4vLyAgICAgd2hpdGVSb29rLmhlaWdodCA9IDQ4XG4vLyAgICAgd2hpdGVSb29rLnNvdXJjZUxlZnQgPSAwXG4vLyAgICAgd2hpdGVSb29rLnNvdXJjZVRvcCA9IDBcbi8vICAgICB3aGl0ZVJvb2suc291cmNlV2lkdGggPSA2OVxuLy8gICAgIHdoaXRlUm9vay5zb3VyY2VIZWlnaHQgPSA3OFxuLy8gICAgIGlmIChpPT0wKXtcbi8vICAgICAgICAgd2hpdGVSb29rLnBvc2l0aW9uWT1zcXVhcmVNYXBbJ2ExJ10ueVBvc2l0aW9uXG4vLyAgICAgICAgIHdoaXRlUm9vay5wb3NpdGlvblg9c3F1YXJlTWFwWydhMSddLnhQb3NpdGlvblxuLy8gICAgIH1cbi8vICAgICBlbHNle1xuLy8gICAgICAgICB3aGl0ZVJvb2sucG9zaXRpb25ZPXNxdWFyZU1hcFsnaDEnXS55UG9zaXRpb25cbi8vICAgICAgICAgd2hpdGVSb29rLnBvc2l0aW9uWD1zcXVhcmVNYXBbJ2gxJ10ueFBvc2l0aW9uXG4vLyAgICAgfVxuLy8gICAgIHdoaXRlUGllY2VzLnB1c2god2hpdGVSb29rKVxuLy8gfVxuXG4vLyBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKyl7XG4vLyAgICAgY29uc3QgYmxhY2tSb29rID0gbmV3IFVJSW1hZ2UoY2FudmFzLCBuZXcgVGV4dHVyZShcImltYWdlcy9jaGVzc2JvYXJkL2JsYWNrLXJvb2sucG5nXCIpKVxuLy8gICAgIGJsYWNrUm9vay52aXNpYmxlID0gZmFsc2Vcbi8vICAgICBibGFja1Jvb2sud2lkdGggPSA0MlxuLy8gICAgIGJsYWNrUm9vay5oZWlnaHQgPSA0OFxuLy8gICAgIGJsYWNrUm9vay5zb3VyY2VMZWZ0ID0gMFxuLy8gICAgIGJsYWNrUm9vay5zb3VyY2VUb3AgPSAwXG4vLyAgICAgYmxhY2tSb29rLnNvdXJjZVdpZHRoID0gNzBcbi8vICAgICBibGFja1Jvb2suc291cmNlSGVpZ2h0ID0gNzdcbi8vICAgICBpZiAoaT09MCl7XG4vLyAgICAgICAgIGJsYWNrUm9vay5wb3NpdGlvblk9c3F1YXJlTWFwWydhOCddLnlQb3NpdGlvblxuLy8gICAgICAgICBibGFja1Jvb2sucG9zaXRpb25YPXNxdWFyZU1hcFsnYTgnXS54UG9zaXRpb25cbi8vICAgICB9XG4vLyAgICAgZWxzZXtcbi8vICAgICAgICAgYmxhY2tSb29rLnBvc2l0aW9uWT1zcXVhcmVNYXBbJ2g4J10ueVBvc2l0aW9uXG4vLyAgICAgICAgIGJsYWNrUm9vay5wb3NpdGlvblg9c3F1YXJlTWFwWydoOCddLnhQb3NpdGlvblxuLy8gICAgIH1cbi8vICAgICBibGFja1BpZWNlcy5wdXNoKGJsYWNrUm9vaylcbi8vIH1cblxuLy8gY29uc3Qgd2hpdGVRdWVlbjpVSUltYWdlID0gbmV3IFVJSW1hZ2UoY2FudmFzLCBuZXcgVGV4dHVyZShcImltYWdlcy9jaGVzc2JvYXJkL3doaXRlLXF1ZWVuLnBuZ1wiKSlcbi8vIHdoaXRlUXVlZW4udmlzaWJsZSA9IGZhbHNlXG4vLyB3aGl0ZVF1ZWVuLndpZHRoID0gNDhcbi8vIHdoaXRlUXVlZW4uaGVpZ2h0ID0gNDhcbi8vIHdoaXRlUXVlZW4uc291cmNlTGVmdCA9IDBcbi8vIHdoaXRlUXVlZW4uc291cmNlVG9wID0gMFxuLy8gd2hpdGVRdWVlbi5zb3VyY2VXaWR0aCA9IDk1XG4vLyB3aGl0ZVF1ZWVuLnNvdXJjZUhlaWdodCA9IDg1XG4vLyB3aGl0ZVF1ZWVuLnBvc2l0aW9uWT1zcXVhcmVNYXBbJ2QxJ10ueVBvc2l0aW9uXG4vLyB3aGl0ZVF1ZWVuLnBvc2l0aW9uWD1zcXVhcmVNYXBbJ2QxJ10ueFBvc2l0aW9uXG4vLyB3aGl0ZVBpZWNlcy5wdXNoKHdoaXRlUXVlZW4pXG5cbi8vIGNvbnN0IGJsYWNrUXVlZW46VUlJbWFnZSA9IG5ldyBVSUltYWdlKGNhbnZhcywgbmV3IFRleHR1cmUoXCJpbWFnZXMvY2hlc3Nib2FyZC9ibGFjay1xdWVlbi5wbmdcIikpXG4vLyBibGFja1F1ZWVuLnZpc2libGUgPSBmYWxzZVxuLy8gYmxhY2tRdWVlbi53aWR0aCA9IDQ4XG4vLyBibGFja1F1ZWVuLmhlaWdodCA9IDQ4XG4vLyBibGFja1F1ZWVuLnNvdXJjZUxlZnQgPSAwXG4vLyBibGFja1F1ZWVuLnNvdXJjZVRvcCA9IDBcbi8vIGJsYWNrUXVlZW4uc291cmNlV2lkdGggPSA5NFxuLy8gYmxhY2tRdWVlbi5zb3VyY2VIZWlnaHQgPSA5MFxuLy8gYmxhY2tRdWVlbi5wb3NpdGlvblk9c3F1YXJlTWFwWydkOCddLnlQb3NpdGlvblxuLy8gYmxhY2tRdWVlbi5wb3NpdGlvblg9c3F1YXJlTWFwWydkOCddLnhQb3NpdGlvblxuLy8gYmxhY2tQaWVjZXMucHVzaChibGFja1F1ZWVuKVxuXG5cblxuLy8gY29uc3Qgd2hpdGVLaW5nOlVJSW1hZ2UgPSBuZXcgVUlJbWFnZShjYW52YXMsIG5ldyBUZXh0dXJlKFwiaW1hZ2VzL2NoZXNzYm9hcmQvd2hpdGUta2luZy5wbmdcIikpXG4vLyB3aGl0ZUtpbmcudmlzaWJsZSA9IGZhbHNlXG4vLyB3aGl0ZUtpbmcud2lkdGggPSA0OFxuLy8gd2hpdGVLaW5nLmhlaWdodCA9IDQ4XG4vLyB3aGl0ZUtpbmcuc291cmNlTGVmdCA9IDBcbi8vIHdoaXRlS2luZy5zb3VyY2VUb3AgPSAwXG4vLyB3aGl0ZUtpbmcuc291cmNlV2lkdGggPSA4N1xuLy8gd2hpdGVLaW5nLnNvdXJjZUhlaWdodCA9IDg1XG4vLyB3aGl0ZUtpbmcucG9zaXRpb25ZPXNxdWFyZU1hcFsnZTEnXS55UG9zaXRpb25cbi8vIHdoaXRlS2luZy5wb3NpdGlvblg9c3F1YXJlTWFwWydlMSddLnhQb3NpdGlvblxuLy8gd2hpdGVQaWVjZXMucHVzaCh3aGl0ZUtpbmcpXG5cbi8vIGNvbnN0IGJsYWNrS2luZzpVSUltYWdlID0gbmV3IFVJSW1hZ2UoY2FudmFzLCBuZXcgVGV4dHVyZShcImltYWdlcy9jaGVzc2JvYXJkL2JsYWNrLWtpbmcucG5nXCIpKVxuLy8gYmxhY2tLaW5nLnZpc2libGUgPSBmYWxzZVxuLy8gYmxhY2tLaW5nLndpZHRoID0gNDhcbi8vIGJsYWNrS2luZy5oZWlnaHQgPSA0OFxuLy8gYmxhY2tLaW5nLnNvdXJjZUxlZnQgPSAwXG4vLyBibGFja0tpbmcuc291cmNlVG9wID0gMFxuLy8gYmxhY2tLaW5nLnNvdXJjZVdpZHRoID0gODhcbi8vIGJsYWNrS2luZy5zb3VyY2VIZWlnaHQgPSA4N1xuLy8gYmxhY2tLaW5nLnBvc2l0aW9uWT1zcXVhcmVNYXBbJ2U4J10ueVBvc2l0aW9uXG4vLyBibGFja0tpbmcucG9zaXRpb25YPXNxdWFyZU1hcFsnZTgnXS54UG9zaXRpb25cbi8vIGJsYWNrUGllY2VzLnB1c2goYmxhY2tLaW5nKVxuXG4vLyBmb3IobGV0IGk9MDsgaTx3aGl0ZVBpZWNlcy5sZW5ndGg7aSsrKXtcbi8vICAgICB3aGl0ZVBpZWNlc1tpXS53aWR0aCA9IHBhcnNlRmxvYXQod2hpdGVQaWVjZXNbaV0ud2lkdGgucmVwbGFjZSgncHgnLCcnKSkgLyByZXNpemVGYWN0b3Jcbi8vICAgICBibGFja1BpZWNlc1tpXS53aWR0aCA9IHBhcnNlRmxvYXQoYmxhY2tQaWVjZXNbaV0ud2lkdGgucmVwbGFjZSgncHgnLCcnKSkgLyByZXNpemVGYWN0b3Jcbi8vIH1cbiIsImV4cG9ydCBjb25zdCByZXNpemVGYWN0b3I6bnVtYmVyID0gMVxuY29uc3QgeFRyYW5zbGF0aW9uOm51bWJlciA9IC0yMDAuMFxuY29uc3QgeVRyYW5zbGF0aW9uOm51bWJlciA9IDAuMFxuXG5leHBvcnQgY29uc3Qgc3F1YXJlTWFwOntbc3F1YXJlTmFtZTogc3RyaW5nXTogSVNxdWFyZX0gPSB7XG4gICAgXCJhMVwiOnt4UG9zaXRpb246LTIyNCArIHhUcmFuc2xhdGlvbiAsIHlQb3NpdGlvbjotMjI0ICsgeVRyYW5zbGF0aW9ufSwgXCJhMlwiOiB7ICB4UG9zaXRpb246LTIyNCArIHhUcmFuc2xhdGlvbiAsIHlQb3NpdGlvbjotMTYwICsgeVRyYW5zbGF0aW9ufSwgXCJhM1wiOnsgIHhQb3NpdGlvbjotMjI0ICsgeFRyYW5zbGF0aW9uICx5UG9zaXRpb246LTk2ICsgeVRyYW5zbGF0aW9ufSwgIFwiYTRcIjp7ICB4UG9zaXRpb246LTIyNCArIHhUcmFuc2xhdGlvbiAseVBvc2l0aW9uOi0zMiArIHlUcmFuc2xhdGlvbn0sIFwiYTVcIjp7ICB4UG9zaXRpb246LTIyNCArIHhUcmFuc2xhdGlvbiAseVBvc2l0aW9uOjMyICsgeVRyYW5zbGF0aW9ufSwgXCJhNlwiOnsgIHhQb3NpdGlvbjotMjI0ICsgeFRyYW5zbGF0aW9uICx5UG9zaXRpb246OTYgKyB5VHJhbnNsYXRpb259LCBcImE3XCI6eyAgeFBvc2l0aW9uOi0yMjQgKyB4VHJhbnNsYXRpb24gLCB5UG9zaXRpb246MTYwICsgeVRyYW5zbGF0aW9ufSwgXCJhOFwiOnsgIHhQb3NpdGlvbjotMjI0ICsgeFRyYW5zbGF0aW9uICx5UG9zaXRpb246MjI0ICsgeVRyYW5zbGF0aW9ufSxcbiAgICBcImIxXCI6e3hQb3NpdGlvbjotMTYwICsgeFRyYW5zbGF0aW9uICwgeVBvc2l0aW9uOi0yMjQgKyB5VHJhbnNsYXRpb259LCBcImIyXCI6IHsgIHhQb3NpdGlvbjotMTYwICsgeFRyYW5zbGF0aW9uICwgeVBvc2l0aW9uOi0xNjAgKyB5VHJhbnNsYXRpb259LCBcImIzXCI6eyAgeFBvc2l0aW9uOi0xNjAgKyB4VHJhbnNsYXRpb24gLHlQb3NpdGlvbjotOTYgKyB5VHJhbnNsYXRpb259LCAgXCJiNFwiOnsgIHhQb3NpdGlvbjotMTYwICsgeFRyYW5zbGF0aW9uICx5UG9zaXRpb246LTMyICsgeVRyYW5zbGF0aW9ufSwgXCJiNVwiOnsgIHhQb3NpdGlvbjotMTYwICsgeFRyYW5zbGF0aW9uICx5UG9zaXRpb246MzIgKyB5VHJhbnNsYXRpb259LCBcImI2XCI6eyAgeFBvc2l0aW9uOi0xNjAgKyB4VHJhbnNsYXRpb24gLHlQb3NpdGlvbjo5NiArIHlUcmFuc2xhdGlvbn0sIFwiYjdcIjp7ICB4UG9zaXRpb246LTE2MCArIHhUcmFuc2xhdGlvbiAsIHlQb3NpdGlvbjoxNjAgKyB5VHJhbnNsYXRpb259LCBcImI4XCI6eyAgeFBvc2l0aW9uOi0xNjAgKyB4VHJhbnNsYXRpb24gLHlQb3NpdGlvbjoyMjQgKyB5VHJhbnNsYXRpb259LFxuICAgIFwiYzFcIjp7eFBvc2l0aW9uOi05NiArIHhUcmFuc2xhdGlvbiAsICB5UG9zaXRpb246LTIyNCArIHlUcmFuc2xhdGlvbn0sICBcImMyXCI6IHsgeFBvc2l0aW9uOi05NiArIHhUcmFuc2xhdGlvbiAsICB5UG9zaXRpb246LTE2MCArIHlUcmFuc2xhdGlvbn0sICBcImMzXCI6eyB4UG9zaXRpb246LTk2ICsgeFRyYW5zbGF0aW9uICwgeVBvc2l0aW9uOi05NiArIHlUcmFuc2xhdGlvbn0sICAgXCJjNFwiOnsgeFBvc2l0aW9uOi05NiArIHhUcmFuc2xhdGlvbiAsIHlQb3NpdGlvbjotMzIgKyB5VHJhbnNsYXRpb259LCAgXCJjNVwiOnsgeFBvc2l0aW9uOi05NiArIHhUcmFuc2xhdGlvbiAsIHlQb3NpdGlvbjozMiArIHlUcmFuc2xhdGlvbn0sICBcImM2XCI6eyB4UG9zaXRpb246LTk2ICsgeFRyYW5zbGF0aW9uICwgeVBvc2l0aW9uOjk2ICsgeVRyYW5zbGF0aW9ufSwgIFwiYzdcIjp7IHhQb3NpdGlvbjotOTYgKyB4VHJhbnNsYXRpb24gLCAgeVBvc2l0aW9uOjE2MCArIHlUcmFuc2xhdGlvbn0sICBcImM4XCI6eyB4UG9zaXRpb246LTk2ICsgeFRyYW5zbGF0aW9uICwgeVBvc2l0aW9uOjIyNCArIHlUcmFuc2xhdGlvbn0sXG4gICAgXCJkMVwiOnt4UG9zaXRpb246LTMyICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjotMjI0ICsgeVRyYW5zbGF0aW9ufSwgIFwiZDJcIjogeyB4UG9zaXRpb246LTMyICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjotMTYwICsgeVRyYW5zbGF0aW9ufSwgIFwiZDNcIjp7IHhQb3NpdGlvbjotMzIgKyB4VHJhbnNsYXRpb24gLCB5UG9zaXRpb246LTk2ICsgeVRyYW5zbGF0aW9ufSwgICBcImQ0XCI6eyB4UG9zaXRpb246LTMyICsgeFRyYW5zbGF0aW9uICwgeVBvc2l0aW9uOi0zMiArIHlUcmFuc2xhdGlvbn0sICBcImQ1XCI6eyB4UG9zaXRpb246LTMyICsgeFRyYW5zbGF0aW9uICwgeVBvc2l0aW9uOjMyICsgeVRyYW5zbGF0aW9ufSwgIFwiZDZcIjp7IHhQb3NpdGlvbjotMzIgKyB4VHJhbnNsYXRpb24gLCB5UG9zaXRpb246OTYgKyB5VHJhbnNsYXRpb259LCAgXCJkN1wiOnsgeFBvc2l0aW9uOi0zMiArIHhUcmFuc2xhdGlvbiAsICB5UG9zaXRpb246MTYwICsgeVRyYW5zbGF0aW9ufSwgIFwiZDhcIjp7IHhQb3NpdGlvbjotMzIgKyB4VHJhbnNsYXRpb24gLCB5UG9zaXRpb246MjI0ICsgeVRyYW5zbGF0aW9ufSxcbiAgICBcImUxXCI6e3hQb3NpdGlvbjozMiArIHhUcmFuc2xhdGlvbiAsICAgeVBvc2l0aW9uOi0yMjQgKyB5VHJhbnNsYXRpb259LCAgIFwiZTJcIjoge3hQb3NpdGlvbjozMiArIHhUcmFuc2xhdGlvbiAsICAgeVBvc2l0aW9uOi0xNjAgKyB5VHJhbnNsYXRpb259LCAgIFwiZTNcIjp7eFBvc2l0aW9uOjMyICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjotOTYgKyB5VHJhbnNsYXRpb259LCAgICBcImU0XCI6e3hQb3NpdGlvbjozMiArIHhUcmFuc2xhdGlvbiAsICB5UG9zaXRpb246LTMyICsgeVRyYW5zbGF0aW9ufSwgICBcImU1XCI6e3hQb3NpdGlvbjozMiArIHhUcmFuc2xhdGlvbiAsICB5UG9zaXRpb246MzIgKyB5VHJhbnNsYXRpb259LCAgIFwiZTZcIjp7eFBvc2l0aW9uOjMyICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjo5NiArIHlUcmFuc2xhdGlvbn0sICAgXCJlN1wiOnt4UG9zaXRpb246MzIgKyB4VHJhbnNsYXRpb24gLCAgIHlQb3NpdGlvbjoxNjAgKyB5VHJhbnNsYXRpb259LCAgIFwiZThcIjp7eFBvc2l0aW9uOjMyICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjoyMjQgKyB5VHJhbnNsYXRpb259LFxuICAgIFwiZjFcIjp7eFBvc2l0aW9uOjk2ICsgeFRyYW5zbGF0aW9uICwgICB5UG9zaXRpb246LTIyNCArIHlUcmFuc2xhdGlvbn0sICAgXCJmMlwiOiB7eFBvc2l0aW9uOjk2ICsgeFRyYW5zbGF0aW9uICwgICB5UG9zaXRpb246LTE2MCArIHlUcmFuc2xhdGlvbn0sICAgXCJmM1wiOnt4UG9zaXRpb246OTYgKyB4VHJhbnNsYXRpb24gLCAgeVBvc2l0aW9uOi05NiArIHlUcmFuc2xhdGlvbn0sICAgIFwiZjRcIjp7eFBvc2l0aW9uOjk2ICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjotMzIgKyB5VHJhbnNsYXRpb259LCAgIFwiZjVcIjp7eFBvc2l0aW9uOjk2ICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjozMiArIHlUcmFuc2xhdGlvbn0sICAgXCJmNlwiOnt4UG9zaXRpb246OTYgKyB4VHJhbnNsYXRpb24gLCAgeVBvc2l0aW9uOjk2ICsgeVRyYW5zbGF0aW9ufSwgICBcImY3XCI6e3hQb3NpdGlvbjo5NiArIHhUcmFuc2xhdGlvbiAsICAgeVBvc2l0aW9uOjE2MCArIHlUcmFuc2xhdGlvbn0sICAgXCJmOFwiOnt4UG9zaXRpb246OTYgKyB4VHJhbnNsYXRpb24gLCAgeVBvc2l0aW9uOjIyNCArIHlUcmFuc2xhdGlvbn0sXG4gICAgXCJnMVwiOnt4UG9zaXRpb246MTYwICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjotMjI0ICsgeVRyYW5zbGF0aW9ufSwgIFwiZzJcIjogeyB4UG9zaXRpb246MTYwICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjotMTYwICsgeVRyYW5zbGF0aW9ufSwgIFwiZzNcIjp7IHhQb3NpdGlvbjoxNjAgKyB4VHJhbnNsYXRpb24gLCB5UG9zaXRpb246LTk2ICsgeVRyYW5zbGF0aW9ufSwgICBcImc0XCI6eyB4UG9zaXRpb246MTYwICsgeFRyYW5zbGF0aW9uICwgeVBvc2l0aW9uOi0zMiArIHlUcmFuc2xhdGlvbn0sICBcImc1XCI6eyB4UG9zaXRpb246MTYwICsgeFRyYW5zbGF0aW9uICwgeVBvc2l0aW9uOjMyICsgeVRyYW5zbGF0aW9ufSwgIFwiZzZcIjp7IHhQb3NpdGlvbjoxNjAgKyB4VHJhbnNsYXRpb24gLCB5UG9zaXRpb246OTYgKyB5VHJhbnNsYXRpb259LCAgXCJnN1wiOnsgeFBvc2l0aW9uOjE2MCArIHhUcmFuc2xhdGlvbiAsICB5UG9zaXRpb246MTYwICsgeVRyYW5zbGF0aW9ufSwgIFwiZzhcIjp7IHhQb3NpdGlvbjoxNjAgKyB4VHJhbnNsYXRpb24gLCB5UG9zaXRpb246MjI0ICsgeVRyYW5zbGF0aW9ufSxcbiAgICBcImgxXCI6e3hQb3NpdGlvbjoyMjQgKyB4VHJhbnNsYXRpb24gLCAgeVBvc2l0aW9uOi0yMjQgKyB5VHJhbnNsYXRpb259LCAgXCJoMlwiOiB7IHhQb3NpdGlvbjoyMjQgKyB4VHJhbnNsYXRpb24gLCAgeVBvc2l0aW9uOi0xNjAgKyB5VHJhbnNsYXRpb259LCAgXCJoM1wiOnsgeFBvc2l0aW9uOjIyNCArIHhUcmFuc2xhdGlvbiAsIHlQb3NpdGlvbjotOTYgKyB5VHJhbnNsYXRpb259LCAgIFwiaDRcIjp7IHhQb3NpdGlvbjoyMjQgKyB4VHJhbnNsYXRpb24gLCB5UG9zaXRpb246LTMyICsgeVRyYW5zbGF0aW9ufSwgIFwiaDVcIjp7IHhQb3NpdGlvbjoyMjQgKyB4VHJhbnNsYXRpb24gLCB5UG9zaXRpb246MzIgKyB5VHJhbnNsYXRpb259LCAgXCJoNlwiOnsgeFBvc2l0aW9uOjIyNCArIHhUcmFuc2xhdGlvbiAsIHlQb3NpdGlvbjo5NiArIHlUcmFuc2xhdGlvbn0sICBcImg3XCI6eyB4UG9zaXRpb246MjI0ICsgeFRyYW5zbGF0aW9uICwgIHlQb3NpdGlvbjoxNjAgKyB5VHJhbnNsYXRpb259LCAgXCJoOFwiOnsgeFBvc2l0aW9uOjIyNCArIHhUcmFuc2xhdGlvbiAsIHlQb3NpdGlvbjoyMjQgKyB5VHJhbnNsYXRpb259XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHRDaGFyKGM6c3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYy5jaGFyQ29kZUF0KDApICsgMSk7XG59XG5cbmV4cG9ydCBlbnVtIFBpZWNlVHlwZXtcbiAgICBQQVdOID0gXCJwYXduXCIsXG4gICAgS05JR0hUID0gXCJrbmlnaHRcIixcbiAgICBCSVNIT1AgPSBcImJpc2hvcFwiLFxuICAgIFJPT0sgPSBcInJvb2tcIixcbiAgICBRVUVFTiA9IFwicXVlZW5cIixcbiAgICBLSU5HID0gXCJraW5nXCJcbn1cblxuZXhwb3J0IGVudW0gY2hlc3NDb2xvcntcbiAgICBXSElURSA9IFwid2hpdGVcIixcbiAgICBCTEFDSyA9IFwiYmxhY2tcIlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTcXVhcmV7XG4gICAgeFBvc2l0aW9uOiBudW1iZXIsXG4gICAgeVBvc2l0aW9uOiBudW1iZXIsXG59XG5cbi8vcmV0dXJucyB0aGUgY29sb3Igb2YgYSBzcXVhcmUgLS0gZ2V0U3F1YXJlQ29sb3IoJ2ExJylcbmV4cG9ydCBmdW5jdGlvbiBnZXRTcXVhcmVDb2xvcihzcXVhcmU6IHN0cmluZyk6IGNoZXNzQ29sb3J7XG4gICAgbGV0IGNvbHVtbjpzdHJpbmcgPSBzcXVhcmUuY2hhckF0KHNxdWFyZS5sZW5ndGgtMilcbiAgICBsZXQgcm93OnN0cmluZyA9IHNxdWFyZS5jaGFyQXQoc3F1YXJlLmxlbmd0aC0xKVxuICAgIGxldCBhOm51bWJlciA9IDk3IC8vICdhJyBBU0NJSSBjb2RlXG4gICAgbGV0IGNvbG9yID0gY2hlc3NDb2xvci5XSElURVxuICAgIGlmICgoKGNvbHVtbi5jaGFyQ29kZUF0KDApLWErMSkrcGFyc2VJbnQocm93KSklMiA9PSAwKVxuICAgICAgICBjb2xvciA9IGNoZXNzQ29sb3IuQkxBQ0s7XG5cbiAgICByZXR1cm4gY29sb3IgICAgXG59IiwiaW1wb3J0IHtjaGVzc0NvbG9yfSBmcm9tICcuL3V0aWxzJ1xuXG5leHBvcnQgY2xhc3MgQW5ub3RhdGlvbntcbiAgICBtb3ZlX251bWJlcjogbnVtYmVyXG4gICAgd2hpdGVfbW92ZW1lbnQ6IHN0cmluZyA9ICcnXG4gICAgYmxhY2tfbW92ZW1lbnQ6IHN0cmluZyA9ICcnXG4gICAgZ3JhcGhpY2FsX3JlcHJlc2VudGF0aW9uOiBVSVRleHRcbiAgICBmZW46IHN0cmluZyA9IFwiXCIgLy9mZW4gaXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjaGVzcyBwb3NpdGlvbiAtLSBzdG9yZWQgYWZ0ZXIgbW92ZVxuICAgIC8vIGNvbG9yOiBjaGVzc0NvbG9yXG5cbiAgICAvLyB0aGVzZSBvYmplY3RzIGFyZSBub3QgdmlzaWJsZSBieSBkZWZhdWx0IVxuICAgIGNvbnN0cnVjdG9yKG51bWJlcjogbnVtYmVyLCBjYW52YXM6IFVJQ2FudmFzLCBmZW46c3RyaW5nKXtcbiAgICAgICAgdGhpcy5tb3ZlX251bWJlciA9IG51bWJlclxuICAgICAgICB0aGlzLmZlbiA9IGZlblxuICAgICAgICB0aGlzLmdyYXBoaWNhbF9yZXByZXNlbnRhdGlvbiA9IG5ldyBVSVRleHQoY2FudmFzKVxuICAgICAgICAvLyB0aGlzLndoaXRlX21vdmVtZW50ID0gbW92ZW1lbnRcbiAgICAgICAgLy8gdGhpcy5jb2xvciA9IGNvbG9yXG5cbiAgICAgICAgLy8gdGhpcy5ncmFwaGljYWxfcmVwcmVzZW50YXRpb24udmFsdWUgPSB0aGlzLm1vdmVtZW50XG4gICAgICAgIC8vIGlmKHRoaXMuY29sb3IgPT0gXCJ3aGl0ZVwiKSB0aGlzLmdyYXBoaWNhbF9yZXByZXNlbnRhdGlvbi52YWx1ZSA9IHRoaXMubW92ZV9udW1iZXIgKyBcIi4gXCIgKyB0aGlzLm1vdmVtZW50XG4gICAgICAgIC8vIHRoaXMuZ3JhcGhpY2FsX3JlcHJlc2VudGF0aW9uLmZvbnRTaXplID0gMjBcbiAgICAgICAgLy8gdGhpcy5ncmFwaGljYWxfcmVwcmVzZW50YXRpb24uY29sb3IgPSBDb2xvcjQuQmxhY2soKVxuICAgICAgICAvLyB0aGlzLmdyYXBoaWNhbF9yZXByZXNlbnRhdGlvbi5wb3NpdGlvblggPSA1MFxuICAgICAgICAvLyAvLyBpZih0aGlzLmNvbG9yID09IFwiYmxhY2tcIikgdGhpcy5ncmFwaGljYWxfcmVwcmVzZW50YXRpb24ucG9zaXRpb25YID0gMjUwXG4gICAgICAgIC8vIHRoaXMuZ3JhcGhpY2FsX3JlcHJlc2VudGF0aW9uLnBvc2l0aW9uWSA9IDBcbiAgICAgICAgLy8gdGhpcy5ncmFwaGljYWxfcmVwcmVzZW50YXRpb24udmlzaWJsZSA9IHRydWVcbiAgICB9XG5cbiAgICBnZXRNb3ZlbWVudCgpOiBzdHJpbmdbXXtcbiAgICAgICAgcmV0dXJuIFt0aGlzLndoaXRlX21vdmVtZW50LCB0aGlzLmJsYWNrX21vdmVtZW50XVxuICAgIH1cblxuICAgIGdldE1vdmVOdW1iZXIoKTogbnVtYmVye1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlX251bWJlclxuICAgIH1cblxuICAgIGdldE9iamVjdCgpOiBVSVRleHR7XG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBoaWNhbF9yZXByZXNlbnRhdGlvblxuICAgIH1cblxuICAgIGdldEZlbigpOiBzdHJpbmd7XG4gICAgICAgIHJldHVybiB0aGlzLmZlblxuICAgIH1cblxuICAgIHN0b3JlRmVuKGZlbjpzdHJpbmcpe1xuICAgICAgICB0aGlzLmZlbiA9IGZlblxuICAgIH1cblxuICAgIHNldE1vdmVtZW50KGNvbG9yOmNoZXNzQ29sb3IsIG1vdmVtZW50OiBzdHJpbmcpe1xuICAgICAgICBpZiAoY29sb3IgPT0gXCJ3aGl0ZVwiICYmICF0aGlzLndoaXRlX21vdmVtZW50KVxuICAgICAgICAgICAgdGhpcy53aGl0ZV9tb3ZlbWVudCA9IG1vdmVtZW50XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmJsYWNrX21vdmVtZW50KVxuICAgICAgICAgICAgdGhpcy5ibGFja19tb3ZlbWVudCA9IG1vdmVtZW50IFxuICAgICAgICB0aGlzLnVwZGF0ZVVJKCkgICAgICAgXG4gICAgfVxuXG4gICAgdXBkYXRlVUkoKXtcbiAgICAgICAgdGhpcy5ncmFwaGljYWxfcmVwcmVzZW50YXRpb24uZm9udFNpemUgPSAxNVxuICAgICAgICB0aGlzLmdyYXBoaWNhbF9yZXByZXNlbnRhdGlvbi5jb2xvciA9IENvbG9yNC5CbGFjaygpXG4gICAgICAgIGxldCBzcGFjZTpzdHJpbmc7XG4gICAgICAgIHRoaXMuZ3JhcGhpY2FsX3JlcHJlc2VudGF0aW9uLnZhbHVlID0gdGhpcy5nZXRNb3ZlTnVtYmVyKCkgKyBcIi4gXCIgKyB0aGlzLndoaXRlX21vdmVtZW50ICsgQXJyYXkoMTUtKHRoaXMud2hpdGVfbW92ZW1lbnQubGVuZ3RoKSoyKS5qb2luKFwiIFwiKSArIHRoaXMuYmxhY2tfbW92ZW1lbnRcblxuICAgICAgICBsb2codGhpcy5ncmFwaGljYWxfcmVwcmVzZW50YXRpb24udmFsdWUpXG5cbiAgICAgICAgdGhpcy5ncmFwaGljYWxfcmVwcmVzZW50YXRpb24ucG9zaXRpb25YID0gNTBcbiAgICAgICAgdGhpcy5ncmFwaGljYWxfcmVwcmVzZW50YXRpb24ucG9zaXRpb25ZID0gMFxuICAgICAgICB0aGlzLmdyYXBoaWNhbF9yZXByZXNlbnRhdGlvbi53aWR0aCA9IDE1MFxuICAgICAgICB0aGlzLmdyYXBoaWNhbF9yZXByZXNlbnRhdGlvbi5oZWlnaHQgPSAyNVxuICAgICAgICB0aGlzLmdyYXBoaWNhbF9yZXByZXNlbnRhdGlvbi52aXNpYmxlID0gdHJ1ZVxuICAgIH1cblxufSIsImltcG9ydCB7QW5ub3RhdGlvbn0gZnJvbSAnLi9hbm5vdGF0aW9uJ1xuaW1wb3J0IHtjaGVzc0NvbG9yfSBmcm9tICcuL3V0aWxzJ1xuXG5leHBvcnQgY2xhc3MgQW5ub3RhdGlvbnN7XG4gICAgYW5ub3RhdGlvbnM6IEFubm90YXRpb25bXVxuICAgIG1vdmVfY291bnRlcjogbnVtYmVyXG4gICAgY2FudmFzOiBVSUNhbnZhc1xuXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBVSUNhbnZhcyl7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBbXVxuICAgICAgICB0aGlzLm1vdmVfY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzXG4gICAgfVxuXG4gICAgYWRkTW92ZShtb3ZlbWVudDogc3RyaW5nLCBjb2xvcjogY2hlc3NDb2xvciwgZmVuOiBzdHJpbmcpe1xuICAgICAgICBpZihjb2xvciA9PSBcIndoaXRlXCIpe1xuICAgICAgICAgICAgbGV0IGFubm90YXRpb24gPSBuZXcgQW5ub3RhdGlvbihNYXRoLmZsb29yKCh0aGlzLm1vdmVfY291bnRlci8yKSsxKSwgdGhpcy5jYW52YXMsIGZlbilcbiAgICAgICAgICAgIGFubm90YXRpb24uc2V0TW92ZW1lbnQoY29sb3IsIG1vdmVtZW50KVxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb24pXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAgICBcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnNbdGhpcy5hbm5vdGF0aW9ucy5sZW5ndGggLSAxXS5zZXRNb3ZlbWVudChjb2xvciwgbW92ZW1lbnQpXG4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5tb3ZlX2NvdW50ZXIrK1xuICAgIH1cblxuICAgIGdldE1vdmVzKCl7XG4gICAgICAgIGxldCBtb3ZlbWVudHM6c3RyaW5nW10gPSBbXVxuICAgICAgICB0aGlzLmFubm90YXRpb25zLmZvckVhY2goYW5ub3RhdGlvbiA9PiB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uLmdldE1vdmVtZW50KCkuZm9yRWFjaChtb3ZlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgbW92ZW1lbnRzLnB1c2gobW92ZW1lbnQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gbW92ZW1lbnRzXG4gICAgfVxufSIsIi8vY29uc2lkZXJpbmcgYSA1MTIqNTEyIGJvYXJkXG5pbXBvcnQge3NxdWFyZU1hcCwgY2hlc3NDb2xvciwgUGllY2VUeXBlLCByZXNpemVGYWN0b3IsIElTcXVhcmUsIGdldFNxdWFyZUNvbG9yfSBmcm9tICcuL3V0aWxzJ1xuLy8gaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi91dGlscydcblxubGV0IHBpZWNlc1NpemUgPSB7XG4gICAgXCJwYXduXCI6IHtcImhlaWdodFwiOiA0OC9yZXNpemVGYWN0b3IsIFwid2lkdGhcIjogMzIvcmVzaXplRmFjdG9yLCBcInNvdXJjZS1sZWZ0XCI6IDAgLCBcInNvdXJjZS10b3BcIjogMCwgXCJzb3VyY2Utd2lkdGhcIjogNjAsIFwic291cmNlLWhlaWdodFwiOjc4fSxcbiAgICBcImtuaWdodFwiOiB7XCJoZWlnaHRcIjogNDgvcmVzaXplRmFjdG9yLCBcIndpZHRoXCI6IDQ4L3Jlc2l6ZUZhY3RvciwgXCJzb3VyY2UtbGVmdFwiOiAwICwgXCJzb3VyY2UtdG9wXCI6IDAsIFwic291cmNlLXdpZHRoXCI6IDgyLCBcInNvdXJjZS1oZWlnaHRcIjo4M30sXG4gICAgXCJiaXNob3BcIjoge1wiaGVpZ2h0XCI6IDQ4L3Jlc2l6ZUZhY3RvciwgXCJ3aWR0aFwiOiA0OC9yZXNpemVGYWN0b3IsIFwic291cmNlLWxlZnRcIjogMCAsIFwic291cmNlLXRvcFwiOiAwLCBcInNvdXJjZS13aWR0aFwiOiA4MiwgXCJzb3VyY2UtaGVpZ2h0XCI6ODJ9LFxuICAgIFwicm9va1wiOiB7XCJoZWlnaHRcIjogNDgvcmVzaXplRmFjdG9yLCBcIndpZHRoXCI6IDQyL3Jlc2l6ZUZhY3RvciwgXCJzb3VyY2UtbGVmdFwiOiAwICwgXCJzb3VyY2UtdG9wXCI6IDAsIFwic291cmNlLXdpZHRoXCI6IDY5LjUsIFwic291cmNlLWhlaWdodFwiOjc4LjV9LFxuICAgIFwicXVlZW5cIjoge1wiaGVpZ2h0XCI6IDQ4L3Jlc2l6ZUZhY3RvciwgXCJ3aWR0aFwiOiA0OC9yZXNpemVGYWN0b3IsIFwic291cmNlLWxlZnRcIjogMCAsIFwic291cmNlLXRvcFwiOiAwLCBcInNvdXJjZS13aWR0aFwiOiA5NSwgXCJzb3VyY2UtaGVpZ2h0XCI6ODV9LFxuICAgIFwia2luZ1wiOiB7XCJoZWlnaHRcIjogNDgvcmVzaXplRmFjdG9yLCBcIndpZHRoXCI6IDQ4L3Jlc2l6ZUZhY3RvciwgXCJzb3VyY2UtbGVmdFwiOiAwICwgXCJzb3VyY2UtdG9wXCI6IDAsIFwic291cmNlLXdpZHRoXCI6IDg3LjUsIFwic291cmNlLWhlaWdodFwiOjg2LjJ9XG59XG5cbmV4cG9ydCBjbGFzcyBQaWVjZXtcbiAgICBjb2xvcjogY2hlc3NDb2xvclxuICAgIHBvc2l0aW9uOiBzdHJpbmdcbiAgICBwaWVjZTogUGllY2VUeXBlXG4gICAgY2FudmFzOiBVSUNhbnZhc1xuICAgIGltYWdlOiBVSUltYWdlXG5cbiAgICBjb25zdHJ1Y3RvcihfY29sb3I6Y2hlc3NDb2xvcixfcGllY2U6IFBpZWNlVHlwZSwgIF9wb3NpdGlvbjpzdHJpbmcsIF9jYW52YXM6VUlDYW52YXMpe1xuICAgICAgICB0aGlzLmNvbG9yID0gX2NvbG9yXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBfcG9zaXRpb25cbiAgICAgICAgdGhpcy5waWVjZSAgPV9waWVjZVxuICAgICAgICB0aGlzLmNhbnZhcyA9IF9jYW52YXNcbiAgICAgICAgLy8gdGhpcy5oZWlnaHQgPSBcbiAgICAgICAgLy8gdGhpcy53aWR0aCA9IFxuICAgICAgICB0aGlzLmltYWdlID0gdGhpcy5nZW5lcmF0ZTJVSSgpXG4gICAgICAgIHRoaXMuc2V0MlVJUHJvcGVydGllcygpXG4gICAgfSAgIFxuXG4gICAgZ2VuZXJhdGUyVUkoKTpVSUltYWdle1xuICAgICAgICBsZXQgcGF0aDpzdHJpbmcgPSBcImltYWdlcy9jaGVzc2JvYXJkL1wiICsgdGhpcy5jb2xvciArIFwiLVwiICsgdGhpcy5waWVjZSArIFwiLnBuZ1wiXG4gICAgICAgIGxldCBpbWFnZTpVSUltYWdlID0gbmV3IFVJSW1hZ2UodGhpcy5jYW52YXMsIG5ldyBUZXh0dXJlKHBhdGgpKVxuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfVxuXG5cbiAgICBzZXQyVUlQcm9wZXJ0aWVzKCl7XG4gICAgICAgIHRoaXMuaW1hZ2UudmlzaWJsZSA9IHRydWVcbiAgICAgICAgdGhpcy5pbWFnZS53aWR0aCA9IHBpZWNlc1NpemVbdGhpcy5waWVjZV1bXCJ3aWR0aFwiXVxuICAgICAgICB0aGlzLmltYWdlLmhlaWdodCA9IHBpZWNlc1NpemVbdGhpcy5waWVjZV1bXCJoZWlnaHRcIl1cbiAgICAgICAgdGhpcy5pbWFnZS5zb3VyY2VMZWZ0ID0gcGllY2VzU2l6ZVt0aGlzLnBpZWNlXVtcInNvdXJjZS1sZWZ0XCJdXG4gICAgICAgIHRoaXMuaW1hZ2Uuc291cmNlVG9wID0gcGllY2VzU2l6ZVt0aGlzLnBpZWNlXVtcInNvdXJjZS10b3BcIl1cbiAgICAgICAgdGhpcy5pbWFnZS5zb3VyY2VXaWR0aCA9IHBpZWNlc1NpemVbdGhpcy5waWVjZV1bXCJzb3VyY2Utd2lkdGhcIl1cbiAgICAgICAgdGhpcy5pbWFnZS5zb3VyY2VIZWlnaHQgPSBwaWVjZXNTaXplW3RoaXMucGllY2VdW1wic291cmNlLWhlaWdodFwiXVxuICAgICAgICB0aGlzLmltYWdlLnBvc2l0aW9uWT1zcXVhcmVNYXBbdGhpcy5wb3NpdGlvbl0ueVBvc2l0aW9uXG4gICAgICAgIHRoaXMuaW1hZ2UucG9zaXRpb25YPXNxdWFyZU1hcFt0aGlzLnBvc2l0aW9uXS54UG9zaXRpb25cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q29sb3IoKTpjaGVzc0NvbG9ye1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UG9zaXRpb24oKTogc3RyaW5ne1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvblxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRQaWVjZSgpOiBQaWVjZVR5cGV7XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlXG4gICAgfVxuXG4gICAgcHVibGljIHNldFZpc2liaWxpdHkobW9kZTpib29sZWFuKTp2b2lkIHtcbiAgICAgICAgdGhpcy5pbWFnZS52aXNpYmxlID0gbW9kZVxuICAgIH1cblxuICAgIC8vcHJlOiBUaGUgdmFsaWRpdHkgb2YgdGhlIG1vdmUgaGFzIGJlZW4gY2hlY2tlZFxuICAgIHB1YmxpYyBtb3ZlUGllY2Uoc3F1YXJlOiBzdHJpbmcpe1xuICAgICAgICAvLyB0aGlzLmltYWdlLnBvc2l0aW9uWCA9IHNxdWFyZU1hcFtzcXVhcmVdLnhQb3NpdGlvblxuICAgICAgICAvLyB0aGlzLmltYWdlLnBvc2l0aW9uWSA9IHNxdWFyZU1hcFtzcXVhcmVdLnlQb3NpdGlvblxuICAgICAgICAvLyB0aGlzLmltYWdlID0gbmV3IFVJSW1hZ2UodGhpcy5jYW52YXMsICBUZXh0dXJlICgpKVxuICAgICAgICAvLyB0aGlzLnBvc2l0aW9uID0gc3F1YXJlelxuICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZmFsc2UpXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IodGhpcy5jb2xvciwgdGhpcy5waWVjZSwgc3F1YXJlLCB0aGlzLmNhbnZhcylcbiAgICB9XG59IiwiLy8gaW1wb3J0IHtzcXVhcmVNYXAsIGNoZXNzQ29sb3IsIFBpZWNlVHlwZSwgSVNxdWFyZSwgZ2V0U3F1YXJlQ29sb3IsIHJlc2l6ZUZhY3Rvcn0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7c3F1YXJlTWFwLCBjaGVzc0NvbG9yLCBQaWVjZVR5cGUsIHJlc2l6ZUZhY3RvciwgSVNxdWFyZSwgZ2V0U3F1YXJlQ29sb3J9IGZyb20gJy4vdXRpbHMnXG4vLyBpbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL3V0aWxzJ1xuXG5leHBvcnQgY2xhc3MgU3F1YXJle1xuICAgIG5hbWU6IHN0cmluZyAvL25hbWUgb2YgdGhlIHNxdWFyZSAoYTEsYTIsYTMsIGV0Yy4pXG4gICAgY2FudmFzOiBVSUNhbnZhcyBcbiAgICBjb2xvcjogY2hlc3NDb2xvciAvL2NvbG9yIG9mIHRoZSBzcXVhcmVcbiAgICBwb3NpdGlvbjogSVNxdWFyZSAvL3NxdWFyZSBwb3NpdGlvblxuICAgIGltYWdlOiBVSUltYWdlIFxuICAgIHBhdGg6IHN0cmluZ1xuXG4gICAgY29uc3RydWN0b3IoX25hbWU6c3RyaW5nLCBfY2FudmFzOiBVSUNhbnZhcywgX3BhdGg6IHN0cmluZyA9IFwiZGVmYXVsdFwiKXtcbiAgICAgICAgdGhpcy5uYW1lID0gX25hbWVcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHNxdWFyZU1hcFtfbmFtZV1cbiAgICAgICAgdGhpcy5jb2xvciA9IGdldFNxdWFyZUNvbG9yKF9uYW1lKSBcbiAgICAgICAgdGhpcy5jYW52YXMgPSBfY2FudmFzXG4gICAgICAgIHRoaXMucGF0aCA9IF9wYXRoXG4gICAgICAgIGlmKF9wYXRoID09IFwiZGVmYXVsdFwiKVxuICAgICAgICAgICAgdGhpcy5pbWFnZSA9ICh0aGlzLmNvbG9yID09IGNoZXNzQ29sb3IuV0hJVEUpID8gbmV3IFVJSW1hZ2UoX2NhbnZhcywgbmV3IFRleHR1cmUoXCJpbWFnZXMvY2hlc3Nib2FyZC93aGl0ZS1zcXVhcmUucG5nXCIpKSA6IG5ldyBVSUltYWdlKF9jYW52YXMsIG5ldyBUZXh0dXJlKFwiaW1hZ2VzL2NoZXNzYm9hcmQvYmxhY2stc3F1YXJlLnBuZ1wiKSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IG5ldyBVSUltYWdlKF9jYW52YXMsIG5ldyBUZXh0dXJlKF9wYXRoKSlcblxuICAgICAgICB0aGlzLnNldEltYWdlUHJvcGVydGllcygpXG4gICAgfVxuXG4gICAgcHVibGljIGdldENvbG9yKCk6IGNoZXNzQ29sb3J7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yXG4gICAgfVxuXG4gICAgcHVibGljIGdldFBvc2l0aW9uKCk6IElTcXVhcmV7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uXG4gICAgfVxuXG4gICAgcHVibGljIGdldEltYWdlKCk6IFVJSW1hZ2V7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlXG4gICAgfVxuXG4gICAgLy8gcHVibGljIG1vZGlmeUltYWdlKHBhdGg6c3RyaW5nKXtcbiAgICAvLyAgICAgdGhpcy5pbWFnZSA9IG5ldyBVSUltYWdlKHRoaXMuY2FudmFzLCBuZXcgVGV4dHVyZShwYXRoKSlcbiAgICAvLyAgICAgdGhpcy5zZXRJbWFnZVByb3BlcnRpZXMoKVxuICAgIC8vIH1cblxuICAgIHNldEltYWdlUHJvcGVydGllcygpe1xuICAgICAgICB0aGlzLmltYWdlLnBvc2l0aW9uWCA9IHRoaXMucG9zaXRpb24ueFBvc2l0aW9uXG4gICAgICAgIHRoaXMuaW1hZ2UucG9zaXRpb25ZID0gdGhpcy5wb3NpdGlvbi55UG9zaXRpb25cbiAgICAgICAgdGhpcy5pbWFnZS5zb3VyY2VMZWZ0ID0gMFxuICAgICAgICB0aGlzLmltYWdlLnNvdXJjZVRvcCA9IDBcbiAgICAgICAgaWYodGhpcy5wYXRoICE9IFwiZGVmYXVsdFwiKXtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2Uuc291cmNlV2lkdGggPSA5MFxuICAgICAgICAgICAgdGhpcy5pbWFnZS5zb3VyY2VIZWlnaHQgPSA5MFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1hZ2UuaGVpZ2h0ID0gNjQvcmVzaXplRmFjdG9yXG4gICAgICAgIHRoaXMuaW1hZ2Uud2lkdGggPSA2NC9yZXNpemVGYWN0b3JcbiAgICAgICAgdGhpcy5pbWFnZS52aXNpYmxlID0gdHJ1ZSBcbiAgICB9XG5cbiAgICAvL3NldHMgdGhlIHNxdWFyZSB2aXNpYmxlIGlmIG1vZGUgPT0gdHJ1ZVxuICAgIHB1YmxpYyBzZXRWaXNpYmlsaXkobW9kZTpib29sZWFuKXtcbiAgICAgICAgdGhpcy5pbWFnZS52aXNpYmxlID0gbW9kZVxuICAgIH1cbn0iLCJpbXBvcnQgeyBFTVBUWSwgV0hJVEUgfSBmcm9tIFwiLi9jb25zdGFudHNcIlxuaW1wb3J0IHsgZ2V0RmVuIH0gZnJvbSBcIi4vc3RhdGVcIlxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgQ29sb3IgPSAndycgfCAnYidcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCB0eXBlIEZlbkNvbW1lbnQgPSB7XG4gIGZlbjogc3RyaW5nO1xuICBjb21tZW50OiBzdHJpbmc7XG59XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBQYXJ0aWFsTW92ZSA9IHtcbiAgdG86IHN0cmluZztcbiAgZnJvbTogc3RyaW5nO1xuICBwcm9tb3Rpb24/OiBQaWVjZVN5bWJvbDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hlc3MgbW92ZVxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgYHBpZWNlYCwgYGNhcHR1cmVkYCwgYW5kIGBwcm9tb3Rpb25gIGZpZWxkcyBjb250YWluIHRoZSBsb3dlcmNhc2VcbiAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhcHBsaWNhYmxlIHBpZWNlLlxuICpcbiAqIFRoZSBgZmxhZ3NgIGZpZWxkIGluIHZlcmJvc2UgbW9kZSBtYXkgY29udGFpbiBvbmUgb3IgbW9yZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqXG4gKiAtIGBuYCAtIGEgbm9uLWNhcHR1cmVcbiAqXG4gKiAtIGBiYCAtIGEgcGF3biBwdXNoIG9mIHR3byBzcXVhcmVzXG4gKlxuICogLSBgZWAgLSBhbiBlbiBwYXNzYW50IGNhcHR1cmVcbiAqXG4gKiAtIGBjYCAtIGEgc3RhbmRhcmQgY2FwdHVyZVxuICpcbiAqIC0gYHBgIC0gYSBwcm9tb3Rpb25cbiAqXG4gKiAtIGBrYCAtIGtpbmdzaWRlIGNhc3RsaW5nXG4gKlxuICogLSBgcWAgLSBxdWVlbnNpZGUgY2FzdGxpbmdcbiAqXG4gKiBBIGZsYWcgb2YgYHBjYCB3b3VsZCBtZWFuIHRoYXQgYSBwYXduIGNhcHR1cmVkIGEgcGllY2Ugb24gdGhlIDh0aCByYW5rIGFuZCBwcm9tb3RlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCB0eXBlIE1vdmUgPSBQYXJ0aWFsTW92ZSAmIHtcbiAgY29sb3I6IENvbG9yO1xuICBmbGFnczogc3RyaW5nO1xuICBwaWVjZTogUGllY2VTeW1ib2w7XG4gIHNhbjogc3RyaW5nO1xuICBjYXB0dXJlZD86IFBpZWNlU3ltYm9sO1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgUGllY2UgPSB7XG4gIGNvbG9yOiBDb2xvcjtcbiAgdHlwZTogUGllY2VTeW1ib2w7XG59XG5cbi8qKiBAcHVibGljICovXG5leHBvcnQgdHlwZSBQaWVjZVN5bWJvbCA9ICdwJyB8ICduJyB8ICdiJyB8ICdyJyB8ICdxJyB8ICdrJ1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgVmFsaWRhdGlvbiA9IHtcbiAgdmFsaWQ6IGJvb2xlYW47XG4gIGVycm9yX251bWJlcjogbnVtYmVyO1xuICBlcnJvcjogc3RyaW5nO1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGNsYXNzIFN0YXRlIHtcbiAgYm9hcmQ6IEJvYXJkO1xuICBraW5nczogQ29sb3JTdGF0ZTtcbiAgdHVybjogQ29sb3I7XG4gIGNhc3RsaW5nOiBDb2xvclN0YXRlO1xuICBlcF9zcXVhcmU6IG51bWJlcjtcbiAgaGFsZl9tb3ZlczogbnVtYmVyO1xuICBtb3ZlX251bWJlcjogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGJvYXJkPzogQm9hcmQsXG4gICAga2luZ3M/OiBDb2xvclN0YXRlLFxuICAgIHR1cm4/OiBDb2xvcixcbiAgICBjYXN0bGluZz86IENvbG9yU3RhdGUsXG4gICAgZXBfc3F1YXJlPzogbnVtYmVyLFxuICAgIGhhbGZfbW92ZXM/OiBudW1iZXIsXG4gICAgbW92ZV9udW1iZXI/OiBudW1iZXIsXG4gICkge1xuICAgIHRoaXMuYm9hcmQgPSBib2FyZCB8fCBuZXcgQXJyYXkoMTI4KVxuICAgIHRoaXMua2luZ3MgPSBraW5ncyB8fCB7IHc6IEVNUFRZLCBiOiBFTVBUWSB9XG4gICAgdGhpcy50dXJuID0gdHVybiB8fCBXSElURVxuICAgIHRoaXMuY2FzdGxpbmcgPSBjYXN0bGluZyB8fCB7IHc6IDAsIGI6IDAgfVxuICAgIHRoaXMuZXBfc3F1YXJlID0gZXBfc3F1YXJlIHx8IEVNUFRZXG4gICAgdGhpcy5oYWxmX21vdmVzID0gaGFsZl9tb3ZlcyB8fCAwXG4gICAgdGhpcy5tb3ZlX251bWJlciA9IG1vdmVfbnVtYmVyIHx8IDFcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBTdGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZShcbiAgICAgIHRoaXMuYm9hcmQuc2xpY2UoKSxcbiAgICAgIHtcbiAgICAgICAgdzogdGhpcy5raW5ncy53LFxuICAgICAgICBiOiB0aGlzLmtpbmdzLmIsXG4gICAgICB9LFxuICAgICAgdGhpcy50dXJuLFxuICAgICAge1xuICAgICAgICB3OiB0aGlzLmNhc3RsaW5nLncsXG4gICAgICAgIGI6IHRoaXMuY2FzdGxpbmcuYixcbiAgICAgIH0sXG4gICAgICB0aGlzLmVwX3NxdWFyZSxcbiAgICAgIHRoaXMuaGFsZl9tb3ZlcyxcbiAgICAgIHRoaXMubW92ZV9udW1iZXIsXG4gICAgKVxuICB9XG5cbiAgcHVibGljIGdldCBmZW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0RmVuKHRoaXMpXG4gIH1cbn1cblxuLyoqIFByaXZhdGUgdHlwZXMgKi9cbmV4cG9ydCB0eXBlIEJvYXJkID0gQXJyYXk8UGllY2UgfCB1bmRlZmluZWQ+XG5cbmV4cG9ydCB0eXBlIENvbG9yU3RhdGUgPSBSZWNvcmQ8Q29sb3IsIG51bWJlcj4gJiB7XG4gIHc6IG51bWJlcjtcbiAgYjogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBDb21tZW50cyA9IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgc3RyaW5nPj5cblxuZXhwb3J0IHR5cGUgRmxhZ0tleSA9ICdOT1JNQUwnIHwgJ0NBUFRVUkUnIHwgJ0JJR19QQVdOJyB8ICdFUF9DQVBUVVJFJyB8ICdQUk9NT1RJT04nIHwgJ0tTSURFX0NBU1RMRScgfCAnUVNJREVfQ0FTVExFJ1xuXG5leHBvcnQgdHlwZSBHYW1lSGlzdG9yeSA9IHtcbiAgbW92ZTogSGV4TW92ZTtcbiAgc3RhdGU6IFN0YXRlO1xufVxuXG5leHBvcnQgdHlwZSBIZXhNb3ZlID0ge1xuICB0bzogbnVtYmVyO1xuICBmcm9tOiBudW1iZXI7XG4gIGNvbG9yOiBDb2xvcjtcbiAgZmxhZ3M6IG51bWJlcjtcbiAgcGllY2U6IFBpZWNlU3ltYm9sO1xuICBjYXB0dXJlZD86IFBpZWNlU3ltYm9sO1xuICBwcm9tb3Rpb24/OiBQaWVjZVN5bWJvbDtcbiAgc2FuPzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBTcXVhcmUgPSAnYTgnIHwgJ2I4JyB8ICdjOCcgfCAnZDgnIHwgJ2U4JyB8ICdmOCcgfCAnZzgnIHwgJ2g4JyB8XG4gICAgICAgICAgICAgICdhNycgfCAnYjcnIHwgJ2M3JyB8ICdkNycgfCAnZTcnIHwgJ2Y3JyB8ICdnNycgfCAnaDcnIHxcbiAgICAgICAgICAgICAgJ2E2JyB8ICdiNicgfCAnYzYnIHwgJ2Q2JyB8ICdlNicgfCAnZjYnIHwgJ2c2JyB8ICdoNicgfFxuICAgICAgICAgICAgICAnYTUnIHwgJ2I1JyB8ICdjNScgfCAnZDUnIHwgJ2U1JyB8ICdmNScgfCAnZzUnIHwgJ2g1JyB8XG4gICAgICAgICAgICAgICdhNCcgfCAnYjQnIHwgJ2M0JyB8ICdkNCcgfCAnZTQnIHwgJ2Y0JyB8ICdnNCcgfCAnaDQnIHxcbiAgICAgICAgICAgICAgJ2EzJyB8ICdiMycgfCAnYzMnIHwgJ2QzJyB8ICdlMycgfCAnZjMnIHwgJ2czJyB8ICdoMycgfFxuICAgICAgICAgICAgICAnYTInIHwgJ2IyJyB8ICdjMicgfCAnZDInIHwgJ2UyJyB8ICdmMicgfCAnZzInIHwgJ2gyJyB8XG4gICAgICAgICAgICAgICdhMScgfCAnYjEnIHwgJ2MxJyB8ICdkMScgfCAnZTEnIHwgJ2YxJyB8ICdnMScgfCAnaDEnXG4iLCJpbXBvcnQge1xuICBDb2xvcixcbiAgRmxhZ0tleSxcbiAgUGllY2VTeW1ib2wsXG4gIFNxdWFyZSxcbn0gZnJvbSAnLi90eXBlcydcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBjb25zdCBXSElURTogQ29sb3IgPSAndydcbi8qKiBAcHVibGljICovXG5leHBvcnQgY29uc3QgQkxBQ0s6IENvbG9yID0gJ2InXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGNvbnN0IFBBV046IFBpZWNlU3ltYm9sID0gJ3AnXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGNvbnN0IEtOSUdIVDogUGllY2VTeW1ib2wgPSAnbidcbi8qKiBAcHVibGljICovXG5leHBvcnQgY29uc3QgQklTSE9QOiBQaWVjZVN5bWJvbCA9ICdiJ1xuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBjb25zdCBST09LOiBQaWVjZVN5bWJvbCA9ICdyJ1xuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBjb25zdCBRVUVFTjogUGllY2VTeW1ib2wgPSAncSdcbi8qKiBAcHVibGljICovXG5leHBvcnQgY29uc3QgS0lORzogUGllY2VTeW1ib2wgPSAnaydcbi8qKiBAcHVibGljICovXG5leHBvcnQgY29uc3QgRU1QVFkgPSAtMVxuXG5leHBvcnQgY29uc3QgU1lNQk9MUyA9ICdwbmJycWtQTkJSUUsnXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPU0lUSU9OID1cbiAgICAncm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDEnXG5cbmV4cG9ydCBjb25zdCBQT1NTSUJMRV9SRVNVTFRTOiBzdHJpbmdbXSA9IFsnMS0wJywgJzAtMScsICcxLzItMS8yJywgJyonXVxuXG5leHBvcnQgY29uc3QgUEFXTl9PRkZTRVRTOiBSZWNvcmQ8Q29sb3IsIG51bWJlcltdPiA9IHtcbiAgYjogWzE2LCAzMiwgMTcsIDE1XSxcbiAgdzogWy0xNiwgLTMyLCAtMTcsIC0xNV1cbn1cblxuZXhwb3J0IGNvbnN0IFBJRUNFX09GRlNFVFM6IFJlY29yZDxQaWVjZVN5bWJvbCwgbnVtYmVyW10+ID0ge1xuICBwOiBbXSxcbiAgbjogWy0xOCwgLTMzLCAtMzEsIC0xNCwgMTgsIDMzLCAzMSwgMTRdLFxuICBiOiBbLTE3LCAtMTUsIDE3LCAxNV0sXG4gIHI6IFstMTYsIDEsIDE2LCAtMV0sXG4gIHE6IFstMTcsIC0xNiwgLTE1LCAxLCAxNywgMTYsIDE1LCAtMV0sXG4gIGs6IFstMTcsIC0xNiwgLTE1LCAxLCAxNywgMTYsIDE1LCAtMV1cbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgQVRUQUNLUzogbnVtYmVyW10gPSBbXG4gIDIwLCAwLCAwLCAwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsIDAsIDAsIDAsMjAsIDAsXG4gICAwLDIwLCAwLCAwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsIDAsIDAsMjAsIDAsIDAsXG4gICAwLCAwLDIwLCAwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsIDAsMjAsIDAsIDAsIDAsXG4gICAwLCAwLCAwLDIwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsMjAsIDAsIDAsIDAsIDAsXG4gICAwLCAwLCAwLCAwLDIwLCAwLCAwLCAyNCwgIDAsIDAsMjAsIDAsIDAsIDAsIDAsIDAsXG4gICAwLCAwLCAwLCAwLCAwLDIwLCAyLCAyNCwgIDIsMjAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAwLCAwLCAwLCAwLCAwLCAyLDUzLCA1NiwgNTMsIDIsIDAsIDAsIDAsIDAsIDAsIDAsXG4gIDI0LDI0LDI0LDI0LDI0LDI0LDU2LCAgMCwgNTYsMjQsMjQsMjQsMjQsMjQsMjQsIDAsXG4gICAwLCAwLCAwLCAwLCAwLCAyLDUzLCA1NiwgNTMsIDIsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAwLCAwLCAwLCAwLCAwLDIwLCAyLCAyNCwgIDIsMjAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAwLCAwLCAwLCAwLDIwLCAwLCAwLCAyNCwgIDAsIDAsMjAsIDAsIDAsIDAsIDAsIDAsXG4gICAwLCAwLCAwLDIwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsMjAsIDAsIDAsIDAsIDAsXG4gICAwLCAwLDIwLCAwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsIDAsMjAsIDAsIDAsIDAsXG4gICAwLDIwLCAwLCAwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsIDAsIDAsMjAsIDAsIDAsXG4gIDIwLCAwLCAwLCAwLCAwLCAwLCAwLCAyNCwgIDAsIDAsIDAsIDAsIDAsIDAsMjBcbl1cblxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgUkFZUzogbnVtYmVyW10gPSBbXG4gICAxNywgIDAsICAwLCAgMCwgIDAsICAwLCAgMCwgMTYsICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsIDE1LCAwLFxuICAgIDAsIDE3LCAgMCwgIDAsICAwLCAgMCwgIDAsIDE2LCAgMCwgIDAsICAwLCAgMCwgIDAsIDE1LCAgMCwgMCxcbiAgICAwLCAgMCwgMTcsICAwLCAgMCwgIDAsICAwLCAxNiwgIDAsICAwLCAgMCwgIDAsIDE1LCAgMCwgIDAsIDAsXG4gICAgMCwgIDAsICAwLCAxNywgIDAsICAwLCAgMCwgMTYsICAwLCAgMCwgIDAsIDE1LCAgMCwgIDAsICAwLCAwLFxuICAgIDAsICAwLCAgMCwgIDAsIDE3LCAgMCwgIDAsIDE2LCAgMCwgIDAsIDE1LCAgMCwgIDAsICAwLCAgMCwgMCxcbiAgICAwLCAgMCwgIDAsICAwLCAgMCwgMTcsICAwLCAxNiwgIDAsIDE1LCAgMCwgIDAsICAwLCAgMCwgIDAsIDAsXG4gICAgMCwgIDAsICAwLCAgMCwgIDAsICAwLCAxNywgMTYsIDE1LCAgMCwgIDAsICAwLCAgMCwgIDAsICAwLCAwLFxuICAgIDEsICAxLCAgMSwgIDEsICAxLCAgMSwgIDEsICAwLCAtMSwgLTEsICAtMSwtMSwgLTEsIC0xLCAtMSwgMCxcbiAgICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsLTE1LC0xNiwtMTcsICAwLCAgMCwgIDAsICAwLCAgMCwgIDAsIDAsXG4gICAgMCwgIDAsICAwLCAgMCwgIDAsLTE1LCAgMCwtMTYsICAwLC0xNywgIDAsICAwLCAgMCwgIDAsICAwLCAwLFxuICAgIDAsICAwLCAgMCwgIDAsLTE1LCAgMCwgIDAsLTE2LCAgMCwgIDAsLTE3LCAgMCwgIDAsICAwLCAgMCwgMCxcbiAgICAwLCAgMCwgIDAsLTE1LCAgMCwgIDAsICAwLC0xNiwgIDAsICAwLCAgMCwtMTcsICAwLCAgMCwgIDAsIDAsXG4gICAgMCwgIDAsLTE1LCAgMCwgIDAsICAwLCAgMCwtMTYsICAwLCAgMCwgIDAsICAwLC0xNywgIDAsICAwLCAwLFxuICAgIDAsLTE1LCAgMCwgIDAsICAwLCAgMCwgIDAsLTE2LCAgMCwgIDAsICAwLCAgMCwgIDAsLTE3LCAgMCwgMCxcbiAgLTE1LCAgMCwgIDAsICAwLCAgMCwgIDAsICAwLC0xNiwgIDAsICAwLCAgMCwgIDAsICAwLCAgMCwtMTdcbl1cblxuZXhwb3J0IGNvbnN0IFNISUZUUzogUmVjb3JkPFBpZWNlU3ltYm9sLCBudW1iZXI+ID0geyBwOiAwLCBuOiAxLCBiOiAyLCByOiAzLCBxOiA0LCBrOiA1IH1cblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBjb25zdCBGTEFHUzogUmVjb3JkPEZsYWdLZXksIHN0cmluZz4gPSB7XG4gIE5PUk1BTDogJ24nLFxuICBDQVBUVVJFOiAnYycsXG4gIEJJR19QQVdOOiAnYicsXG4gIEVQX0NBUFRVUkU6ICdlJyxcbiAgUFJPTU9USU9OOiAncCcsXG4gIEtTSURFX0NBU1RMRTogJ2snLFxuICBRU0lERV9DQVNUTEU6ICdxJ1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGNvbnN0IEJJVFM6IFJlY29yZDxGbGFnS2V5LCBudW1iZXI+ID0ge1xuICBOT1JNQUw6IDEsXG4gIENBUFRVUkU6IDIsXG4gIEJJR19QQVdOOiA0LFxuICBFUF9DQVBUVVJFOiA4LFxuICBQUk9NT1RJT046IDE2LFxuICBLU0lERV9DQVNUTEU6IDMyLFxuICBRU0lERV9DQVNUTEU6IDY0XG59XG5cbmV4cG9ydCBjb25zdCBSQU5LXzEgPSA3XG5leHBvcnQgY29uc3QgUkFOS18yID0gNlxuZXhwb3J0IGNvbnN0IFJBTktfMyA9IDVcbmV4cG9ydCBjb25zdCBSQU5LXzQgPSA0XG5leHBvcnQgY29uc3QgUkFOS181ID0gM1xuZXhwb3J0IGNvbnN0IFJBTktfNiA9IDJcbmV4cG9ydCBjb25zdCBSQU5LXzcgPSAxXG5leHBvcnQgY29uc3QgUkFOS184ID0gMFxuXG5leHBvcnQgY29uc3QgUkFOS1MgPSBbUkFOS184LCBSQU5LXzcsIFJBTktfNiwgUkFOS181LCBSQU5LXzQsIFJBTktfMywgUkFOS18yLCBSQU5LXzFdXG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBjb25zdCBTUVVBUkVTOiBSZWNvcmQ8U3F1YXJlLCBudW1iZXI+ID0ge1xuICBhODogICAwLCBiODogICAxLCBjODogICAyLCBkODogICAzLCBlODogICA0LCBmODogICA1LCBnODogICA2LCBoODogICA3LFxuICBhNzogIDE2LCBiNzogIDE3LCBjNzogIDE4LCBkNzogIDE5LCBlNzogIDIwLCBmNzogIDIxLCBnNzogIDIyLCBoNzogIDIzLFxuICBhNjogIDMyLCBiNjogIDMzLCBjNjogIDM0LCBkNjogIDM1LCBlNjogIDM2LCBmNjogIDM3LCBnNjogIDM4LCBoNjogIDM5LFxuICBhNTogIDQ4LCBiNTogIDQ5LCBjNTogIDUwLCBkNTogIDUxLCBlNTogIDUyLCBmNTogIDUzLCBnNTogIDU0LCBoNTogIDU1LFxuICBhNDogIDY0LCBiNDogIDY1LCBjNDogIDY2LCBkNDogIDY3LCBlNDogIDY4LCBmNDogIDY5LCBnNDogIDcwLCBoNDogIDcxLFxuICBhMzogIDgwLCBiMzogIDgxLCBjMzogIDgyLCBkMzogIDgzLCBlMzogIDg0LCBmMzogIDg1LCBnMzogIDg2LCBoMzogIDg3LFxuICBhMjogIDk2LCBiMjogIDk3LCBjMjogIDk4LCBkMjogIDk5LCBlMjogMTAwLCBmMjogMTAxLCBnMjogMTAyLCBoMjogMTAzLFxuICBhMTogMTEyLCBiMTogMTEzLCBjMTogMTE0LCBkMTogMTE1LCBlMTogMTE2LCBmMTogMTE3LCBnMTogMTE4LCBoMTogMTE5XG59XG5cbmV4cG9ydCBjb25zdCBST09LUzogUmVjb3JkPENvbG9yLCB7IHNxdWFyZTogbnVtYmVyLCBmbGFnOiBudW1iZXIgfVtdPiA9IHtcbiAgdzogW1xuICAgIHsgc3F1YXJlOiBTUVVBUkVTLmExLCBmbGFnOiBCSVRTLlFTSURFX0NBU1RMRSB9LFxuICAgIHsgc3F1YXJlOiBTUVVBUkVTLmgxLCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9XG4gIF0sXG4gIGI6IFtcbiAgICB7IHNxdWFyZTogU1FVQVJFUy5hOCwgZmxhZzogQklUUy5RU0lERV9DQVNUTEUgfSxcbiAgICB7IHNxdWFyZTogU1FVQVJFUy5oOCwgZmxhZzogQklUUy5LU0lERV9DQVNUTEUgfVxuICBdXG59XG4iLCJpbXBvcnQge1xuICBCTEFDSyxcbiAgV0hJVEUsXG59IGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHtcbiAgQ29sb3IsXG4gIEZsYWdLZXksXG4gIFBpZWNlLFxuICBQaWVjZVN5bWJvbCxcbiAgU3F1YXJlLFxuICBWYWxpZGF0aW9uLFxufSBmcm9tIFwiLi90eXBlc1wiXG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIHplcm8tYmFzZWQgcmFuayBvZiBhbiAweDg4IHNxdWFyZS5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmsoaTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGkgPj4gNFxufVxuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSB6ZXJvLWJhc2VkIGZpbGUgb2YgYW4gMHg4OCBzcXVhcmUuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWxlKGk6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBpICYgMTVcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIDB4ODggc3F1YXJlIHRvIGFsZ2VicmFpYyBub3RhdGlvbi5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsZ2VicmFpYyhpOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBmID0gZmlsZShpKVxuICBjb25zdCByID0gcmFuayhpKVxuICByZXR1cm4gJ2FiY2RlZmdoJy5zdWJzdHJpbmcoZiwgZiArIDEpICsgJzg3NjU0MzIxJy5zdWJzdHJpbmcociwgciArIDEpXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3Bwb3NpdGUgY29sb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzd2FwQ29sb3IoYzogQ29sb3IpOiBDb2xvciB7XG4gIHJldHVybiBjID09PSBXSElURSA/IEJMQUNLIDogV0hJVEVcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjaGFyYWN0ZXIgaXMgYSBudW1lcmljIGRpZ2l0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEaWdpdChjOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9eWzAtOV0kLy50ZXN0KGMpXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgQVNDSUkgc3ltYm9sIGZvciBlYWNoIHBpZWNlLiAgV2hpdGUgcGllY2VzIGFyZSBpbiB1cHBlcmNhc2UsXG4gKiBibGFjayBpbiBsb3dlcmNhc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzeW1ib2woeyB0eXBlLCBjb2xvciB9OiBQaWVjZSk6IHN0cmluZyB7XG4gIHJldHVybiBjb2xvciA9PT0gV0hJVEUgPyB0eXBlLnRvVXBwZXJDYXNlKCkgOiB0eXBlLnRvTG93ZXJDYXNlKClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29sb3IoY29sb3I6IHN0cmluZyk6IGNvbG9yIGlzIENvbG9yIHtcbiAgcmV0dXJuIGNvbG9yID09PSAndycgfHwgY29sb3IgPT09ICdiJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQaWVjZVN5bWJvbChzeW1ib2w6IHN0cmluZyk6IHN5bWJvbCBpcyBQaWVjZVN5bWJvbCB7XG4gIHJldHVybiAvXltwbmJycWtdJC8udGVzdChzeW1ib2wpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NxdWFyZShzcTogc3RyaW5nKTogc3EgaXMgU3F1YXJlIHtcbiAgcmV0dXJuIC9eW2EtaF1bMS04XSQvLnRlc3Qoc3EpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZsYWdLZXkoa2V5OiBzdHJpbmcpOiBrZXkgaXMgRmxhZ0tleSB7XG4gIGNvbnN0IGtleXMgPSBbJ05PUk1BTCcsICdDQVBUVVJFJywgJ0JJR19QQVdOJywgJ0VQX0NBUFRVUkUnLCAnUFJPTU9USU9OJywgJ0tTSURFX0NBU1RMRScsICdRU0lERV9DQVNUTEUnXVxuICByZXR1cm4ga2V5cy5pbmRleE9mKGtleSkgIT09IC0xXG59XG5cbi8qIFRPRE86IHRoaXMgZnVuY3Rpb24gaXMgcHJldHR5IG11Y2ggY3JhcCAtIGl0IHZhbGlkYXRlcyBzdHJ1Y3R1cmUgYnV0XG4gKiBjb21wbGV0ZWx5IGlnbm9yZXMgY29udGVudCAoZS5nLiBkb2Vzbid0IHZlcmlmeSB0aGF0IGVhY2ggc2lkZSBoYXMgYSBraW5nKVxuICogLi4uIHdlIHNob3VsZCByZXdyaXRlIHRoaXMsIGFuZCBkaXRjaCB0aGUgc2lsbHkgZXJyb3JfbnVtYmVyIGZpZWxkIHdoaWxlXG4gKiB3ZSdyZSBhdCBpdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGZW4oZmVuOiBzdHJpbmcpOiBWYWxpZGF0aW9uIHtcbiAgY29uc3QgZXJyb3JzOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge1xuICAgIDA6ICdObyBlcnJvcnMuJyxcbiAgICAxOiAnRkVOIHN0cmluZyBtdXN0IGNvbnRhaW4gc2l4IHNwYWNlLWRlbGltaXRlZCBmaWVsZHMuJyxcbiAgICAyOiAnNnRoIGZpZWxkIChtb3ZlIG51bWJlcikgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyxcbiAgICAzOiAnNXRoIGZpZWxkIChoYWxmIG1vdmUgY291bnRlcikgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLicsXG4gICAgNDogJzR0aCBmaWVsZCAoZW4tcGFzc2FudCBzcXVhcmUpIGlzIGludmFsaWQuJyxcbiAgICA1OiAnM3JkIGZpZWxkIChjYXN0bGluZyBhdmFpbGFiaWxpdHkpIGlzIGludmFsaWQuJyxcbiAgICA2OiAnMm5kIGZpZWxkIChzaWRlIHRvIG1vdmUpIGlzIGludmFsaWQuJyxcbiAgICA3OiBcIjFzdCBmaWVsZCAocGllY2UgcG9zaXRpb25zKSBkb2VzIG5vdCBjb250YWluIDggJy8nLWRlbGltaXRlZCByb3dzLlwiLFxuICAgIDg6ICcxc3QgZmllbGQgKHBpZWNlIHBvc2l0aW9ucykgaXMgaW52YWxpZCBbY29uc2VjdXRpdmUgbnVtYmVyc10uJyxcbiAgICA5OiAnMXN0IGZpZWxkIChwaWVjZSBwb3NpdGlvbnMpIGlzIGludmFsaWQgW2ludmFsaWQgcGllY2VdLicsXG4gICAgMTA6ICcxc3QgZmllbGQgKHBpZWNlIHBvc2l0aW9ucykgaXMgaW52YWxpZCBbcm93IHRvbyBsYXJnZV0uJyxcbiAgICAxMTogJ0lsbGVnYWwgZW4tcGFzc2FudCBzcXVhcmUnXG4gIH1cblxuICAvKiAxc3QgY3JpdGVyaW9uOiA2IHNwYWNlLXNlcGVyYXRlZCBmaWVsZHM/ICovXG4gIGNvbnN0IHRva2VucyA9IGZlbi5zcGxpdCgvXFxzKy8pXG4gIGlmICh0b2tlbnMubGVuZ3RoICE9PSA2KSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcl9udW1iZXI6IDEsIGVycm9yOiBlcnJvcnNbMV0gfVxuICB9XG5cbiAgLyogMm5kIGNyaXRlcmlvbjogbW92ZSBudW1iZXIgZmllbGQgaXMgYSBpbnRlZ2VyIHZhbHVlID4gMD8gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgaWYgKGlzTmFOKHRva2Vuc1s1XSBhcyBhbnkpIHx8IHBhcnNlSW50KHRva2Vuc1s1XSwgMTApIDw9IDApIHtcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yX251bWJlcjogMiwgZXJyb3I6IGVycm9yc1syXSB9XG4gIH1cblxuICAvKiAzcmQgY3JpdGVyaW9uOiBoYWxmIG1vdmUgY291bnRlciBpcyBhbiBpbnRlZ2VyID49IDA/ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGlmIChpc05hTih0b2tlbnNbNF0gYXMgYW55KSB8fCBwYXJzZUludCh0b2tlbnNbNF0sIDEwKSA8IDApIHtcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yX251bWJlcjogMywgZXJyb3I6IGVycm9yc1szXSB9XG4gIH1cblxuICAvKiA0dGggY3JpdGVyaW9uOiA0dGggZmllbGQgaXMgYSB2YWxpZCBlLnAuLXN0cmluZz8gKi9cbiAgaWYgKCEvXigtfFthYmNkZWZnaF1bMzZdKSQvLnRlc3QodG9rZW5zWzNdKSkge1xuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiA0LCBlcnJvcjogZXJyb3JzWzRdIH1cbiAgfVxuXG4gIC8qIDV0aCBjcml0ZXJpb246IDN0aCBmaWVsZCBpcyBhIHZhbGlkIGNhc3RsZS1zdHJpbmc/ICovXG4gIGlmICghL14oS1E/az9xP3xRaz9xP3xrcT98cXwtKSQvLnRlc3QodG9rZW5zWzJdKSkge1xuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiA1LCBlcnJvcjogZXJyb3JzWzVdIH1cbiAgfVxuXG4gIC8qIDZ0aCBjcml0ZXJpb246IDJuZCBmaWVsZCBpcyBcIndcIiAod2hpdGUpIG9yIFwiYlwiIChibGFjayk/ICovXG4gIGlmICghL14od3xiKSQvLnRlc3QodG9rZW5zWzFdKSkge1xuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiA2LCBlcnJvcjogZXJyb3JzWzZdIH1cbiAgfVxuXG4gIC8qIDd0aCBjcml0ZXJpb246IDFzdCBmaWVsZCBjb250YWlucyA4IHJvd3M/ICovXG4gIGNvbnN0IHJvd3MgPSB0b2tlbnNbMF0uc3BsaXQoJy8nKVxuICBpZiAocm93cy5sZW5ndGggIT09IDgpIHtcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yX251bWJlcjogNywgZXJyb3I6IGVycm9yc1s3XSB9XG4gIH1cblxuICAvKiA4dGggY3JpdGVyaW9uOiBldmVyeSByb3cgaXMgdmFsaWQ/ICovXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgIC8qIGNoZWNrIGZvciByaWdodCBzdW0gb2YgZmllbGRzIEFORCBub3QgdHdvIG51bWJlcnMgaW4gc3VjY2Vzc2lvbiAqL1xuICAgIGxldCBzdW1fZmllbGRzID0gMFxuICAgIGxldCBwcmV2aW91c193YXNfbnVtYmVyID0gZmFsc2VcblxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93c1tpXS5sZW5ndGg7IGsrKykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgIGlmICghaXNOYU4ocm93c1tpXVtrXSBhcyBhbnkpKSB7XG4gICAgICAgIGlmIChwcmV2aW91c193YXNfbnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcl9udW1iZXI6IDgsIGVycm9yOiBlcnJvcnNbOF0gfVxuICAgICAgICB9XG4gICAgICAgIHN1bV9maWVsZHMgKz0gcGFyc2VJbnQocm93c1tpXVtrXSwgMTApXG4gICAgICAgIHByZXZpb3VzX3dhc19udW1iZXIgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIS9eW3BybmJxa1BSTkJRS10kLy50ZXN0KHJvd3NbaV1ba10pKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcl9udW1iZXI6IDksIGVycm9yOiBlcnJvcnNbOV0gfVxuICAgICAgICB9XG4gICAgICAgIHN1bV9maWVsZHMgKz0gMVxuICAgICAgICBwcmV2aW91c193YXNfbnVtYmVyID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1bV9maWVsZHMgIT09IDgpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiAxMCwgZXJyb3I6IGVycm9yc1sxMF0gfVxuICAgIH1cbiAgfVxuXG4gIGlmIChcbiAgICAodG9rZW5zWzNdWzFdID09ICczJyAmJiB0b2tlbnNbMV0gPT0gJ3cnKSB8fFxuICAgICAgKHRva2Vuc1szXVsxXSA9PSAnNicgJiYgdG9rZW5zWzFdID09ICdiJylcbiAgKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcl9udW1iZXI6IDExLCBlcnJvcjogZXJyb3JzWzExXSB9XG4gIH1cblxuICAvKiBldmVyeXRoaW5nJ3Mgb2theSEgKi9cbiAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGVycm9yX251bWJlcjogMCwgZXJyb3I6IGVycm9yc1swXSB9XG59XG5cbi8vIHBhcnNlcyBhbGwgb2YgdGhlIGRlY29yYXRvcnMgb3V0IG9mIGEgU0FOIHN0cmluZ1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwcGVkU2FuKG1vdmU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBtb3ZlLnJlcGxhY2UoLz0vLCAnJykucmVwbGFjZSgvWysjXT9bPyFdKiQvLCAnJylcbn1cbiIsImltcG9ydCB7XG4gIEFUVEFDS1MsXG4gIEJJU0hPUCxcbiAgQklUUyxcbiAgQkxBQ0ssXG4gIEVNUFRZLFxuICBGTEFHUyxcbiAgS0lORyxcbiAgS05JR0hULFxuICBQQVdOLFxuICBQQVdOX09GRlNFVFMsXG4gIFBJRUNFX09GRlNFVFMsXG4gIFBPU1NJQkxFX1JFU1VMVFMsXG4gIFFVRUVOLFxuICBSQU5LXzEsXG4gIFJBTktfMixcbiAgUkFOS183LFxuICBSQU5LXzgsXG4gIFJBTktTLFxuICBSQVlTLFxuICBST09LLFxuICBST09LUyxcbiAgU0hJRlRTLFxuICBTUVVBUkVTLFxuICBXSElURSxcbiAgREVGQVVMVF9QT1NJVElPTixcbn0gZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQge1xuICBCb2FyZCxcbiAgQ29sb3IsXG4gIENvbW1lbnRzLFxuICBHYW1lSGlzdG9yeSxcbiAgSGV4TW92ZSxcbiAgUGllY2UsXG4gIE1vdmUsXG4gIFNxdWFyZSxcbiAgU3RhdGUsXG4gIFBhcnRpYWxNb3ZlLFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHtcbiAgYWxnZWJyYWljLFxuICBmaWxlLFxuICBpc0NvbG9yLFxuICBpc0RpZ2l0LFxuICBpc0ZsYWdLZXksXG4gIGlzUGllY2VTeW1ib2wsXG4gIGlzU3F1YXJlLFxuICByYW5rLFxuICBzdHJpcHBlZFNhbixcbiAgc3dhcENvbG9yLFxuICBzeW1ib2wsXG4gIHZhbGlkYXRlRmVuLFxufSBmcm9tICcuL3V0aWxzJ1xuXG4vKiB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW1iaWd1b3VzIG1vdmVzICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzYW1iaWd1YXRvcihzdGF0ZTogU3RhdGUsIG1vdmU6IEhleE1vdmUsIHNsb3BweTogYm9vbGVhbik6IHN0cmluZyB7XG4gIGNvbnN0IG1vdmVzID0gZ2VuZXJhdGVNb3ZlcyhzdGF0ZSwgeyBsZWdhbDogIXNsb3BweSB9KVxuXG4gIGNvbnN0IGZyb20gPSBtb3ZlLmZyb21cbiAgY29uc3QgdG8gPSBtb3ZlLnRvXG4gIGNvbnN0IHBpZWNlID0gbW92ZS5waWVjZVxuXG4gIGxldCBhbWJpZ3VpdGllcyA9IDBcbiAgbGV0IHNhbWVfcmFuayA9IDBcbiAgbGV0IHNhbWVfZmlsZSA9IDBcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBhbWJpZ19mcm9tID0gbW92ZXNbaV0uZnJvbVxuICAgIGNvbnN0IGFtYmlnX3RvID0gbW92ZXNbaV0udG9cbiAgICBjb25zdCBhbWJpZ19waWVjZSA9IG1vdmVzW2ldLnBpZWNlXG5cbiAgICAvKiBpZiBhIG1vdmUgb2YgdGhlIHNhbWUgcGllY2UgdHlwZSBlbmRzIG9uIHRoZSBzYW1lIHRvIHNxdWFyZSwgd2UnbGxcbiAgICAgKiBuZWVkIHRvIGFkZCBhIGRpc2FtYmlndWF0b3IgdG8gdGhlIGFsZ2VicmFpYyBub3RhdGlvblxuICAgICAqL1xuICAgIGlmIChwaWVjZSA9PT0gYW1iaWdfcGllY2UgJiYgZnJvbSAhPT0gYW1iaWdfZnJvbSAmJiB0byA9PT0gYW1iaWdfdG8pIHtcbiAgICAgIGFtYmlndWl0aWVzKytcblxuICAgICAgaWYgKHJhbmsoZnJvbSkgPT09IHJhbmsoYW1iaWdfZnJvbSkpIHtcbiAgICAgICAgc2FtZV9yYW5rKytcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGUoZnJvbSkgPT09IGZpbGUoYW1iaWdfZnJvbSkpIHtcbiAgICAgICAgc2FtZV9maWxlKytcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYW1iaWd1aXRpZXMgPiAwKSB7XG4gICAgLyogaWYgdGhlcmUgZXhpc3RzIGEgc2ltaWxhciBtb3ZpbmcgcGllY2Ugb24gdGhlIHNhbWUgcmFuayBhbmQgZmlsZSBhc1xuICAgICAqIHRoZSBtb3ZlIGluIHF1ZXN0aW9uLCB1c2UgdGhlIHNxdWFyZSBhcyB0aGUgZGlzYW1iaWd1YXRvclxuICAgICAqL1xuICAgIGlmIChzYW1lX3JhbmsgPiAwICYmIHNhbWVfZmlsZSA+IDApIHtcbiAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSlcbiAgICB9IGVsc2UgaWYgKHNhbWVfZmlsZSA+IDApIHtcbiAgICAgIC8qIGlmIHRoZSBtb3ZpbmcgcGllY2UgcmVzdHMgb24gdGhlIHNhbWUgZmlsZSwgdXNlIHRoZSByYW5rIHN5bWJvbCBhcyB0aGVcbiAgICAgICAqIGRpc2FtYmlndWF0b3JcbiAgICAgICAqL1xuICAgICAgcmV0dXJuIGFsZ2VicmFpYyhmcm9tKS5jaGFyQXQoMSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZWxzZSB1c2UgdGhlIGZpbGUgc3ltYm9sICovXG4gICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pLmNoYXJBdCgwKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVuKHN0YXRlOiBTdGF0ZSk6IHN0cmluZyB7XG4gIGxldCBlbXB0eSA9IDBcbiAgbGV0IGZlbiA9ICcnXG5cbiAgZm9yIChsZXQgaSA9IFNRVUFSRVMuYTg7IGkgPD0gU1FVQVJFUy5oMTsgaSsrKSB7XG4gICAgY29uc3QgcGllY2UgPSBzdGF0ZS5ib2FyZFtpXVxuICAgIGlmICghcGllY2UpIHtcbiAgICAgIGVtcHR5KytcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVtcHR5ID4gMCkge1xuICAgICAgICBmZW4gKz0gZW1wdHlcbiAgICAgICAgZW1wdHkgPSAwXG4gICAgICB9XG4gICAgICBjb25zdCBjb2xvciA9IHBpZWNlLmNvbG9yXG4gICAgICBjb25zdCBwaWVjZV90eXBlID0gcGllY2UudHlwZVxuXG4gICAgICBmZW4gKz0gY29sb3IgPT09IFdISVRFID8gcGllY2VfdHlwZS50b1VwcGVyQ2FzZSgpIDogcGllY2VfdHlwZS50b0xvd2VyQ2FzZSgpXG4gICAgfVxuXG4gICAgaWYgKChpICsgMSkgJiAweDg4KSB7XG4gICAgICBpZiAoZW1wdHkgPiAwKSB7XG4gICAgICAgIGZlbiArPSBlbXB0eVxuICAgICAgfVxuXG4gICAgICBpZiAoaSAhPT0gU1FVQVJFUy5oMSkge1xuICAgICAgICBmZW4gKz0gJy8nXG4gICAgICB9XG5cbiAgICAgIGVtcHR5ID0gMFxuICAgICAgaSArPSA4XG4gICAgfVxuICB9XG5cbiAgbGV0IGNmbGFncyA9ICcnXG4gIGlmIChzdGF0ZS5jYXN0bGluZ1tXSElURV0gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgIGNmbGFncyArPSAnSydcbiAgfVxuICBpZiAoc3RhdGUuY2FzdGxpbmdbV0hJVEVdICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICBjZmxhZ3MgKz0gJ1EnXG4gIH1cbiAgaWYgKHN0YXRlLmNhc3RsaW5nW0JMQUNLXSAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgY2ZsYWdzICs9ICdrJ1xuICB9XG4gIGlmIChzdGF0ZS5jYXN0bGluZ1tCTEFDS10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgIGNmbGFncyArPSAncSdcbiAgfVxuXG4gIC8qIGRvIHdlIGhhdmUgYW4gZW1wdHkgY2FzdGxpbmcgZmxhZz8gKi9cbiAgY2ZsYWdzID0gY2ZsYWdzIHx8ICctJ1xuICBjb25zdCBlcGZsYWdzID0gc3RhdGUuZXBfc3F1YXJlID09PSBFTVBUWSA/ICctJyA6IGFsZ2VicmFpYyhzdGF0ZS5lcF9zcXVhcmUpXG5cbiAgcmV0dXJuIFtmZW4sIHN0YXRlLnR1cm4sIGNmbGFncywgZXBmbGFncywgc3RhdGUuaGFsZl9tb3Zlcywgc3RhdGUubW92ZV9udW1iZXJdLmpvaW4oJyAnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEZlbihmZW46IHN0cmluZyk6IFN0YXRlIHwgbnVsbCB7XG4gIGNvbnN0IHRva2VucyA9IGZlbi5zcGxpdCgvXFxzKy8pXG4gIGNvbnN0IHBvc2l0aW9uID0gdG9rZW5zWzBdXG4gIGxldCBzcXVhcmUgPSAwXG5cbiAgaWYgKCF2YWxpZGF0ZUZlbihmZW4pLnZhbGlkKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxldCBzdGF0ZSA9IG5ldyBTdGF0ZSgpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBpZWNlID0gcG9zaXRpb24uY2hhckF0KGkpXG5cbiAgICBpZiAocGllY2UgPT09ICcvJykge1xuICAgICAgc3F1YXJlICs9IDhcbiAgICB9IGVsc2UgaWYgKGlzRGlnaXQocGllY2UpKSB7XG4gICAgICBzcXVhcmUgKz0gcGFyc2VJbnQocGllY2UsIDEwKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb2xvciA9IHBpZWNlIDwgJ2EnID8gV0hJVEUgOiBCTEFDS1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSBwdXRQaWVjZShcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHsgdHlwZTogcGllY2UudG9Mb3dlckNhc2UoKSwgY29sb3I6IGNvbG9yIH0sXG4gICAgICAgIGFsZ2VicmFpYyhzcXVhcmUpXG4gICAgICApXG4gICAgICBpZiAoIW5ld1N0YXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBzdGF0ZSA9IG5ld1N0YXRlXG4gICAgICBzcXVhcmUrK1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnR1cm4gPSB0b2tlbnNbMV0gPT09IEJMQUNLID8gQkxBQ0sgOiBXSElURVxuXG4gIGlmICh0b2tlbnNbMl0uaW5kZXhPZignSycpID4gLTEpIHtcbiAgICBzdGF0ZS5jYXN0bGluZy53IHw9IEJJVFMuS1NJREVfQ0FTVExFXG4gIH1cbiAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdRJykgPiAtMSkge1xuICAgIHN0YXRlLmNhc3RsaW5nLncgfD0gQklUUy5RU0lERV9DQVNUTEVcbiAgfVxuICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ2snKSA+IC0xKSB7XG4gICAgc3RhdGUuY2FzdGxpbmcuYiB8PSBCSVRTLktTSURFX0NBU1RMRVxuICB9XG4gIGlmICh0b2tlbnNbMl0uaW5kZXhPZigncScpID4gLTEpIHtcbiAgICBzdGF0ZS5jYXN0bGluZy5iIHw9IEJJVFMuUVNJREVfQ0FTVExFXG4gIH1cblxuICBzdGF0ZS5lcF9zcXVhcmUgPSB0b2tlbnNbM10gPT09ICctJyA/IEVNUFRZIDogU1FVQVJFU1t0b2tlbnNbM10gYXMgU3F1YXJlXVxuICBzdGF0ZS5oYWxmX21vdmVzID0gcGFyc2VJbnQodG9rZW5zWzRdLCAxMClcbiAgc3RhdGUubW92ZV9udW1iZXIgPSBwYXJzZUludCh0b2tlbnNbNV0sIDEwKVxuXG4gIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGduKFxuICBzdGF0ZTogU3RhdGUsXG4gIGhlYWRlcjogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgY29tbWVudHM6IENvbW1lbnRzLFxuICBoaXN0b3J5OiBHYW1lSGlzdG9yeVtdLFxuICBvcHRpb25zOiB7IG5ld2xpbmVfY2hhcj86IHN0cmluZywgbWF4X3dpZHRoPzogbnVtYmVyIH0gPSB7fVxuKTogc3RyaW5nIHtcbiAgLyogdXNpbmcgdGhlIHNwZWNpZmljYXRpb24gZnJvbSBodHRwOi8vd3d3LmNoZXNzY2x1Yi5jb20vaGVscC9QR04tc3BlY1xuICAgKiBleGFtcGxlIGZvciBodG1sIHVzYWdlOiAucGduKHsgbWF4X3dpZHRoOiA3MiwgbmV3bGluZV9jaGFyOiBcIjxiciAvPlwiIH0pXG4gICAqL1xuICBjb25zdCB7XG4gICAgbmV3bGluZV9jaGFyOiBuZXdsaW5lID0gJ1xcbicsXG4gICAgbWF4X3dpZHRoID0gMFxuICB9ID0gb3B0aW9uc1xuXG4gIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXVxuICBsZXQgaGVhZGVyX2V4aXN0cyA9IGZhbHNlXG5cbiAgLyogYWRkIHRoZSBQR04gaGVhZGVyIGhlYWRlcnJtYXRpb24gKi9cbiAgZm9yIChjb25zdCBpIGluIGhlYWRlcikge1xuICAgIC8qIFRPRE86IG9yZGVyIG9mIGVudW1lcmF0ZWQgcHJvcGVydGllcyBpbiBoZWFkZXIgb2JqZWN0IGlzIG5vdFxuICAgICAqIGd1YXJhbnRlZWQsIHNlZSBFQ01BLTI2MiBzcGVjIChzZWN0aW9uIDEyLjYuNClcbiAgICAgKi9cbiAgICByZXN1bHQucHVzaCgnWycgKyBpICsgJyBcIicgKyBoZWFkZXJbaV0gKyAnXCJdJyArIG5ld2xpbmUpXG4gICAgaGVhZGVyX2V4aXN0cyA9IHRydWVcbiAgfVxuXG4gIGlmIChoZWFkZXJfZXhpc3RzICYmIGhpc3RvcnkubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2gobmV3bGluZSlcbiAgfVxuXG4gIGNvbnN0IGFwcGVuZENvbW1lbnQgPSAobW92ZVN0cjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCBjb21tZW50ID0gY29tbWVudHNbc3RhdGUuZmVuXVxuICAgIGlmICh0eXBlb2YgY29tbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGRlbGltaXRlciA9IG1vdmVTdHIubGVuZ3RoID4gMCA/ICcgJyA6ICcnXG4gICAgICBtb3ZlU3RyID0gYCR7bW92ZVN0cn0ke2RlbGltaXRlcn17JHtjb21tZW50fX1gXG4gICAgfVxuICAgIHJldHVybiBtb3ZlU3RyXG4gIH1cblxuICAvLyBTZXQgaW5pdGlhbCBzdGF0ZVxuICBpZiAoaGlzdG9yeVswXSkge1xuICAgIHN0YXRlID0gaGlzdG9yeVswXS5zdGF0ZVxuICB9XG5cbiAgY29uc3QgbW92ZXMgPSBbXVxuICBsZXQgbW92ZVN0ciA9ICcnXG5cbiAgLyogc3BlY2lhbCBjYXNlIG9mIGEgY29tbWVudGVkIHN0YXJ0aW5nIHBvc2l0aW9uIHdpdGggbm8gbW92ZXMgKi9cbiAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgbW92ZXMucHVzaChhcHBlbmRDb21tZW50KCcnKSlcbiAgfVxuXG4gIC8qIGJ1aWxkIHRoZSBsaXN0IG9mIG1vdmVzLiAgYSBtb3ZlX3N0cmluZyBsb29rcyBsaWtlOiBcIjMuIGUzIGU2XCIgKi9cbiAgaGlzdG9yeS5mb3JFYWNoKChoaXN0b3J5U3RhdGUsIGkpID0+IHtcbiAgICBjb25zdCBtb3ZlID0gaGlzdG9yeVN0YXRlLm1vdmVcblxuICAgIG1vdmVTdHIgPSBhcHBlbmRDb21tZW50KG1vdmVTdHIpXG5cbiAgICAvKiBpZiB0aGUgcG9zaXRpb24gc3RhcnRlZCB3aXRoIGJsYWNrIHRvIG1vdmUsIHN0YXJ0IFBHTiB3aXRoIDEuIC4uLiAqL1xuICAgIGlmIChpID09PSAwICYmIG1vdmUuY29sb3IgPT09IEJMQUNLKSB7XG4gICAgICBtb3ZlU3RyID0gc3RhdGUubW92ZV9udW1iZXIgKyAnLiAuLi4nXG4gICAgfSBlbHNlIGlmIChtb3ZlLmNvbG9yID09PSBXSElURSkge1xuICAgICAgLyogc3RvcmUgdGhlIHByZXZpb3VzIGdlbmVyYXRlZCBtb3ZlX3N0cmluZyBpZiB3ZSBoYXZlIG9uZSAqL1xuICAgICAgaWYgKG1vdmVTdHIubGVuZ3RoKSB7XG4gICAgICAgIG1vdmVzLnB1c2gobW92ZVN0cilcbiAgICAgIH1cbiAgICAgIG1vdmVTdHIgPSBzdGF0ZS5tb3ZlX251bWJlciArICcuJ1xuICAgIH1cblxuICAgIG1vdmVTdHIgPSBtb3ZlU3RyICsgJyAnICsgbW92ZVRvU2FuKHN0YXRlLCBtb3ZlKVxuICAgIHN0YXRlID0gbWFrZU1vdmUoc3RhdGUsIG1vdmUpXG4gIH0pXG5cbiAgLy8gQXBwZW5kIGxlZnRvdmVyIG1vdmVzXG4gIGlmIChtb3ZlU3RyLmxlbmd0aCkge1xuICAgIG1vdmVzLnB1c2goYXBwZW5kQ29tbWVudChtb3ZlU3RyKSlcbiAgfVxuXG4gIC8qIGlzIHRoZXJlIGEgcmVzdWx0PyAqL1xuICBpZiAodHlwZW9mIGhlYWRlci5SZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW92ZXMucHVzaChoZWFkZXIuUmVzdWx0KVxuICB9XG5cbiAgLyogaGlzdG9yeSBzaG91bGQgYmUgYmFjayB0byB3aGF0IGl0IHdhcyBiZWZvcmUgd2Ugc3RhcnRlZCBnZW5lcmF0aW5nIFBHTixcbiAgICogc28gam9pbiB0b2dldGhlciBtb3Zlc1xuICAgKi9cbiAgaWYgKG1heF93aWR0aCA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQuam9pbignJykgKyBtb3Zlcy5qb2luKCcgJylcbiAgfVxuXG4gIGNvbnN0IHN0cmlwID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgICAgcmVzdWx0LnBvcCgpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qIE5COiB0aGlzIGRvZXMgbm90IHByZXNlcnZlIGNvbW1lbnQgd2hpdGVzcGFjZS4gKi9cbiAgY29uc3Qgd3JhcENvbW1lbnQgPSAod2lkdGg6IG51bWJlciwgbW92ZTogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1vdmUuc3BsaXQoJyAnKSkge1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKHdpZHRoICsgdG9rZW4ubGVuZ3RoID4gbWF4X3dpZHRoKSB7XG4gICAgICAgIHdoaWxlIChzdHJpcCgpKSB7XG4gICAgICAgICAgd2lkdGgtLVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpXG4gICAgICAgIHdpZHRoID0gMFxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godG9rZW4pXG4gICAgICB3aWR0aCArPSB0b2tlbi5sZW5ndGhcbiAgICAgIHJlc3VsdC5wdXNoKCcgJylcbiAgICAgIHdpZHRoKytcbiAgICB9XG4gICAgaWYgKHN0cmlwKCkpIHtcbiAgICAgIHdpZHRoLS1cbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoXG4gIH1cblxuICAvKiB3cmFwIHRoZSBQR04gb3V0cHV0IGF0IG1heF93aWR0aCAqL1xuICBsZXQgY3VycmVudFdpZHRoID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN1cnJlbnRXaWR0aCArIG1vdmVzW2ldLmxlbmd0aCA+IG1heF93aWR0aCkge1xuICAgICAgaWYgKG1vdmVzW2ldLmluY2x1ZGVzKCd7JykpIHtcbiAgICAgICAgY3VycmVudFdpZHRoID0gd3JhcENvbW1lbnQoY3VycmVudFdpZHRoLCBtb3Zlc1tpXSlcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgLyogaWYgdGhlIGN1cnJlbnQgbW92ZSB3aWxsIHB1c2ggcGFzdCBtYXhfd2lkdGggKi9cbiAgICBpZiAoY3VycmVudFdpZHRoICsgbW92ZXNbaV0ubGVuZ3RoID4gbWF4X3dpZHRoICYmIGkgIT09IDApIHtcbiAgICAgIC8qIGRvbid0IGVuZCB0aGUgbGluZSB3aXRoIHdoaXRlc3BhY2UgKi9cbiAgICAgIGlmIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAgICAgcmVzdWx0LnBvcCgpXG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpXG4gICAgICBjdXJyZW50V2lkdGggPSAwXG4gICAgfSBlbHNlIGlmIChpICE9PSAwKSB7XG4gICAgICByZXN1bHQucHVzaCgnICcpXG4gICAgICBjdXJyZW50V2lkdGgrK1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtb3Zlc1tpXSlcbiAgICBjdXJyZW50V2lkdGggKz0gbW92ZXNbaV0ubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gcmVzdWx0LmpvaW4oJycpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUGduKFxuICBwZ246IHN0cmluZyxcbiAgb3B0aW9uczogeyBuZXdsaW5lX2NoYXI/OiBzdHJpbmcsIHNsb3BweT86IGJvb2xlYW4gfSA9IHt9XG4pOiBbU3RhdGUsIFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIENvbW1lbnRzLCBHYW1lSGlzdG9yeVtdXSB8IG51bGwge1xuICBjb25zdCB7XG4gICAgbmV3bGluZV9jaGFyID0gJ1xccj9cXG4nLFxuICAgIC8vIGFsbG93IHRoZSB1c2VyIHRvIHNwZWNpZnkgdGhlIHNsb3BweSBtb3ZlIHBhcnNlciB0byB3b3JrIGFyb3VuZCBvdmVyXG4gICAgLy8gZGlzYW1iaWd1YXRpb24gYnVncyBpbiBGcml0eiBhbmQgQ2hlc3NiYXNlXG4gICAgc2xvcHB5ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnNcblxuICBjb25zdCBtYXNrID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFwnKVxuICB9XG5cbiAgY29uc3QgcGFyc2VfcGduX2hlYWRlciA9IChcbiAgICBoZWFkZXI6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7IG5ld2xpbmVfY2hhcjogc3RyaW5nLCBzbG9wcHk6IGJvb2xlYW4gfVxuICApOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBuZXdsaW5lX2NoYXIgPSBvcHRpb25zLm5ld2xpbmVfY2hhclxuICAgIGNvbnN0IGhlYWRlcl9vYmo6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuICAgIGNvbnN0IGhlYWRlcnMgPSBoZWFkZXIuc3BsaXQobmV3IFJlZ0V4cChtYXNrKG5ld2xpbmVfY2hhcikpKVxuICAgIGxldCBrZXkgPSAnJ1xuICAgIGxldCB2YWx1ZSA9ICcnXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGhlYWRlcnNbaV0ucmVwbGFjZSgvXlxcWyhbQS1aXVtBLVphLXpdKilcXHMuKlxcXSQvLCAnJDEnKVxuICAgICAgdmFsdWUgPSBoZWFkZXJzW2ldLnJlcGxhY2UoL15cXFtbQS1aYS16XStcXHNcIiguKilcIiAqXFxdJC8sICckMScpXG4gICAgICBpZiAoa2V5LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhlYWRlcl9vYmpba2V5LnRyaW0oKV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJfb2JqXG4gIH1cblxuICAvLyBSZWdFeHAgdG8gc3BsaXQgaGVhZGVyLiBUYWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCBoZWFkZXIgYW5kIG1vdmV0ZXh0XG4gIC8vIHdpbGwgYWx3YXlzIGhhdmUgYSBibGFuayBsaW5lIGJldHdlZW4gdGhlbSAoaWUsIHR3byBuZXdsaW5lX2NoYXIncykuXG4gIC8vIFdpdGggZGVmYXVsdCBuZXdsaW5lX2NoYXIsIHdpbGwgZXF1YWw6IC9eKFxcWygoPzpcXHI/XFxuKXwuKSpcXF0pKD86XFxyP1xcbil7Mn0vXG4gIGNvbnN0IGhlYWRlcl9yZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgJ14oXFxcXFsoKD86JyArXG4gICAgICBtYXNrKG5ld2xpbmVfY2hhcikgK1xuICAgICAgJyl8LikqXFxcXF0pJyArXG4gICAgICAnKD86JyArXG4gICAgICBtYXNrKG5ld2xpbmVfY2hhcikgK1xuICAgICAgJyl7Mn0nXG4gIClcblxuICAvLyBJZiBubyBoZWFkZXIgZ2l2ZW4sIGJlZ2luIHdpdGggbW92ZXMuXG4gIGNvbnN0IGhlYWRlcl9zdHJpbmcgPSBoZWFkZXJfcmVnZXgudGVzdChwZ24pID8gKGhlYWRlcl9yZWdleC5leGVjKHBnbikgYXMgc3RyaW5nW10pWzFdIDogJydcblxuICAvLyBQdXQgdGhlIGJvYXJkIGluIHRoZSBzdGFydGluZyBwb3NpdGlvblxuICBsZXQgc3RhdGUgPSBsb2FkRmVuKERFRkFVTFRfUE9TSVRJT04pIGFzIFN0YXRlXG5cbiAgLyogcGFyc2UgUEdOIGhlYWRlciAqL1xuICBjb25zdCBoZWFkZXIgPSBwYXJzZV9wZ25faGVhZGVyKGhlYWRlcl9zdHJpbmcsIHsgbmV3bGluZV9jaGFyLCBzbG9wcHkgfSlcblxuICAvKiBsb2FkIHRoZSBzdGFydGluZyBwb3NpdGlvbiBpbmRpY2F0ZWQgYnkgW1NldHVwICcxJ10gYW5kXG4gICAqIFtGRU4gcG9zaXRpb25dICovXG4gIGlmIChoZWFkZXJbJ1NldFVwJ10gPT09ICcxJykge1xuICAgIGlmICgnRkVOJyBpbiBoZWFkZXIpIHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gbG9hZEZlbihoZWFkZXJbJ0ZFTiddIGFzIHN0cmluZylcbiAgICAgIGlmICghbmV3U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIHN0YXRlID0gbmV3U3RhdGVcbiAgICB9XG4gIH1cblxuICAvKiBOQjogdGhlIHJlZ2V4ZXMgYmVsb3cgdGhhdCBkZWxldGUgbW92ZSBudW1iZXJzLCByZWN1cnNpdmVcbiAgICogYW5ub3RhdGlvbnMsIGFuZCBudW1lcmljIGFubm90YXRpb24gZ2x5cGhzIG1heSBhbHNvIG1hdGNoXG4gICAqIHRleHQgaW4gY29tbWVudHMuIFRvIHByZXZlbnQgdGhpcywgd2UgdHJhbnNmb3JtIGNvbW1lbnRzXG4gICAqIGJ5IGhleC1lbmNvZGluZyB0aGVtIGluIHBsYWNlIGFuZCBkZWNvZGluZyB0aGVtIGFnYWluIGFmdGVyXG4gICAqIHRoZSBvdGhlciB0b2tlbnMgaGF2ZSBiZWVuIGRlbGV0ZWQuXG4gICAqXG4gICAqIFdoaWxlIHRoZSBzcGVjIHN0YXRlcyB0aGF0IFBHTiBmaWxlcyBzaG91bGQgYmUgQVNDSUkgZW5jb2RlZCxcbiAgICogd2UgdXNlIHtlbixkZX1jb2RlVVJJQ29tcG9uZW50IGhlcmUgdG8gc3VwcG9ydCBhcmJpdHJhcnkgVVRGOFxuICAgKiBhcyBhIGNvbnZlbmllbmNlIGZvciBtb2Rlcm4gdXNlcnMgKi9cblxuICBjb25zdCB0b0hleCA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIEFycmF5XG4gICAgICAuZnJvbShzdHIpXG4gICAgICAubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgLyogZW5jb2RlVVJJIGRvZXNuJ3QgdHJhbnNmb3JtIG1vc3QgQVNDSUkgY2hhcmFjdGVycyxcbiAgICAgICAgICogc28gd2UgaGFuZGxlIHRoZXNlIG91cnNlbHZlcyAqL1xuICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApIDwgMTI4XG4gICAgICAgICAgPyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgOiBlbmNvZGVVUklDb21wb25lbnQoYykucmVwbGFjZSgvJS9nLCAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgfSlcbiAgICAgIC5qb2luKCcnKVxuICB9XG5cbiAgY29uc3QgZnJvbUhleCA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT0gMFxuICAgICAgPyAnJ1xuICAgICAgOiBkZWNvZGVVUklDb21wb25lbnQoJyUnICsgc3RyPy5tYXRjaCgvLnsxLDJ9L2cpPy5qb2luKCclJykpXG4gIH1cblxuICBjb25zdCBlbmNvZGVDb21tZW50ID0gZnVuY3Rpb24oc3RyOiBzdHJpbmcpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKG1hc2sobmV3bGluZV9jaGFyKSwgJ2cnKSwgJyAnKVxuICAgIHJldHVybiBgeyR7dG9IZXgoc3RyLnNsaWNlKDEsIHN0ci5sZW5ndGggLSAxKSl9fWBcbiAgfVxuXG4gIGNvbnN0IGRlY29kZUNvbW1lbnQgPSBmdW5jdGlvbihzdHI6IHN0cmluZykge1xuICAgIGlmIChzdHIuc3RhcnRzV2l0aCgneycpICYmIHN0ci5lbmRzV2l0aCgnfScpKSB7XG4gICAgICByZXR1cm4gZnJvbUhleChzdHIuc2xpY2UoMSwgc3RyLmxlbmd0aCAtIDEpKVxuICAgIH1cbiAgfVxuXG4gIC8qIGRlbGV0ZSBoZWFkZXIgdG8gZ2V0IHRoZSBtb3ZlcyAqL1xuICBsZXQgbXMgPSBwZ25cbiAgICAucmVwbGFjZShoZWFkZXJfc3RyaW5nLCAnJylcbiAgICAucmVwbGFjZShcbiAgICAgIC8qIGVuY29kZSBjb21tZW50cyBzbyB0aGV5IGRvbid0IGdldCBkZWxldGVkIGJlbG93ICovXG4gICAgICBuZXcgUmVnRXhwKGAoe1tefV0qfSkrP3w7KFteJHttYXNrKG5ld2xpbmVfY2hhcil9XSopYCwgJ2cnKSxcbiAgICAgIChfLCBicmFja2V0LCBzZW1pY29sb24pID0+IHtcbiAgICAgICAgcmV0dXJuIGJyYWNrZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gZW5jb2RlQ29tbWVudChicmFja2V0KVxuICAgICAgICAgIDogJyAnICsgZW5jb2RlQ29tbWVudChgeyR7c2VtaWNvbG9uLnNsaWNlKDEpfX1gKVxuICAgICAgfVxuICAgIClcbiAgICAucmVwbGFjZShuZXcgUmVnRXhwKG1hc2sobmV3bGluZV9jaGFyKSwgJ2cnKSwgJyAnKVxuXG4gIC8qIGRlbGV0ZSByZWN1cnNpdmUgYW5ub3RhdGlvbiB2YXJpYXRpb25zICovXG4gIGNvbnN0IHJhdl9yZWdleCA9IC8oXFwoW14oKV0rXFwpKSs/L2dcbiAgd2hpbGUgKHJhdl9yZWdleC50ZXN0KG1zKSkge1xuICAgIG1zID0gbXMucmVwbGFjZShyYXZfcmVnZXgsICcnKVxuICB9XG5cbiAgLyogZGVsZXRlIG1vdmUgbnVtYmVycyAqL1xuICBtcyA9IG1zLnJlcGxhY2UoL1xcZCtcXC4oXFwuXFwuKT8vZywgJycpXG5cbiAgLyogZGVsZXRlIC4uLiBpbmRpY2F0aW5nIGJsYWNrIHRvIG1vdmUgKi9cbiAgbXMgPSBtcy5yZXBsYWNlKC9cXC5cXC5cXC4vZywgJycpXG5cbiAgLyogZGVsZXRlIG51bWVyaWMgYW5ub3RhdGlvbiBnbHlwaHMgKi9cbiAgbXMgPSBtcy5yZXBsYWNlKC9cXCRcXGQrL2csICcnKVxuXG4gIC8qIHRyaW0gYW5kIGdldCBhcnJheSBvZiBtb3Zlcy9jb21tZW50cyAqL1xuICBjb25zdCB0b2tlbnMgPSBtc1xuICAgIC50cmltKClcbiAgICAuc3BsaXQobmV3IFJlZ0V4cCgvXFxzKy8pKVxuICAgIC5qb2luKCcsJylcbiAgICAucmVwbGFjZSgvLCwrL2csICcsJylcbiAgICAuc3BsaXQoJywnKVxuXG4gIGNvbnN0IGNvbW1lbnRzOiBDb21tZW50cyA9IHt9XG4gIGNvbnN0IGhpc3Rvcnk6IEdhbWVIaXN0b3J5W10gPSBbXVxuXG4gIGZvciAobGV0IGhhbGZfbW92ZSA9IDA7IGhhbGZfbW92ZSA8IHRva2Vucy5sZW5ndGg7IGhhbGZfbW92ZSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaGFsZl9tb3ZlXVxuICAgIGNvbnN0IGNvbW1lbnQgPSBkZWNvZGVDb21tZW50KHRva2VuKVxuICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbW1lbnRzW3N0YXRlLmZlbl0gPSBjb21tZW50XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChoYWxmX21vdmUgPT09IHRva2Vucy5sZW5ndGggLSAxICYmIFBPU1NJQkxFX1JFU1VMVFMuaW5kZXhPZih0b2tlbikgIT09IC0xKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoaGVhZGVyKS5sZW5ndGggJiYgdHlwZW9mIGhlYWRlci5SZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGhlYWRlclsnUmVzdWx0J10gPSB0b2tlblxuICAgICAgfVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBtb3ZlID0gc2FuVG9Nb3ZlKHN0YXRlLCB0b2tlbnNbaGFsZl9tb3ZlXSwgeyBzbG9wcHkgfSlcbiAgICBpZiAobW92ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgaGlzdG9yeS5wdXNoKHsgbW92ZSwgc3RhdGUgfSlcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gbWFrZU1vdmUoc3RhdGUsIG1vdmUpXG4gICAgICBpZiAoIW5ld1N0YXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBzdGF0ZSA9IG5ld1N0YXRlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtzdGF0ZSwgaGVhZGVyLCBjb21tZW50cywgaGlzdG9yeV1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpZWNlKHN0YXRlOiBTdGF0ZSwgc3F1YXJlPzogc3RyaW5nKTogUGllY2UgfCBudWxsIHtcbiAgaWYgKCFzcXVhcmUpIHJldHVybiBudWxsXG4gIHNxdWFyZSA9IHNxdWFyZS50b0xvd2VyQ2FzZSgpXG4gIGlmICghaXNTcXVhcmUoc3F1YXJlKSkgcmV0dXJuIG51bGxcblxuICBjb25zdCBzcSA9IFNRVUFSRVNbc3F1YXJlXVxuICBjb25zdCBwaWVjZSA9IHN0YXRlLmJvYXJkW3NxXVxuICBpZiAocGllY2UpIHtcbiAgICByZXR1cm4gY2xvbmVQaWVjZShwaWVjZSlcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVNb3ZlKG1vdmU6IEhleE1vdmUpOiBIZXhNb3ZlIHtcbiAgcmV0dXJuIHtcbiAgICB0bzogbW92ZS50byxcbiAgICBmcm9tOiBtb3ZlLmZyb20sXG4gICAgY29sb3I6IG1vdmUuY29sb3IsXG4gICAgZmxhZ3M6IG1vdmUuZmxhZ3MsXG4gICAgcGllY2U6IG1vdmUucGllY2UsXG4gICAgY2FwdHVyZWQ6IG1vdmUuY2FwdHVyZWQsXG4gICAgcHJvbW90aW9uOiBtb3ZlLnByb21vdGlvbixcbiAgICBzYW46IG1vdmUuc2FuLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVBpZWNlKHBpZWNlOiBQaWVjZSk6IFBpZWNlIHtcbiAgcmV0dXJuIHtcbiAgICBjb2xvcjogcGllY2UuY29sb3IsXG4gICAgdHlwZTogcGllY2UudHlwZSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHV0UGllY2UoXG4gIHByZXZTdGF0ZTogU3RhdGUsXG4gIHBpZWNlOiB7IHR5cGU/OiBzdHJpbmcsIGNvbG9yPzogc3RyaW5nIH0sIHNxdWFyZT86IHN0cmluZ1xuKTogU3RhdGUgfCBudWxsIHtcbiAgbGV0IHsgdHlwZSwgY29sb3IgfSA9IHBpZWNlXG5cbiAgLyogY2hlY2sgZm9yIHByZXNlbmNlICovXG4gIGlmICghdHlwZSB8fCAhY29sb3IgfHwgIXNxdWFyZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpXG4gIGNvbG9yID0gY29sb3IudG9Mb3dlckNhc2UoKVxuICBzcXVhcmUgPSBzcXVhcmUudG9Mb3dlckNhc2UoKVxuXG4gIC8qIGNoZWNrIGZvciB2YWxpZCBwYXJhbXMgKi9cbiAgaWYgKCFpc1BpZWNlU3ltYm9sKHR5cGUpIHx8ICFpc0NvbG9yKGNvbG9yKSB8fCAhaXNTcXVhcmUoc3F1YXJlKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHByZXZTdGF0ZS5jbG9uZSgpXG4gIC8qIGRvbid0IGxldCB0aGUgdXNlciBwbGFjZSBtb3JlIHRoYW4gb25lIGtpbmcgKi9cbiAgY29uc3Qgc3EgPSBTUVVBUkVTW3NxdWFyZV1cbiAgaWYgKHR5cGUgPT09IEtJTkcgJiZcbiAgICBzdGF0ZS5raW5nc1tjb2xvcl0gIT09IEVNUFRZICYmXG4gICAgc3RhdGUua2luZ3NbY29sb3JdICE9PSBzcSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBzdGF0ZS5ib2FyZFtzcV0gPSB7IHR5cGUsIGNvbG9yIH1cbiAgaWYgKHR5cGUgPT09IEtJTkcpIHtcbiAgICBzdGF0ZS5raW5nc1tjb2xvcl0gPSBzcVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQaWVjZShwcmV2U3RhdGU6IFN0YXRlLCBzcXVhcmU/OiBzdHJpbmcpOiBTdGF0ZSB8IG51bGwge1xuICBpZiAoIXNxdWFyZSkgcmV0dXJuIG51bGxcblxuICBzcXVhcmUgPSBzcXVhcmUudG9Mb3dlckNhc2UoKVxuICBpZiAoIWlzU3F1YXJlKHNxdWFyZSkpIHJldHVybiBudWxsXG5cbiAgY29uc3Qgc3EgPSBTUVVBUkVTW3NxdWFyZV1cbiAgY29uc3QgcGllY2UgPSBwcmV2U3RhdGUuYm9hcmRbc3FdXG4gIGlmICghcGllY2UpIHJldHVybiBudWxsXG5cbiAgY29uc3Qgc3RhdGUgPSBwcmV2U3RhdGUuY2xvbmUoKVxuICBjb25zdCB7IHR5cGUsIGNvbG9yIH0gPSBwaWVjZVxuICBpZiAodHlwZSA9PT0gS0lORykge1xuICAgIHN0YXRlLmtpbmdzW2NvbG9yXSA9IEVNUFRZXG4gIH1cbiAgZGVsZXRlIHN0YXRlLmJvYXJkW3NxXVxuICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTW92ZXMoXG4gIHN0YXRlOiBTdGF0ZSxcbiAgb3B0aW9uczogeyBsZWdhbD86IGJvb2xlYW4sIHNxdWFyZT86IHN0cmluZyB9ID0ge31cbik6IEhleE1vdmVbXSB7XG4gIGNvbnN0IHsgbGVnYWwgPSB0cnVlIH0gPSBvcHRpb25zXG4gIGNvbnN0IGFkZF9tb3ZlID0gKGJvYXJkOiBCb2FyZCwgbW92ZXM6IEhleE1vdmVbXSwgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCBmbGFnczogbnVtYmVyKSA9PiB7XG4gICAgLyogaWYgcGF3biBwcm9tb3Rpb24gKi9cbiAgICBjb25zdCBwaWVjZSA9IGJvYXJkW2Zyb21dXG4gICAgaWYgKFxuICAgICAgcGllY2UgJiZcbiAgICAgICAgcGllY2UudHlwZSA9PT0gUEFXTiAmJlxuICAgICAgICAocmFuayh0bykgPT09IFJBTktfOCB8fCByYW5rKHRvKSA9PT0gUkFOS18xKVxuICAgICkge1xuICAgICAgY29uc3QgcGllY2VzID0gW1FVRUVOLCBST09LLCBCSVNIT1AsIEtOSUdIVF1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwaWVjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbW92ZXMucHVzaChidWlsZE1vdmUoc3RhdGUsIGZyb20sIHRvLCBmbGFncywgcGllY2VzW2ldKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW92ZXMucHVzaChidWlsZE1vdmUoc3RhdGUsIGZyb20sIHRvLCBmbGFncykpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbW92ZXM6IEhleE1vdmVbXSA9IFtdXG4gIGNvbnN0IHVzID0gc3RhdGUudHVyblxuICBjb25zdCB0aGVtID0gc3dhcENvbG9yKHVzKVxuICBjb25zdCBzZWNvbmRfcmFuazogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHsgYjogUkFOS183LCB3OiBSQU5LXzIgfVxuXG4gIGxldCBmaXJzdF9zcSA9IFNRVUFSRVMuYThcbiAgbGV0IGxhc3Rfc3EgPSBTUVVBUkVTLmgxXG4gIGxldCBzaW5nbGVfc3F1YXJlID0gZmFsc2VcblxuICAvKiBhcmUgd2UgZ2VuZXJhdGluZyBtb3ZlcyBmb3IgYSBzaW5nbGUgc3F1YXJlPyAqL1xuICBsZXQgeyBzcXVhcmUgfSA9IG9wdGlvbnNcbiAgaWYgKHNxdWFyZSkge1xuICAgIHNxdWFyZSA9IHNxdWFyZS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGlzU3F1YXJlKHNxdWFyZSkpIHtcbiAgICAgIGZpcnN0X3NxID0gbGFzdF9zcSA9IFNRVUFSRVNbc3F1YXJlXVxuICAgICAgc2luZ2xlX3NxdWFyZSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgLyogaW52YWxpZCBzcXVhcmUgKi9cbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSBmaXJzdF9zcTsgaSA8PSBsYXN0X3NxOyBpKyspIHtcbiAgICAvKiBkaWQgd2UgcnVuIG9mZiB0aGUgZW5kIG9mIHRoZSBib2FyZCAqL1xuICAgIGlmIChpICYgMHg4OCkge1xuICAgICAgaSArPSA3XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IHBpZWNlID0gc3RhdGUuYm9hcmRbaV1cbiAgICBpZiAoIXBpZWNlIHx8IHBpZWNlLmNvbG9yICE9PSB1cykge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAocGllY2UudHlwZSA9PT0gUEFXTikge1xuICAgICAgLyogc2luZ2xlIHNxdWFyZSwgbm9uLWNhcHR1cmluZyAqL1xuICAgICAgY29uc3Qgc3F1YXJlMSA9IGkgKyBQQVdOX09GRlNFVFNbdXNdWzBdXG4gICAgICBpZiAoIXN0YXRlLmJvYXJkW3NxdWFyZTFdKSB7XG4gICAgICAgIGFkZF9tb3ZlKHN0YXRlLmJvYXJkLCBtb3ZlcywgaSwgc3F1YXJlMSwgQklUUy5OT1JNQUwpXG5cbiAgICAgICAgLyogZG91YmxlIHNxdWFyZSAqL1xuICAgICAgICBjb25zdCBzcXVhcmUyID0gaSArIFBBV05fT0ZGU0VUU1t1c11bMV1cbiAgICAgICAgaWYgKHNlY29uZF9yYW5rW3VzXSA9PT0gcmFuayhpKSAmJiAhc3RhdGUuYm9hcmRbc3F1YXJlMl0pIHtcbiAgICAgICAgICBhZGRfbW92ZShzdGF0ZS5ib2FyZCwgbW92ZXMsIGksIHNxdWFyZTIsIEJJVFMuQklHX1BBV04pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogcGF3biBjYXB0dXJlcyAqL1xuICAgICAgZm9yIChsZXQgaiA9IDI7IGogPCA0OyBqKyspIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlID0gaSArIFBBV05fT0ZGU0VUU1t1c11bal1cbiAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIGNvbnRpbnVlXG5cbiAgICAgICAgaWYgKHN0YXRlLmJvYXJkW3NxdWFyZV0gJiYgc3RhdGUuYm9hcmRbc3F1YXJlXT8uY29sb3IgPT09IHRoZW0pIHtcbiAgICAgICAgICBhZGRfbW92ZShzdGF0ZS5ib2FyZCwgbW92ZXMsIGksIHNxdWFyZSwgQklUUy5DQVBUVVJFKVxuICAgICAgICB9IGVsc2UgaWYgKHNxdWFyZSA9PT0gc3RhdGUuZXBfc3F1YXJlKSB7XG4gICAgICAgICAgYWRkX21vdmUoc3RhdGUuYm9hcmQsIG1vdmVzLCBpLCBzdGF0ZS5lcF9zcXVhcmUsIEJJVFMuRVBfQ0FQVFVSRSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBqID0gMCwgbGVuID0gUElFQ0VfT0ZGU0VUU1twaWVjZS50eXBlXS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBQSUVDRV9PRkZTRVRTW3BpZWNlLnR5cGVdW2pdXG4gICAgICAgIGxldCBzcXVhcmUgPSBpXG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBzcXVhcmUgKz0gb2Zmc2V0XG4gICAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIGJyZWFrXG5cbiAgICAgICAgICBpZiAoIXN0YXRlLmJvYXJkW3NxdWFyZV0pIHtcbiAgICAgICAgICAgIGFkZF9tb3ZlKHN0YXRlLmJvYXJkLCBtb3ZlcywgaSwgc3F1YXJlLCBCSVRTLk5PUk1BTClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmJvYXJkW3NxdWFyZV0/LmNvbG9yID09PSB1cykgYnJlYWtcbiAgICAgICAgICAgIGFkZF9tb3ZlKHN0YXRlLmJvYXJkLCBtb3ZlcywgaSwgc3F1YXJlLCBCSVRTLkNBUFRVUkUpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIGJyZWFrLCBpZiBrbmlnaHQgb3Iga2luZyAqL1xuICAgICAgICAgIGlmIChwaWVjZS50eXBlID09PSAnbicgfHwgcGllY2UudHlwZSA9PT0gJ2snKSBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNhc3RsaW5nIGlmOiBhKSB3ZSdyZSBnZW5lcmF0aW5nIGFsbCBtb3Zlcywgb3IgYikgd2UncmUgZG9pbmdcbiAgICogc2luZ2xlIHNxdWFyZSBtb3ZlIGdlbmVyYXRpb24gb24gdGhlIGtpbmcncyBzcXVhcmVcbiAgICovXG4gIGlmICghc2luZ2xlX3NxdWFyZSB8fCBsYXN0X3NxID09PSBzdGF0ZS5raW5nc1t1c10pIHtcbiAgICAvKiBraW5nLXNpZGUgY2FzdGxpbmcgKi9cbiAgICBpZiAoc3RhdGUuY2FzdGxpbmdbdXNdICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgIGNvbnN0IGNhc3RsaW5nX2Zyb20gPSBzdGF0ZS5raW5nc1t1c11cbiAgICAgIGNvbnN0IGNhc3RsaW5nX3RvID0gY2FzdGxpbmdfZnJvbSArIDJcblxuICAgICAgaWYgKFxuICAgICAgICAhc3RhdGUuYm9hcmRbY2FzdGxpbmdfZnJvbSArIDFdICYmXG4gICAgICAgICAgIXN0YXRlLmJvYXJkW2Nhc3RsaW5nX3RvXSAmJlxuICAgICAgICAgICFpc0F0dGFja2VkKHN0YXRlLCB0aGVtLCBzdGF0ZS5raW5nc1t1c10pICYmXG4gICAgICAgICAgIWlzQXR0YWNrZWQoc3RhdGUsIHRoZW0sIGNhc3RsaW5nX2Zyb20gKyAxKSAmJlxuICAgICAgICAgICFpc0F0dGFja2VkKHN0YXRlLCB0aGVtLCBjYXN0bGluZ190bylcbiAgICAgICkge1xuICAgICAgICBhZGRfbW92ZShzdGF0ZS5ib2FyZCwgbW92ZXMsIHN0YXRlLmtpbmdzW3VzXSwgY2FzdGxpbmdfdG8sIEJJVFMuS1NJREVfQ0FTVExFKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIHF1ZWVuLXNpZGUgY2FzdGxpbmcgKi9cbiAgICBpZiAoc3RhdGUuY2FzdGxpbmdbdXNdICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgIGNvbnN0IGNhc3RsaW5nX2Zyb20gPSBzdGF0ZS5raW5nc1t1c11cbiAgICAgIGNvbnN0IGNhc3RsaW5nX3RvID0gY2FzdGxpbmdfZnJvbSAtIDJcblxuICAgICAgaWYgKFxuICAgICAgICAhc3RhdGUuYm9hcmRbY2FzdGxpbmdfZnJvbSAtIDFdICYmXG4gICAgICAgICAgIXN0YXRlLmJvYXJkW2Nhc3RsaW5nX2Zyb20gLSAyXSAmJlxuICAgICAgICAgICFzdGF0ZS5ib2FyZFtjYXN0bGluZ19mcm9tIC0gM10gJiZcbiAgICAgICAgICAhaXNBdHRhY2tlZChzdGF0ZSwgdGhlbSwgc3RhdGUua2luZ3NbdXNdKSAmJlxuICAgICAgICAgICFpc0F0dGFja2VkKHN0YXRlLCB0aGVtLCBjYXN0bGluZ19mcm9tIC0gMSkgJiZcbiAgICAgICAgICAhaXNBdHRhY2tlZChzdGF0ZSwgdGhlbSwgY2FzdGxpbmdfdG8pXG4gICAgICApIHtcbiAgICAgICAgYWRkX21vdmUoc3RhdGUuYm9hcmQsIG1vdmVzLCBzdGF0ZS5raW5nc1t1c10sIGNhc3RsaW5nX3RvLCBCSVRTLlFTSURFX0NBU1RMRSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiByZXR1cm4gYWxsIHBzZXVkby1sZWdhbCBtb3ZlcyAodGhpcyBpbmNsdWRlcyBtb3ZlcyB0aGF0IGFsbG93IHRoZSBraW5nXG4gICAqIHRvIGJlIGNhcHR1cmVkKVxuICAgKi9cbiAgaWYgKCFsZWdhbCkge1xuICAgIHJldHVybiBtb3Zlc1xuICB9XG5cbiAgLyogZmlsdGVyIG91dCBpbGxlZ2FsIG1vdmVzICovXG4gIGNvbnN0IGxlZ2FsX21vdmVzID0gW11cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBtYWtlTW92ZShzdGF0ZSwgbW92ZXNbaV0pXG4gICAgaWYgKCFpc0tpbmdBdHRhY2tlZChuZXdTdGF0ZSwgdXMpKSB7XG4gICAgICBsZWdhbF9tb3Zlcy5wdXNoKG1vdmVzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZWdhbF9tb3Zlc1xufVxuXG4vKiBjb252ZXJ0IGEgbW92ZSBmcm9tIDB4ODggY29vcmRpbmF0ZXMgdG8gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uXG4gKiAoU0FOKVxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2xvcHB5IFVzZSB0aGUgc2xvcHB5IFNBTiBnZW5lcmF0b3IgdG8gd29yayBhcm91bmQgb3ZlclxuICogZGlzYW1iaWd1YXRpb24gYnVncyBpbiBGcml0eiBhbmQgQ2hlc3NiYXNlLiAgU2VlIGJlbG93OlxuICpcbiAqIHIxYnFrYm5yL3BwcDJwcHAvMm41LzFCMXBQMy80UDMvOC9QUFBQMlBQL1JOQlFLMU5SIGIgS1FrcSAtIDIgNFxuICogNC4gLi4uIE5nZTcgaXMgb3Zlcmx5IGRpc2FtYmlndWF0ZWQgYmVjYXVzZSB0aGUga25pZ2h0IG9uIGM2IGlzIHBpbm5lZFxuICogNC4gLi4uIE5lNyBpcyB0ZWNobmljYWxseSB0aGUgdmFsaWQgU0FOXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlVG9TYW4oXG4gIHN0YXRlOiBTdGF0ZSxcbiAgbW92ZTogSGV4TW92ZSxcbiAgb3B0aW9uczogeyBzbG9wcHk/OiBib29sZWFuLCBjaGVja1Byb21vdGlvbj86IGJvb2xlYW4gfSA9IHt9XG4pOiBzdHJpbmcge1xuICBjb25zdCB7IHNsb3BweSA9IGZhbHNlLCBjaGVja1Byb21vdGlvbiA9IHRydWUgfSA9IG9wdGlvbnNcbiAgbGV0IG91dHB1dCA9ICcnXG5cbiAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgIG91dHB1dCA9ICdPLU8nXG4gIH0gZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgb3V0cHV0ID0gJ08tTy1PJ1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRpc2FtYmlndWF0b3IgPSBnZXREaXNhbWJpZ3VhdG9yKHN0YXRlLCBtb3ZlLCBzbG9wcHkpXG5cbiAgICBpZiAobW92ZS5waWVjZSAhPT0gUEFXTikge1xuICAgICAgb3V0cHV0ICs9IG1vdmUucGllY2UudG9VcHBlckNhc2UoKSArIGRpc2FtYmlndWF0b3JcbiAgICB9XG5cbiAgICBpZiAobW92ZS5mbGFncyAmIChCSVRTLkNBUFRVUkUgfCBCSVRTLkVQX0NBUFRVUkUpKSB7XG4gICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUuZnJvbSlbMF1cbiAgICAgIH1cbiAgICAgIG91dHB1dCArPSAneCdcbiAgICB9XG5cbiAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUudG8pXG5cbiAgICBpZiAoY2hlY2tQcm9tb3Rpb24gJiYgbW92ZS5mbGFncyAmIEJJVFMuUFJPTU9USU9OKSB7XG4gICAgICBvdXRwdXQgKz0gJz0nICsgbW92ZS5wcm9tb3Rpb24/LnRvVXBwZXJDYXNlKClcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdTdGF0ZSA9IG1ha2VNb3ZlKHN0YXRlLCBtb3ZlKVxuICBpZiAoaW5DaGVjayhuZXdTdGF0ZSkpIHtcbiAgICBpZiAoaW5DaGVja21hdGUobmV3U3RhdGUpKSB7XG4gICAgICBvdXRwdXQgKz0gJyMnXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCArPSAnKydcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYW5Ub01vdmUoXG4gIHN0YXRlOiBTdGF0ZSxcbiAgbW92ZTogc3RyaW5nLFxuICBvcHRpb25zOiB7IHNsb3BweT86IGJvb2xlYW4sIGNoZWNrUHJvbW90aW9uPzogYm9vbGVhbiB9ID0ge31cbik6IEhleE1vdmUgfCBudWxsIHtcbiAgY29uc3QgeyBzbG9wcHkgPSBmYWxzZSwgY2hlY2tQcm9tb3Rpb24gPSB0cnVlIH0gPSBvcHRpb25zXG5cbiAgLy8gc3RyaXAgb2ZmIGFueSBtb3ZlIGRlY29yYXRpb25zOiBlLmcgTmYzKz8hXG4gIGNvbnN0IGNsZWFuTW92ZSA9IHN0cmlwcGVkU2FuKG1vdmUpXG5cbiAgbGV0IG1hdGNoZXMsIHBpZWNlLCBmcm9tLCB0bywgcHJvbW90aW9uXG5cbiAgLy8gaWYgd2UncmUgdXNpbmcgdGhlIHNsb3BweSBwYXJzZXIgcnVuIGEgcmVnZXggdG8gZ3JhYiBwaWVjZSwgdG8sIGFuZCBmcm9tXG4gIC8vIHRoaXMgc2hvdWxkIHBhcnNlIGludmFsaWQgU0FOIGxpa2U6IFBlMi1lNCwgUmMxYzQsIFFmM3hmN1xuICBpZiAoc2xvcHB5KSB7XG4gICAgbWF0Y2hlcyA9IGNsZWFuTW92ZS5tYXRjaChcbiAgICAgIC8oW3BuYnJxa1BOQlJRS10pPyhbYS1oXVsxLThdKXg/LT8oW2EtaF1bMS04XSkoW3FyYm5RUkJOXSk/L1xuICAgIClcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgcGllY2UgPSBtYXRjaGVzWzFdXG4gICAgICBmcm9tID0gbWF0Y2hlc1syXVxuICAgICAgdG8gPSBtYXRjaGVzWzNdXG4gICAgICBwcm9tb3Rpb24gPSBtYXRjaGVzWzRdXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbW92ZXMgPSBnZW5lcmF0ZU1vdmVzKHN0YXRlLCB7IHNxdWFyZTogZnJvbSB9KVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyB0cnkgdGhlIHN0cmljdCBwYXJzZXIgZmlyc3QsIHRoZW4gdGhlIHNsb3BweSBwYXJzZXIgaWYgcmVxdWVzdGVkXG4gICAgLy8gYnkgdGhlIHVzZXJcbiAgICBjb25zdCBzYW4gPSBtb3ZlVG9TYW4oc3RhdGUsIG1vdmVzW2ldLCB7IGNoZWNrUHJvbW90aW9uIH0pXG4gICAgaWYgKGNsZWFuTW92ZSA9PT0gc3RyaXBwZWRTYW4oc2FuKSB8fFxuICAgICAgKHNsb3BweSAmJiBjbGVhbk1vdmUgPT09IHN0cmlwcGVkU2FuKG1vdmVUb1NhbihzdGF0ZSwgbW92ZXNbaV0sIG9wdGlvbnMpKSkpIHtcbiAgICAgIHJldHVybiBtb3Zlc1tpXVxuICAgIH1cbiAgICBpZiAoXG4gICAgICBmcm9tICYmXG4gICAgICAgIHRvICYmXG4gICAgICAgIGlzU3F1YXJlKGZyb20pICYmXG4gICAgICAgIGlzU3F1YXJlKHRvKSAmJlxuICAgICAgICBtYXRjaGVzICYmXG4gICAgICAgICghcGllY2UgfHwgcGllY2UudG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5waWVjZSkgJiZcbiAgICAgICAgU1FVQVJFU1tmcm9tXSA9PSBtb3Zlc1tpXS5mcm9tICYmXG4gICAgICAgIFNRVUFSRVNbdG9dID09IG1vdmVzW2ldLnRvICYmXG4gICAgICAgICghY2hlY2tQcm9tb3Rpb24gfHwgIXByb21vdGlvbiB8fCBwcm9tb3Rpb24udG9Mb3dlckNhc2UoKSA9PSBtb3Zlc1tpXS5wcm9tb3Rpb24pXG4gICAgKSB7XG4gICAgICByZXR1cm4gbW92ZXNbaV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVByZXR0eShzdGF0ZTogU3RhdGUsIHVnbHlfbW92ZTogSGV4TW92ZSk6IE1vdmUge1xuICBjb25zdCBtb3ZlOiBIZXhNb3ZlID0gY2xvbmVNb3ZlKHVnbHlfbW92ZSlcblxuICBsZXQgZmxhZ3MgPSAnJ1xuICBmb3IgKGNvbnN0IGZsYWcgaW4gQklUUykge1xuICAgIGlmIChpc0ZsYWdLZXkoZmxhZykgJiYgQklUU1tmbGFnXSAmIG1vdmUuZmxhZ3MpIHtcbiAgICAgIGZsYWdzICs9IEZMQUdTW2ZsYWddXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0bzogYWxnZWJyYWljKG1vdmUudG8pLFxuICAgIGZyb206IGFsZ2VicmFpYyhtb3ZlLmZyb20pLFxuICAgIGNvbG9yOiBtb3ZlLmNvbG9yLFxuICAgIGZsYWdzLFxuICAgIHBpZWNlOiBtb3ZlLnBpZWNlLFxuICAgIHNhbjogbW92ZVRvU2FuKHN0YXRlLCBtb3ZlKSxcbiAgICBjYXB0dXJlZDogbW92ZS5jYXB0dXJlZCxcbiAgICBwcm9tb3Rpb246IG1vdmUucHJvbW90aW9uLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0F0dGFja2VkKHN0YXRlOiBTdGF0ZSwgY29sb3I6IHN0cmluZywgc3F1YXJlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgZm9yIChsZXQgaSA9IFNRVUFSRVMuYTg7IGkgPD0gU1FVQVJFUy5oMTsgaSsrKSB7XG4gICAgLyogZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmQgKi9cbiAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgIGkgKz0gN1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvKiBpZiBlbXB0eSBzcXVhcmUgb3Igd3JvbmcgY29sb3IgKi9cbiAgICBpZiAoc3RhdGUuYm9hcmRbaV0gPT0gbnVsbCB8fCBzdGF0ZS5ib2FyZFtpXT8uY29sb3IgIT09IGNvbG9yKSBjb250aW51ZVxuXG4gICAgY29uc3QgcGllY2UgPSBzdGF0ZS5ib2FyZFtpXVxuICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBpIC0gc3F1YXJlXG4gICAgY29uc3QgaW5kZXggPSBkaWZmZXJlbmNlICsgMTE5XG5cbiAgICBpZiAocGllY2UgJiYgQVRUQUNLU1tpbmRleF0gJiAoMSA8PCBTSElGVFNbcGllY2UudHlwZV0pKSB7XG4gICAgICBpZiAocGllY2UudHlwZSA9PT0gUEFXTikge1xuICAgICAgICBpZiAoZGlmZmVyZW5jZSA+IDApIHtcbiAgICAgICAgICBpZiAocGllY2UuY29sb3IgPT09IFdISVRFKSByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwaWVjZS5jb2xvciA9PT0gQkxBQ0spIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLyogaWYgdGhlIHBpZWNlIGlzIGEga25pZ2h0IG9yIGEga2luZyAqL1xuICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICduJyB8fCBwaWVjZS50eXBlID09PSAnaycpIHJldHVybiB0cnVlXG5cbiAgICAgIGNvbnN0IG9mZnNldCA9IFJBWVNbaW5kZXhdXG4gICAgICBsZXQgaiA9IGkgKyBvZmZzZXRcblxuICAgICAgbGV0IGJsb2NrZWQgPSBmYWxzZVxuICAgICAgd2hpbGUgKGogIT09IHNxdWFyZSkge1xuICAgICAgICBpZiAoc3RhdGUuYm9hcmRbal0pIHtcbiAgICAgICAgICBibG9ja2VkID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaiArPSBvZmZzZXRcbiAgICAgIH1cblxuICAgICAgaWYgKCFibG9ja2VkKSByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNLaW5nQXR0YWNrZWQoc3RhdGU6IFN0YXRlLCBjb2xvcjogQ29sb3IpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzQXR0YWNrZWQoc3RhdGUsIHN3YXBDb2xvcihjb2xvciksIHN0YXRlLmtpbmdzW2NvbG9yXSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluQ2hlY2soc3RhdGU6IFN0YXRlKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc0tpbmdBdHRhY2tlZChzdGF0ZSwgc3RhdGUudHVybilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluQ2hlY2ttYXRlKHN0YXRlOiBTdGF0ZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gaW5DaGVjayhzdGF0ZSkgJiYgZ2VuZXJhdGVNb3ZlcyhzdGF0ZSkubGVuZ3RoID09PSAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpblN0YWxlbWF0ZShzdGF0ZTogU3RhdGUpOiBib29sZWFuIHtcbiAgcmV0dXJuICFpbkNoZWNrKHN0YXRlKSAmJiBnZW5lcmF0ZU1vdmVzKHN0YXRlKS5sZW5ndGggPT09IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluc3VmZmljaWVudE1hdGVyaWFsKHN0YXRlOiBTdGF0ZSk6IGJvb2xlYW4ge1xuICBjb25zdCBwaWVjZXM6IHtba2V5OiBzdHJpbmddOiBudW1iZXJ9ID0ge31cbiAgY29uc3QgYmlzaG9wcyA9IFtdXG4gIGxldCBudW1fcGllY2VzID0gMFxuICBsZXQgc3FfY29sb3IgPSAwXG5cbiAgZm9yIChsZXQgaSA9IFNRVUFSRVMuYTg7IGkgPD0gU1FVQVJFUy5oMTsgaSsrKSB7XG4gICAgc3FfY29sb3IgPSAoc3FfY29sb3IgKyAxKSAlIDJcbiAgICBpZiAoaSAmIDB4ODgpIHtcbiAgICAgIGkgKz0gN1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBwaWVjZSA9IHN0YXRlLmJvYXJkW2ldXG4gICAgaWYgKHBpZWNlKSB7XG4gICAgICBwaWVjZXNbcGllY2UudHlwZV0gPSBwaWVjZS50eXBlIGluIHBpZWNlcyA/IHBpZWNlc1twaWVjZS50eXBlXSArIDEgOiAxXG4gICAgICBpZiAocGllY2UudHlwZSA9PT0gQklTSE9QKSB7XG4gICAgICAgIGJpc2hvcHMucHVzaChzcV9jb2xvcilcbiAgICAgIH1cbiAgICAgIG51bV9waWVjZXMrK1xuICAgIH1cbiAgfVxuXG4gIC8qIGsgdnMuIGsgKi9cbiAgaWYgKG51bV9waWVjZXMgPT09IDIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKFxuICAgIC8qIGsgdnMuIGtuIC4uLi4gb3IgLi4uLiBrIHZzLiBrYiAqL1xuICAgIG51bV9waWVjZXMgPT09IDMgJiZcbiAgICAgIChwaWVjZXNbQklTSE9QXSA9PT0gMSB8fCBwaWVjZXNbS05JR0hUXSA9PT0gMSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChudW1fcGllY2VzID09PSBwaWVjZXNbQklTSE9QXSArIDIpIHtcbiAgICAvKiBrYiB2cy4ga2Igd2hlcmUgYW55IG51bWJlciBvZiBiaXNob3BzIGFyZSBhbGwgb24gdGhlIHNhbWUgY29sb3IgKi9cbiAgICBsZXQgc3VtID0gMFxuICAgIGNvbnN0IGxlbiA9IGJpc2hvcHMubGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgc3VtICs9IGJpc2hvcHNbaV1cbiAgICB9XG4gICAgaWYgKHN1bSA9PT0gMCB8fCBzdW0gPT09IGxlbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VNb3ZlKHByZXZTdGF0ZTogU3RhdGUsIG1vdmU6IEhleE1vdmUpOiBTdGF0ZSB7XG4gIGNvbnN0IHN0YXRlID0gcHJldlN0YXRlLmNsb25lKClcbiAgY29uc3QgdXMgPSBzdGF0ZS50dXJuXG4gIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpXG4gIC8vIHRoaXMucHVzaChtb3ZlKVxuXG4gIHN0YXRlLmJvYXJkW21vdmUudG9dID0gc3RhdGUuYm9hcmRbbW92ZS5mcm9tXVxuICBkZWxldGUgc3RhdGUuYm9hcmRbbW92ZS5mcm9tXVxuXG4gIC8qIGlmIGVwIGNhcHR1cmUsIHJlbW92ZSB0aGUgY2FwdHVyZWQgcGF3biAqL1xuICBpZiAobW92ZS5mbGFncyAmIEJJVFMuRVBfQ0FQVFVSRSkge1xuICAgIGlmIChzdGF0ZS50dXJuID09PSBCTEFDSykge1xuICAgICAgZGVsZXRlIHN0YXRlLmJvYXJkW21vdmUudG8gLSAxNl1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHN0YXRlLmJvYXJkW21vdmUudG8gKyAxNl1cbiAgICB9XG4gIH1cblxuICAvKiBpZiBwYXduIHByb21vdGlvbiwgcmVwbGFjZSB3aXRoIG5ldyBwaWVjZSAqL1xuICBpZiAobW92ZS5mbGFncyAmIEJJVFMuUFJPTU9USU9OICYmIG1vdmUucHJvbW90aW9uICYmIGlzUGllY2VTeW1ib2wobW92ZS5wcm9tb3Rpb24pKSB7XG4gICAgc3RhdGUuYm9hcmRbbW92ZS50b10gPSB7IHR5cGU6IG1vdmUucHJvbW90aW9uLCBjb2xvcjogdXMgfVxuICB9XG5cbiAgLyogaWYgd2UgbW92ZWQgdGhlIGtpbmcgKi9cbiAgY29uc3QgcGllY2UgPSBzdGF0ZS5ib2FyZFttb3ZlLnRvXVxuICBpZiAocGllY2UgJiYgcGllY2UudHlwZSA9PT0gS0lORykge1xuICAgIHN0YXRlLmtpbmdzW3BpZWNlLmNvbG9yXSA9IG1vdmUudG9cblxuICAgIC8qIGlmIHdlIGNhc3RsZWQsIG1vdmUgdGhlIHJvb2sgbmV4dCB0byB0aGUga2luZyAqL1xuICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgIGNvbnN0IGNhc3RsaW5nX3RvID0gbW92ZS50byAtIDFcbiAgICAgIGNvbnN0IGNhc3RsaW5nX2Zyb20gPSBtb3ZlLnRvICsgMVxuICAgICAgc3RhdGUuYm9hcmRbY2FzdGxpbmdfdG9dID0gc3RhdGUuYm9hcmRbY2FzdGxpbmdfZnJvbV1cbiAgICAgIGRlbGV0ZSBzdGF0ZS5ib2FyZFtjYXN0bGluZ19mcm9tXVxuICAgIH0gZWxzZSBpZiAobW92ZS5mbGFncyAmIEJJVFMuUVNJREVfQ0FTVExFKSB7XG4gICAgICBjb25zdCBjYXN0bGluZ190byA9IG1vdmUudG8gKyAxXG4gICAgICBjb25zdCBjYXN0bGluZ19mcm9tID0gbW92ZS50byAtIDJcbiAgICAgIHN0YXRlLmJvYXJkW2Nhc3RsaW5nX3RvXSA9IHN0YXRlLmJvYXJkW2Nhc3RsaW5nX2Zyb21dXG4gICAgICBkZWxldGUgc3RhdGUuYm9hcmRbY2FzdGxpbmdfZnJvbV1cbiAgICB9XG5cbiAgICAvKiB0dXJuIG9mZiBjYXN0bGluZyAqL1xuICAgIHN0YXRlLmNhc3RsaW5nW3VzXSA9IDBcbiAgfVxuXG4gIC8qIHR1cm4gb2ZmIGNhc3RsaW5nIGlmIHdlIG1vdmUgYSByb29rICovXG4gIGlmIChzdGF0ZS5jYXN0bGluZ1t1c10pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gUk9PS1NbdXNdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1vdmUuZnJvbSA9PT0gUk9PS1NbdXNdW2ldLnNxdWFyZSAmJlxuICAgICAgICAgIHN0YXRlLmNhc3RsaW5nW3VzXSAmIFJPT0tTW3VzXVtpXS5mbGFnXG4gICAgICApIHtcbiAgICAgICAgc3RhdGUuY2FzdGxpbmdbdXNdIF49IFJPT0tTW3VzXVtpXS5mbGFnXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgY2FwdHVyZSBhIHJvb2sgKi9cbiAgaWYgKHN0YXRlLmNhc3RsaW5nW3RoZW1dKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IFJPT0tTW3RoZW1dLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1vdmUudG8gPT09IFJPT0tTW3RoZW1dW2ldLnNxdWFyZSAmJlxuICAgICAgICAgIHN0YXRlLmNhc3RsaW5nW3RoZW1dICYgUk9PS1NbdGhlbV1baV0uZmxhZ1xuICAgICAgKSB7XG4gICAgICAgIHN0YXRlLmNhc3RsaW5nW3RoZW1dIF49IFJPT0tTW3RoZW1dW2ldLmZsYWdcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiBpZiBiaWcgcGF3biBtb3ZlLCB1cGRhdGUgdGhlIGVuIHBhc3NhbnQgc3F1YXJlICovXG4gIGlmIChtb3ZlLmZsYWdzICYgQklUUy5CSUdfUEFXTikge1xuICAgIGlmIChzdGF0ZS50dXJuID09PSAnYicpIHtcbiAgICAgIHN0YXRlLmVwX3NxdWFyZSA9IG1vdmUudG8gLSAxNlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5lcF9zcXVhcmUgPSBtb3ZlLnRvICsgMTZcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuZXBfc3F1YXJlID0gRU1QVFlcbiAgfVxuXG4gIC8qIHJlc2V0IHRoZSA1MCBtb3ZlIGNvdW50ZXIgaWYgYSBwYXduIGlzIG1vdmVkIG9yIGEgcGllY2UgaXMgY2FwdHVyZWQgKi9cbiAgaWYgKG1vdmUucGllY2UgPT09IFBBV04pIHtcbiAgICBzdGF0ZS5oYWxmX21vdmVzID0gMFxuICB9IGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5DQVBUVVJFIHwgQklUUy5FUF9DQVBUVVJFKSkge1xuICAgIHN0YXRlLmhhbGZfbW92ZXMgPSAwXG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuaGFsZl9tb3ZlcysrXG4gIH1cblxuICBpZiAoc3RhdGUudHVybiA9PT0gQkxBQ0spIHtcbiAgICBzdGF0ZS5tb3ZlX251bWJlcisrXG4gIH1cbiAgc3RhdGUudHVybiA9IHN3YXBDb2xvcihzdGF0ZS50dXJuKVxuICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTW92ZShzdGF0ZTogU3RhdGUsIGZyb206IG51bWJlciwgdG86IG51bWJlciwgZmxhZ3M6IG51bWJlciwgcHJvbW90aW9uPzogc3RyaW5nKTogSGV4TW92ZSB7XG4gIGNvbnN0IG1vdmU6IEhleE1vdmUgPSB7XG4gICAgY29sb3I6IHN0YXRlLnR1cm4sXG4gICAgZnJvbTogZnJvbSxcbiAgICB0bzogdG8sXG4gICAgZmxhZ3M6IGZsYWdzLFxuICAgIHBpZWNlOiAoc3RhdGUuYm9hcmRbZnJvbV0gYXMgUGllY2UpLnR5cGVcbiAgfVxuXG4gIGlmIChwcm9tb3Rpb24gJiYgaXNQaWVjZVN5bWJvbChwcm9tb3Rpb24pKSB7XG4gICAgbW92ZS5mbGFncyB8PSBCSVRTLlBST01PVElPTlxuICAgIG1vdmUucHJvbW90aW9uID0gcHJvbW90aW9uXG4gIH1cblxuICBpZiAoc3RhdGUuYm9hcmRbdG9dKSB7XG4gICAgbW92ZS5jYXB0dXJlZCA9IHN0YXRlLmJvYXJkW3RvXT8udHlwZVxuICB9IGVsc2UgaWYgKGZsYWdzICYgQklUUy5FUF9DQVBUVVJFKSB7XG4gICAgbW92ZS5jYXB0dXJlZCA9IFBBV05cbiAgfVxuICByZXR1cm4gbW92ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNjaWkoYm9hcmQ6IEJvYXJkLCBlb2wgPSAnXFxuJyk6IHN0cmluZyB7XG4gIGNvbnN0IHBpZWNlcyA9IFJBTktTLm1hcChyYW5rID0+IHtcbiAgICBjb25zdCByYW5rUGllY2VzID0gYm9hcmQuc2xpY2UocmFuayAqIDE2LCByYW5rICogMTYgKyA4KVxuICAgIC8vIFVzZSBhIGxvb3AgYmVjYXVzZSBgbWFwYCBza2lwcyBlbXB0eSBpbmRleGVzXG4gICAgY29uc3Qgcm93OiBzdHJpbmdbXSA9IFtdXG4gICAgZm9yIChjb25zdCBwaWVjZSBvZiByYW5rUGllY2VzKSB7XG4gICAgICByb3cucHVzaChwaWVjZSA/IGAgJHtzeW1ib2wocGllY2UpfSBgIDogJyAuICcpXG4gICAgfVxuICAgIGNvbnN0IHJhbmtTdHIgPSByb3cuam9pbignJylcblxuICAgIHJldHVybiAnODc2NTQzMjEnW3JhbmtdICsgJyB8JyArIHJhbmtTdHIgKyAnfCdcbiAgfSlcblxuICByZXR1cm4gW1xuICAgICcgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rJyxcbiAgICBwaWVjZXMuam9pbihlb2wpLFxuICAgICcgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rJyxcbiAgICAnICAgIGEgIGIgIGMgIGQgIGUgIGYgIGcgIGgnLFxuICBdLmpvaW4oZW9sKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm9hcmQoYm9hcmQ6IEJvYXJkKTogKFBpZWNlIHwgbnVsbClbXVtdIHtcbiAgY29uc3Qgb3V0cHV0ID0gW11cbiAgbGV0IHJvdyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IFNRVUFSRVMuYTg7IGkgPD0gU1FVQVJFUy5oMTsgaSsrKSB7XG4gICAgY29uc3QgcGllY2UgPSBib2FyZFtpXVxuICAgIGlmIChwaWVjZSA9PSBudWxsKSB7XG4gICAgICByb3cucHVzaChudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICByb3cucHVzaCh7IHR5cGU6IHBpZWNlLnR5cGUsIGNvbG9yOiBwaWVjZS5jb2xvciB9KVxuICAgIH1cbiAgICBpZiAoKGkgKyAxKSAmIDB4ODgpIHtcbiAgICAgIG91dHB1dC5wdXNoKHJvdylcbiAgICAgIHJvdyA9IFtdXG4gICAgICBpICs9IDhcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1vdmUoXG4gIHN0YXRlOiBTdGF0ZSxcbiAgbW92ZTogc3RyaW5nIHwgUGFydGlhbE1vdmUsXG4gIG9wdGlvbnM6IHsgc2xvcHB5PzogYm9vbGVhbiwgY2hlY2tQcm9tb3Rpb24/OiBib29sZWFuIH0gPSB7fVxuKTogSGV4TW92ZSB8IG51bGwge1xuICAvLyBBbGxvdyB0aGUgdXNlciB0byBzcGVjaWZ5IHRoZSBzbG9wcHkgbW92ZSBwYXJzZXIgdG8gd29yayBhcm91bmQgb3ZlclxuICAvLyBkaXNhbWJpZ3VhdGlvbiBidWdzIGluIEZyaXR6IGFuZCBDaGVzc2Jhc2VcbiAgY29uc3QgeyBjaGVja1Byb21vdGlvbiA9IHRydWUgfSA9IG9wdGlvbnNcblxuICBpZiAodHlwZW9mIG1vdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHNhblRvTW92ZShzdGF0ZSwgbW92ZSwgb3B0aW9ucylcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW92ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBtb3ZlcyA9IGdlbmVyYXRlTW92ZXMoc3RhdGUsIHsgc3F1YXJlOiBtb3ZlLmZyb20gfSlcbiAgICAvLyBGaW5kIGEgbWF0Y2hpbmcgbW92ZVxuICAgIGZvciAoY29uc3QgbW92ZU9iaiBvZiBtb3Zlcykge1xuICAgICAgaWYgKFxuICAgICAgICBtb3ZlLmZyb20gPT09IGFsZ2VicmFpYyhtb3ZlT2JqLmZyb20pICYmXG4gICAgICAgICAgbW92ZS50byA9PT0gYWxnZWJyYWljKG1vdmVPYmoudG8pICYmXG4gICAgICAgICAgKCFjaGVja1Byb21vdGlvbiB8fCAhKCdwcm9tb3Rpb24nIGluIG1vdmVPYmopIHx8XG4gICAgICAgICAgICBtb3ZlLnByb21vdGlvbiA9PT0gbW92ZU9iai5wcm9tb3Rpb24pXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG1vdmVPYmpcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwiaW1wb3J0IHtcbiAgZ2VuZXJhdGVNb3ZlcyxcbiAgaXNBdHRhY2tlZCxcbiAgbWFrZU1vdmUsXG4gIG1vdmVUb1NhbixcbiAgcHV0UGllY2UsXG4gIGxvYWRGZW4sXG4gIG1ha2VQcmV0dHksXG4gIGdldFBpZWNlLFxuICByZW1vdmVQaWVjZSxcbiAgaW5DaGVjayxcbiAgaW5DaGVja21hdGUsXG4gIGluU3RhbGVtYXRlLFxuICBpbnN1ZmZpY2llbnRNYXRlcmlhbCxcbiAgbG9hZFBnbixcbiAgZ2V0UGduLFxuICBhc2NpaSxcbiAgZ2V0Qm9hcmQsXG4gIHZhbGlkYXRlTW92ZSxcbn0gZnJvbSAnLi9zdGF0ZSdcbmltcG9ydCB7XG4gIENvbG9yLFxuICBDb21tZW50cyxcbiAgR2FtZUhpc3RvcnksXG4gIEhleE1vdmUsXG4gIE1vdmUsXG4gIEZlbkNvbW1lbnQsXG4gIFBpZWNlLFxuICBTdGF0ZSxcbiAgVmFsaWRhdGlvbixcbiAgUGFydGlhbE1vdmUsXG59IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQge1xuICBmaWxlLFxuICBpc1NxdWFyZSxcbiAgcmFuayxcbiAgc3dhcENvbG9yLFxuICB2YWxpZGF0ZUZlbixcbn0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7XG4gIERFRkFVTFRfUE9TSVRJT04sXG4gIFNRVUFSRVMsXG4gIEJJVFMsXG59IGZyb20gJy4vY29uc3RhbnRzJ1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGNsYXNzIENoZXNzIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgX3N0YXRlOiBTdGF0ZVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIF9oaXN0b3J5OiBHYW1lSGlzdG9yeVtdXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgX2hlYWRlcjogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIF9jb21tZW50czogQ29tbWVudHNcblxuICBfd2hpdGVSZXNpZ25lZDpib29sZWFuID0gZmFsc2VcbiAgX2JsYWNrUmVzaWduZWQ6Ym9vbGVhbiA9IGZhbHNlXG4gIF9kcmF3QWdyZWVkOiBib29sZWFuID0gZmFsc2VcbiAgLyoqXG4gICAqIFRoZSBDaGVzcygpIGNvbnN0cnVjdG9yIHRha2VzIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB3aGljaCBzcGVjaWZpZXMgdGhlIGJvYXJkIGNvbmZpZ3VyYXRpb25cbiAgICogaW4gW0ZvcnN5dGgtRWR3YXJkcyBOb3RhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3JzeXRoJUUyJTgwJTkzRWR3YXJkc19Ob3RhdGlvbikuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIC8vIGJvYXJkIGRlZmF1bHRzIHRvIHRoZSBzdGFydGluZyBwb3NpdGlvbiB3aGVuIGNhbGxlZCB3aXRoIG5vIHBhcmFtZXRlcnNcbiAgICogY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3MoKVxuICAgKlxuICAgKiAvLyBwYXNzIGluIGEgRkVOIHN0cmluZyB0byBsb2FkIGEgcGFydGljdWxhciBwb3NpdGlvblxuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcyhcbiAgICogICAgICdyMWs0ci9wMm5iMXAxLzJiNHAvMXAxbjFwMi8yUFA0LzNRMU5CMS8xUDNQUFAvUjVLMSBiIC0gYzMgMCAxOSdcbiAgICogKVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGZlbjogc3RyaW5nID0gREVGQVVMVF9QT1NJVElPTikge1xuICAgIHRoaXMuX3N0YXRlID0gbmV3IFN0YXRlKClcbiAgICB0aGlzLl9oaXN0b3J5ID0gW11cbiAgICB0aGlzLl9oZWFkZXIgPSB7fVxuICAgIHRoaXMuX2NvbW1lbnRzID0ge31cblxuICAgIGlmICghdGhpcy5sb2FkKGZlbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgbG9hZGluZyBmZW4nKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIGdldCBzdGF0ZSgpOiBTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmNsb25lKClcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKiovXG4gIHB1YmxpYyBnZXQgc3RhdGVzKCk6IFN0YXRlW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5faGlzdG9yeS5tYXAoKGdhbWVIaXN0b3J5KSA9PiBnYW1lSGlzdG9yeS5zdGF0ZS5jbG9uZSgpKSwgdGhpcy5zdGF0ZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGJvYXJkIGFuZCBsb2FkcyB0aGUgRm9yc3l0aOKAk0Vkd2FyZHMgTm90YXRpb24gKEZFTikgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gZmVuIC0gRkVOIHN0cmluZ1xuICAgKiBAcGFyYW0ga2VlcEhlYWRlcnMgLSBGbGFnIHRvIGtlZXAgaGVhZGVyc1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBwb3NpdGlvbiB3YXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgcHVibGljIGxvYWQoZmVuOiBzdHJpbmcsIGtlZXBIZWFkZXJzID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICBjb25zdCBzdGF0ZSA9IGxvYWRGZW4oZmVuKVxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlXG4gICAgdGhpcy5faGlzdG9yeSA9IFtdXG4gICAgaWYgKCFrZWVwSGVhZGVycykgdGhpcy5faGVhZGVyID0ge31cbiAgICB0aGlzLl9jb21tZW50cyA9IHt9XG4gICAgdGhpcy51cGRhdGVTZXR1cCgpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGJvYXJkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjaGVzcy5jbGVhcigpXG4gICAqIGNoZXNzLmZlbigpXG4gICAqIC8vIC0+ICc4LzgvOC84LzgvOC84LzggdyAtIC0gMCAxJyA8LSBlbXB0eSBib2FyZFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGtlZXBIZWFkZXJzIC0gRmxhZyB0byBrZWVwIGhlYWRlcnNcbiAgICovXG4gIHB1YmxpYyBjbGVhcihrZWVwSGVhZGVycyA9IGZhbHNlKTogdm9pZCB7XG4gICAgdGhpcy5fc3RhdGUgPSBuZXcgU3RhdGUoKVxuICAgIHRoaXMuX2hpc3RvcnkgPSBbXVxuICAgIGlmICgha2VlcEhlYWRlcnMpIHRoaXMuX2hlYWRlciA9IHt9XG4gICAgdGhpcy5fY29tbWVudHMgPSB7fVxuICAgIHRoaXMudXBkYXRlU2V0dXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBib2FyZCB0byB0aGUgaW5pdGlhbCBzdGFydGluZyBwb3NpdGlvbi5cbiAgICovXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmxvYWQoREVGQVVMVF9QT1NJVElPTilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaWVjZSBvbiB0aGUgc3F1YXJlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjaGVzcy5jbGVhcigpXG4gICAqIGNoZXNzLnB1dCh7IHR5cGU6IGNoZXNzLlBBV04sIGNvbG9yOiBjaGVzcy5CTEFDSyB9LCAnYTUnKSAvLyBwdXQgYSBibGFjayBwYXduIG9uIGE1XG4gICAqXG4gICAqIGNoZXNzLmdldCgnYTUnKVxuICAgKiAvLyAtPiB7IHR5cGU6ICdwJywgY29sb3I6ICdiJyB9LFxuICAgKiBjaGVzcy5nZXQoJ2E2JylcbiAgICogLy8gLT4gbnVsbFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHNxdWFyZSAtIGUuZy4gJ2U0J1xuICAgKiBAcmV0dXJucyBDb3B5IG9mIHRoZSBwaWVjZSBvciBudWxsXG4gICAqL1xuICBwdWJsaWMgZ2V0KHNxdWFyZT86IHN0cmluZyk6IFBpZWNlIHwgbnVsbCB7XG4gICAgcmV0dXJuIGdldFBpZWNlKHRoaXMuX3N0YXRlLCBzcXVhcmUpXG4gIH1cblxuICAvKipcbiAgICogUGxhY2UgYSBwaWVjZSBvbiB0aGUgc3F1YXJlIHdoZXJlIHBpZWNlIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb3JtXG4gICAqIGB7IHR5cGU6IC4uLiwgY29sb3I6IC4uLiB9YC4gUmV0dXJucyB0cnVlIGlmIHRoZSBwaWVjZSB3YXMgc3VjY2Vzc2Z1bGx5XG4gICAqIHBsYWNlZCwgb3RoZXJ3aXNlLCB0aGUgYm9hcmQgcmVtYWlucyB1bmNoYW5nZWQgYW5kIGZhbHNlIGlzIHJldHVybmVkLlxuICAgKiBgcHV0KClgIHdpbGwgZmFpbCB3aGVuIHBhc3NlZCBhbiBpbnZhbGlkIHBpZWNlIG9yIHNxdWFyZSwgb3Igd2hlbiB0d28gb3JcbiAgICogbW9yZSBraW5ncyBvZiB0aGUgc2FtZSBjb2xvciBhcmUgcGxhY2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjaGVzcy5jbGVhcigpXG4gICAqXG4gICAqIGNoZXNzLnB1dCh7IHR5cGU6IGNoZXNzLlBBV04sIGNvbG9yOiBjaGVzcy5CTEFDSyB9LCAnYTUnKSAvLyBwdXQgYSBibGFjayBwYXduIG9uIGE1XG4gICAqIC8vIC0+IHRydWVcbiAgICogY2hlc3MucHV0KHsgdHlwZTogJ2snLCBjb2xvcjogJ3cnIH0sICdoMScpIC8vIHNob3J0aGFuZFxuICAgKiAvLyAtPiB0cnVlXG4gICAqXG4gICAqIGNoZXNzLmZlbigpXG4gICAqIC8vIC0+ICc4LzgvOC9wNy84LzgvOC83SyB3IC0gLSAwIDAnXG4gICAqXG4gICAqIGNoZXNzLnB1dCh7IHR5cGU6ICd6JywgY29sb3I6ICd3JyB9LCAnYTEnKSAvLyBpbnZhbGlkIHBpZWNlXG4gICAqIC8vIC0+IGZhbHNlXG4gICAqXG4gICAqIGNoZXNzLmNsZWFyKClcbiAgICpcbiAgICogY2hlc3MucHV0KHsgdHlwZTogJ2snLCBjb2xvcjogJ3cnIH0sICdhMScpXG4gICAqIC8vIC0+IHRydWVcbiAgICpcbiAgICogY2hlc3MucHV0KHsgdHlwZTogJ2snLCBjb2xvcjogJ3cnIH0sICdoMScpIC8vIGZhaWwgLSB0d28ga2luZ3NcbiAgICogLy8gLT4gZmFsc2VcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBwaWVjZSAtIE9iamVjdCBvZiB0aGUgZm9ybSBgeyB0eXBlOiAncCcsIGNvbG9yOiAndycgfWBcbiAgICogQHBhcmFtIHNxdWFyZSAtIGUuZy4gYCdlNCdgXG4gICAqIEByZXR1cm5zIFRydWUgaWYgcGxhY2VkIHN1Y2Nlc3NmdWxseSwgb3RoZXJ3aXNlIGZhbHNlXG4gICAqL1xuICBwdWJsaWMgcHV0KHBpZWNlOiB7IHR5cGU/OiBzdHJpbmcsIGNvbG9yPzogc3RyaW5nIH0sIHNxdWFyZT86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gcHV0UGllY2UodGhpcy5fc3RhdGUsIHBpZWNlLCBzcXVhcmUpXG4gICAgaWYgKG5ld1N0YXRlKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlXG4gICAgICB0aGlzLnVwZGF0ZVNldHVwKClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBwaWVjZSBvbiBgc3F1YXJlYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY2hlc3MuY2xlYXIoKVxuICAgKiBjaGVzcy5wdXQoeyB0eXBlOiBjaGVzcy5QQVdOLCBjb2xvcjogY2hlc3MuQkxBQ0sgfSwgJ2E1JykgLy8gcHV0IGEgYmxhY2sgcGF3biBvbiBhNVxuICAgKiBjaGVzcy5wdXQoeyB0eXBlOiBjaGVzcy5LSU5HLCBjb2xvcjogY2hlc3MuV0hJVEUgfSwgJ2gxJykgLy8gcHV0IGEgd2hpdGUga2luZyBvbiBoMVxuICAgKlxuICAgKiBjaGVzcy5yZW1vdmUoJ2E1JylcbiAgICogLy8gLT4geyB0eXBlOiAncCcsIGNvbG9yOiAnYicgfSxcbiAgICogY2hlc3MucmVtb3ZlKCdoMScpXG4gICAqIC8vIC0+IHsgdHlwZTogJ2snLCBjb2xvcjogJ3cnIH0sXG4gICAqIGNoZXNzLnJlbW92ZSgnZTEnKVxuICAgKiAvLyAtPiBudWxsXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gc3F1YXJlIC0gZS5nLiAnZTQnXG4gICAqIEByZXR1cm5zIFBpZWNlIG9yIG51bGxcbiAgICovXG4gIHB1YmxpYyByZW1vdmUoc3F1YXJlPzogc3RyaW5nKTogUGllY2UgfCBudWxsIHtcbiAgICBjb25zdCBwaWVjZSA9IGdldFBpZWNlKHRoaXMuX3N0YXRlLCBzcXVhcmUpXG4gICAgaWYgKCFwaWVjZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IHJlbW92ZVBpZWNlKHRoaXMuX3N0YXRlLCBzcXVhcmUpXG4gICAgaWYgKCFuZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZVxuICAgIHJldHVybiBwaWVjZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGxlZ2FsIG1vdmVzIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uIFRoZSBmdW5jdGlvblxuICAgKiB0YWtlcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgd2hpY2ggY29udHJvbHMgdGhlIHNpbmdsZS1zcXVhcmUgbW92ZVxuICAgKiBnZW5lcmF0aW9uIGFuZCB2ZXJib3NpdHkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKClcbiAgICogY2hlc3MubW92ZXMoKVxuICAgKiAvLyAtPiBbJ2EzJywgJ2E0JywgJ2IzJywgJ2I0JywgJ2MzJywgJ2M0JywgJ2QzJywgJ2Q0JywgJ2UzJywgJ2U0JyxcbiAgICogLy8gICAgICdmMycsICdmNCcsICdnMycsICdnNCcsICdoMycsICdoNCcsICdOYTMnLCAnTmMzJywgJ05mMycsICdOaDMnXVxuICAgKlxuICAgKiBjaGVzcy5tb3Zlcyh7IHNxdWFyZTogJ2UyJyB9KVxuICAgKiAvLyAtPiBbJ2UzJywgJ2U0J11cbiAgICpcbiAgICogY2hlc3MubW92ZXMoeyBzcXVhcmU6ICdlOScgfSkgLy8gaW52YWxpZCBzcXVhcmVcbiAgICogLy8gLT4gW11cbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgbW92ZXMob3B0aW9ucz86IHsgc3F1YXJlPzogc3RyaW5nLCB2ZXJib3NlPzogZmFsc2UgfSk6IHN0cmluZ1tdXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGxlZ2FsIG1vdmVzIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uIFRoZSBmdW5jdGlvblxuICAgKiB0YWtlcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgd2hpY2ggY29udHJvbHMgdGhlIHNpbmdsZS1zcXVhcmUgbW92ZVxuICAgKiBnZW5lcmF0aW9uIGFuZCB2ZXJib3NpdHkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKClcbiAgICogY2hlc3MubW92ZXMoeyB2ZXJib3NlOiB0cnVlIH0pXG4gICAqIC8vIC0+IFt7IGNvbG9yOiAndycsIGZyb206ICdhMicsIHRvOiAnYTMnLFxuICAgKiAvLyAgICAgICBmbGFnczogJ24nLCBwaWVjZTogJ3AnLCBzYW4gJ2EzJ1xuICAgKiAvLyAgICAgICAjIGEgY2FwdHVyZWQ6IGtleSBpcyBpbmNsdWRlZCB3aGVuIHRoZSBtb3ZlIGlzIGEgY2FwdHVyZVxuICAgKiAvLyAgICAgICAjIGEgcHJvbW90aW9uOiBrZXkgaXMgaW5jbHVkZWQgd2hlbiB0aGUgbW92ZSBpcyBhIHByb21vdGlvblxuICAgKiAvLyAgICAgfSxcbiAgICogLy8gICAgIC4uLlxuICAgKiAvLyAgICAgXVxuICAgKiBgYGBcbiAgICoge0BsaW5rIE1vdmV9XG4gICAqL1xuICBwdWJsaWMgbW92ZXMob3B0aW9uczogeyBzcXVhcmU/OiBzdHJpbmcsIHZlcmJvc2U6IHRydWUgfSk6IE1vdmVbXVxuXG4gIHB1YmxpYyBtb3ZlcyhvcHRpb25zOiB7IHNxdWFyZT86IHN0cmluZywgdmVyYm9zZT86IGJvb2xlYW59ID0ge30pOiBzdHJpbmdbXSB8IE1vdmVbXSB7XG4gICAgLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgY2hlc3MgbW92ZSBpcyBpbiAweDg4IGZvcm1hdCwgYW5kXG4gICAgLy8gbm90IG1lYW50IHRvIGJlIGh1bWFuLXJlYWRhYmxlLiAgVGhlIGNvZGUgYmVsb3cgY29udmVydHMgdGhlIDB4ODhcbiAgICAvLyBzcXVhcmUgY29vcmRpbmF0ZXMgdG8gYWxnZWJyYWljIGNvb3JkaW5hdGVzLiAgSXQgYWxzbyBwcnVuZXMgYW5cbiAgICAvLyB1bm5lY2Vzc2FyeSBtb3ZlIGtleXMgcmVzdWx0aW5nIGZyb20gYSB2ZXJib3NlIGNhbGwuXG4gICAgY29uc3QgeyBzcXVhcmUsIHZlcmJvc2UgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHVnbHlNb3ZlcyA9IGdlbmVyYXRlTW92ZXModGhpcy5fc3RhdGUsIHsgc3F1YXJlIH0pXG5cbiAgICBpZiAodmVyYm9zZSkge1xuICAgICAgcmV0dXJuIHVnbHlNb3Zlcy5tYXAoKHVnbHlNb3ZlKSA9PiBtYWtlUHJldHR5KHRoaXMuX3N0YXRlLCB1Z2x5TW92ZSkpXG4gICAgfVxuICAgIHJldHVybiB1Z2x5TW92ZXMubWFwKCh1Z2x5TW92ZSkgPT4gbW92ZVRvU2FuKHRoaXMuX3N0YXRlLCB1Z2x5TW92ZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgRkVOIHN0cmluZyBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKClcbiAgICpcbiAgICogLy8gbWFrZSBzb21lIG1vdmVzXG4gICAqIGNoZXNzLm1vdmUoJ2U0JylcbiAgICogY2hlc3MubW92ZSgnZTUnKVxuICAgKiBjaGVzcy5tb3ZlKCdmNCcpXG4gICAqXG4gICAqIGNoZXNzLmZlbigpXG4gICAqIC8vIC0+ICdybmJxa2Juci9wcHBwMXBwcC84LzRwMy80UFAyLzgvUFBQUDJQUC9STkJRS0JOUiBiIEtRa3EgZjMgMCAyJ1xuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBmZW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuZmVuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIHRoZSBzaWRlIHRvIG1vdmUgaXMgaW4gY2hlY2suXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKFxuICAgKiAgICAgJ3JuYjFrYm5yL3BwcHAxcHBwLzgvNHAzLzVQUHEvOC9QUFBQUDJQL1JOQlFLQk5SIHcgS1FrcSAtIDEgMydcbiAgICogKVxuICAgKiBjaGVzcy5pbkNoZWNrKClcbiAgICogLy8gLT4gdHJ1ZVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBpbkNoZWNrKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpbkNoZWNrKHRoaXMuX3N0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiB0aGUgc2lkZSB0byBtb3ZlIGhhcyBiZWVuIGNoZWNrbWF0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKFxuICAgKiAgICAgJ3JuYjFrYm5yL3BwcHAxcHBwLzgvNHAzLzVQUHEvOC9QUFBQUDJQL1JOQlFLQk5SIHcgS1FrcSAtIDEgMydcbiAgICogKVxuICAgKiBjaGVzcy5pbkNoZWNrbWF0ZSgpXG4gICAqIC8vIC0+IHRydWVcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgaW5DaGVja21hdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGluQ2hlY2ttYXRlKHRoaXMuX3N0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiB0aGUgc2lkZSB0byBtb3ZlIGhhcyBiZWVuIHN0YWxlbWF0ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKCc0azMvNFAzLzRLMy84LzgvOC84LzggYiAtIC0gMCA3OCcpXG4gICAqIGNoZXNzLmluU3RhbGVtYXRlKClcbiAgICogLy8gLT4gdHJ1ZVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBpblN0YWxlbWF0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaW5TdGFsZW1hdGUodGhpcy5fc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnYW1lIGlzIGRyYXduIGR1ZSB0byBpbnN1ZmZpY2llbnQgbWF0ZXJpYWwgKEsgdnMuIEssXG4gICAqIEsgdnMuIEtCLCBvciBLIHZzLiBLTikgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygnazcvOC9uNy84LzgvOC84LzdLIGIgLSAtIDAgMScpXG4gICAqIGNoZXNzLmluc3VmZmljaWVudE1hdGVyaWFsKClcbiAgICogLy8gLT4gdHJ1ZVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBpbnN1ZmZpY2llbnRNYXRlcmlhbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaW5zdWZmaWNpZW50TWF0ZXJpYWwodGhpcy5fc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIHRoZSBjdXJyZW50IGJvYXJkIHBvc2l0aW9uIGhhcyBvY2N1cnJlZCB0aHJlZSBvciBtb3JlXG4gICAqIHRpbWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygncm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDEnKVxuICAgKiAvLyAtPiB0cnVlXG4gICAqIC8vIHJuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlIgdyBLUWtxIG9jY3VycyAxc3QgdGltZVxuICAgKiBjaGVzcy5pblRocmVlZm9sZFJlcGV0aXRpb24oKVxuICAgKiAvLyAtPiBmYWxzZVxuICAgKlxuICAgKiBjaGVzcy5tb3ZlKCdOZjMnKSBjaGVzcy5tb3ZlKCdOZjYnKSBjaGVzcy5tb3ZlKCdOZzEnKSBjaGVzcy5tb3ZlKCdOZzgnKVxuICAgKiAvLyBybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSBvY2N1cnMgMm5kIHRpbWVcbiAgICogY2hlc3MuaW5UaHJlZWZvbGRSZXBldGl0aW9uKClcbiAgICogLy8gLT4gZmFsc2VcbiAgICpcbiAgICogY2hlc3MubW92ZSgnTmYzJykgY2hlc3MubW92ZSgnTmY2JykgY2hlc3MubW92ZSgnTmcxJykgY2hlc3MubW92ZSgnTmc4JylcbiAgICogLy8gcm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3Egb2NjdXJzIDNyZCB0aW1lXG4gICAqIGNoZXNzLmluVGhyZWVmb2xkUmVwZXRpdGlvbigpXG4gICAqIC8vIC0+IHRydWVcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgaW5UaHJlZWZvbGRSZXBldGl0aW9uKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHBvc2l0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XG5cbiAgICBjb25zdCBjaGVja1N0YXRlID0gKHN0YXRlOiBTdGF0ZSk6IGJvb2xlYW4gPT4ge1xuICAgICAgY29uc3Qga2V5ID0gc3RhdGUuZmVuLnNwbGl0KCcgJykuc2xpY2UoMCwgNCkuam9pbignICcpXG5cbiAgICAgIC8vIEhhcyB0aGUgcG9zaXRpb24gb2NjdXJyZWQgdGhyZWUgb3IgbW92ZSB0aW1lcz9cbiAgICAgIHBvc2l0aW9uc1trZXldID0ga2V5IGluIHBvc2l0aW9ucyA/IHBvc2l0aW9uc1trZXldICsgMSA6IDFcbiAgICAgIGlmIChwb3NpdGlvbnNba2V5XSA+PSAzKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHsgc3RhdGUgfSBvZiB0aGlzLl9oaXN0b3J5KSB7XG4gICAgICBpZiAoY2hlY2tTdGF0ZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrU3RhdGUodGhpcy5fc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIHRoZSBnYW1lIGlzIGRyYXduICg1MC1tb3ZlIHJ1bGUgb3IgaW5zdWZmaWNpZW50IG1hdGVyaWFsKS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3MoJzRrMy80UDMvNEszLzgvOC84LzgvOCBiIC0gLSAwIDc4JylcbiAgICogY2hlc3MuaW5EcmF3KClcbiAgICogLy8gLT4gdHJ1ZVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBpbkRyYXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuX3N0YXRlLmhhbGZfbW92ZXMgPj0gMTAwIHx8XG4gICAgICAgIHRoaXMuaW5TdGFsZW1hdGUoKSB8fFxuICAgICAgICB0aGlzLmluc3VmZmljaWVudE1hdGVyaWFsKCkgfHxcbiAgICAgICAgdGhpcy5pblRocmVlZm9sZFJlcGV0aXRpb24oKVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdhbWUgaGFzIGVuZGVkIHZpYSBjaGVja21hdGUsIHN0YWxlbWF0ZSwgZHJhdyxcbiAgICogdGhyZWVmb2xkIHJlcGV0aXRpb24sIG9yIGluc3VmZmljaWVudCBtYXRlcmlhbC4gT3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygpXG4gICAqIGNoZXNzLmdhbWVPdmVyKClcbiAgICogLy8gLT4gZmFsc2VcbiAgICpcbiAgICogLy8gc3RhbGVtYXRlXG4gICAqIGNoZXNzLmxvYWQoJzRrMy80UDMvNEszLzgvOC84LzgvOCBiIC0gLSAwIDc4JylcbiAgICogY2hlc3MuZ2FtZU92ZXIoKVxuICAgKiAvLyAtPiB0cnVlXG4gICAqXG4gICAqIC8vIGNoZWNrbWF0ZVxuICAgKiBjaGVzcy5sb2FkKCdybmIxa2Juci9wcHBwMXBwcC84LzRwMy81UFBxLzgvUFBQUFAyUC9STkJRS0JOUiB3IEtRa3EgLSAxIDMnKVxuICAgKiBjaGVzcy5nYW1lT3ZlcigpXG4gICAqIC8vIC0+IHRydWVcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgZ2FtZU92ZXIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5DaGVja21hdGUoKSB8fCB0aGlzLmluRHJhdygpIHx8IHRoaXMuX3doaXRlUmVzaWduZWQgfHwgdGhpcy5fYmxhY2tSZXNpZ25lZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gMkQgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgcG9zaXRpb24uIEVtcHR5IHNxdWFyZXNcbiAgICogYXJlIHJlcHJlc2VudGVkIGJ5IGBudWxsYC5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3MoKVxuICAgKlxuICAgKiBjaGVzcy5ib2FyZCgpXG4gICAqIC8vIC0+IFtbe3R5cGU6ICdyJywgY29sb3I6ICdiJ30sXG4gICAqICAgICAgICAge3R5cGU6ICduJywgY29sb3I6ICdiJ30sXG4gICAqICAgICAgICAge3R5cGU6ICdiJywgY29sb3I6ICdiJ30sXG4gICAqICAgICAgICAge3R5cGU6ICdxJywgY29sb3I6ICdiJ30sXG4gICAqICAgICAgICAge3R5cGU6ICdrJywgY29sb3I6ICdiJ30sXG4gICAqICAgICAgICAge3R5cGU6ICdiJywgY29sb3I6ICdiJ30sXG4gICAqICAgICAgICAge3R5cGU6ICduJywgY29sb3I6ICdiJ30sXG4gICAqICAgICAgICAge3R5cGU6ICdyJywgY29sb3I6ICdiJ31dLFxuICAgKiAgICAgICAgIFsuLi5dLFxuICAgKiAgICAgICAgIFsuLi5dLFxuICAgKiAgICAgICAgIFsuLi5dLFxuICAgKiAgICAgICAgIFsuLi5dLFxuICAgKiAgICAgICAgIFsuLi5dLFxuICAgKiAgICAgICAgIFt7dHlwZTogJ3InLCBjb2xvcjogJ3cnfSxcbiAgICogICAgICAgICAge3R5cGU6ICduJywgY29sb3I6ICd3J30sXG4gICAqICAgICAgICAgIHt0eXBlOiAnYicsIGNvbG9yOiAndyd9LFxuICAgKiAgICAgICAgICB7dHlwZTogJ3EnLCBjb2xvcjogJ3cnfSxcbiAgICogICAgICAgICAge3R5cGU6ICdrJywgY29sb3I6ICd3J30sXG4gICAqICAgICAgICAgIHt0eXBlOiAnYicsIGNvbG9yOiAndyd9LFxuICAgKiAgICAgICAgICB7dHlwZTogJ24nLCBjb2xvcjogJ3cnfSxcbiAgICogICAgICAgICAge3R5cGU6ICdyJywgY29sb3I6ICd3J31dXVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBib2FyZCgpOiAoUGllY2UgfCBudWxsKVtdW10ge1xuICAgIHJldHVybiBnZXRCb2FyZCh0aGlzLl9zdGF0ZS5ib2FyZClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnYW1lIGluIFBHTiBmb3JtYXQuIE9wdGlvbnMgaXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHdoaWNoIG1heSBpbmNsdWRlXG4gICAqIG1heCB3aWR0aCBhbmQvb3IgYSBuZXdsaW5lIGNoYXJhY3RlciBzZXR0aW5ncy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3MoKVxuICAgKiBjaGVzcy5oZWFkZXIoJ1doaXRlJywgJ1BsdW5reScsICdCbGFjaycsICdQbGlua2llJylcbiAgICogY2hlc3MubW92ZSgnZTQnKVxuICAgKiBjaGVzcy5tb3ZlKCdlNScpXG4gICAqIGNoZXNzLm1vdmUoJ05jMycpXG4gICAqIGNoZXNzLm1vdmUoJ05jNicpXG4gICAqXG4gICAqIGNoZXNzLnBnbih7IG1heF93aWR0aDogNSwgbmV3bGluZV9jaGFyOiAnPGJyIC8+JyB9KVxuICAgKiAvLyAtPiAnW1doaXRlIFwiUGx1bmt5XCJdPGJyIC8+W0JsYWNrIFwiUGxpbmtpZVwiXTxiciAvPjxiciAvPjEuIGU0IGU1PGJyIC8+Mi4gTmMzIE5jNidcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgcGduKG9wdGlvbnM6IHsgbmV3bGluZV9jaGFyPzogc3RyaW5nLCBtYXhfd2lkdGg/OiBudW1iZXIgfSA9IHt9KTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0UGduKHRoaXMuX3N0YXRlLCB0aGlzLl9oZWFkZXIsIHRoaXMuX2NvbW1lbnRzLCB0aGlzLl9oaXN0b3J5LCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIG1vdmVzIG9mIGEgZ2FtZSBzdG9yZWQgaW5cbiAgICogW1BvcnRhYmxlIEdhbWUgTm90YXRpb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9ydGFibGVfR2FtZV9Ob3RhdGlvbikuXG4gICAqIGBwZ25gIHNob3VsZCBiZSBhIHN0cmluZy4gT3B0aW9ucyBpcyBhbiBvcHRpb25hbCBgb2JqZWN0YCB3aGljaCBtYXkgY29udGFpblxuICAgKiBhIHN0cmluZyBgbmV3bGluZV9jaGFyYCBhbmQgYSBib29sZWFuIGBzbG9wcHlgLlxuICAgKlxuICAgKiBUaGUgYG5ld2xpbmVfY2hhcmAgaXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2YWxpZCBSZWdFeHAgZnJhZ21lbnQgYW5kIGlzXG4gICAqIHVzZWQgdG8gcHJvY2VzcyB0aGUgUEdOLiBJdCBkZWZhdWx0cyB0byBgXFxyP1xcbmAuIFNwZWNpYWwgY2hhcmFjdGVyc1xuICAgKiBzaG91bGQgbm90IGJlIHByZS1lc2NhcGVkLCBidXQgYW55IGxpdGVyYWwgc3BlY2lhbCBjaGFyYWN0ZXJzIHNob3VsZCBiZSBlc2NhcGVkXG4gICAqIGFzIGlzIG5vcm1hbCBmb3IgYSBSZWdFeHAuIEtlZXAgaW4gbWluZCB0aGF0IGJhY2tzbGFzaGVzIGluIEphdmFTY3JpcHQgc3RyaW5nc1xuICAgKiBtdXN0IHRoZW1zZWx2ZXMgYmUgZXNjYXBlZCAoc2VlIGBzbG9wcHlfcGduYCBleGFtcGxlIGJlbG93KS4gQXZvaWQgdXNpbmdcbiAgICogYSBgbmV3bGluZV9jaGFyYCB0aGF0IG1heSBvY2N1ciBlbHNld2hlcmUgaW4gYSBQR04sIHN1Y2ggYXMgYC5gIG9yIGB4YCwgYXMgdGhpc1xuICAgKiB3aWxsIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yLlxuICAgKlxuICAgKiBUaGUgYHNsb3BweWAgZmxhZyBpcyBhIGJvb2xlYW4gdGhhdCBwZXJtaXRzIGNoZXNzLmpzIHRvIHBhcnNlIG1vdmVzIGluXG4gICAqIG5vbi1zdGFuZGFyZCBub3RhdGlvbnMuIFNlZSBgLm1vdmVgIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXRcbiAgICogbm9uLVNBTiBub3RhdGlvbnMuXG4gICAqXG4gICAqIFRoZSBtZXRob2Qgd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBQR04gd2FzIHBhcnNlZCBzdWNjZXNzZnVsbHksIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygpXG4gICAqIGNvbnN0IHBnbiA9IFtcbiAgICogICAgICdbRXZlbnQgXCJDYXN1YWwgR2FtZVwiXScsXG4gICAqICAgICAnW1NpdGUgXCJCZXJsaW4gR0VSXCJdJyxcbiAgICogICAgICdbRGF0ZSBcIjE4NTIuPz8uPz9cIl0nLFxuICAgKiAgICAgJ1tFdmVudERhdGUgXCI/XCJdJyxcbiAgICogICAgICdbUm91bmQgXCI/XCJdJyxcbiAgICogICAgICdbUmVzdWx0IFwiMS0wXCJdJyxcbiAgICogICAgICdbV2hpdGUgXCJBZG9sZiBBbmRlcnNzZW5cIl0nLFxuICAgKiAgICAgJ1tCbGFjayBcIkplYW4gRHVmcmVzbmVcIl0nLFxuICAgKiAgICAgJ1tFQ08gXCJDNTJcIl0nLFxuICAgKiAgICAgJ1tXaGl0ZUVsbyBcIj9cIl0nLFxuICAgKiAgICAgJ1tCbGFja0VsbyBcIj9cIl0nLFxuICAgKiAgICAgJ1tQbHlDb3VudCBcIjQ3XCJdJyxcbiAgICogICAgICcnLFxuICAgKiAgICAgJzEuZTQgZTUgMi5OZjMgTmM2IDMuQmM0IEJjNSA0LmI0IEJ4YjQgNS5jMyBCYTUgNi5kNCBleGQ0IDcuTy1PJyxcbiAgICogICAgICdkMyA4LlFiMyBRZjYgOS5lNSBRZzYgMTAuUmUxIE5nZTcgMTEuQmEzIGI1IDEyLlF4YjUgUmI4IDEzLlFhNCcsXG4gICAqICAgICAnQmI2IDE0Lk5iZDIgQmI3IDE1Lk5lNCBRZjUgMTYuQnhkMyBRaDUgMTcuTmY2KyBneGY2IDE4LmV4ZjYnLFxuICAgKiAgICAgJ1JnOCAxOS5SYWQxIFF4ZjMgMjAuUnhlNysgTnhlNyAyMS5ReGQ3KyBLeGQ3IDIyLkJmNSsgS2U4JyxcbiAgICogICAgICcyMy5CZDcrIEtmOCAyNC5CeGU3IyAxLTAnXG4gICAqIF1cbiAgICpcbiAgICogY2hlc3MubG9hZFBnbihwZ24uam9pbignXFxuJykpXG4gICAqIC8vIC0+IHRydWVcbiAgICpcbiAgICogY2hlc3MuZmVuKClcbiAgICogLy8gLT4gMXIza3IxL3BicEJCcDFwLzFiM1AyLzgvOC8yUDJxMi9QNFBQUC8zUjJLMSBiIC0gLSAwIDI0XG4gICAqXG4gICAqIGNoZXNzLmFzY2lpKClcbiAgICogLy8gLT4gJyAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogLy8gICAgIDggfCAuICByICAuICAuICAuICBrICByICAuIHxcbiAgICogLy8gICAgIDcgfCBwICBiICBwICBCICBCICBwICAuICBwIHxcbiAgICogLy8gICAgIDYgfCAuICBiICAuICAuICAuICBQICAuICAuIHxcbiAgICogLy8gICAgIDUgfCAuICAuICAuICAuICAuICAuICAuICAuIHxcbiAgICogLy8gICAgIDQgfCAuICAuICAuICAuICAuICAuICAuICAuIHxcbiAgICogLy8gICAgIDMgfCAuICAuICBQICAuICAuICBxICAuICAuIHxcbiAgICogLy8gICAgIDIgfCBQICAuICAuICAuICAuICBQICBQICBQIHxcbiAgICogLy8gICAgIDEgfCAuICAuICAuICBSICAuICAuICBLICAuIHxcbiAgICogLy8gICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogLy8gICAgICAgICBhICBiICBjICBkICBlICBmICBnICBoJ1xuICAgKlxuICAgKiAvLyBQYXJzZSBub24tc3RhbmRhcmQgbW92ZSBmb3JtYXRzIGFuZCB1bnVzdWFsIGxpbmUgc2VwYXJhdG9yc1xuICAgKiBjb25zdCBzbG9wcHlQZ24gPSBbXG4gICAqICAgICAnW0V2ZW50IFwiV2lqayBhYW4gWmVlIChOZXRoZXJsYW5kcylcIl0nLFxuICAgKiAgICAgJ1tEYXRlIFwiMTk3MS4wMS4yNlwiXScsXG4gICAqICAgICAnW1Jlc3VsdCBcIjEtMFwiXScsXG4gICAqICAgICAnW1doaXRlIFwiVGlncmFuIFZhcnRhbm92aWNoIFBldHJvc2lhblwiXScsXG4gICAqICAgICAnW0JsYWNrIFwiSGFucyBSZWVcIl0nLFxuICAgKiAgICAgJ1tFQ08gXCJBMjlcIl0nLFxuICAgKiAgICAgJycsXG4gICAqICAgICAnMS4gUGMyYzQgUGU3ZTUnLCAvLyBub24tc3RhbmRhcmRcbiAgICogICAgICcyLiBOYzMgTmY2JyxcbiAgICogICAgICczLiBOZjMgTmM2JyxcbiAgICogICAgICc0LiBnMmczIEJiNCcsIC8vIG5vbi1zdGFuZGFyZFxuICAgKiAgICAgJzUuIE5kNSBOeGQ1JyxcbiAgICogICAgICc2LiBjNHhkNSBlNS1lNCcsIC8vIG5vbi1zdGFuZGFyZFxuICAgKiAgICAgJzcuIGR4YzYgZXhmMycsXG4gICAqICAgICAnOC4gUWIzIDEtMCdcbiAgICogXS5qb2luKCd8JylcbiAgICpcbiAgICogY29uc3Qgb3B0aW9ucyA9IHtcbiAgICogICAgIG5ld2xpbmVfY2hhcjogJ1xcXFx8JywgLy8gTGl0ZXJhbCAnfCcgY2hhcmFjdGVyIGVzY2FwZWRcbiAgICogICAgIHNsb3BweTogdHJ1ZVxuICAgKiB9XG4gICAqXG4gICAqIGNoZXNzLmxvYWRQZ24oc2xvcHB5UGduKVxuICAgKiAvLyAtPiBmYWxzZVxuICAgKlxuICAgKiBjaGVzcy5sb2FkUGduKHNsb3BweVBnbiwgb3B0aW9ucylcbiAgICogLy8gLT4gdHJ1ZVxuICAgKlxuICAgKiBjaGVzcy5mZW4oKVxuICAgKiAvLyAtPiAncjFicWsyci9wcHBwMXBwcC8yUDUvOC8xYjYvMVEzcFAxL1BQMVBQUDFQL1IxQjFLQjFSIGIgS1FrcSAtIDEgOCdcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgbG9hZFBnbihcbiAgICBwZ246IHN0cmluZyxcbiAgICBvcHRpb25zOiB7IG5ld2xpbmVfY2hhcj86IHN0cmluZywgc2xvcHB5PzogYm9vbGVhbiB9ID0ge31cbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcmVzID0gbG9hZFBnbihwZ24sIG9wdGlvbnMpXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IFsgc3RhdGUsIGhlYWRlciwgY29tbWVudHMsIGhpc3RvcnkgXSA9IHJlc1xuICAgIHRoaXMuX3N0YXRlID0gc3RhdGVcbiAgICB0aGlzLl9oZWFkZXIgPSBoZWFkZXJcbiAgICB0aGlzLl9jb21tZW50cyA9IGNvbW1lbnRzXG4gICAgdGhpcy5faGlzdG9yeSA9IGhpc3RvcnlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgUEdOIGhlYWRlciBpbmZvcm1hdGlvbiBhcyBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNoZXNzLmhlYWRlcigpXG4gICAqIC8vIC0+IHsgV2hpdGU6ICdNb3JwaHknLCBCbGFjazogJ0FuZGVyc3NlbicsIERhdGU6ICcxODU4LT8/LT8/JyB9XG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIGhlYWRlcigpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBQR04gaGVhZGVyIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjaGVzcy5zZXRIZWFkZXIoe1xuICAgKiAgICdXaGl0ZSc6ICdSb2JlcnQgSmFtZXMgRmlzY2hlcicsXG4gICAqICAgJ0JsYWNrJzogJ01pa2hhaWwgVGFsJ1xuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBzZXRIZWFkZXIoaGVhZGVyOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XG4gICAgdGhpcy5faGVhZGVyID0gaGVhZGVyXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIFBHTiBoZWFkZXIgZW50cnlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY2hlc3MuYWRkSGVhZGVyKCdXaGl0ZScsICdSb2JlcnQgSmFtZXMgRmlzY2hlcicpXG4gICAqIGNoZXNzLmFkZEhlYWRlcignQmxhY2snLCAnTWlraGFpbCBUYWwnKVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBhZGRIZWFkZXIoa2V5OiBzdHJpbmcsIHZhbDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5faGVhZGVyW2tleV0gPSB2YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgUEdOIGhlYWRlciBlbnRyeVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjaGVzcy5yZW1vdmVIZWFkZXIoJ1doaXRlJylcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlSGVhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgZGVsZXRlIHRoaXMuX2hlYWRlcltrZXldXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgUEdOIGhlYWRlciBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY2hlc3Muc2V0SGVhZGVyKCdXaGl0ZScsICdSb2JlcnQgSmFtZXMgRmlzY2hlcicpXG4gICAqIGNoZXNzLnNldEhlYWRlcignQmxhY2snLCAnTWlraGFpbCBUYWwnKVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBjbGVhckhlYWRlcigpOiB2b2lkIHtcbiAgICB0aGlzLl9oZWFkZXIgPSB7fVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyBhbiBBU0NJSSBkaWFncmFtIG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygpXG4gICAqXG4gICAqIC8vIE1ha2Ugc29tZSBtb3Zlc1xuICAgKiBjaGVzcy5tb3ZlKCdlNCcpXG4gICAqIGNoZXNzLm1vdmUoJ2U1JylcbiAgICogY2hlc3MubW92ZSgnZjQnKVxuICAgKlxuICAgKiBjaGVzcy5hc2NpaSgpXG4gICAqIC8vIC0+ICcgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAvLyAgICAgIDggfCByICBuICBiICBxICBrICBiICBuICByIHxcbiAgICogLy8gICAgICA3IHwgcCAgcCAgcCAgcCAgLiAgcCAgcCAgcCB8XG4gICAqIC8vICAgICAgNiB8IC4gIC4gIC4gIC4gIC4gIC4gIC4gIC4gfFxuICAgKiAvLyAgICAgIDUgfCAuICAuICAuICAuICBwICAuICAuICAuIHxcbiAgICogLy8gICAgICA0IHwgLiAgLiAgLiAgLiAgUCAgUCAgLiAgLiB8XG4gICAqIC8vICAgICAgMyB8IC4gIC4gIC4gIC4gIC4gIC4gIC4gIC4gfFxuICAgKiAvLyAgICAgIDIgfCBQICBQICBQICBQICAuICAuICBQICBQIHxcbiAgICogLy8gICAgICAxIHwgUiAgTiAgQiAgUSAgSyAgQiAgTiAgUiB8XG4gICAqIC8vICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAvLyAgICAgICAgICBhICBiICBjICBkICBlICBmICBnICBoJ1xuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBhc2NpaShlb2wgPSAnXFxuJyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGFzY2lpKHRoaXMuX3N0YXRlLmJvYXJkLCBlb2wpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzaWRlIHRvIG1vdmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNoZXNzLmxvYWQoJ3JuYnFrYm5yL3BwcHBwcHBwLzgvOC80UDMvOC9QUFBQMVBQUC9STkJRS0JOUiBiIEtRa3EgZTMgMCAxJylcbiAgICogY2hlc3MudHVybigpXG4gICAqIC8vIC0+ICdiJ1xuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyB0dXJuKCk6IENvbG9yIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUudHVyblxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIG1ha2UgYSBtb3ZlIG9uIHRoZSBib2FyZCwgcmV0dXJuaW5nIGEgbW92ZSBvYmplY3QgaWYgdGhlIG1vdmUgd2FzXG4gICAqIGxlZ2FsLCBvdGhlcndpc2UgbnVsbC4gVGhlIC5tb3ZlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdHdvIHdheXMsIGJ5IHBhc3NpbmdcbiAgICogYSBzdHJpbmcgaW4gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygpXG4gICAqXG4gICAqIGNoZXNzLm1vdmUoJ2U0JylcbiAgICogLy8gLT4geyBjb2xvcjogJ3cnLCBmcm9tOiAnZTInLCB0bzogJ2U0JywgZmxhZ3M6ICdiJywgcGllY2U6ICdwJywgc2FuOiAnZTQnIH1cbiAgICpcbiAgICogY2hlc3MubW92ZSgnbmY2JykgLy8gU0FOIGlzIGNhc2Ugc2Vuc2l0aXZlISFcbiAgICogLy8gLT4gbnVsbFxuICAgKlxuICAgKiBjaGVzcy5tb3ZlKCdOZjYnKVxuICAgKiAvLyAtPiB7IGNvbG9yOiAnYicsIGZyb206ICdnOCcsIHRvOiAnZjYnLCBmbGFnczogJ24nLCBwaWVjZTogJ24nLCBzYW46ICdOZjYnIH1cbiAgICogYGBgXG4gICAqXG4gICAqXG4gICAqIE9yIGJ5IHBhc3NpbmcgLm1vdmUoKSBhIG1vdmUgb2JqZWN0IChvbmx5IHRoZSAndG8nLCAnZnJvbScsIGFuZCB3aGVuIG5lY2Vzc2FyeVxuICAgKiAncHJvbW90aW9uJywgZmllbGRzIGFyZSBuZWVkZWQpOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygpXG4gICAqXG4gICAqIGNoZXNzLm1vdmUoeyBmcm9tOiAnZzInLCB0bzogJ2czJyB9KVxuICAgKiAvLyAtPiB7IGNvbG9yOiAndycsIGZyb206ICdnMicsIHRvOiAnZzMnLCBmbGFnczogJ24nLCBwaWVjZTogJ3AnLCBzYW46ICdnMycgfVxuICAgKiBgYGBcbiAgICpcbiAgICogQW4gb3B0aW9uYWwgc2xvcHB5IGZsYWcgY2FuIGJlIHVzZWQgdG8gcGFyc2UgYSB2YXJpZXR5IG9mIG5vbi1zdGFuZGFyZCBtb3ZlXG4gICAqIG5vdGF0aW9uczpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3MoKVxuICAgKlxuICAgKiAvLyB2YXJpb3VzIGZvcm1zIG9mIExvbmcgQWxnZWJyYWljIE5vdGF0aW9uXG4gICAqIGNoZXNzLm1vdmUoJ2UyZTQnLCB7IHNsb3BweTogdHJ1ZSB9KVxuICAgKiAvLyAtPiB7IGNvbG9yOiAndycsIGZyb206ICdlMicsIHRvOiAnZTQnLCBmbGFnczogJ2InLCBwaWVjZTogJ3AnLCBzYW46ICdlNCcgfVxuICAgKiBjaGVzcy5tb3ZlKCdlNy1lNScsIHsgc2xvcHB5OiB0cnVlIH0pXG4gICAqIC8vIC0+IHsgY29sb3I6ICdiJywgZnJvbTogJ2U3JywgdG86ICdlNScsIGZsYWdzOiAnYicsIHBpZWNlOiAncCcsIHNhbjogJ2U1JyB9XG4gICAqIGNoZXNzLm1vdmUoJ1BmMmY0JywgeyBzbG9wcHk6IHRydWUgfSlcbiAgICogLy8gLT4geyBjb2xvcjogJ3cnLCBmcm9tOiAnZjInLCB0bzogJ2Y0JywgZmxhZ3M6ICdiJywgcGllY2U6ICdwJywgc2FuOiAnZjQnIH1cbiAgICogY2hlc3MubW92ZSgnUGU1eGY0JywgeyBzbG9wcHk6IHRydWUgfSlcbiAgICogLy8gLT4geyBjb2xvcjogJ2InLCBmcm9tOiAnZTUnLCB0bzogJ2Y0JywgZmxhZ3M6ICdjJywgcGllY2U6ICdwJywgY2FwdHVyZWQ6ICdwJywgc2FuOiAnZXhmNCcgfVxuICAgKlxuICAgKiAvLyBjb3JyZWN0bHkgcGFyc2VzIGluY29ycmVjdGx5IGRpc2FtYmlndWF0ZWQgbW92ZXNcbiAgICogY2hlc3MgPSBuZXcgQ2hlc3MoXG4gICAqICAgICAncjJxa2Juci9wcHAycHBwLzJuNS8xQjJwUTIvNFAzLzgvUFBQMlBQUC9STkIxSzJSIGIgS1FrcSAtIDMgNydcbiAgICogKVxuICAgKlxuICAgKiBjaGVzcy5tb3ZlKCdOZ2U3JykgLy8gTmU3IGlzIHVuYW1iaWd1b3VzIGJlY2F1c2UgdGhlIGtuaWdodCBvbiBjNiBpcyBwaW5uZWRcbiAgICogLy8gLT4gbnVsbFxuICAgKlxuICAgKiBjaGVzcy5tb3ZlKCdOZ2U3JywgeyBzbG9wcHk6IHRydWUgfSlcbiAgICogLy8gLT4geyBjb2xvcjogJ2InLCBmcm9tOiAnZzgnLCB0bzogJ2U3JywgZmxhZ3M6ICduJywgcGllY2U6ICduJywgc2FuOiAnTmU3JyB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gbW92ZSAtIENhc2Utc2Vuc2l0aXZlIFNBTiBzdHJpbmcgb3Igb2JqZWN0LCBlLmcuIGAnTnhiNydgIG9yXG4gICAqIGB7IGZyb206ICdoNycsIHRvOiAnaDgnLCBwcm9tb3Rpb246ICdxJyB9YFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gZW5hYmxlIHBhcnNpbmcgb2YgYSB2YXJpZXR5IG9mIG5vbi1zdGFuZGFyZFxuICAgKiBtb3ZlIG5vdGF0aW9uc1xuICAgKi9cbiAgcHVibGljIG1vdmUoXG4gICAgbW92ZTogc3RyaW5nIHwgUGFydGlhbE1vdmUsXG4gICAgb3B0aW9uczogeyBzbG9wcHk/OiBib29sZWFuLCBkcnlfcnVuPzogYm9vbGVhbiB9ID0ge31cbiAgKTogTW92ZSB8IG51bGwge1xuICAgIGNvbnN0IHZhbGlkTW92ZSA9IHZhbGlkYXRlTW92ZSh0aGlzLl9zdGF0ZSwgbW92ZSwgb3B0aW9ucylcblxuICAgIGlmICghdmFsaWRNb3ZlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBwcmV0dHkgbW92ZSBiZWZvcmUgdXBkYXRpbmcgdGhlIHN0YXRlXG4gICAgY29uc3QgcHJldHR5TW92ZSA9IG1ha2VQcmV0dHkodGhpcy5fc3RhdGUsIHZhbGlkTW92ZSlcbiAgICBpZiAoIW9wdGlvbnMuZHJ5X3J1bikge1xuICAgICAgdGhpcy5tYWtlTW92ZSh2YWxpZE1vdmUpXG4gICAgfVxuICAgIHJldHVybiBwcmV0dHlNb3ZlXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGEgc2VxdWVuY2Ugb2YgbW92ZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiBtb3ZlIG9iamVjdHMgaWYgdGhlXG4gICAqIG1vdmVzIGFyZSBhbGwgbGVnYWwsIG90aGVyd2lzZSBudWxsLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygpXG4gICAqXG4gICAqIGNoZXNzLnZhbGlkYXRlTW92ZXMoWydlNCcsICdOZjYnXSlcbiAgICogLy8gLT4gW3sgY29sb3I6ICd3JywgZnJvbTogJ2UyJywgdG86ICdlNCcsIGZsYWdzOiAnYicsIHBpZWNlOiAncCcsIHNhbjogJ2U0JyB9LFxuICAgKiAgICAgICAgeyBjb2xvcjogJ2InLCBmcm9tOiAnZzgnLCB0bzogJ2Y2JywgZmxhZ3M6ICduJywgcGllY2U6ICduJywgc2FuOiAnTmY2JyB9XVxuICAgKlxuICAgKiBjaGVzcy52YWxpZGF0ZU1vdmVzKFsnZTQsICduZjYnXSkgLy8gU0FOIGlzIGNhc2Ugc2Vuc2l0aXZlISFcbiAgICogLy8gLT4gbnVsbFxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIG1vdmVzIC0gQXJyYXkgb2YgY2FzZS1zZW5zaXRpdmUgU0FOIHN0cmluZ3Mgb3Igb2JqZWN0cywgZS5nLiBgJ054YjcnYCBvclxuICAgKiBgeyBmcm9tOiAnaDcnLCB0bzogJ2g4JywgcHJvbW90aW9uOiAncScgfWBcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGVuYWJsZSBwYXJzaW5nIG9mIGEgdmFyaWV0eSBvZiBub24tc3RhbmRhcmRcbiAgICogbW92ZSBub3RhdGlvbnNcbiAgICovXG4gIHB1YmxpYyB2YWxpZGF0ZU1vdmVzKFxuICAgIG1vdmVzOiBzdHJpbmdbXSB8IFBhcnRpYWxNb3ZlW10sXG4gICAgb3B0aW9uczogeyBzbG9wcHk/OiBib29sZWFuIH0gPSB7fVxuICApOiBNb3ZlW10gfCBudWxsIHtcbiAgICBjb25zdCB2YWxpZE1vdmVzOiBNb3ZlW10gPSBbXVxuICAgIGxldCBzdGF0ZSA9IHRoaXMuX3N0YXRlXG4gICAgZm9yIChjb25zdCBtb3ZlIG9mIG1vdmVzKSB7XG4gICAgICBjb25zdCB2YWxpZE1vdmUgPSB2YWxpZGF0ZU1vdmUoc3RhdGUsIG1vdmUsIG9wdGlvbnMpXG4gICAgICBpZiAoIXZhbGlkTW92ZSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgdmFsaWRNb3Zlcy5wdXNoKG1ha2VQcmV0dHkoc3RhdGUsIHZhbGlkTW92ZSkpXG4gICAgICBzdGF0ZSA9IG1ha2VNb3ZlKHN0YXRlLCB2YWxpZE1vdmUpXG4gICAgfVxuICAgIHJldHVybiB2YWxpZE1vdmVzXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgbW92ZSByZXN1bHRzIGluIGEgcHJvbW90aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygpXG4gICAqXG4gICAqIGNoZXNzLmlzUHJvbW90aW9uKCdlNCcpXG4gICAqIC8vIC0+IGZhbHNlXG4gICAqXG4gICAqIGNoZXNzLmxvYWQoJzgvMlAyazIvOC84LzgvNUsyLzgvOCB3IC0gLSAwIDEnKVxuICAgKiBjaGVzcy5pc1Byb21vdGlvbignYzgnKVxuICAgKiAvLyAtPiB0cnVlXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gbW92ZSAtIENhc2Utc2Vuc2l0aXZlIFNBTiBzdHJpbmcgb3Igb2JqZWN0LCBlLmcuIGAnTnhiNydgIG9yXG4gICAqIGB7IGZyb206ICdoNycsIHRvOiAnaDgnIH1gXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBlbmFibGUgcGFyc2luZyBvZiBhIHZhcmlldHkgb2Ygbm9uLXN0YW5kYXJkXG4gICAqIG1vdmUgbm90YXRpb25zXG4gICAqL1xuICBwdWJsaWMgaXNQcm9tb3Rpb24oXG4gICAgbW92ZTogc3RyaW5nIHwgUGFydGlhbE1vdmUsXG4gICAgb3B0aW9uczogeyBzbG9wcHk/OiBib29sZWFuIH0gPSB7fVxuICApOiBib29sZWFuIHtcbiAgICBjb25zdCB2YWxpZE1vdmUgPSB2YWxpZGF0ZU1vdmUodGhpcy5fc3RhdGUsIG1vdmUsIHsgLi4ub3B0aW9ucywgY2hlY2tQcm9tb3Rpb246IGZhbHNlIH0pXG5cbiAgICBpZiAoIXZhbGlkTW92ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuICEhKHZhbGlkTW92ZS5mbGFncyAmIEJJVFMuUFJPTU9USU9OKVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2ViYWNrIHRoZSBsYXN0IGhhbGYtbW92ZSwgcmV0dXJuaW5nIGEgbW92ZSBvYmplY3QgaWYgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKClcbiAgICpcbiAgICogY2hlc3MuZmVuKClcbiAgICogLy8gLT4gJ3JuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlIgdyBLUWtxIC0gMCAxJ1xuICAgKiBjaGVzcy5tb3ZlKCdlNCcpXG4gICAqIGNoZXNzLmZlbigpXG4gICAqIC8vIC0+ICdybmJxa2Juci9wcHBwcHBwcC84LzgvNFAzLzgvUFBQUDFQUFAvUk5CUUtCTlIgYiBLUWtxIGUzIDAgMSdcbiAgICpcbiAgICogY2hlc3MudW5kbygpXG4gICAqIC8vIC0+IHsgY29sb3I6ICd3JywgZnJvbTogJ2UyJywgdG86ICdlNCcsIGZsYWdzOiAnYicsIHBpZWNlOiAncCcsIHNhbjogJ2U0JyB9XG4gICAqIGNoZXNzLmZlbigpXG4gICAqIC8vIC0+ICdybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMSdcbiAgICogY2hlc3MudW5kbygpXG4gICAqIC8vIC0+IG51bGxcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgdW5kbygpOiBNb3ZlIHwgbnVsbCB7XG4gICAgY29uc3QgbW92ZSA9IHRoaXMudW5kb01vdmUoKVxuICAgIHJldHVybiBtb3ZlID8gbWFrZVByZXR0eSh0aGlzLl9zdGF0ZSwgbW92ZSkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29sb3Igb2YgdGhlIHNxdWFyZSAoJ2xpZ2h0JyBvciAnZGFyaycpLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IENoZXNzKClcbiAgICogY2hlc3Muc3F1YXJlQ29sb3IoJ2gxJylcbiAgICogLy8gLT4gJ2xpZ2h0J1xuICAgKiBjaGVzcy5zcXVhcmVDb2xvcignYTcnKVxuICAgKiAvLyAtPiAnZGFyaydcbiAgICogY2hlc3Muc3F1YXJlQ29sb3IoJ2JvZ3VzIHNxdWFyZScpXG4gICAqIC8vIC0+IG51bGxcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgc3F1YXJlQ29sb3Ioc3F1YXJlOiBzdHJpbmcpOiAnbGlnaHQnIHwgJ2RhcmsnIHwgbnVsbCB7XG4gICAgaWYgKGlzU3F1YXJlKHNxdWFyZSkpIHtcbiAgICAgIGNvbnN0IHNxXzB4ODggPSBTUVVBUkVTW3NxdWFyZV1cbiAgICAgIHJldHVybiAocmFuayhzcV8weDg4KSArIGZpbGUoc3FfMHg4OCkpICUgMiA9PT0gMCA/ICdsaWdodCcgOiAnZGFyaydcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgdGhlIG1vdmVzIG9mIHRoZSBjdXJyZW50IGdhbWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKClcbiAgICogY2hlc3MubW92ZSgnZTQnKVxuICAgKiBjaGVzcy5tb3ZlKCdlNScpXG4gICAqIGNoZXNzLm1vdmUoJ2Y0JylcbiAgICogY2hlc3MubW92ZSgnZXhmNCcpXG4gICAqXG4gICAqIGNoZXNzLmhpc3RvcnkoKVxuICAgKiAvLyAtPiBbJ2U0JywgJ2U1JywgJ2Y0JywgJ2V4ZjQnXVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBoaXN0b3J5KG9wdGlvbnM/OiB7IHZlcmJvc2U/OiBmYWxzZSB9KTogc3RyaW5nW11cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3QgY29udGFpbmluZyB0aGUgbW92ZXMgb2YgdGhlIGN1cnJlbnQgZ2FtZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3MoKVxuICAgKiBjaGVzcy5tb3ZlKCdlNCcpXG4gICAqIGNoZXNzLm1vdmUoJ2U1JylcbiAgICogY2hlc3MubW92ZSgnZjQnKVxuICAgKiBjaGVzcy5tb3ZlKCdleGY0JylcbiAgICpcbiAgICogY2hlc3MuaGlzdG9yeSh7IHZlcmJvc2U6IHRydWUgfSlcbiAgICogLy8gLT4gW3sgY29sb3I6ICd3JywgZnJvbTogJ2UyJywgdG86ICdlNCcsIGZsYWdzOiAnYicsIHBpZWNlOiAncCcsIHNhbjogJ2U0JyB9LFxuICAgKiAvLyAgICAgeyBjb2xvcjogJ2InLCBmcm9tOiAnZTcnLCB0bzogJ2U1JywgZmxhZ3M6ICdiJywgcGllY2U6ICdwJywgc2FuOiAnZTUnIH0sXG4gICAqIC8vICAgICB7IGNvbG9yOiAndycsIGZyb206ICdmMicsIHRvOiAnZjQnLCBmbGFnczogJ2InLCBwaWVjZTogJ3AnLCBzYW46ICdmNCcgfSxcbiAgICogLy8gICAgIHsgY29sb3I6ICdiJywgZnJvbTogJ2U1JywgdG86ICdmNCcsIGZsYWdzOiAnYycsIHBpZWNlOiAncCcsIGNhcHR1cmVkOiAncCcsIHNhbjogJ2V4ZjQnIH1dXG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIGhpc3Rvcnkob3B0aW9uczogeyB2ZXJib3NlOiB0cnVlIH0pOiBNb3ZlW11cblxuICBwdWJsaWMgaGlzdG9yeShvcHRpb25zOiB7IHZlcmJvc2U/OiBib29sZWFuIH0gPSB7fSk6IHN0cmluZ1tdIHwgTW92ZVtdIHtcbiAgICBjb25zdCB7IHZlcmJvc2UgPSBmYWxzZSB9ID0gb3B0aW9uc1xuXG4gICAgaWYgKCF0aGlzLl9oaXN0b3J5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgbGV0IHN0YXRlXG4gICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oaXN0b3J5Lm1hcCgoZ2FtZUhpc3RvcnkpID0+IHtcbiAgICAgICAgY29uc3QgbW92ZSA9IGdhbWVIaXN0b3J5Lm1vdmVcbiAgICAgICAgc3RhdGUgPSBnYW1lSGlzdG9yeS5zdGF0ZVxuICAgICAgICByZXR1cm4gbWFrZVByZXR0eShzdGF0ZSwgbW92ZSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9oaXN0b3J5Lm1hcCgoZ2FtZUhpc3RvcnkpID0+IHtcbiAgICAgIGNvbnN0IG1vdmUgPSBnYW1lSGlzdG9yeS5tb3ZlXG4gICAgICBzdGF0ZSA9IGdhbWVIaXN0b3J5LnN0YXRlXG4gICAgICByZXR1cm4gbW92ZVRvU2FuKHN0YXRlLCBtb3ZlKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGNvbW1lbnQgZm9yIGEgcG9zaXRpb24sIGlmIGl0IGV4aXN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3MoKVxuICAgKlxuICAgKiBjaGVzcy5sb2FkUGduKFwiMS4gZTQgZTUgMi4gTmYzIE5jNiAzLiBCYzQgQmM1IHtnaXVvY28gcGlhbm99ICpcIilcbiAgICpcbiAgICogY2hlc3MuZ2V0Q29tbWVudCgpXG4gICAqIC8vIC0+IFwiZ2l1b2NvIHBpYW5vXCJcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBmZW4gLSBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgKi9cbiAgcHVibGljIGdldENvbW1lbnQoZmVuPzogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBmZW4gPSBmZW4gfHwgdGhpcy5mZW4oKVxuICAgIHJldHVybiB0aGlzLl9jb21tZW50c1tmZW5dXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgY29tbWVudHMgZm9yIGFsbCBwb3NpdGlvbnMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKClcbiAgICpcbiAgICogY2hlc3MubG9hZFBnbihcIjEuIGU0IGU1IHtraW5nJ3MgcGF3biBvcGVuaW5nfSAyLiBOZjMgTmM2IDMuIEJjNCBCYzUge2dpdW9jbyBwaWFub30gKlwiKVxuICAgKlxuICAgKiBjaGVzcy5nZXRDb21tZW50cygpXG4gICAqIC8vIC0+IFtcbiAgICogLy8gICAgIHtcbiAgICogLy8gICAgICAgZmVuOiBcInJuYnFrYm5yL3BwcHAxcHBwLzgvNHAzLzRQMy84L1BQUFAxUFBQL1JOQlFLQk5SIHcgS1FrcSBlNiAwIDJcIixcbiAgICogLy8gICAgICAgY29tbWVudDogXCJraW5nJ3MgcGF3biBvcGVuaW5nXCJcbiAgICogLy8gICAgIH0sXG4gICAqIC8vICAgICB7XG4gICAqIC8vICAgICAgIGZlbjogXCJyMWJxa2Juci9wcHBwMXBwcC8ybjUvNHAzLzRQMy81TjIvUFBQUDFQUFAvUk5CUUtCMVIgdyBLUWtxIC0gMiAzXCIsXG4gICAqIC8vICAgICAgIGNvbW1lbnQ6IFwiZ2l1b2NvIHBpYW5vXCJcbiAgICogLy8gICAgIH1cbiAgICogLy8gICAgXVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBnZXRDb21tZW50cygpOiBGZW5Db21tZW50W10ge1xuICAgIHRoaXMucHJ1bmVDb21tZW50cygpXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NvbW1lbnRzKS5tYXAoKGZlbikgPT4ge1xuICAgICAgcmV0dXJuIHtmZW46IGZlbiwgY29tbWVudDogdGhpcy5fY29tbWVudHNbZmVuXX1cbiAgICB9KSBhcyBGZW5Db21tZW50W11cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21tZW50IG9uIGEgcG9zaXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGNoZXNzID0gbmV3IENoZXNzKClcbiAgICpcbiAgICogY2hlc3MubW92ZShcImU0XCIpXG4gICAqIGNoZXNzLnNldENvbW1lbnQoXCJraW5nJ3MgcGF3biBvcGVuaW5nXCIpXG4gICAqXG4gICAqIGNoZXNzLnBnbigpXG4gICAqIC8vIC0+IFwiMS4gZTQge2tpbmcncyBwYXduIG9wZW5pbmd9XCJcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjb21tZW50XG4gICAqIEBwYXJhbSBmZW4gLSBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgKi9cbiAgcHVibGljIHNldENvbW1lbnQoY29tbWVudDogc3RyaW5nLCBmZW4/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBmZW4gPSBmZW4gfHwgdGhpcy5mZW4oKVxuICAgIHRoaXMuX2NvbW1lbnRzW2Zlbl0gPSBjb21tZW50LnJlcGxhY2UoJ3snLCAnWycpLnJlcGxhY2UoJ30nLCAnXScpXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFuZCByZXR1cm4gdGhlIGNvbW1lbnQgZm9yIGEgcG9zaXRpb24sIGlmIGl0IGV4aXN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3MoKVxuICAgKlxuICAgKiBjaGVzcy5sb2FkUGduKFwiMS4gZTQgZTUgMi4gTmYzIE5jNiAzLiBCYzQgQmM1IHtnaXVvY28gcGlhbm99ICpcIilcbiAgICpcbiAgICogY2hlc3MuZ2V0Q29tbWVudCgpXG4gICAqIC8vIC0+IFwiZ2l1b2NvIHBpYW5vXCJcbiAgICpcbiAgICogY2hlc3MuZGVsZXRlQ29tbWVudHMoKVxuICAgKiAvLyAtPiBcImdpdW9jbyBwaWFub1wiXG4gICAqXG4gICAqIGNoZXNzLmdldENvbW1lbnQoKVxuICAgKiAvLyAtPiB1bmRlZmluZWRcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBmZW4gLSBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgKi9cbiAgcHVibGljIGRlbGV0ZUNvbW1lbnQoZmVuPzogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBmZW4gPSBmZW4gfHwgdGhpcy5mZW4oKVxuICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLl9jb21tZW50c1tmZW5dXG4gICAgZGVsZXRlIHRoaXMuX2NvbW1lbnRzW2Zlbl1cbiAgICByZXR1cm4gY29tbWVudFxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbmQgcmV0dXJuIGNvbW1lbnRzIGZvciBhbGwgcG9zaXRpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjaGVzcyA9IG5ldyBDaGVzcygpXG4gICAqXG4gICAqIGNoZXNzLmxvYWRQZ24oXCIxLiBlNCBlNSB7a2luZydzIHBhd24gb3BlbmluZ30gMi4gTmYzIE5jNiAzLiBCYzQgQmM1IHtnaXVvY28gcGlhbm99ICpcIilcbiAgICpcbiAgICogY2hlc3MuZGVsZXRlQ29tbWVudHMoKVxuICAgKiAvLyAtPiBbXG4gICAqIC8vICAgICB7XG4gICAqIC8vICAgICAgIGZlbjogXCJybmJxa2Juci9wcHBwMXBwcC84LzRwMy80UDMvOC9QUFBQMVBQUC9STkJRS0JOUiB3IEtRa3EgZTYgMCAyXCIsXG4gICAqIC8vICAgICAgIGNvbW1lbnQ6IFwia2luZydzIHBhd24gb3BlbmluZ1wiXG4gICAqIC8vICAgICB9LFxuICAgKiAvLyAgICAge1xuICAgKiAvLyAgICAgICBmZW46IFwicjFicWtibnIvcHBwcDFwcHAvMm41LzRwMy80UDMvNU4yL1BQUFAxUFBQL1JOQlFLQjFSIHcgS1FrcSAtIDIgM1wiLFxuICAgKiAvLyAgICAgICBjb21tZW50OiBcImdpdW9jbyBwaWFub1wiXG4gICAqIC8vICAgICB9XG4gICAqIC8vICAgIF1cbiAgICpcbiAgICogY2hlc3MuZ2V0Q29tbWVudHMoKVxuICAgKiAvLyAtPiBbXVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBkZWxldGVDb21tZW50cygpOiBGZW5Db21tZW50W10ge1xuICAgIHRoaXMucHJ1bmVDb21tZW50cygpXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NvbW1lbnRzKS5tYXAoKGZlbikgPT4ge1xuICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW2Zlbl1cbiAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1tmZW5dXG4gICAgICByZXR1cm4ge2ZlbjogZmVuLCBjb21tZW50OiBjb21tZW50fVxuICAgIH0pIGFzIEZlbkNvbW1lbnRbXVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWxpZGF0aW9uIG9iamVjdCBzcGVjaWZ5aW5nIHZhbGlkaXR5IG9yIHRoZSBlcnJvcnMgZm91bmRcbiAgICogd2l0aGluIHRoZSBGRU4gc3RyaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjaGVzcy52YWxpZGF0ZUZlbignMm4xcjMvcDFrMnBwMS9CMXAzYjEvUDcvNWJQMS8yTjFCMy8xUDJLUDIvMlI1IGIgLSAtIDQgMjUnKVxuICAgKiAvLyAtPiB7IHZhbGlkOiB0cnVlLCBlcnJvcl9udW1iZXI6IDAsIGVycm9yOiAnTm8gZXJyb3JzLicgfVxuICAgKlxuICAgKiBjaGVzcy52YWxpZGF0ZUZlbignNHIzLzgvWDEyWFBrLzFwNi9wUDJwMVIxL1AxQjUvMlAySzIvM3I0IHcgLSAtIDEgNDUnKVxuICAgKiAvLyAtPiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JfbnVtYmVyOiA5LFxuICAgKiAvLyAgICAgZXJyb3I6ICcxc3QgZmllbGQgKHBpZWNlIHBvc2l0aW9ucykgaXMgaW52YWxpZCBbaW52YWxpZCBwaWVjZV0uJyB9XG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIHZhbGlkYXRlRmVuKGZlbjogc3RyaW5nKTogVmFsaWRhdGlvbiB7XG4gICAgcmV0dXJuIHZhbGlkYXRlRmVuKGZlbilcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIGNsb25lKCk6IENoZXNzIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBDaGVzcygpXG4gICAgY2xvbmUuX3N0YXRlID0gdGhpcy5fc3RhdGVcbiAgICBjbG9uZS5faGlzdG9yeSA9IFsuLi50aGlzLl9oaXN0b3J5XVxuICAgIGNsb25lLl9oZWFkZXIgPSB7Li4udGhpcy5faGVhZGVyfVxuICAgIGNsb25lLl9jb21tZW50cyA9IHsuLi50aGlzLl9jb21tZW50c31cbiAgICByZXR1cm4gY2xvbmVcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIHBlcmZ0KGRlcHRoOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IG1vdmVzID0gZ2VuZXJhdGVNb3Zlcyh0aGlzLl9zdGF0ZSwgeyBsZWdhbDogZmFsc2UgfSlcbiAgICBsZXQgbm9kZXMgPSAwXG4gICAgY29uc3QgY29sb3IgPSB0aGlzLl9zdGF0ZS50dXJuXG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMubWFrZU1vdmUobW92ZXNbaV0pXG4gICAgICBpZiAoIXRoaXMua2luZ0F0dGFja2VkKGNvbG9yKSkge1xuICAgICAgICBpZiAoZGVwdGggLSAxID4gMCkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkX25vZGVzID0gdGhpcy5wZXJmdChkZXB0aCAtIDEpXG4gICAgICAgICAgbm9kZXMgKz0gY2hpbGRfbm9kZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlcysrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudW5kb01vdmUoKVxuICAgIH1cblxuICAgIHJldHVybiBub2Rlc1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBpbml0aWFsIGJvYXJkIHNldHVwIGlzIGNoYW5nZWQgd2l0aCBwdXQoKSBvciByZW1vdmUoKS5cbiAgICogbW9kaWZpZXMgdGhlIFNldFVwIGFuZCBGRU4gcHJvcGVydGllcyBvZiB0aGUgaGVhZGVyIG9iamVjdC4gIGlmIHRoZSBGRU4gaXNcbiAgICogZXF1YWwgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24sIHRoZSBTZXRVcCBhbmQgRkVOIGFyZSBkZWxldGVkXG4gICAqIHRoZSBzZXR1cCBpcyBvbmx5IHVwZGF0ZWQgaWYgaGlzdG9yeS5sZW5ndGggaXMgemVybywgaWUgbW92ZXMgaGF2ZW4ndCBiZWVuXG4gICAqIG1hZGUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIHVwZGF0ZVNldHVwKCk6IHZvaWQge1xuICAgIGNvbnN0IGZlbiA9IHRoaXMuX3N0YXRlLmZlblxuICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHJldHVyblxuXG4gICAgaWYgKGZlbiAhPT0gREVGQVVMVF9QT1NJVElPTikge1xuICAgICAgdGhpcy5faGVhZGVyWydTZXRVcCddID0gJzEnXG4gICAgICB0aGlzLl9oZWFkZXJbJ0ZFTiddID0gZmVuXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJbJ1NldFVwJ11cbiAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJbJ0ZFTiddXG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQgcHJ1bmVDb21tZW50cygpOiB2b2lkIHtcbiAgICBjb25zdCBjb21tZW50czogQ29tbWVudHMgPSB7fVxuXG4gICAgY29uc3QgY29weUNvbW1lbnRzID0gKGZlbjogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoZmVuIGluIHRoaXMuX2NvbW1lbnRzKSB7XG4gICAgICAgIGNvbW1lbnRzW2Zlbl0gPSB0aGlzLl9jb21tZW50c1tmZW5dXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faGlzdG9yeS5mb3JFYWNoKCh7IHN0YXRlOiBoaXN0b3J5U3RhdGUgfSkgPT4ge1xuICAgICAgc3RhdGUgPSBoaXN0b3J5U3RhdGVcbiAgICAgIGNvcHlDb21tZW50cyhzdGF0ZS5mZW4pXG4gICAgfSlcblxuICAgIGxldCBzdGF0ZSA9IHRoaXMuX3N0YXRlXG4gICAgY29weUNvbW1lbnRzKHN0YXRlLmZlbilcblxuICAgIHRoaXMuX2NvbW1lbnRzID0gY29tbWVudHNcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYWxsIG9mIHRoZSBkZWNvcmF0b3JzIG91dCBvZiBhIFNBTiBzdHJpbmdcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgc3RyaXBwZWRTYW4obW92ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbW92ZS5yZXBsYWNlKC89LywgJycpLnJlcGxhY2UoL1srI10/Wz8hXSokLywgJycpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBhdHRhY2tlZChjb2xvcjogc3RyaW5nLCBzcXVhcmU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0F0dGFja2VkKHRoaXMuX3N0YXRlLCBjb2xvciwgc3F1YXJlKVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcm90ZWN0ZWQga2luZ0F0dGFja2VkKGNvbG9yOiBDb2xvcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmF0dGFja2VkKHN3YXBDb2xvcihjb2xvciksIHRoaXMuX3N0YXRlLmtpbmdzW2NvbG9yXSlcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJvdGVjdGVkIG1ha2VNb3ZlKG1vdmU6IEhleE1vdmUpOiB2b2lkIHtcbiAgICB0aGlzLl9oaXN0b3J5LnB1c2goe1xuICAgICAgbW92ZTogbW92ZSxcbiAgICAgIHN0YXRlOiB0aGlzLl9zdGF0ZSxcbiAgICB9KVxuICAgIHRoaXMuX3N0YXRlID0gbWFrZU1vdmUodGhpcy5fc3RhdGUsIG1vdmUpXG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCB1bmRvTW92ZSgpOiBIZXhNb3ZlIHwgbnVsbCB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMuX2hpc3RvcnkucG9wKClcbiAgICBpZiAocHJldiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IHByZXYuc3RhdGVcbiAgICByZXR1cm4gcHJldi5tb3ZlXG4gIH1cbn1cbiIsImltcG9ydCB7UGllY2V9ZnJvbSAnLi9waWVjZSdcbmltcG9ydCB7U3F1YXJlfWZyb20gJy4vc3F1YXJlJ1xuaW1wb3J0IHtBbm5vdGF0aW9uc30gZnJvbSAgJy4vYW5ub3RhdGlvbnMnXG5pbXBvcnQgeyBDaGVzcyB9IGZyb20gJy4uL25vZGVfbW9kdWxlcy9jaGVzcy50cy9zcmMvY2hlc3MnXG5pbXBvcnQge3NxdWFyZU1hcCwgY2hlc3NDb2xvciwgUGllY2VUeXBlLCByZXNpemVGYWN0b3IsIElTcXVhcmUsIGdldFNxdWFyZUNvbG9yfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgQ2xpZW50LCBSb29tIH0gZnJvbSAnY29seXNldXMuanMnXG5cbmV4cG9ydCBjbGFzcyBCb2FyZHtcbiAgICBjYW52YXNfY29udGFpbmVyOiBVSUNvbnRhaW5lclN0YWNrXG4gICAgY2FudmFzOiBVSUNhbnZhc1xuICAgIHNxdWFyZXM6IHsgW2tleTogc3RyaW5nXTogU3F1YXJlIH0gLy9TcXVhcmVbXVxuICAgIHdoaXRlX3BpZWNlczpQaWVjZVtdID0gW11cbiAgICBibGFja19waWVjZXM6UGllY2VbXSA9IFtdXG4gICAgY2hlc3NnYW1lOiBDaGVzcyAgXG4gICAgYW5ub3RhdGlvbnNfY29udGFpbmVyOlVJQ29udGFpbmVyU3RhY2tcbiAgICBhbm5vdGF0aW9uczogQW5ub3RhdGlvbnMgICAgICBcbiAgICBwb3NzaWJsZU1vdmVzSW1hZ2VzOnsgW2tleTogc3RyaW5nXTogU3F1YXJlIH0gPSB7fVxuICAgIHJvb206Um9vbVxuICAgIHR1cm46IGJvb2xlYW5cblxuICAgIGNvbnN0cnVjdG9yKHJvb206IFJvb20pe1xuICAgICAgICB0aGlzLmNoZXNzZ2FtZSA9IG5ldyBDaGVzcygpXG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IFVJQ2FudmFzKClcbiAgICAgICAgdGhpcy5jYW52YXNfY29udGFpbmVyID0gbmV3IFVJQ29udGFpbmVyU3RhY2sodGhpcy5jYW52YXMpIC8vZGVjbGFyZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICB0aGlzLmFubm90YXRpb25zX2NvbnRhaW5lciA9IG5ldyBVSUNvbnRhaW5lclN0YWNrKHRoaXMuY2FudmFzKVxuICAgICAgICB0aGlzLmNvbmZpZ3VyZUNvbnRhaW5lcihcImNhbnZhc1wiKVxuICAgICAgICB0aGlzLmNvbmZpZ3VyZUNvbnRhaW5lcihcImFubm90YXRpb25zXCIpXG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBuZXcgQW5ub3RhdGlvbnModGhpcy5hbm5vdGF0aW9uc19jb250YWluZXIpXG4gICAgICAgIHRoaXMuc3F1YXJlcyA9IHRoaXMuZ2VuZXJhdGVCb2FyZCgpXG4gICAgICAgIHRoaXMud2hpdGVfcGllY2VzID0gdGhpcy5nZW5lcmF0ZVBpZWNlcyhjaGVzc0NvbG9yLldISVRFKVxuICAgICAgICB0aGlzLmJsYWNrX3BpZWNlcyA9IHRoaXMuZ2VuZXJhdGVQaWVjZXMoY2hlc3NDb2xvci5CTEFDSylcbiAgICAgICAgdGhpcy5zZXRBbGxWaXNpYmxlKClcbiAgICAgICAgdGhpcy5yb29tID0gcm9vbVxuICAgICAgICB0aGlzLnR1cm4gPSBmYWxzZVxuXG4gICAgICAgIC8vIHRoaXMuYW5ub3RhdGlvbnNfY29udGFpbmVyLlxuICAgIH1cblxuICAgIC8vc3VwcG9ydHMgbW9kZXMgXCJjYW52YXNcIiBhbmQgXCJhbm5vdGF0aW9uc1wiXG4gICAgY29uZmlndXJlQ29udGFpbmVyKGNvbnRhaW5lcl9uYW1lOnN0cmluZyl7XG4gICAgICAgIGlmIChjb250YWluZXJfbmFtZSA9PSBcImNhbnZhc1wiKXtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzX2NvbnRhaW5lci5hZGFwdFdpZHRoID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5jYW52YXNfY29udGFpbmVyLndpZHRoID0gXCI3MCVcIlxuICAgICAgICAgICAgdGhpcy5jYW52YXNfY29udGFpbmVyLmhlaWdodCA9IFwiMTAwJVwiXG4gICAgICAgICAgICB0aGlzLmNhbnZhc19jb250YWluZXIub3BhY2l0eSA9IDFcbiAgICAgICAgICAgIHRoaXMuY2FudmFzX2NvbnRhaW5lci5jb2xvciA9IENvbG9yNC5HcmF5KCkgLy9zZXQgYmFja2dyb3VuZC1jb2xvclxuICAgICAgICAgICAgdGhpcy5jYW52YXNfY29udGFpbmVyLnZpc2libGUgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSBpZihjb250YWluZXJfbmFtZSA9PSBcImFubm90YXRpb25zXCIpe1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uc19jb250YWluZXIuYWRhcHRXaWR0aCA9IHRydWVcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnNfY29udGFpbmVyLndpZHRoID0gXCIyNSVcIlxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uc19jb250YWluZXIuaGVpZ2h0ID0gXCI5MCVcIlxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uc19jb250YWluZXIub3BhY2l0eSA9IDFcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnNfY29udGFpbmVyLmNvbG9yID0gQ29sb3I0LldoaXRlKCkgLy9zZXQgYmFja2dyb3VuZC1jb2xvclxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uc19jb250YWluZXIudmlzaWJsZSA9IHRydWVcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnNfY29udGFpbmVyLnBvc2l0aW9uWCA9IHNxdWFyZU1hcFsnaDQnXS54UG9zaXRpb24gKyAyNjBcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnNfY29udGFpbmVyLnBvc2l0aW9uWSA9IHNxdWFyZU1hcFsnaDQnXS55UG9zaXRpb24gKyAzMFxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uc19jb250YWluZXIuYWRhcHRXaWR0aD0gZmFsc2UgXG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25zX2NvbnRhaW5lci5hZGFwdEhlaWdodCA9ZmFsc2UgLy8tPiBUT0RPOiBtYWtlIGl0IHNjcm9sbGFibGVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdlbmVyYXRlQm9hcmRGcm9tRmVuKGZlbjpzdHJpbmcpe1xuICAgIC8vICAgICB0aGlzLmNoZXNzZ2FtZS5sb2FkKGZlbilcbiAgICAvLyAgICAgbGV0IHJvd3MgPSBmZW4uc3BsaXQoXCIvXCIsIDgpXG4gICAgLy8gICAgIHJvd3MuZm9yRWFjaCgocm93LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgXG4gICAgLy8gICAgIH0pXG4gICAgLy8gfVxuXG4gICAgLy9maWxscyB0aGlzLnNxdWFyZXMgd2l0aCBTcXVhcmUgb2JqZWN0c1xuICAgIGdlbmVyYXRlQm9hcmQoKXtcbiAgICAgICAgY29uc3QgYm9hcmQ6IHsgW2tleTogc3RyaW5nXTogU3F1YXJlIH0gPSB7fTtcbiAgICAgICAgbGV0IHNxdWFyZTpzdHJpbmcgPSAnYTEnIFxuICAgICAgICBsZXQgYm9hcmRfYnVpbHQ6IGJvb2xlYW4gPSBmYWxzZVxuICAgICAgICBsZXQgY291bnRlcl94Om51bWJlciA9IDEsIGNvdW50ZXJfeTpudW1iZXIgPSAxXG4gICAgICAgIHdoaWxlICghYm9hcmRfYnVpbHQpe1xuICAgICAgICAgICAgc3F1YXJlID0gU3RyaW5nLmZyb21DaGFyQ29kZSg5NiArIGNvdW50ZXJfeCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDQ4ICsgY291bnRlcl95KTtcbiAgICAgICAgICAgIGJvYXJkW3NxdWFyZV0gPSBuZXcgU3F1YXJlIChzcXVhcmUsIHRoaXMuY2FudmFzKVxuICAgICAgICAgICAgaWYoY291bnRlcl94ID09IDggJiYgY291bnRlcl95ID09IDgpe1xuICAgICAgICAgICAgICAgIGJvYXJkX2J1aWx0ID0gdHJ1ZVxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIGVsc2UgaWYoY291bnRlcl95ID09IDgpe1xuICAgICAgICAgICAgICAgIGNvdW50ZXJfeSA9IDE7XG4gICAgICAgICAgICAgICAgY291bnRlcl94Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGNvdW50ZXJfeSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvYXJkXG4gICAgfVxuXG4gICAgLy9maWxzIHRoaXMud2hpdGVfcGllY2VzICYgdGhpcy5ibGFja19waWVjZXMgd2l0aCBQaWVjZXMgb2JqZWN0c1xuICAgIGdlbmVyYXRlUGllY2VzKGNvbG9yOiBjaGVzc0NvbG9yKTogUGllY2VbXXtcbiAgICAgICAgbGV0IHBpZWNlczogUGllY2VbXSA9IFtdIFxuXG4gICAgICAgIC8vUEFXTlNcbiAgICAgICAgZm9yIChsZXQgaTpudW1iZXI9OTc7IGk8PTEwNDsgaSsrKXsgLy9hc2NpaSBhLWhcbiAgICAgICAgICAgIGxldCBjb2x1bW46c3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKSwgcm93OnN0cmluZyA9IChjb2xvciA9PSBjaGVzc0NvbG9yLldISVRFKSA/ICcyJyA6ICc3J1xuICAgICAgICAgICAgbGV0IHNxdWFyZTpzdHJpbmcgPSBjb2x1bW4gKyByb3dcbiAgICAgICAgICAgIGxldCBwYXduOlBpZWNlID0gbmV3IFBpZWNlKGNvbG9yLCBQaWVjZVR5cGUuUEFXTiwgc3F1YXJlICwgdGhpcy5jYW52YXMpXG4gICAgICAgICAgICBwYXduLmltYWdlLm9uQ2xpY2sgPSBuZXcgT25Qb2ludGVyRG93bigoKT0+IHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5jaGVzc2dhbWUuZ2FtZU92ZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5UG9zaWJpbGl0aWVzKHBhd24pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBwaWVjZXMucHVzaChwYXduKVxuICAgICAgICB9IFxuXG4gICAgICAgIC8vS05JR0hUXG4gICAgICAgIGZvcihsZXQgaTpudW1iZXI9OTg7IGk8PTEwMzsgaT1pKzUpe1xuICAgICAgICAgICAgbGV0IGNvbHVtbjpzdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpLCByb3c6c3RyaW5nID0gKGNvbG9yID09IGNoZXNzQ29sb3IuV0hJVEUpID8gJzEnIDogJzgnXG4gICAgICAgICAgICBsZXQgc3F1YXJlOnN0cmluZyA9IGNvbHVtbiArIHJvd1xuICAgICAgICAgICAgbGV0IGtuaWdodDpQaWVjZSA9IG5ldyBQaWVjZShjb2xvciwgUGllY2VUeXBlLktOSUdIVCwgc3F1YXJlICwgdGhpcy5jYW52YXMpXG4gICAgICAgICAgICBrbmlnaHQuaW1hZ2Uub25DbGljayA9IG5ldyBPblBvaW50ZXJEb3duKCgpPT4ge1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmNoZXNzZ2FtZS5nYW1lT3ZlcigpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlQb3NpYmlsaXRpZXMoa25pZ2h0KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKGtuaWdodClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQklTSE9QU1xuICAgICAgICBmb3IobGV0IGk6bnVtYmVyPTk5OyBpPD0xMDI7IGk9aSszKXtcbiAgICAgICAgICAgIGxldCBjb2x1bW46c3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKSwgcm93OnN0cmluZyA9IChjb2xvciA9PSBjaGVzc0NvbG9yLldISVRFKSA/ICcxJyA6ICc4J1xuICAgICAgICAgICAgbGV0IHNxdWFyZTpzdHJpbmcgPSBjb2x1bW4gKyByb3dcbiAgICAgICAgICAgIGxldCBiaXNob3A6UGllY2UgPSBuZXcgUGllY2UoY29sb3IsIFBpZWNlVHlwZS5CSVNIT1AsIHNxdWFyZSAsIHRoaXMuY2FudmFzKVxuICAgICAgICAgICAgYmlzaG9wLmltYWdlLm9uQ2xpY2sgPSBuZXcgT25Qb2ludGVyRG93bigoKT0+IHtcbiAgICAgICAgICAgICAgICBpZighdGhpcy5jaGVzc2dhbWUuZ2FtZU92ZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5UG9zaWJpbGl0aWVzKGJpc2hvcClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwaWVjZXMucHVzaChiaXNob3ApXG4gICAgICAgIH1cblxuICAgICAgICAvL1JPT0tcbiAgICAgICAgZm9yKGxldCBpOm51bWJlcj05NzsgaTw9MTA0OyBpPWkrNyl7XG4gICAgICAgICAgICBsZXQgY29sdW1uOnN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSksIHJvdzpzdHJpbmcgPSAoY29sb3IgPT0gY2hlc3NDb2xvci5XSElURSkgPyAnMScgOiAnOCdcbiAgICAgICAgICAgIGxldCBzcXVhcmU6c3RyaW5nID0gY29sdW1uICsgcm93XG4gICAgICAgICAgICBsZXQgcm9vazpQaWVjZSA9IG5ldyBQaWVjZShjb2xvciwgUGllY2VUeXBlLlJPT0ssIHNxdWFyZSAsIHRoaXMuY2FudmFzKVxuICAgICAgICAgICAgcm9vay5pbWFnZS5vbkNsaWNrID0gbmV3IE9uUG9pbnRlckRvd24oKCk9PiB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuY2hlc3NnYW1lLmdhbWVPdmVyKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVBvc2liaWxpdGllcyhyb29rKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHJvb2spXG4gICAgICAgIH1cblxuICAgICAgICAvL1FVRUVOXG4gICAgICAgIGxldCBzcXVhcmU6c3RyaW5nID0gKGNvbG9yID09IGNoZXNzQ29sb3IuV0hJVEUpID8gJ2QxJyA6ICdkOCdcbiAgICAgICAgbGV0IHF1ZWVuOlBpZWNlID0gbmV3IFBpZWNlKGNvbG9yLCBQaWVjZVR5cGUuUVVFRU4sIHNxdWFyZSAsIHRoaXMuY2FudmFzKVxuICAgICAgICBxdWVlbi5pbWFnZS5vbkNsaWNrID0gbmV3IE9uUG9pbnRlckRvd24oKCk9PiB7XG4gICAgICAgICAgICBpZighdGhpcy5jaGVzc2dhbWUuZ2FtZU92ZXIoKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlQb3NpYmlsaXRpZXMocXVlZW4pXG4gICAgICAgIH0pXG4gICAgICAgIHBpZWNlcy5wdXNoKHF1ZWVuKVxuXG4gICAgICAgIC8vS0lOR1xuICAgICAgICBzcXVhcmUgPSAoY29sb3IgPT0gY2hlc3NDb2xvci5XSElURSkgPyAnZTEnIDogJ2U4J1xuICAgICAgICBsZXQga2luZzpQaWVjZSA9IG5ldyBQaWVjZShjb2xvciwgUGllY2VUeXBlLktJTkcsIHNxdWFyZSAsIHRoaXMuY2FudmFzKVxuICAgICAgICBraW5nLmltYWdlLm9uQ2xpY2sgPSBuZXcgT25Qb2ludGVyRG93bigoKT0+IHtcbiAgICAgICAgICAgIGlmKCF0aGlzLmNoZXNzZ2FtZS5nYW1lT3ZlcigpKVxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVBvc2liaWxpdGllcyhraW5nKVxuICAgICAgICB9KVxuICAgICAgICBwaWVjZXMucHVzaChraW5nKVxuXG4gICAgICAgIHJldHVybiBwaWVjZXNcbiAgICAgICAgXG4gICAgfVxuXG5cbiAgICAvL3NldHMgYWxsIGVsZW1lbnRzIHZpc2libGVcbiAgICBzZXRBbGxWaXNpYmxlKCl7XG4gICAgICAgIHRoaXMuY2FudmFzX2NvbnRhaW5lci52aXNpYmxlID0gdHJ1ZVxuICAgICAgICB0aGlzLmNhbnZhcy52aXNpYmxlID0gdHJ1ZVxuICAgICAgICB0aGlzLndoaXRlX3BpZWNlcy5mb3JFYWNoKCh3aGl0ZV9waWVjZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHdoaXRlX3BpZWNlLnNldFZpc2liaWxpdHkodHJ1ZSlcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmJsYWNrX3BpZWNlcy5mb3JFYWNoKChibGFja19waWVjZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGJsYWNrX3BpZWNlLnNldFZpc2liaWxpdHkodHJ1ZSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvL21vdmVzIGEgcGllY2UgdG8gYSBzcXVhcmVcbiAgICBtb3ZlUGllY2UocGllY2U6IFBpZWNlLCBtb3ZlbWVudDogc3RyaW5nKXtcbiAgICAgICAgaWYodGhpcy50dXJuID09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlc3NnYW1lLm1vdmUobW92ZW1lbnQpIC8vbWFrZSBtb3ZlIGluIGNoZXNzZ2FtZVxuICAgICAgICAgICAgdGhpcy5yZXNldFBvc3NpYmxlTW92ZXMoKVxuICAgICAgICAgICAgbG9nKFwiZG9zIGNvcHM/XCIpXG4gICAgICAgICAgICBsZXQgY29sb3I6c3RyaW5nID0gcGllY2UuZ2V0Q29sb3IoKSBcbiAgICAgICAgICAgIGxvZyhcImFxdWkgbm8gYXJyaWJhIHNhc1wiKVxuICAgICAgICAgICAgaWYobW92ZW1lbnQgPT0gXCJPLU9cIil7XG4gICAgICAgICAgICAgICAgcGllY2UubW92ZVBpZWNlKGNvbG9yPT1cIndoaXRlXCIgPyAnZzEnIDogJ2c4JylcbiAgICAgICAgICAgICAgICBsZXQgcm9vazpQaWVjZSA9IHRoaXMuZ2V0UGllY2UoY29sb3I9PSd3aGl0ZScgPyAnaDEnIDogJ2g4JylcbiAgICAgICAgICAgICAgICByb29rLm1vdmVQaWVjZShjb2xvcj09XCJ3aGl0ZVwiID8gJ2YxJyA6ICdmOCcpXG4gICAgICAgICAgICAgICAgcm9vay5pbWFnZS5vbkNsaWNrID0gcGllY2UuaW1hZ2Uub25DbGljayA9IG5ldyBPblBvaW50ZXJEb3duKCgpPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlQb3NpYmlsaXRpZXMocm9vaylcbiAgICAgICAgICAgICAgICB9KSAgICAgICAgXG4gICAgICAgICAgICB9ICBcblxuICAgICAgICAgICAgZWxzZSBpZihtb3ZlbWVudCA9PSBcIk8tTy1PXCIpe1xuICAgICAgICAgICAgICAgIHBpZWNlLm1vdmVQaWVjZShjb2xvcj09XCJ3aGl0ZVwiID8gJ2MxJyA6ICdjOCcpXG4gICAgICAgICAgICAgICAgbGV0IHJvb2s6UGllY2UgPSB0aGlzLmdldFBpZWNlKGNvbG9yPT0nd2hpdGUnID8gJ2ExJyA6ICdhOCcpXG4gICAgICAgICAgICAgICAgcm9vay5tb3ZlUGllY2UoY29sb3I9PVwid2hpdGVcIiA/ICdkMScgOiAnZDgnKVxuICAgICAgICAgICAgICAgIHJvb2suaW1hZ2Uub25DbGljayA9IHBpZWNlLmltYWdlLm9uQ2xpY2sgPSBuZXcgT25Qb2ludGVyRG93bigoKT0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5UG9zaWJpbGl0aWVzKHJvb2spXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgLy9Ob3JtYWwgbW92ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBpZWNlLm1vdmVQaWVjZShtb3ZlbWVudC5zdWJzdHIobW92ZW1lbnQubGVuZ3RoLTIpKSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGllY2UuaW1hZ2Uub25DbGljayA9IHBpZWNlLmltYWdlLm9uQ2xpY2sgPW5ldyBPblBvaW50ZXJEb3duKCgpPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVBvc2liaWxpdGllcyhwaWVjZSlcbiAgICAgICAgICAgIH0pOyBcblxuICAgICAgICAgICAgLy90aGlzLnJvb20uc2VuZChcIm1vdmVyRmljaGFcIiwge21vdmU6IG1vdmVtZW50LCBwaWU6IHBpZWNlfSlcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMuYWRkTW92ZShtb3ZlbWVudCwgcGllY2UuZ2V0Q29sb3IoKSwgdGhpcy5jaGVzc2dhbWUuZmVuKCkpXG4gICAgICAgICAgICB0aGlzLnR1cm4gPSBmYWxzZSAvL3Bvc28gZWwgdG9ybiB1biBhbHRyZSBjb3AgYSBmYWxzIGZpbnMgcXVlIGxhIHNlbnlhbCBlbSBkaWd1aSBlbCBjb250cmFyaVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9nZXRzIHBpZWNlIG9uIGEgc3F1YXJlXG4gICAgZ2V0UGllY2UocG9zaXRpb246c3RyaW5nKTpQaWVjZXtcbiAgICAgICAgLy8gbGV0IHBpZWNlOiBQaWVjZSA9IG5ldyBQaWVjZShjaGVzc0NvbG9yLldISVRFLCBQaWVjZVR5cGUuUEFXTiwgXCJhMVwiLCB0aGlzLmNhbnZhcylcbiAgICAgICAgZm9yKGxldCBpOm51bWJlciA9IDA7IGkgPCB0aGlzLndoaXRlX3BpZWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZih0aGlzLndoaXRlX3BpZWNlc1tpXS5wb3NpdGlvbiA9PSBwb3NpdGlvbil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hpdGVfcGllY2VzW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGxldCBpOm51bWJlciA9IDA7IGkgPCB0aGlzLmJsYWNrX3BpZWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZih0aGlzLmJsYWNrX3BpZWNlc1tpXS5wb3NpdGlvbiA9PSBwb3NpdGlvbil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxhY2tfcGllY2VzW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gICAgICAgIFxuXG4gICAgICAgIGxldCBwaWVjZTogUGllY2UgPSBuZXcgUGllY2UoY2hlc3NDb2xvci5XSElURSwgUGllY2VUeXBlLlBBV04sIFwiYTFcIiwgdGhpcy5jYW52YXMpXG4gICAgICAgIHBpZWNlLnNldFZpc2liaWxpdHkoZmFsc2UpXG4gICAgICAgIHJldHVybiBwaWVjZTtcbiAgICB9ICBcblxuICAgIC8vc2V0cyBib2FyZCBhdHRyaWJ1dGUgcG9zc2libGVNb3Zlc0ltYWdlcyB3aXRoIGEgbGlzdCBvZiBTcXVhcmUgdmFyaWFibGVzLiBFYWNoIG9uZSBvZiB0aGVzZSB2YXJpYWJsZXMgcG9pbnRzIHRvIGEgc3F1YXJlIFxuICAgIC8vb24gdGhlIGJvYXJkIHdob3NlIGltYWdlIHdpbGwgaGF2ZSBjaGFuZ2VkIHRvIGEgc2VsZWN0b3IgaW1hZ2VcbiAgICBkaXNwbGF5UG9zaWJpbGl0aWVzKHBpZWNlOiBQaWVjZSl7XG4gICAgICAgIHRoaXMucmVzZXRQb3NzaWJsZU1vdmVzKClcbiAgICAgICAgdGhpcy5yZXNldFBpZWNlRXZlbnRzKClcbiAgICAgICAgbGV0IHNxdWFyZTpzdHJpbmcgPSBwaWVjZS5wb3NpdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9waWVjZSBwb3NpdGlvblxuICAgICAgICBsZXQgbW92ZXM6c3RyaW5nW10gPSB0aGlzLmNoZXNzZ2FtZS5tb3Zlcyh7c3F1YXJlOiBzcXVhcmV9KSAvL3Bvc3NpYmxlIG1vdmVzIGZvciBwaWVjZVxuICAgICAgICAvLyBwaWVjZS5zZXRQb3NzaWJsZU1vdmVzKG1vdmVzKSBcbiAgICAgICAgbW92ZXMuZm9yRWFjaCgobW92ZSkgPT57XG4gICAgICAgICAgICBtb3ZlID0gbW92ZS5yZXBsYWNlKCcjJywnJylcbiAgICAgICAgICAgIG1vdmUgPSBtb3ZlLnJlcGxhY2UoJysnLCcnKVxuICAgICAgICAgICAgbG9nKG1vdmUpXG4gICAgICAgICAgICAvL3Nob3J0IGNhc3RsaW5nXG4gICAgICAgICAgICBpZihtb3ZlID09IFwiTy1PXCIpe1xuICAgICAgICAgICAgICAgIGxldCBzcXVhcmVfcG9zaXRpb246c3RyaW5nID0gcGllY2UuZ2V0Q29sb3IoKSA9PSBcIndoaXRlXCIgPyAnZzEnIDogJ2c4J1xuICAgICAgICAgICAgICAgIGxldCBzcXVhcmU6U3F1YXJlID0gbmV3IFNxdWFyZShzcXVhcmVfcG9zaXRpb24sIHRoaXMuY2FudmFzLCBcImltYWdlcy9jaGVzc2JvYXJkL21vdmUtXCIgKyBnZXRTcXVhcmVDb2xvcihzcXVhcmVfcG9zaXRpb24pICsgXCItc3F1YXJlLnBuZ1wiKVxuICAgICAgICAgICAgICAgIHNxdWFyZS5pbWFnZS5vbkNsaWNrID0gbmV3IE9uUG9pbnRlckRvd24oKCk9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vbS5zZW5kKFwibW92ZXJGaWNoYVwiLCB7bW92ZTogXCJPLU9cIiwgb3JpZ2luYWxfcG9zaXRpb246IHBpZWNlLnBvc2l0aW9ufSkgLy9jdWFuZG8gc2UgcmVhbGl6YSB1biBtb3ZpbWllbnRvIHNlIG1hbmRhIHVuYSBzZcOxYWwgYSBsYSByb29tIHBhcmEgcXVlIGVsIHNlcnZpZG9yIHNlIGxvIGhhZ2Egc2FiZXIgYSBsb3MgZGVtw6FzIGp1Z2Fkb3Jlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVQaWVjZShwaWVjZSwgJ08tTycpXG5cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHRoaXMucG9zc2libGVNb3Zlc0ltYWdlc1tzcXVhcmVfcG9zaXRpb25dID0gdGhpcy5zcXVhcmVzW3NxdWFyZV9wb3NpdGlvbl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vbG9uZyBjYXN0bGluZ1xuICAgICAgICAgICAgZWxzZSBpZihtb3ZlID09IFwiTy1PLU9cIil7XG4gICAgICAgICAgICAgICAgbGV0IHNxdWFyZV9wb3NpdGlvbjpzdHJpbmcgPSBwaWVjZS5nZXRDb2xvcigpID09IFwid2hpdGVcIiA/ICdjMScgOiAnYzgnXG4gICAgICAgICAgICAgICAgbGV0IHNxdWFyZTpTcXVhcmUgPSBuZXcgU3F1YXJlKHNxdWFyZV9wb3NpdGlvbiwgdGhpcy5jYW52YXMsIFwiaW1hZ2VzL2NoZXNzYm9hcmQvbW92ZS1cIiArIGdldFNxdWFyZUNvbG9yKHNxdWFyZV9wb3NpdGlvbikgKyBcIi1zcXVhcmUucG5nXCIpXG4gICAgICAgICAgICAgICAgc3F1YXJlLmltYWdlLm9uQ2xpY2sgPSBuZXcgT25Qb2ludGVyRG93bigoKT0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb29tLnNlbmQoXCJtb3ZlckZpY2hhXCIsIHttb3ZlOiBcIk8tTy1PXCIsIG9yaWdpbmFsX3Bvc2l0aW9uOiBwaWVjZS5wb3NpdGlvbn0pIC8vY3VhbmRvIHNlIHJlYWxpemEgdW4gbW92aW1pZW50byBzZSBtYW5kYSB1bmEgc2XDsWFsIGEgbGEgcm9vbSBwYXJhIHF1ZSBlbCBzZXJ2aWRvciBzZSBsbyBoYWdhIHNhYmVyIGEgbG9zIGRlbcOhcyBqdWdhZG9yZXNcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVBpZWNlKHBpZWNlLCAnTy1PLU8nKVxuXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3NpYmxlTW92ZXNJbWFnZXNbc3F1YXJlX3Bvc2l0aW9uXSA9IHRoaXMuc3F1YXJlc1tzcXVhcmVfcG9zaXRpb25dXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NhcHR1cmUgbW92ZVxuICAgICAgICAgICAgZWxzZSBpZiAobW92ZS5pbmRleE9mKFwieFwiKSAhPSAgLTEpe1xuICAgICAgICAgICAgICAgIGxldCBzcXVhcmVfdG9fbW92ZTpzdHJpbmcgPSBtb3ZlLnN1YnN0cihtb3ZlLmxlbmd0aC0yKVxuICAgICAgICAgICAgICAgIGxldCBwaWVjZV9vbl9zcXVhcmU6IFBpZWNlID0gdGhpcy5nZXRQaWVjZShzcXVhcmVfdG9fbW92ZSkgXG4gICAgICAgICAgICAgICAgaWYocGllY2Vfb25fc3F1YXJlLmltYWdlLnZpc2libGUgPT0gdHJ1ZSl7ICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBlbmVteSBwaWVjZSBvbiB0aGF0IHNxdWFyZVxuICAgICAgICAgICAgICAgICAgICBwaWVjZV9vbl9zcXVhcmUuaW1hZ2Uub25DbGljayA9IG5ldyBPblBvaW50ZXJEb3duKCgpPT4geyAgICAvL2NyZWF0ZSBhbiBldmVudCBvbiB0aGUgcGllY2Ugb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5jaGVzc2dhbWUuZ2FtZU92ZXIoKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGllY2Vfb25fc3F1YXJlLmltYWdlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWVjZV9vbl9zcXVhcmUuZ2V0Q29sb3IoKSA9PSBcIndoaXRlXCIgPyB0aGlzLndoaXRlX3BpZWNlcy5zcGxpY2UodGhpcy53aGl0ZV9waWVjZXMuaW5kZXhPZihwaWVjZV9vbl9zcXVhcmUpLCAxKSA6IHRoaXMuYmxhY2tfcGllY2VzLnNwbGljZSh0aGlzLmJsYWNrX3BpZWNlcy5pbmRleE9mKHBpZWNlX29uX3NxdWFyZSksIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb29tLnNlbmQoXCJtb3ZlckZpY2hhXCIsIHttb3ZlOiBtb3ZlLCBvcmlnaW5hbF9wb3NpdGlvbjogcGllY2UucG9zaXRpb259KSAvL2N1YW5kbyBzZSByZWFsaXphIHVuIG1vdmltaWVudG8gc2UgbWFuZGEgdW5hIHNlw7FhbCBhIGxhIHJvb20gcGFyYSBxdWUgZWwgc2Vydmlkb3Igc2UgbG8gaGFnYSBzYWJlciBhIGxvcyBkZW3DoXMganVnYWRvcmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlUGllY2UocGllY2UsIG1vdmUpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwaWVjZS5nZXRQaWVjZSgpID09IFBpZWNlVHlwZS5QQVdOKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNxdWFyZV9wb3NpdGlvbjpzdHJpbmcgPSBcIlwiXG4gICAgICAgICAgICAgICAgICAgIGlmKHBpZWNlLmNvbG9yID09IFwid2hpdGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxdWFyZV9wb3NpdGlvbiA9IHNxdWFyZV90b19tb3ZlWzBdICsgU3RyaW5nLmZyb21DaGFyQ29kZShzcXVhcmVfdG9fbW92ZS5jaGFyQ29kZUF0KDEpLTEpXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXVhcmVfcG9zaXRpb24gPSBzcXVhcmVfdG9fbW92ZVswXSArIFN0cmluZy5mcm9tQ2hhckNvZGUoc3F1YXJlX3RvX21vdmUuY2hhckNvZGVBdCgxKSsxKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhd25fdG9fdGFrZSA9IHRoaXMuZ2V0UGllY2Uoc3F1YXJlX3Bvc2l0aW9uKVxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmdldFBpZWNlKHNxdWFyZV9wb3NpdGlvbikucGllY2UgPT0gXCJwYXduXCIgJiYgcGF3bl90b190YWtlLmltYWdlLnZpc2libGUgJiYgcGF3bl90b190YWtlLmNvbG9yICE9IHBpZWNlLmNvbG9yKXsgICAvL2NvbWVyIGFsIHBhc28/XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3F1YXJlID0gbmV3IFNxdWFyZShtb3ZlLnN1YnN0cihtb3ZlLmxlbmd0aC0yKSwgdGhpcy5jYW52YXMsIFwiaW1hZ2VzL2NoZXNzYm9hcmQvbW92ZS1cIiArIGdldFNxdWFyZUNvbG9yKG1vdmUuc3Vic3RyKG1vdmUubGVuZ3RoLTIpKSArIFwiLXNxdWFyZS5wbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxdWFyZS5pbWFnZS5vbkNsaWNrID0gbmV3IE9uUG9pbnRlckRvd24oKCk9PiB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIGFuIGV2ZW50IG9uIHRoZSBzcXVhcmUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuY2hlc3NnYW1lLmdhbWVPdmVyKCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb20uc2VuZChcIm1vdmVyRmljaGFcIiwge21vdmU6IG1vdmUsIG9yaWdpbmFsX3Bvc2l0aW9uOiBwaWVjZS5wb3NpdGlvbn0pIC8vY3VhbmRvIHNlIHJlYWxpemEgdW4gbW92aW1pZW50byBzZSBtYW5kYSB1bmEgc2XDsWFsIGEgbGEgcm9vbSBwYXJhIHF1ZSBlbCBzZXJ2aWRvciBzZSBsbyBoYWdhIHNhYmVyIGEgbG9zIGRlbcOhcyBqdWdhZG9yZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVBpZWNlKHBpZWNlLCBtb3ZlKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhd25fdG9fdGFrZS5pbWFnZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhd25fdG9fdGFrZS5nZXRDb2xvcigpID09IFwid2hpdGVcIiA/IHRoaXMud2hpdGVfcGllY2VzLnNwbGljZSh0aGlzLndoaXRlX3BpZWNlcy5pbmRleE9mKHBhd25fdG9fdGFrZSksIDEpIDogdGhpcy5ibGFja19waWVjZXMuc3BsaWNlKHRoaXMuYmxhY2tfcGllY2VzLmluZGV4T2YocGF3bl90b190YWtlKSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcXVhcmVzW21vdmUuc3Vic3RyKG1vdmUubGVuZ3RoLTIpXSA9IHNxdWFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NzaWJsZU1vdmVzSW1hZ2VzW21vdmUuc3Vic3RyKG1vdmUubGVuZ3RoLTIpXSA9IHRoaXMuc3F1YXJlc1ttb3ZlLnN1YnN0cihtb3ZlLmxlbmd0aC0yKV1cbiAgICAgICAgICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9wcm9tb3Rpb25cbiAgICAgICAgICAgIC8vIGVsc2UgaWYgKG1vdmUuaW5kZXhPZihcIj1cIikgIT0gIC0xKXtcbiAgICAgICAgICAgIC8vICAgICBsZXQgc3F1YXJlX3RvX21vdmU6c3RyaW5nID0gbW92ZS5zdWJzdHIobW92ZS5sZW5ndGgtMilcbiAgICAgICAgICAgIC8vICAgICBsZXQgcGllY2Vfb25fc3F1YXJlOiBQaWVjZSA9IHRoaXMuZ2V0UGllY2Uoc3F1YXJlX3RvX21vdmUpIFxuICAgICAgICAgICAgLy8gICAgIGlmKHBpZWNlX29uX3NxdWFyZS5pbWFnZS52aXNpYmxlID09IHRydWUpeyAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgZW5lbXkgcGllY2Ugb24gdGhhdCBzcXVhcmVcbiAgICAgICAgICAgIC8vICAgICAgICAgcGllY2Vfb25fc3F1YXJlLmltYWdlLm9uQ2xpY2sgPSBuZXcgT25Qb2ludGVyRG93bigoKT0+IHsgICAgLy9jcmVhdGUgYW4gZXZlbnQgb24gdGhlIHBpZWNlIG9iamVjdFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgcGllY2Vfb25fc3F1YXJlLmltYWdlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHBpZWNlX29uX3NxdWFyZS5nZXRDb2xvcigpID09IFwid2hpdGVcIiA/IHRoaXMud2hpdGVfcGllY2VzLnNwbGljZSh0aGlzLndoaXRlX3BpZWNlcy5pbmRleE9mKHBpZWNlX29uX3NxdWFyZSksIDEpIDogdGhpcy5ibGFja19waWVjZXMuc3BsaWNlKHRoaXMuYmxhY2tfcGllY2VzLmluZGV4T2YocGllY2Vfb25fc3F1YXJlKSwgMSlcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHRoaXMubW92ZVBpZWNlKHBpZWNlLCBtb3ZlKVxuICAgICAgICAgICAgLy8gICAgICAgICB9KVxuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBsZXQgc3F1YXJlID0gbmV3IFNxdWFyZShtb3ZlLnN1YnN0cihtb3ZlLmxlbmd0aC0yKSwgdGhpcy5jYW52YXMsIFwiaW1hZ2VzL2NoZXNzYm9hcmQvbW92ZS1cIiArIGdldFNxdWFyZUNvbG9yKG1vdmUuc3Vic3RyKG1vdmUubGVuZ3RoLTIpKSArIFwiLXNxdWFyZS5wbmdcIilcbiAgICAgICAgICAgICAgICBzcXVhcmUuaW1hZ2Uub25DbGljayA9IG5ldyBPblBvaW50ZXJEb3duKCgpPT4geyAgICAgICAgICAgICAgLy9jcmVhdGUgYW4gZXZlbnQgb24gdGhlIHNxdWFyZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb29tLnNlbmQoXCJtb3ZlckZpY2hhXCIsIHttb3ZlOiBtb3ZlLCBvcmlnaW5hbF9wb3NpdGlvbjogcGllY2UucG9zaXRpb259KSAvL2N1YW5kbyBzZSByZWFsaXphIHVuIG1vdmltaWVudG8gc2UgbWFuZGEgdW5hIHNlw7FhbCBhIGxhIHJvb20gcGFyYSBxdWUgZWwgc2Vydmlkb3Igc2UgbG8gaGFnYSBzYWJlciBhIGxvcyBkZW3DoXMganVnYWRvcmVzXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVQaWVjZShwaWVjZSwgbW92ZSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHRoaXMuc3F1YXJlc1ttb3ZlLnN1YnN0cihtb3ZlLmxlbmd0aC0yKV0gPSBzcXVhcmVcbiAgICAgICAgICAgICAgICB0aGlzLnBvc3NpYmxlTW92ZXNJbWFnZXNbbW92ZS5zdWJzdHIobW92ZS5sZW5ndGgtMildID0gdGhpcy5zcXVhcmVzW21vdmUuc3Vic3RyKG1vdmUubGVuZ3RoLTIpXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSAgICBcbiAgICB9XG5cbiAgICAvL3Jlc2V0cyBib2FyZCBhdHRyaWJ1dGUgcG9zc2libGVNb3Zlc0ltYWdlcyBhbmQgc2V0cyBhbGwgc3F1YXJlcyB0byB0aGVpciBvcmlnaW5hbCBpbWFnZVxuICAgIHJlc2V0UG9zc2libGVNb3Zlcygpe1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnBvc3NpYmxlTW92ZXNJbWFnZXMpLmZvckVhY2goKHNxdWFyZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zcXVhcmVzW3NxdWFyZV0gPSBuZXcgU3F1YXJlKHNxdWFyZSwgdGhpcy5jYW52YXMpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMucG9zc2libGVNb3Zlc0ltYWdlcyA9IHt9XG4gICAgfVxuXG4gICAgLy9yZXNldHMgb25Qb2ludGVyRG93biBldmVudHMgb24gYWxsIHBpZWNlcyB0byBkaXNwbGF5UG9zaWJpbGl0aWVzIC0tIHRoaXMgZGVmYXVsdCBldmVudCBtYXkgaGF2ZSBjaGFuZ2VkIHdoZW4gYSBwaWVjZSB3YXMgc2VsZWN0ZWRcbiAgICByZXNldFBpZWNlRXZlbnRzKCl7XG4gICAgICAgIHRoaXMud2hpdGVfcGllY2VzLmZvckVhY2goKHBpZWNlKSA9PiB7XG4gICAgICAgICAgICBwaWVjZS5pbWFnZS5vbkNsaWNrID0gbmV3IE9uUG9pbnRlckRvd24oKCk9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5UG9zaWJpbGl0aWVzKHBpZWNlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmJsYWNrX3BpZWNlcy5mb3JFYWNoKChwaWVjZSkgPT4ge1xuICAgICAgICAgICAgcGllY2UuaW1hZ2Uub25DbGljayA9IG5ldyBPblBvaW50ZXJEb3duKCgpPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVBvc2liaWxpdGllcyhwaWVjZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG4iLCIvKmltcG9ydCB7Qm9hcmR9IGZyb20gJy4vYm9hcmQnXG5cbmNsYXNzIGNoZXNzR2FtZSB7XG4gICAgYm9hcmQ6IEJvYXJkXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5ib2FyZCA9IG5ldyBCb2FyZCgpXG4gICAgfVxufSovIiwiaW1wb3J0IHtzcXVhcmVNYXAsIGNoZXNzQ29sb3IsIFBpZWNlVHlwZSwgcmVzaXplRmFjdG9yLCBJU3F1YXJlLCBnZXRTcXVhcmVDb2xvcn0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGNsYXNzIENsb2Nre1xuICAgIGNsb2NrOiBVSVRleHQgIFxuICAgIHRpbWVyOiBudW1iZXJcblxuICAgIGNvbnN0cnVjdG9yKGNvbG9yOnN0cmluZywgdGltZXI6bnVtYmVyLCBjYW52YXM6VUlDYW52YXMpe1xuICAgICAgICB0aGlzLnRpbWVyID0gdGltZXJcbiAgICAgICAgdGhpcy5jbG9jayA9IG5ldyBVSVRleHQoY2FudmFzKVxuICAgICAgICB0aGlzLmNsb2NrLnZhbHVlID0gdGltZXIudG9TdHJpbmcoKVxuICAgICAgICB0aGlzLmNsb2NrLmZvbnRTaXplID0gMjVcbiAgICAgICAgaWYoY29sb3IgPT0gXCJ3aGl0ZVwiKXtcbiAgICAgICAgICAgIHRoaXMuY2xvY2sucG9zaXRpb25YID0gc3F1YXJlTWFwWydoMSddLnhQb3NpdGlvbiArIDEwXG4gICAgICAgICAgICB0aGlzLmNsb2NrLnBvc2l0aW9uWSA9IHNxdWFyZU1hcFsnaDEnXS55UG9zaXRpb24gLSA0NVxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0aGlzLmNsb2NrLnBvc2l0aW9uWCA9IHNxdWFyZU1hcFsnaDgnXS54UG9zaXRpb24gKyAxMFxuICAgICAgICAgICAgdGhpcy5jbG9jay5wb3NpdGlvblkgPSBzcXVhcmVNYXBbJ2g4J10ueVBvc2l0aW9uICsgNjJcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVyKClcbiAgICB9XG5cbiAgICB1cGRhdGVUaW1lcigpe1xuICAgICAgICBsZXQgbWludXRlczpzdHJpbmcgPSBNYXRoLmZsb29yKHRoaXMudGltZXIvNjApLnRvU3RyaW5nKClcbiAgICAgICAgbGV0IHNlY29uZHM6c3RyaW5nID0gKE1hdGgucm91bmQodGhpcy50aW1lciU2MCkpLnRvU3RyaW5nKClcbiAgICAgICAgaWYgKHNlY29uZHMubGVuZ3RoID09IDEpe1xuICAgICAgICAgICAgc2Vjb25kcyA9IFwiMFwiICsgc2Vjb25kc1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvY2sudmFsdWUgPSBtaW51dGVzK1wiOlwiK3NlY29uZHNcbiAgICB9XG59IiwiLy9cbi8vIElNUE9SVEFOVCA6XG4vLyAtIGluY2x1ZGUgYG5vTGliOiBmYWxzZWAgdG8geW91ciB0c2NvbmZpZy5qc29uIGZpbGUsIHVuZGVyIFwiY29tcGlsZXJPcHRpb25zXCJcbi8vXG4vLy88cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5zeW1ib2xcIiAvPlxuLy8vPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuc3ltYm9sLndlbGxrbm93blwiIC8+XG4vLy88cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb2xsZWN0aW9uXCIgLz5cbi8vLzxyZWZlcmVuY2UgbGliPVwiZXMyMDE1Lml0ZXJhYmxlXCIgLz5cblxuaW1wb3J0IHsgQ2xpZW50LCBSb29tIH0gZnJvbSAnY29seXNldXMuanMnXG5pbXBvcnQgeyBpc1ByZXZpZXdNb2RlLCBnZXRDdXJyZW50UmVhbG0gfSBmcm9tICdAZGVjZW50cmFsYW5kL0Vudmlyb25tZW50QVBJJ1xuaW1wb3J0IHsgZ2V0VXNlckRhdGEsIFVzZXJEYXRhIH0gZnJvbSAnQGRlY2VudHJhbGFuZC9JZGVudGl0eSdcbi8vaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jb2x5c2V1cy5qcy9saWIvQ2xpZW50XCJcbi8vaW1wb3J0IHsgUm9vbSB9IGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY29seXNldXMuanMvbGliL1Jvb21cIlxuXG5cbmV4cG9ydCBsZXQgdXNlckRhdGE6IFVzZXJEYXRhIHwgbnVsbFxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0VXNlckRhdGEoKSB7XG4gIHVzZXJEYXRhID0gYXdhaXQgZ2V0VXNlckRhdGEoKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29ubmVjdChyb29tTmFtZTogc3RyaW5nLCBvcHRpb25zOiBhbnkgPSB7fSkge1xuICBjb25zdCBpc1ByZXZpZXcgPSBhd2FpdCBpc1ByZXZpZXdNb2RlKClcbiAgY29uc3QgcmVhbG0gPSBhd2FpdCBnZXRDdXJyZW50UmVhbG0oKVxuXG4gIC8vXG4gIC8vIG1ha2Ugc3VyZSB1c2VycyBhcmUgbWF0Y2hlZCB0b2dldGhlciBieSB0aGUgc2FtZSBcInJlYWxtXCIuXG4gIC8vXG4gIGlmIChpc1ByZXZpZXcpIHtcbiAgICBvcHRpb25zLnJlYWxtID0gJ3Rlc3QnXG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5yZWFsbSA9IHJlYWxtPy5kaXNwbGF5TmFtZVxuICB9XG5cbiAgaWYgKCF1c2VyRGF0YSkge1xuICAgIGF3YWl0IHNldFVzZXJEYXRhKClcbiAgfVxuICBvcHRpb25zLnVzZXJEYXRhID0gdXNlckRhdGFcblxuICBsb2coJ2RhdGEgc2VudDonLCBvcHRpb25zKVxuXG4gIC8vIGNvbnN0IEVORFBPSU5UID0gXCJ3c3M6Ly9oZXB0LWouY29seXNldXMuZGV2XCI7XG4gIGNvbnN0IEVORFBPSU5UID0gaXNQcmV2aWV3XG4gICAgPyAnd3M6Ly8xMjcuMC4wLjE6MjU2NycgLy8gbG9jYWwgZW52aXJvbm1lbnRcbiAgICA6ICd3c3M6Ly9sOXRpbzMuY29seXNldXMuZGV2JyAvLyBwcm9kdWN0aW9uIGVudmlyb25tZW50XG5cbiAgaWYgKGlzUHJldmlldykge1xuICAgIGFkZENvbm5lY3Rpb25EZWJ1Z2dlcihFTkRQT0lOVClcbiAgfVxuICBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KEVORFBPSU5UKVxuXG4gIHRyeSB7XG4gICAgLy9cbiAgICAvLyBEb2NzOiBodHRwczovL2RvY3MuY29seXNldXMuaW8vY2xpZW50L2NsaWVudC8jam9pbm9yY3JlYXRlLXJvb21uYW1lLXN0cmluZy1vcHRpb25zLWFueVxuICAgIC8vXG4gICAgY29uc3Qgcm9vbSA9IGF3YWl0IGNsaWVudC5qb2luT3JDcmVhdGU8YW55Pihyb29tTmFtZSwgb3B0aW9ucylcbiAgICBpZiAoaXNQcmV2aWV3KSB7XG4gICAgICB1cGRhdGVDb25uZWN0aW9uRGVidWdnZXIocm9vbSlcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vbVxuICB9IGNhdGNoIChlKSB7XG4gICAgdXBkYXRlQ29ubmVjdGlvbk1lc3NhZ2UoYEVycm9yOiBgLCBDb2xvcjQuUmVkKCkpXG4gICAgdGhyb3cgZVxuICB9XG59XG5cbmxldCBtZXNzYWdlOiBVSVRleHRcblxuZnVuY3Rpb24gYWRkQ29ubmVjdGlvbkRlYnVnZ2VyKGVuZHBvaW50OiBzdHJpbmcpIHtcbiAgY29uc3QgY2FudmFzID0gbmV3IFVJQ2FudmFzKClcbiAgbWVzc2FnZSA9IG5ldyBVSVRleHQoY2FudmFzKVxuICBtZXNzYWdlLmZvbnRTaXplID0gMTVcbiAgbWVzc2FnZS53aWR0aCA9IDEyMFxuICBtZXNzYWdlLmhlaWdodCA9IDMwXG4gIG1lc3NhZ2UuaFRleHRBbGlnbiA9ICdjZW50ZXInXG4gIG1lc3NhZ2UudkFsaWduID0gJ2JvdHRvbSdcbiAgbWVzc2FnZS5wb3NpdGlvblggPSAtODBcbiAgdXBkYXRlQ29ubmVjdGlvbk1lc3NhZ2UoYENvbm5lY3RpbmcgdG8gJHtlbmRwb2ludH1gLCBDb2xvcjQuV2hpdGUoKSlcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGlvbk1lc3NhZ2UodmFsdWU6IHN0cmluZywgY29sb3I6IENvbG9yNCkge1xuICBtZXNzYWdlLnZhbHVlID0gdmFsdWVcbiAgbWVzc2FnZS5jb2xvciA9IGNvbG9yXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3Rpb25EZWJ1Z2dlcihyb29tOiBSb29tKSB7XG4gIHVwZGF0ZUNvbm5lY3Rpb25NZXNzYWdlKCdDb25uZWN0ZWQuJywgQ29sb3I0LkdyZWVuKCkpXG4gIHJvb20ub25MZWF2ZSgoKSA9PiB1cGRhdGVDb25uZWN0aW9uTWVzc2FnZSgnQ29ubmVjdGlvbiBsb3N0JywgQ29sb3I0LlJlZCgpKSlcbn0iLCJpbXBvcnQge0JvYXJkfSBmcm9tICcuL2JvYXJkJ1xuaW1wb3J0IHtDbG9ja30gZnJvbSAnLi9jbG9jaydcbmltcG9ydCB7Y29ubmVjdH0gZnJvbSAnLi9jb25uZWN0aW9uJ1xuaW1wb3J0IHsgUGllY2UgfSBmcm9tICcuL3BpZWNlJ1xuXG5pbXBvcnQge3NxdWFyZU1hcCwgY2hlc3NDb2xvciwgUGllY2VUeXBlLCByZXNpemVGYWN0b3IsIElTcXVhcmUsIGdldFNxdWFyZUNvbG9yfSBmcm9tICcuL3V0aWxzJ1xuXG5jb25uZWN0KCdteV9yb29tJykudGhlbigocm9vbSk9PntcbiAgXG5cbiAgLy9sZXQgbXlfdHVybjogYm9vbGVhbiA9IGZhbHNlXG4gIGxldCB3aGl0ZV90aW1lcjpudW1iZXIgPSAzMDBcbiAgbGV0IGJsYWNrX3RpbWVyOm51bWJlciA9IDMwMFxuXG4gIGNsYXNzIFJvdGF0b3JTeXN0ZW0ge1xuICAgIC8vIHRoaXMgZ3JvdXAgd2lsbCBjb250YWluIGV2ZXJ5IGVudGl0eSB0aGF0IGhhcyBhIFRyYW5zZm9ybSBjb21wb25lbnRcbiAgICBncm91cCA9IGVuZ2luZS5nZXRDb21wb25lbnRHcm91cChUcmFuc2Zvcm0pXG5cbiAgICB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBlbnRpdGllcyBvZiB0aGUgZ3JvdXBcbiAgICAgIGZvciAobGV0IGVudGl0eSBvZiB0aGlzLmdyb3VwLmVudGl0aWVzKSB7XG4gICAgICAgIC8vIGdldCB0aGUgVHJhbnNmb3JtIGNvbXBvbmVudCBvZiB0aGUgZW50aXR5XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKVxuXG4gICAgICAgIC8vIG11dGF0ZSB0aGUgcm90YXRpb25cbiAgICAgICAgdHJhbnNmb3JtLnJvdGF0ZShWZWN0b3IzLlVwKCksIGR0ICogMTApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy91cGRhdGVzIGJvYXJkcyB0aW1lciB2YWx1ZXNcbiAgY2xhc3MgVGltZXJTeXN0ZW0ge1xuICAgIGdyb3VwID0gZW5naW5lLmdldENvbXBvbmVudEdyb3VwKFRyYW5zZm9ybSlcbiAgICB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgICAgYm9hcmQuY2hlc3NnYW1lLnR1cm4oKSA9PSAndycgPyB3aGl0ZV9jbG9jay50aW1lciAtPSBkdCA6IGJsYWNrX2Nsb2NrLnRpbWVyIC09IGR0XG4gICAgICBib2FyZC5jaGVzc2dhbWUudHVybigpID09ICd3JyA/IHdoaXRlX2Nsb2NrLnVwZGF0ZVRpbWVyKCkgOiBibGFja19jbG9jay51cGRhdGVUaW1lcigpXG4gICAgICBpZiAod2hpdGVfY2xvY2sudGltZXIgPD0gMCl7XG4gICAgICAgIC8vIGJvYXJkLmNoZXNzZ2FtZS5nYW1lT3ZlcigpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKGJsYWNrX2Nsb2NrLnRpbWVyIDw9IDApe1xuICAgICAgICAvLyBib2FyZC5jaGVzc2dhbWUubW92ZSgndycsICdyZXNpZ24nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQWRkIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBzeXN0ZW0gdG8gdGhlIGVuZ2luZVxuICAvL2VuZ2luZS5hZGRTeXN0ZW0obmV3IFJvdGF0b3JTeXN0ZW0oKSlcblxuICAvLy8gLS0tIFNwYXduZXIgZnVuY3Rpb24gLS0tXG5cbiAgZnVuY3Rpb24gc3Bhd25DdWJlKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpIHtcbiAgICAvLyBjcmVhdGUgdGhlIGVudGl0eVxuICAgIGNvbnN0IGN1YmUgPSBuZXcgRW50aXR5KClcblxuICAgIC8vIGFkZCBhIHRyYW5zZm9ybSB0byB0aGUgZW50aXR5XG4gICAgY3ViZS5hZGRDb21wb25lbnQobmV3IFRyYW5zZm9ybSh7IHBvc2l0aW9uOiBuZXcgVmVjdG9yMyh4LCB5LCB6KSB9KSlcblxuICAgIC8vIGFkZCBhIHNoYXBlIHRvIHRoZSBlbnRpdHlcbiAgICBjdWJlLmFkZENvbXBvbmVudChuZXcgQm94U2hhcGUoKSlcblxuICAgIC8vIGFkZCB0aGUgZW50aXR5IHRvIHRoZSBlbmdpbmVcbiAgICBlbmdpbmUuYWRkRW50aXR5KGN1YmUpXG5cbiAgICByZXR1cm4gY3ViZVxuICB9XG5cbiAgY29uc3QgY3ViZSA9IHNwYXduQ3ViZSg4LCAxLCA4KVxuICBsZXQgYm9hcmQ6Qm9hcmRcbiAgbGV0IHdoaXRlX2Nsb2NrOkNsb2NrXG4gIGxldCBibGFja19jbG9jazpDbG9ja1xuICBjdWJlLmFkZENvbXBvbmVudChcbiAgICBuZXcgT25Qb2ludGVyRG93bigoKSA9PiB7XG4gICAgICBjdWJlLmdldENvbXBvbmVudChUcmFuc2Zvcm0pLnNjYWxlLnogKj0gMS4xXG4gICAgICBjdWJlLmdldENvbXBvbmVudChUcmFuc2Zvcm0pLnNjYWxlLnggKj0gMC45XG4gICAgICBib2FyZCA9IG5ldyBCb2FyZChyb29tKVxuICAgICAgd2hpdGVfY2xvY2sgPSBuZXcgQ2xvY2soJ3doaXRlJywgd2hpdGVfdGltZXIsIGJvYXJkLmNhbnZhcylcbiAgICAgIGJsYWNrX2Nsb2NrID0gbmV3IENsb2NrKCdibGFjaycsIHdoaXRlX3RpbWVyLCBib2FyZC5jYW52YXMpXG5cbiAgICAgIGVuZ2luZS5hZGRTeXN0ZW0obmV3IFRpbWVyU3lzdGVtKCkpXG4gICAgfSlcbiAgKVxuXG4gIHJvb20ub25NZXNzYWdlKFwiZmxhc2hNb3ZlbWVudFwiLCAoZGF0YSk9PntcbiAgICBsb2coXCJoZSByZWNiaWRvIGVsIG1vdlwiKVxuICAgIC8vbGV0IHA6IFBpZWNlID0gZGF0YS5waWVjZVxuICAgIC8vbGV0IG06IHN0cmluZyA9IGRhdGEucGllY2VcbiAgICBib2FyZC5nZXRQaWVjZShkYXRhLm9yaWdpbmFsX3Bvc2l0aW9uKVxuICAgIGxldCBwaWVjZTogUGllY2UgPSBib2FyZC5nZXRQaWVjZShkYXRhLm9yaWdpbmFsX3Bvc2l0aW9uKVxuICAgIGJvYXJkLm1vdmVQaWVjZShwaWVjZSwgZGF0YS5tb3ZlbWVudClcbiAgICBsb2coZGF0YS5vcmlnaW5hbF9wb3NpdGlvbilcbiAgICBsb2coZGF0YS5tb3ZlbWVudClcbiAgICAvL2JvYXJkLm1vdmVQaWVjZShkYXRhLm1vdmVtZW50KVxuICB9KVxuXG4gIHJvb20ub25NZXNzYWdlKFwiWW91clR1cm5cIiwgKGRhdGEpPT57XG4gICAgYm9hcmQudHVybiA9IHRydWVcbiAgfSlcblxuICBsZXQgY3AgPSBuZXcgRW50aXR5KClcbiAgY3AuYWRkQ29tcG9uZW50KG5ldyBHTFRGU2hhcGUoJ21vZGVscy9DUF9NREwuZ2xiJykpXG4gIGNwLmFkZENvbXBvbmVudChuZXcgVHJhbnNmb3JtKHsgXG4gICAgcG9zaXRpb246IG5ldyBWZWN0b3IzKDgsIDAsIDgpLFxuICAgIHNjYWxlOiBuZXcgVmVjdG9yMygxMDAsIDEwMCwgMTAwKVxuICB9KSlcbiAgZW5naW5lLmFkZEVudGl0eShjcClcbn0pXG5cblxuXG5cbiJdfQ==",
    "sha256": "26cdf332f770776b500239597d51c29e99a1161f321da58cd6c1376e7f114da8"
  }
]